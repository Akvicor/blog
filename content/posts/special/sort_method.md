---
title: "一堆乱七八糟绝不正经的排序算法"
date: 2019-11-08 21:39:09 +08:00
draft: false
categories: [Special]
tags: []
card: false
weight: 0
---

花里胡哨

<!--more-->

----

## 猴子排序

> （提供者cy1306110516）

猴子排序的思想源自于著名的 **无限猴子定理**。

既然猴子们能敲出《哈姆雷特》，区区排序又算什么呢？

### 思路：

1. 判断数组是否有序，如果无序，进入下一步。
2. 随机打乱数组，回到上一步。

### 适用人群：

欧皇

### 时间复杂度：

- 最坏情况{{<latex>}}O(\infty){{</latex>}}
- 最好情况{{<latex>}}O(n){{</latex>}}

### 算法实现：

```c++
#include <bits/stdc++.h>
using namespace std;
int n,a[100005];
inline void random_(){
    for (int i=1;i<=n;i++) swap(a[i],a[i+rand()%(n-i+1)]);
    //打乱，AC全靠RP
}
inline bool check(){
    for (int i=2;i<=n;i++) if (a[i]<a[i-1]) return false;
    return true;
    //判断是否有序
}
inline void bogo_sort(){
    while (!check())
    random_();
    //核心代码
}
int main(){
    scanf("%d",&n);
    srand(time(NULL));
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    bogo_sort();
    for (int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0;
}//提供者cy1306110516
```

----

## 钻石排序

> （提供者DARTH_VADER）

钻石排序（又名戴蒙德排序）的思想源自于演化生物学家贾雷德·戴蒙德的作品 **《枪炮、病菌与钢铁》** 。

### 思路：

1. 对于数组中的每一项，创造一个等同人数的人类部落。
2. 让他们独立地发展。
3. 第一个发展出枪支的最大，以此类推。

### 适用人群：

极远未来的统治阶层

### 时间复杂度：

{{<latex>}}O(n){{</latex>}}，常数为13000年。

### 代码实现：

暂无

----

## 恶魔排序

> （提供者DARTH_VADER）

恶魔排序的思想源自于十九世纪英国物理学家詹姆斯·克拉克·麦克斯韦的 **麦克斯韦恶魔假说**。

### 思路：

创造这样的一种气体：其每一个分子运动速度与数组中的每一个数成比例。

将这样的气体灌入一个密封的盒子，该盒子被一分为二，中间有一个小孔接通两侧。

小孔一次只能经过一个分子。

每一次迅速打开小孔，让特定分子经过。

那么长时间后，盒子将一侧热一侧冷。

对于每一侧，分治进行本算法。

### 适用人群：

麦克斯韦的恶魔

### 时间复杂的：

{{<latex>}}O(n!){{</latex>}}

### 代码实现：

暂无

----

## 珠排序

> （提供者502_Bad_Gateaway）

珠排序的思想源自于中国历史悠久的 **算盘**。（大雾）

### 思路：

1. 对于每一个数字，我们用一排珠子表示。
2. 将这些珠子叠在一起，使其自然下落。
3. 每一层的珠子数量即为该位置数值。

珠排序示意图

![](https://img.akvicor.com/i/2024/09/17/66e99e04b3f2b.png)

### 适用人群：

喜好珠算的OIer

### 时间复杂度：

这个。。。呃呃呃看你怎么说了

### 代码实现：

等一下哈，本人正在敲

----

## 怂货地精排序

> （提供者502_Bad_Gateaway）

怂货排序。。。很怂。

### 思路：

- 当i=0或a\[i\]>a\[i-1\]时，i++。
- 否则交换a\[i\]与a\[i-1\]，i--。

### 适用人群：

正常人类

### 时间复杂度：

{{<latex>}}O(n^2){{</latex>}}

### 代码实现：

```c++
void gnome_sort(int *unsorted[]){
    int i = 0;
    while (i < unsorted.Length){
        if (i == 0 || unsorted[i - 1] <= unsorted[i])i++;
        else{
            int tmp = unsorted[i];
            unsorted[i] = unsorted[i - 1];
            unsorted[i - 1] = tmp;
            i--;
        }
    }
}//提供者DARTH_VADER
```

----

## 智能设计排序

> （提供者DARTH_VADER）

智能设计排序的思想源自于 **智能设计论（智设论）**。

### 思路：

假设我们有一些数字（它们组成了给出的数组），那么它们恰好排序成给出的数组的概率是 {{<latex>}}\frac{1}{n!}{{</latex>}}

面对如此小的可能性，我们断言这样的数组是随机出现的，未免太过果断。

有理由相信，这样的一个数组是一个有自我意志的排序者给出的。

由于我们对排序的认知被局限在递增或递减，揣摩排序者用意的行为是不理智的。

因此大可放心：数组已被排序！

### 适用人群：

懒人

### 时间复杂度：

{{<latex>}}O(0){{</latex>}}，当然算上输入就是{{<latex>}}O(n){{</latex>}}

### 代码实现：

```c++
#define donothing return
void intelligentDesignSort(int list[]){
    donothing;
}//提供者DARTH_VADER
```

----

## 指鹿为马排序

> （提供者life_w_back）

指鹿为马排序的思想源自于典故 **指鹿为马**。

### 思路：

选取若干无辜路人，重复执行以下操作直至所有人认为数组已排序：

1. 询问数组是否已排序。
2. 杀死所有说没排序的。

### 适用人群：

赵高

### 时间复杂度：

{{<latex>}}O(1){{</latex>}}，常数为1分钟。

### 代码实现：

本算法须手动实现。

----

## “生命，宇宙与一切”排序

> （提供者AThousandSuns）

“生命，宇宙与一切”排序的思想来源于 **银河系漫游指南**。

### 思路：

在每两个数之间插入42，然后提交给深思。

### 适用人群：

道格拉斯·亚当斯

### 时间复杂度：

{{<latex>}}O(n^2){{</latex>}}，常数约为1000万年。

### 代码实现：

```c++
void ftSort(int *list[],int size){
    for(int i=1;i<size-1;i++){
        for(int j=size;j>i;j--){
            list[j]=list[j-1];
        }
        list[i]=42;
    }
}//提供者DARTH_VADER
```

----

