<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="Search - https://blog.akvicor.com/search/">
    <meta name="author" content="Akvicor - https://blog.akvicor.com/">
	
	<meta name="baidu-site-verification" content="codeva-84NnEJvKGE" />
    
    <meta name="msvalidate.01" content="23AB88DCE901A2BD829B9DC162576D33" />
    <title>Search</title>
    
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
	<script defer src="https://analy.akvicor.com/script.js" data-website-id="c0cbafdd-207e-431e-a252-4a64c31d98b9"></script>
    
    <link rel="stylesheet" href="https://blog.akvicor.com/style.min.4151072d6fc9fe1a3df6b17d57d2d8ca2e6573201efdbc03d4e8e48525582b64.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    <script src="/js/hide_and_seek.js"></script>
    <link rel="stylesheet" href="/css/hide_and_seek.css">
    <link rel="stylesheet" href="/css/heimu.css">
	
		<script>
			console.log(String.raw`
          _           _                _ 
    /\   | |         (_)              | |
   /  \  | | ____   ___  ___ ___  _ __| |
  / /\ \ | |/ /\ \ / / |/ __/ _ \| '__| |
 / ____ \|   <  \ V /| | (_| (_) | |  |_|
/_/    \_\_|\_\  \_/ |_|\___\___/|_|  (_)`);
		</script>
		<script>
			try{
				if(window.console&&window.console.log) {
					console.log("%cFor the Horde! %cFor the Azeroth!","color:red","color:blue");
					console.log("%c火墙火墙火墙火墙！","color:red");
					console.log("%c快打大怪！","color:red");
					console.log("%c快打断！","color:red");
					console.log("%c注意脚下！","color:red");
					console.log("%c快躲开！","color:red");
					console.log("%c震慑波！","color:red");
					console.log("%c快转身！","color:red");
					console.log("%c注意减伤！","color:red");
					console.log("%c<Deadly Boss Mods> %cCombat against 10 Player - Garrosh Hellscream(1%) ended after 8 minutes ad 19 seconds. you have 3 total wipes on this difficulty.","color:red","color:blue");
				}
			}
			catch(e){};
        </script>
	
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$math_inline$','$math_inline$'], ['\\(','\\)']],
				displayMath: [['$math_noinline$','$math_noinline$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$math_noinline$", right: "$math_noinline$", display: true},
									{left: "$math_inline$", right: "$math_inline$", display: false}
							]
					});
			});
			</script>
	
    
</head>
<body class="active-animate ">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": false,
		"svgColor": "",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            搜索
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-search 
    ">

    <div class="desc">
        
    </div>
    
    <div class="toc">
        
        <nav id="TableOfContents"></nav>
    </div>

    <div class='content  content '>
        
    </div>

    <div class="container-search">
    <div id="data" style="display: none;">
        
            
                [{"content":"这是一篇指导如何使用和开发wallet的博客\n详细的内容以后再说吧, 今天连着开源了三个项目, 写了三篇博客, 燃尽了 相关项目 项目代码 github https://github.com/akvicor/wallet 项目代码 gitee https://gitee.com/akvicor/wallet 界面预览 多用户 自定义银行,货币类型,银行卡类型 保存银行卡信息 自定义汇率 自定义交易分类(收入/支出/转账/兑换下的子分类 创建钱包, 以及钱包下的划分, 每个划分绑定到某张银行卡 创建愿望单, 与钱包功能一致 创建债务, 与钱包功能一致 创建订阅, 自定义付费周期, 自动计算下次付费时间, 下次付费前通过短信或邮件提醒, 自动计算每天/月/年的订阅开支 开支图表, 日历形式展示每天/月的开支, 饼状图展示区间内的开支占比, 折线图展示区间内的开支占比 通过短信或邮件发送通知 钱包逻辑 钱包和交易 创建钱包时需要选择一张银行卡作为第一个划分绑定的银行卡, 后续可以创建其他绑定不用银行卡的划分.\n同一张一行卡可以绑定多个划分, 同一个划分只能属于一个钱包.\n每次记录交易时, 都需要选择钱包下的划分, 对划分中资金的操作会影响到绑定银行卡的资金(即所有绑定了同一张银行卡的划分的余额总和就是银行卡的余额)\n愿望单和债务 这两个本质上就是钱包, 将划分的名字命名为购买物品的名字, 通过设置目标金额来表示物品价值, 从其他钱包往此愿望划分中转账, 表示资金进度. 债务同理\n订阅 支持配置为 每天/每周/每月/每季度/每年/每隔n天/每隔n月/每隔n年\n当为某个订阅支付后, 点击更新按钮即可将订阅的提醒时间更新到下次的时间\n搭建 docker快速搭建\n如需自己编译镜像, 可以直接使用项目中的dockerfile编译, 编译完成后替换后续docker-compose.yml中的镜像名称\n通过docker-compose.yml快速搭建\n需要修改数据存储的目录\nservices: wallet: image: akvicor/wallet:v0.2.20 restart: always ports: - \u0026#34;3000:3000\u0026#34; volumes: - \u0026#34;/path/to/data:/data\u0026#34; 启动\ndocker compose -p wallet up -d 配置 配置文件 如果docker-compose.yml中配置的目录是/path/to/data, 那么配置文件应在/path/to/data/config.toml\n如果需要接收通知提醒, 例如 订阅付费到期提醒, 银行卡账单日和还款日提醒 需要配置mail和sms, 其中sms是 这篇博客中搭建的\n用户配置 要想收到邮箱或短信, 除了在配置文件中配置, 还需要在网站中为用户添加邮箱地址和手机号\n","date":"2025-02-15","permalink":"https://blog.akvicor.com/posts/project/wallet/","summary":"这是一篇指导如何使用和开发Wallet的博客 详细的内容以后再说吧, 今天连着开源了三个项目, 写了三篇博客, 燃尽了 相关项目 项目代码 Github https://github.com/Akvicor/wallet 项目代码 Gitee https://gitee.com/Akvicor/wallet 界面预览 多用户 自定","title":"wallet 资金管理/订阅管理"},{"content":"这是一篇指导如何使用和开发msg的博客\n概念介绍 平台: 例如sms,邮箱,telegram,微信 bot: 每个bot都可以支持一个或多个平台, 但每种平台只能绑定一个 通知渠道: 将bot,平台以及发送目标绑定在一起, 同时可以给渠道设置标记(全局唯一), 发送信息时可以通过渠道id或渠道标记向对应的渠道发送信息 相关项目 项目代码 github https://github.com/akvicor/msg 项目代码 gitee https://gitee.com/akvicor/msg 相关\nhttps://github.com/akvicor/gmsg 一个go mod, 可以快速调用已经搭建的msg来发送信息 https://github.com/akvicor/msg-cmd 一个命令行应用, 可以快速调用已经搭建的msg来发送信息 https://github.com/akvicor/sms sms平台, 用来发送短信 界面介绍 用户中心 可以在这里面修改密码和头像什么的\n访问密钥 通过api访问时需要使用这个\n发送渠道 实际的发送渠道, 将信息接受者绑定到平台和bot\n发送渠道的 目标\nsms/短信: 手机号 mail/邮件: 邮箱地址 telegram: 会话id(添加对应机器人后, 通过发送/get_id获取到的内容) 微信: 用户在企业微信中的名称 搭建 docker快速搭建\n如需自己编译镜像, 可以直接使用项目中的dockerfile编译, 编译完成后替换后续docker-compose.yml中的镜像名称\n通过docker-compose.yml快速搭建\nsqlite 需要修改数据存储的目录\nservices: msg: image: akvicor/msg:v0.1.6 restart: always volumes: - /path/to/msg/data/msg-data:/data ports: - 3000:3000 healthcheck: test: [\u0026#34;cmd\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;http://localhost:3000/api/sys/info/health\u0026#34;] interval: 10s timeout: 5s retries: 5 postgres 需要修改数据存储的目录, postgres的密码\nservices: msg: image: akvicor/msg:v0.1.6 restart: always volumes: - /path/to/msg/data/msg-data:/data ports: - 3000:3000 healthcheck: test: [\u0026#34;cmd\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;http://localhost:3000/api/sys/info/health\u0026#34;] interval: 10s timeout: 5s retries: 5 depends_on: db: condition: service_healthy db: image: postgres:17.2 restart: always volumes: - /path/to/msg/data/db-data:/var/lib/postgresql/data environment: - postgres_user=postgres - postgres_password=password - postgres_db=msg healthcheck: test: [\u0026#34;cmd-shell\u0026#34;, \u0026#34;pg_isready -u postgres -d msg\u0026#34;] interval: 10s timeout: 5s retries: 5 启动\ndocker compose -p msg up -d 对于使用postgres的用户, 需要在启动后修改/path/to/msg/data/msg-data/config.toml\n将\n[database] # sqlite, postgres type = \u0026#39;sqlite\u0026#39; 改为\n[database] # sqlite, postgres type = \u0026#39;postgres\u0026#39; 然后重启docker容器\ndocker compose -p msg restart 配置 bot部分放在介绍默认bot maid时介绍\nserver 这是配置web服务域名和端口的\ndatabase 配置数据库, 目前仅支持sqlite和postgres两种\nsqlite: 仅type和file生效 postgres: 如果是按照上面的docker-compose.yml启动的服务, 那么host可以直接使用db\nencrypt 每次生成配置文件时, 都会随机生成key和iv\nlog 这是日志配置, 默认不会写入文件\ncron 这是定时执行某个任务时需要的配置, 但这个功能比较私人, 我在开放的版本中清空了这部分\n默认bot reminder 这个bot仅支持微信企业应用, 当然你也可以自己在代码中添加支持其他平台. 毕竟我现在用的就是微信企业应用, 懒得继续加平台 下面这张图就完整的概括了reminder的功能, 这是一个让msg定时向你发送信息的功能, 用于提醒自己指定时间该干啥\n如需使用reminder, 请手动添加一个绑定reminder的通知渠道, 这个通知渠道绑定的发送目标才能使用reminder功能\n默认bot maid (包含如何配置每种平台的示例) 这个bot支持目前所有平台, 但默认情况下仅支持发送信息, 如果你想支持收到消息后自动进行某些操作, 那你需要去代码的指定接收函数中编写对应功能\n配置 sms 这个平台是自己搭建的, 项目地址 https://github.com/akvicor/sms\n将这个项目搭建后开放出来的url以及token配置到这里后, maid就可以通过sms发送短信了\nenable-sender: 是否启用发送短信功能, 默认为false, 如需启用需修改为true enable-receiver: 目前并未实现接受短信功能 [bot.maid.sms] debug = false enable-receiver = false enable-sender = false api = \u0026#39;https://example.com\u0026#39; token = \u0026#39;\u0026#39; 配置 mail 如何搭建邮件服务器可以看 这篇博客\nenable-smtp: 是否启用发送邮件功能, 默认为false, 如需启用需修改为true enable-imap: 是否启用接收邮件功能, 默认为false, 如需启用需修改为true, 如需进一步处理接收到的邮件, 需要自行修改代码 发送邮件需要smtp, 接收邮件需要imap\n[bot.maid.mail] debug = false enable-imap = false host-imap = \u0026#39;https://imap.example.com\u0026#39; port-imap = 993 enable-smtp = false host-smtp = \u0026#39;https://smtp.example.com\u0026#39; port-smtp = 465 from = \u0026#39;msg backend \u0026lt;maid@example.com\u0026gt;\u0026#39; username = \u0026#39;maid@example.com\u0026#39; password = \u0026#39;\u0026#39; 配置 telegram enable-sender: 是否启用发送信息功能, 默认为false, 如需启用需修改为true enable-receiver: 是否启用接收信息功能, 默认为false, 如需启用需修改为true, 如需进一步处理接收到的信息, 需要自行修改代码 token处填写机器人的token, 如何创建机器人请自行google或咨询ai\n当机器人被添加到对话后, 发送/get_id可以获取当前会话的id, 这个id就是本程序的发送渠道中的telegram的渠道目标\n[bot.maid.telegram] debug = false enable-receiver = false enable-sender = false api = \u0026#39;https://api.telegram.org/bot%s/%s\u0026#39; token = \u0026#39;\u0026#39; 配置 微信 enable-sender: 是否启用发送信息功能, 默认为false, 如需启用需修改为true enable-receiver: 是否启用接收信息功能, 默认为false, 如需启用需修改为true, 如需进一步处理接收到的信息, 需要自行修改代码 corp-id: 企业id secret: 企业应用的secret agent-id: 企业应用的id token: 应用收到消息的回调所需的token (receiver使用) aes-key: 应用收到消息的回调所需的加密密钥 (receiver使用) receiver还需要在企业微信中配置应用的回调url, 例如本应用的域名是msg.example.com, bot是maid, 那么url就需要填写https://msg.example.com/api/bot/maid/wechat/callback\n[bot.maid.wechat] debug = false enable-receiver = false enable-sender = false corp-id = \u0026#39;\u0026#39; secret = \u0026#39;\u0026#39; agent-id = 0 token = \u0026#39;\u0026#39; aes-key = \u0026#39;\u0026#39; api调用发送 通过api可以绕过发送渠道直接通过bot发送给指定的目标, 无需先添加发送渠道, 再通过发送渠道发送\n/api/send 发送 支持post/get\n参数如下\nid: 发送渠道的id sign: 发送渠道的标记 type: 消息类型(text/textcard/markdown/html), 由于部分消息类型仅支持特定平台, 因此在不支持的平台会自动变更为其他类型 at: 秒级unix时间戳, 信息期望的发送时间 title: 信息标题 msg: 信息内容 其中id和sign提供一个即可, title和msg至少填写一个\n/send/cancel 取消 在消息还未发送出去时 (未达到指定发送时间), 取消发送此消息\nid: 消息的id 其他api 请在cmd/app/server/app/server.go查询\n示例: maid 每个bot的api请在cmd/app/server/bot/bot.go查询, 通过这些api可以直接调用指定bot发送信息\n/api/bot/maid/sms/send: post/get 参数为phone,msg /api/bot/maid/mail/send: post/get 参数为to,subject,type,msg /api/bot/maid/telegram/send: post/get 参数为chat,mode,msg /api/bot/maid/wechat/send: post/get 参数为touser,type,title,msg,url,btn /api/bot/maid/wechat/callback: 企业微信回调 示例: reminder /api/bot/reminder/wechat/send: post/get 参数为touser,type,title,msg,url,btn /api/bot/reminder/wechat/callback: 企业微信回调 使用简易教程 以maid为例, 仅提供创建所需参数介绍\nsms 在发送渠道这里, 点击创建\n如图\n标记: 我将此渠道的标记配置为channel_sms_1, 这样我就可以用此标记替代通知渠道id来代指某个通知渠道, 这个可以随意填写, 但无法创建已存在的字符串(包括存在于其他人账号中的) 名称: 名称随意 bot: 这个演示里我用 maid 作为发送信息的机器人 类型: 我希望用这个bot发送 短信 目标: 我希望用这个bot给 10086 发送短信 邮件 在发送渠道这里, 点击创建\n如图\n标记: 我将此渠道的标记配置为mail_1, 这样我就可以用此标记替代通知渠道id来代指某个通知渠道, 这个可以随意填写, 但无法创建已存在的字符串(包括存在于其他人账号中的) 名称: 名称随意 bot: 这个演示里我用 maid 作为发送信息的机器人 类型: 我希望用这个bot发送 邮件 目标: 我希望用这个bot给 akvicor@akvicor.com 发送邮件 telegram 在发送渠道这里, 点击创建\n如图\n标记: 我将此渠道的标记配置为tg, 这样我就可以用此标记替代通知渠道id来代指某个通知渠道, 这个可以随意填写, 但无法创建已存在的字符串(包括存在于其他人账号中的) 名称: 名称随意 bot: 这个演示里我用 maid 作为发送信息的机器人 类型: 我希望用这个bot发送 telegram 目标: 我希望用这个bot给 -123456789 发送邮件(通过在会话中发送\\get_id获取,适用于与bot的私聊,和bot共同的group和channel) 微信 在发送渠道这里, 点击创建\n如图\n标记: 我将此渠道的标记配置为wechat, 这样我就可以用此标记替代通知渠道id来代指某个通知渠道, 这个可以随意填写, 但无法创建已存在的字符串(包括存在于其他人账号中的) 名称: 名称随意 bot: 这个演示里我用 maid 作为发送信息的机器人 类型: 我希望用这个bot发送 微信 目标: 我希望用这个bot给 akvicor 发送邮件(通过在会话中发送\\get_id获取,适用于与bot的私聊,和bot共同的group和channel) 发送目标来源\n开发 目录cmd/app/server/bot下存放各类平台和bot\n平台 cmd/app/server/bot/mail 收发邮件相关的代码 cmd/app/server/bot/sms 收发短信相关的代码 cmd/app/server/bot/telegram 收发telegram相关的代码 cmd/app/server/bot/wechat 收发微信相关的代码 maid cmd/app/server/bot/maid.go内就是maid这个bot相关的功能\n开启接收邮件后: mailreceiver函数用于处理接收到的所有邮件, 代码默认不对邮件内容做出任何操作 开启接收telegram后: telegramreceiver函数用于处理接收到的所有电报信息, 函数简单的对每种类型信息做了区分, 如果想要对应功能则自行在对应的信息下编写功能, 代码默认不对信息内容做出任何操作 开启接收微信后: wechatreceiver函数用于处理接收到的所有微信消息, 代码默认不对消息内容做出任何操作 reminder cmd/app/server/bot/reminder.go内就是reminder这个bot相关的功能\n开启接收微信后: wechatreceiver函数用于处理接收到的所有微信消息, 这个函数提供了reminder的定时发送信息功能\n","date":"2025-02-15","permalink":"https://blog.akvicor.com/posts/project/msg/","summary":"这是一篇指导如何使用和开发MSG的博客 概念介绍 平台: 例如SMS,邮箱,Telegram,微信 Bot: 每个bot都可以支持一个或多个平台, 但每种平台只能绑定一个 通知渠道","title":"msg 信息发送平台攻略"},{"content":"苦于国内的短信平台都需要指定发送模板, 没法发送高度自定义的消息, 且模板审核过于麻烦, 因此想要自己开发一套用于发送短信的平台\n受 此文章 的启发, 决定使用air780e和树莓派制作一个能够接收和发送短信的程序\n项目代码 github https://github.com/akvicor/sms 项目代码 gitee https://gitee.com/akvicor/sms 功能 发送短信 接收短信 web界面, 支持查看发送和接收历史 api接口, 直接通过调用api接口发送短信 所需材料 air780e 一张手机卡(最好按照自身需求开通短信包,这样发短信便宜) 树莓派 实现逻辑 在树莓派上运行编写好的程序, 通过gpio和air780e通信, 提供http的api接口来发送或查看收到的短信 air780e收到短信后通过gpio发送给树莓派, 交由树莓派进一步处理 树莓派通过gpio将需要发送的短信内容和手机号发送给air780e, air780e将短信发送给指定手机号 由于我还有一个海外手机卡, 因此你会在代码和配置中看到cn和us两个结尾的配置, 他们分别代表了国内和国外手机卡 对于air780e如何上电自启以及gpio定义可以看 这篇博客 如何刷写固件及代码可以看 官方文档 整体预览 由于我用了两张卡, 两个手机号, 因此使用了两个air780e, 如果你只用一个手机号, 那么可以去掉一个\n图中蓝色部分是串口数据线, 红色部分是5v供电线, air780e上除了供电还有一个用于检测树莓派是否在线(由于本身供电就来自树莓派,因此无意义,不过最好还是连上)\nweb界面\n收到和发出的短信的历史\n注意事项 由于当初开发时没想过要开源出来, 因此很多地方的代码非常简陋, 部分功能需要的配置写死在文件中, 因此如果想获取除收发短信外的功能, 需要一定的代码知识, 手动修改代码\n首先看配置文件 文件: config.ini\nserial-cn和serial-us这里定义了国内和国外手机卡使用的那个串口和air780e通信, 具体树莓派中每个串口使用的是那个gpio需要看自己树莓派版本的gpio定义 server定义了程序提供服务的端口 database定义了数据库文件存放位置 log定义了是否将log输出到文件, 以及log文件存放位置 security定义了访问web界面需要输入的用户名和密码, 以及访问api接口时使用的key air780e中收到短信后自身执行的命令 文件: air780e/main.lua\n这是写入air780e的文件, 也就是air780e用的代码\n搜索代码中的手机号12345678900替换为自己日常使用的手机号(并非插在air780e的手机号)\n例如在收到help短信内容时air780e会直接通过短信返回信息, 不再发送给树莓派处理\nif txt == \u0026#34;help\u0026#34; then sms.send(\u0026#34;+8612345678900\u0026#34;, \u0026#34;[sms][help]\\nreboot - reboot sms\\nstatus - sms status\\ncstatus - sms current status\u0026#34;) return end 同时air780e在上电后也会向这个手机号发送一条短信, 表示程序正常\n树莓派和air780e的数据交换部分 文件: serial/serial_cn.go\n下面代码和main.lua中的手机号一样, 都是自己日常使用的手机号\nconst selfphonecn = \u0026#34;12345678900\u0026#34; 在readcallbackcn函数中有下面代码\n主要说明最后一个else if, 由于树莓派本身运行了ha(home assistant这)是收到特定短信后, 通过ha重启路由器, 这样当家里断网时可以尝试通过短信重启路由器看看能否恢复正常\nif sms.message == \u0026#34;hello\u0026#34; { if strings.contains(sms.phone, selfphonecn) { sendcn(\u0026#34;sms\u0026#34;, model.newmsg(model.msgtagsmssend, model.newsmslong(sms.phone, \u0026#34;hello akvicor! here is sms\u0026#34;))) } else { sendcn(\u0026#34;sms\u0026#34;, model.newmsg(model.msgtagsmssend, model.newsmslong(sms.phone, \u0026#34;hello! here is sms\u0026#34;))) } } else if sms.message == \u0026#34;你好\u0026#34; { if strings.contains(sms.phone, selfphonecn) { sendcn(\u0026#34;sms\u0026#34;, model.newmsg(model.msgtagsmssend, model.newsmslong(sms.phone, \u0026#34;你好akvicor！这里是sms\u0026#34;))) } else { sendcn(\u0026#34;sms\u0026#34;, model.newmsg(model.msgtagsmssend, model.newsmslong(sms.phone, \u0026#34;你好！这里是sms\u0026#34;))) } } else if sms.message == \u0026#34;ha.help\u0026#34; \u0026amp;\u0026amp; strings.contains(sms.phone, selfphonecn) { sendcn(\u0026#34;sms\u0026#34;, model.newmsg(model.msgtagsmssend, model.newsmslong(sms.phone, \u0026#34;[ha][help]\\nha.op.reboot - reboot op\u0026#34;))) } else if sms.message == \u0026#34;ha.op.reboot\u0026#34; \u0026amp;\u0026amp; strings.contains(sms.phone, selfphonecn) { _ = util.httppost(\u0026#34;http://127.0.0.1/api/services/script/reboot_router\u0026#34;, nil, util.httpcontenttypejson, map[string]string{\u0026#34;authorization\u0026#34;: \u0026#34;bearer xxxxxxx\u0026#34;}) sendcn(\u0026#34;sms\u0026#34;, model.newmsg(model.msgtagsmssend, model.newsmslong(sms.phone, \u0026#34;reboot op\u0026#34;))) } 编译运行 将代码下载到本地, 进入代码根目录执行\ngo mod tidy go build -trimpath -ldflags \u0026#34;-s -w\u0026#34; -o sms 假设执行文件目录: path/to/exec/sms 假设数据文件目录: path/to/data 假设配置文件目录: path/to/data/config.ini\n那么可以编写以下systemd脚本/etc/systemd/system/sms.service\n[unit] description=sms after=network.target auditd.service conditionfileisexecutable=path/to/exec/sms [service] user=root startlimitinterval=5 startlimitburst=10 execstart=path/to/exec/sms -c path/to/data/config.ini workingdirectory=path/to/data restart=always restartsec=15 limitnproc=32768 limitnofile=1048576 # cap_net_admin:允许执行网络管理任务 # cap_net_bind_service:允许绑定到小于1024的端口 capabilityboundingset=cap_net_admin cap_net_bind_service ambientcapabilities=cap_net_admin cap_net_bind_service [install] wantedby=multi-user.target 启用服务\nsystemctl enable sms systemctl start sms ","date":"2025-02-15","permalink":"https://blog.akvicor.com/posts/project/sms/","summary":"苦于国内的短信平台都需要指定发送模板, 没法发送高度自定义的消息, 且模板审核过于麻烦, 因此想要自己开发一套用于发送短信的平台 受 此文章 的启发, 决定使用Air780E","title":"air780e+树莓派短信收发平台"},{"content":"首先安装socat\nsudo apt-get install socat 启动虚拟串口\nsocat -d -d pty,raw,echo=0 pty,raw,echo=0 成功后返回以下信息\n2024/09/22 21:32:10 socat[1997612] n pty is /dev/pts/13 2024/09/22 21:32:10 socat[1997612] n pty is /dev/pts/14 2024/09/22 21:32:10 socat[1997612] n starting data transfer loop with fds [5,5] and [7,7] （终端1）监听其中一个串口 cat \u0026lt; /dev/pts/2 （终端2）另一个串口写入数据 echo \u0026quot;hello world!\u0026quot; \u0026gt; /dev/pts/3 现在，从终端1可以看到“”hello world!“”打印信息，证明串口创建并连接成功。\n","date":"2024-09-22","permalink":"https://blog.akvicor.com/posts/linux/serial_port/","summary":"首先安装socat sudo apt-get install socat 启动虚拟串口 socat -d -d pty,raw,echo=0 pty,raw,echo=0 成功后返回以下信息 2024/09/22 21:32:10 socat[1997612] N PTY is /dev/pts/13 2024/09/22 21:32:10 socat[1997612] N PTY is /dev/pts/14 2024/09/22 21:32:10 socat[1997612] N starting data transfer loop with FDs [5,5] and [7,7] （终端1）监听其中一个串口 cat \u0026lt; /dev/pts/2 （终端2","title":"linux虚拟串口 serial port"},{"content":"鉴于harbor官方的安装无比混乱, 因此记录如何将有用的东西提取出来, 最终形成data目录, config目录, docker-compose.yml文件.\n修复因端口问题导致的docker login失败 删除log容器和网络 增加容器名称前缀 按照官方教程进行前期操作 下载执行官方配置脚本, 配置harbor.yml, 注意配置和记录端口, 密码和data目录\n执行install.sh生成data目录, common目录和docker-compose.yml\n修改目录位置 data目录最好一开始就填写正确位置, 这样后续就不需要修改, 如果需要更改则需要修改docker-compose.yml文件\nconfig目录就在common目录中, 修改方法和data目录修改方法一致, 直接修改docker-compose.yml文件即可\n更改log记录方式 官方将容器运行产生的log都存放在了文件里, 我不喜欢它占用主机1514端口, 且不需要记录log, 因此直接删除\nlog记录由下面这个容器提供, 直接删除\nlog: image: goharbor/harbor-log:v2.11.1 container_name: harbor-log restart: always cap_drop: - all cap_add: - chown - dac_override - setgid - setuid volumes: - /var/log/harbor/:/var/log/docker/:z - type: bind source: ./common/config/log/logrotate.conf target: /etc/logrotate.d/logrotate.conf - type: bind source: ./common/config/log/rsyslog_docker.conf target: /etc/rsyslog.d/rsyslog_docker.conf ports: - 127.0.0.1:1514:10514 networks: - harbor 删除容器后, 还需要修改引用到此容器的容器\n删除依赖 如果depends_on中只有log, 那就整个删除, 如果还有其他的, 则只删除log这行\ndepends_on: - log 删除logging 将下面这个样式的直接删除\nlogging: driver: \u0026#34;syslog\u0026#34; options: syslog-address: \u0026#34;tcp://localhost:1514\u0026#34; tag: \u0026#34;registryctl\u0026#34; 删除网络 由于删除log后, 网络不再需要, 因此可以删除, 也就是下面这个\nnetworks: - harbor 最后删除networks配置\nnetworks: harbor: external: false 修复docker login端口 进入config目录执行如下命令, 查询引用到端口的地方(请将11191端口换成自己定义的端口)\nroot@xxx:xxxx/common/config# grep -rn \u0026#34;11191\u0026#34; core/env:8:ext_endpoint=https://dockerhub.akvicor.com:11191 nginx/nginx.conf:147: return 308 https://$host:11191$request_uri; 修改后应该是这样\ncore/env:8:ext_endpoint=https://dockerhub.akvicor.com nginx/nginx.conf:147: return 308 https://$host$request_uri; 删除默认的container_name 删除所有容器的container_name, 方便安装时统一添加前缀\n安装 执行如下命令安装并添加前缀, 这样每个容器的名字都会有个dockerhub前缀, 这样就不会与其他容器冲突了\ndocker compose -p dockerhub up -d ","date":"2024-09-21","permalink":"https://blog.akvicor.com/posts/harbor/install/","summary":"鉴于Harbor官方的安装无比混乱, 因此记录如何将有用的东西提取出来, 最终形成data目录, config目录, docker-compose.yml文件. 修复因端","title":"纯净安装harbor"},{"content":" 2024-09-15 网站搬家中\u0026hellip; 2024-09-17 部分 传送阵 因为年久失修已经不可使用 ","date":"2024-09-15","permalink":"https://blog.akvicor.com/posts/init/","summary":"2024-09-15 网站搬家中\u0026hellip; 2024-09-17 部分 传送阵 因为年久失修已经不可使用","title":"少女祈祷中..."},{"content":"修改时区 ln -sf /usr/share/zoneinfo/etc/gmt-8 /etc/localtime 配置bash命令 alias l=\u0026#39;ls -al --color=auto\u0026#39; alias ll=\u0026#39;ls -alh --color=auto\u0026#39; 配置apt源 删除普通用户 userdel -r admin 安装工具 apt update apt install -y systemd-timesyncd vim curl wget gcc g++ git make screen telnet jq bc tcptrack 修改主机名 vim /etc/hosts vim /etc/hostname 配置ssh key mkdir .ssh chmod 600 .ssh vim .ssh/authorized_keys chmod 600 .ssh/authorized_keys 配置sshd vim /etc/ssh/sshd_config permitrootlogin prohibit-password pubkeyauthentication yes passwordauthentication no clientaliveinterval 15 clientalivecountmax 3 更改密码 passwd 配置git git config --global user.name \u0026#34;akvicor\u0026#34; git config --global user.email akvicor@kayuki.org git config --global core.editor vim motd脚本 vim /etc/motd vim /etc/update-motd.d/99-custom chmod +x /etc/update-motd.d/99-custom 内容\n#!/bin/bash # 主机名 hostname=$(cat /etc/hostname) # 获取系统运行时间（天数） uptime_days=$(awk \u0026#39;{print int($1/86400)}\u0026#39; /proc/uptime) # 获取系统时间 date=$(date) # 获取ipv4地址 ipv4=$(curl -s --max-time 2 ip.sb -4 || echo \u0026#34;-\u0026#34;) # 获取ipv6地址 ipv6=$(curl -s --max-time 2 ip.sb -6 || echo \u0026#34;-\u0026#34;) # 架构 cpu_arch=$(lscpu | grep \u0026#34;^architecture:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $2))}\u0026#39;) # cpu名称 cpu_name=$(lscpu | grep \u0026#34;^model name:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $3))}\u0026#39;) cpu_bios_name=$(lscpu | grep \u0026#34;^bios model name:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $4))}\u0026#39;) # cpu数量 #cpu_num=$(cat /proc/cpuinfo| grep \u0026#34;processor\u0026#34;| wc -l) cpu_num=$(lscpu | grep \u0026#34;^cpu(s):\u0026#34; | awk \u0026#39;{print substr($0, index($0, $2))}\u0026#39;) # cpu socket数量 cpu_socket=$(lscpu | grep \u0026#34;^socket(s):\u0026#34; | awk \u0026#39;{print substr($0, index($0, $2))}\u0026#39;) # cpu core per socket数量 cpu_core_per_socket=$(lscpu | grep \u0026#34;^core(s) per socket:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $4))}\u0026#39;) # cpu thread per core数量 cpu_thread_per_core=$(lscpu | grep \u0026#34;^thread(s) per core:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $4))}\u0026#39;) # cpu最小频率 cpu_min_hz=$(lscpu | grep \u0026#34;^cpu min mhz:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $4))}\u0026#39; | awk \u0026#39;{printf \u0026#34;%.2f\u0026#34;,$0/1000}\u0026#39;) # cpu最大频率 cpu_max_hz=$(lscpu | grep \u0026#34;^cpu max mhz:\u0026#34; | awk \u0026#39;{print substr($0, index($0, $4))}\u0026#39; | awk \u0026#39;{printf \u0026#34;%.2f\u0026#34;,$0/1000}\u0026#39;) # 获取内存占用 mem_usage=$(free -m | sed -n \u0026#39;2p\u0026#39; | awk \u0026#39;{printf \u0026#34;%.2fg / %.2fg\\n\u0026#34;,$3/1024,$2/1024}\u0026#39;) # 获取硬盘使用情况 disk_usage=$(df -h / | awk \u0026#39;nr==2 {print $3 \u0026#34; / \u0026#34; $2}\u0026#39;) echo \u0026#34;-----------------------------------------\u0026#34; echo \u0026#34; hostname: $hostname\u0026#34; echo \u0026#34; online: $uptime_days days\u0026#34; echo \u0026#34; date: $date\u0026#34; echo \u0026#34; network: $ipv4 / $ipv6\u0026#34; echo \u0026#34; cpu arch: ${cpu_arch}\u0026#34; echo \u0026#34; cpu name: ${cpu_name}\u0026#34; echo \u0026#34; cpu bname: ${cpu_bios_name}\u0026#34; echo \u0026#34; cpu num: ${cpu_num}t (${cpu_socket}s*${cpu_core_per_socket}c*${cpu_thread_per_core}t)\u0026#34; echo \u0026#34; cpu hz: ${cpu_min_hz}ghz / ${cpu_max_hz}ghz\u0026#34; echo \u0026#34; memory: $mem_usage\u0026#34; echo \u0026#34; disk: $disk_usage\u0026#34; echo \u0026#34;-----------------------------------------\u0026#34; 安装caddy apt install -y debian-keyring debian-archive-keyring apt-transport-https curl curl -1slf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1slf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | tee /etc/apt/sources.list.d/caddy-stable.list apt update apt install caddy 安装docker apt-get update apt-get install ca-certificates curl install -m 0755 -d /etc/apt/keyrings curl -fssl https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc chmod a+r /etc/apt/keyrings/docker.asc echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$version_codename\u0026#34;) stable\u0026#34; | \\ tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null apt-get update apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin ","date":"2024-08-29","permalink":"https://blog.akvicor.com/posts/linux/vps_init/","summary":"修改时区 ln -sf /usr/share/zoneinfo/Etc/GMT-8 /etc/localtime 配置bash命令 alias l=\u0026#39;ls -Al --color=auto\u0026#39; alias ll=\u0026#39;ls -Alh --color=auto\u0026#39; 配置apt源 删除普通用户 userdel -r admin 安装工具 apt update apt install -y systemd-timesyncd vim curl wget gcc g++ git make screen telnet jq bc tcptrack 修改主机名 vim /etc/hosts vim /etc/hostname 配置ssh key mkdir .ssh chmod 600","title":"vps init"},{"content":"ed25519算法 ssh-keygen -t ed25519 -c \u0026#34;your_email@example.com\u0026#34; 旧算法 ssh-keygen -t rsa -b 4096 -c \u0026#34;your_email@example.com\u0026#34; 设置文件权限 chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys ","date":"2024-08-17","permalink":"https://blog.akvicor.com/posts/linux/ssh_key/","summary":"Ed25519算法 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 旧算法 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 设置文件权限 chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys","title":"ssh 密钥"},{"content":"summary抽屉，可收起和展开\n默认收起 a aaa 默认展开 b bbb ","date":"2024-08-11","permalink":"https://blog.akvicor.com/posts/hugo/summary/","summary":"Summary抽屉，可收起和展开 默认收起 A AAA 默认展开 B BBB","title":"summary"},{"content":"永久关闭ipv6\n编辑grub配置文件/etc/default/grub\n修改增加ipv6.disable=1属性\ngrub_cmdline_linux_default=\u0026#34;quiet splash ipv6.disable=1\u0026#34; grub_cmdline_linux=\u0026#34;ipv6.disable=1\u0026#34; 使设置生效\nupdate-grub ","date":"2024-08-03","permalink":"https://blog.akvicor.com/posts/linux/disable_ipv6/","summary":"永久关闭IPV6 编辑grub配置文件/etc/default/grub 修改增加ipv6.disable=1属性 GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet splash ipv6.disable=1\u0026#34; GRUB_CMDLINE_LINUX=\u0026#34;ipv6.disable=1\u0026#34; 使设置生效 update-grub","title":"disable ipv6"},{"content":"创建新 react 项目\n使用create-react-app创建项目 npx create-react-app 设置yarn版本 前置条件\ncorepack enable # 安装完nodejs后只需要执行一次 设置版本\nyarn policies set-version 4.3.0 修改.yarnrc.yml配置 nodelinker: node-modules yarnpath: .yarn/releases/yarn-4.3.0.cjs 安装依赖 yarn install ","date":"2024-07-27","permalink":"https://blog.akvicor.com/posts/nodejs/new-react-project/","summary":"创建新 React 项目 使用create-react-app创建项目 npx create-react-app 设置yarn版本 前置条件 corepack enable # 安装完nodejs后只需要执行一次 设置版本 yarn policies set-version 4.3.0 修改.yarnrc.","title":"new react project"},{"content":"打开设置按照以下路径进入并关闭\neditor -\u0026gt; inspections -\u0026gt; general -\u0026gt; duplicated code fragment\n","date":"2024-07-06","permalink":"https://blog.akvicor.com/posts/idea/duplicated_code/","summary":"打开设置按照以下路径进入并关闭 Editor -\u0026gt; Inspections -\u0026gt; General -\u0026gt; Duplicated code fragment","title":"重复代码提醒/duplicated code fragment"},{"content":"官方docker-compose文件生成\nhttps://setup.mailu.io/2024.06/\n参考博客\nhttps://www.ywbj.cc/?p=929\n测试服务器是否开启25端口 telnet smtp.google.com 25 #谷歌邮箱地址 # 或者 telnet smtp.qq.com 25 #腾讯qq邮箱 如果已经开启则会显示connected\nroot@mail:~# telnet smtp.qq.com 25 trying 157.148.54.34... connected to smtp.qq.com. escape character is \u0026#39;^]\u0026#39;. 220 newxmesmtplogicsvrsza9.qq.com xmail esmtp qq mail server. 如果未开启会显示一直在连接\nroot@mail:~$ telnet smtp.qq.com 25 trying 157.148.54.34... 设置dns 将 mail.akvicor.com 解析到服务器ip\n安装常用工具 apt-get update apt-get upgrade apt-get install vim gcc g++ nasm make screen git jq bc curl wget 重启\nreboot 关闭密码登录 vim /etc/ssh/sshd_config # passwordauthentication no 安装ufw apt-get install rsyslog ufw 关闭ipv6\nipv6=disable 开放22端口\nufw allow ssh 重启\nreboot 安装 caddy apt install -y debian-keyring debian-archive-keyring apt-transport-https curl curl -1slf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1slf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | tee /etc/apt/sources.list.d/caddy-stable.list apt update apt install caddy 配置\nhttps://mail.akvicor.com { tls /akvicor/arrow/cert/ssl/akvicor.com/crt /akvicor/arrow/cert/ssl/akvicor.com/key encode gzip reverse_proxy https://127.0.0.1:10006 { header_up host {host} header_up x-real-ip {remote} header_up x-forwarded-port {server_port} transport http { tls_insecure_skip_verify } } } 安装docker apt-get update apt-get install ca-certificates curl install -m 0755 -d /etc/apt/keyrings curl -fssl https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc chmod a+r /etc/apt/keyrings/docker.asc echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$version_codename\u0026#34;) stable\u0026#34; | \\ tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null apt-get update apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin crt key 转 pem 直接将后缀改为pem即可, 内容不变\n","date":"2024-06-26","permalink":"https://blog.akvicor.com/posts/mail/install/","summary":"官方docker-compose文件生成 https://setup.mailu.io/2024.06/ 参考博客 https://www.ywbj.cc/?p=929 测试服务器是否开启25端口 telnet smtp.google.com 25 #谷歌邮箱地址 # 或者 telnet smtp.qq.com 25 #腾讯qq邮箱 如果已经开启则会显示Connecte","title":"搭建邮件系统"},{"content":"一个参数 useeffect()本身是一个函数，由 react 框架提供，在函数组件内部调用即可。\n举例来说，我们希望组件加载以后，网页标题（document.title）会随之改变。那么，改变网页标题这个操作，就是组件的副效应，必须通过useeffect()来实现。\nimport react, { useeffect } from \u0026#39;react\u0026#39;; function welcome(props) { useeffect(() =\u0026gt; { document.title = \u0026#39;加载完成\u0026#39;; }); return \u0026lt;h1\u0026gt;hello, {props.name}\u0026lt;/h1\u0026gt;; } 上面例子中，useeffect()的参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，react 就会执行这个函数。（查看运行结果）\nuseeffect()的作用就是指定一个副效应函数，组件每渲染一次，该函数就自动执行一次。组件首次在网页 dom 加载后，副效应函数也会执行。\n两个参数 有时候，我们不希望useeffect()每次渲染都执行，这时可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会重新渲染。\nfunction welcome(props) { useeffect(() =\u0026gt; { document.title = `hello, ${props.name}`; }, [props.name]); return \u0026lt;h1\u0026gt;hello, {props.name}\u0026lt;/h1\u0026gt;; } 上面例子中，useeffect()的第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项（props.name）。只有该变量发生变化时，副效应函数才会执行。\n如果第二个参数是一个空数组，就表明副效应参数没有任何依赖项。因此，副效应函数这时只会在组件加载进入 dom 后执行一次，后面组件重新渲染，就不会再次执行。这很合理，由于副效应不依赖任何变量，所以那些变量无论怎么变，副效应函数的执行结果都不会改变，所以运行一次就够了。\n只运行一次 只需要在第二个参数传入空即可在页面加载后只执行一次\nfunction welcome(props) { useeffect(() =\u0026gt; { document.title = `hello, ${props.name}`; }, []); return \u0026lt;h1\u0026gt;hello, {props.name}\u0026lt;/h1\u0026gt;; } 返回值 副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应。\nuseeffect()允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，useeffect()就不用返回任何值。\nuseeffect(() =\u0026gt; { const subscription = props.source.subscribe(); return () =\u0026gt; { subscription.unsubscribe(); }; }, [props.source]); 上面例子中，useeffect()在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。\n实际使用中，由于副效应函数默认是每次渲染都会执行，所以清理函数不仅会在组件卸载时执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。\n注意 如果有多个副效应，应该调用多个useeffect()，而不应该合并写在一起。\nfunction app() { const [vara, setvara] = usestate(0); const [varb, setvarb] = usestate(0); useeffect(() =\u0026gt; { const timeout = settimeout(() =\u0026gt; setvara(vara + 1), 1000); return () =\u0026gt; cleartimeout(timeout); }, [vara]); useeffect(() =\u0026gt; { const timeout = settimeout(() =\u0026gt; setvarb(varb + 2), 2000); return () =\u0026gt; cleartimeout(timeout); }, [varb]); return \u0026lt;span\u0026gt;{vara}, {varb}\u0026lt;/span\u0026gt;; } ","date":"2024-06-22","permalink":"https://blog.akvicor.com/posts/react/use_effect/","summary":"一个参数 useEffect()本身是一个函数，由 React 框架提供，在函数组件内部调用即可。 举例来说，我们希望组件加载以后，网页标题（document.title）会随","title":"页面加载完毕后执行 useeffect"},{"content":"打开设置搜索inlay hints, 或进入setting/editor/inlay hints, 按照需要关闭\n","date":"2024-06-22","permalink":"https://blog.akvicor.com/posts/idea/inlay_hints/","summary":"打开设置搜索Inlay Hints, 或进入Setting/Editor/Inlay Hints, 按照需要关闭","title":"型参提醒 inlay hints"},{"content":"lsb_release apt-get install lsb-release lsb_release -a issue cat /etc/issue os-release cat /etc/os-release hostnamectl hostnamectl uname uname debian_version cat /etc/debian_version ","date":"2024-05-19","permalink":"https://blog.akvicor.com/posts/linux/debian_version/","summary":"lsb_release apt-get install lsb-release lsb_release -a issue cat /etc/issue os-release cat /etc/os-release hostnamectl hostnamectl uname uname debian_version cat /etc/debian_version","title":"获取 debian version"},{"content":"检查电池电压\nvcgencmd pmic_read_adc batt_v ","date":"2024-05-15","permalink":"https://blog.akvicor.com/posts/raspberry/rtc_battery/","summary":"检查电池电压 vcgencmd pmic_read_adc BATT_V","title":"raspberry pi 5 rtc battery"},{"content":"为其他设备提供ntp授时服务\n# 安装ntp服务 apt-get install ntp # 编辑配置文件, pool 后替换为想要的ntp地址 vim /etc/ntpsec/ntp.conf # 重启ntp服务 systemctl status ntp systemctl restart ntp # 检查ntp同步功能 ntpq -p # 开放udp的123端口 # 检查与ntp服务器的连接, 使用ip可以跳过dns解析 ntpdate -q 13.113.25.87 # 设置ntp服务器 vim /etc/ntpsec/ntp.conf ","date":"2024-05-12","permalink":"https://blog.akvicor.com/posts/linux/ntp/","summary":"为其他设备提供NTP授时服务 # 安装NTP服务 apt-get install ntp # 编辑配置文件, pool 后替换为想要的ntp地址 vim /etc/ntpsec/ntp.conf # 重启NTP服务 systemctl status ntp systemctl restart ntp # 检查NTP同步功能 ntpq -p # 开放UDP","title":"搭建ntp服务器"},{"content":"debian指纹识别\n# 安装 sudo apt install fprintd # 录入 (录入5次后会显示completed) sudo fprintd-enroll # 识别 sudo fprintd-verify ","date":"2024-04-26","permalink":"https://blog.akvicor.com/posts/linux/fingerprint/","summary":"Debian指纹识别 # 安装 sudo apt install fprintd # 录入 (录入5次后会显示completed) sudo fprintd-enroll # 识别 sudo fprintd-verify","title":"指纹识别 fingerprint"},{"content":"通过adb停用系统更新和去除更新统治\n# 屏蔽更新 adb shell pm disable-user com.oneplus.opbackup # 清除更新通知 adb shell pm clear com.oneplus.opbackup # 恢复更新 adb shell pm enable com.oneplus.opbackup ","date":"2024-04-20","permalink":"https://blog.akvicor.com/posts/android/oneplus_disable_update/","summary":"通过ADB停用系统更新和去除更新统治 # 屏蔽更新 adb shell pm disable-user com.oneplus.opbackup # 清除更新通知 adb shell pm clear com.oneplus.opbackup # 恢复更新 adb shell pm enable com.oneplus.opbackup","title":"关闭一加氧系统更新"},{"content":"官方安装教程 https://docs.hoppscotch.io/documentation/self-host/community-edition/install-and-build\nchrome 插件 https://chromewebstore.google.com/detail/hoppscotch-browser-extens/amknoiejhlmhancpahfcfcfhllgkpbld\n安装后在插件中添加域名https://post.akvicor.com来启用插件\n初始化数据库 在安装成功且访问之前, 需要先初始化数据库, 否则容器会崩溃(如果容器已经崩溃, 需要删除容器后重新安装)\n# 进入aio或backend执行 pnpx prisma migrate deploy ","date":"2024-04-13","permalink":"https://blog.akvicor.com/posts/opensource/hoppscotch/","summary":"官方安装教程 https://docs.hoppscotch.io/documentation/self-host/community-edition/install-and-build Chrome 插件 https://chromewebstore.google.com/detail/hoppscotch-browser-extens/amknoiejhlmhancpahfcfcfhllgkpbld 安装后在插件中添加域名https://post.akvicor.com来启用插件 初始化数据库 在安装成功且访问之前, 需要先初始化数据库, 否则","title":"搭建 hoppscotch"},{"content":"引脚定义 展示所有串口 dtoverlay -a | grep uart 查看特定串口信息 dtoverlay -h uart2 开启串口 uart2-5 vim /boot/config.txt # 或 (新版本系统中路径发生变化) vim /boot/firmware/config.txt 在文件结尾添加如下：\ndtoverlay=uart2 dtoverlay=uart3 dtoverlay=uart4 dtoverlay=uart5 重启后查看是否生效：\n# uart1 ls /dev/ttys0 # uart2-5 ls /dev/ttyama* gpio 对应关系 gpio14 = txd0 -\u0026gt; ttyama0 gpio15 = rxd0 -\u0026gt; ttyama0 gpio0 = txd2 -\u0026gt; ttyama2 gpio1 = rxd2 -\u0026gt; ttyama2 gpio4 = txd3 -\u0026gt; ttyama3 gpio5 = rxd3 -\u0026gt; ttyama3 gpio8 = txd4 -\u0026gt; ttyama4 gpio9 = rxd4 -\u0026gt; ttyama$ gpio12 = txd5 -\u0026gt; ttyama5 gpio13 = rxd5 -\u0026gt; ttyama5 ","date":"2024-04-09","permalink":"https://blog.akvicor.com/posts/raspberry/uart/","summary":"引脚定义 展示所有串口 dtoverlay -a | grep uart 查看特定串口信息 dtoverlay -h uart2 开启串口 UART2-5 vim /boot/config.txt # 或 (新版本系统中路径发生变化) vim /boot/firmware/config.txt 在文件结尾添加如下： dtoverlay=uart2 dtoverlay=uart3 dtoverlay=uart4 dtoverlay=uart5 重启后查看是否生效： # UART1 ls /dev/ttyS0 #","title":"树莓派 串口 uart"},{"content":"扩充固件 将.img文件中的分区使用fdisk扩充7g\n写入固件 启用魔法 echo 0xdeadbeef \u0026gt; /etc/config/google_fu_mode shadowsocksr plus+ 添加socks5 opkg update opkg install ipt2socks ","date":"2024-03-24","permalink":"https://blog.akvicor.com/posts/openwrt/install/","summary":"扩充固件 将.img文件中的分区使用fdisk扩充7G 写入固件 启用魔法 echo 0xDEADBEEF \u0026gt; /etc/config/google_fu_mode ShadowSocksR Plus+ 添加Socks5 opkg update opkg install ipt2socks","title":"install openwrt/qwrt"},{"content":"由于css中限制了标签的宽高, 如果标题过长会无法显示, 因此需要修改css中的属性\n在virgo/assets/scss/partials/content/nav.scss中的.container-nav/.toc/li中的width\n","date":"2024-03-16","permalink":"https://blog.akvicor.com/posts/hugo/nav_toc_li/","summary":"由于css中限制了标签的宽高, 如果标题过长会无法显示, 因此需要修改css中的属性 在virgo/assets/scss/partials/content/nav.","title":"nav 右侧导航标题显示不全"},{"content":"","date":"2024-03-11","permalink":"https://blog.akvicor.com/posts/linux/synergy/","summary":"","title":"synergy 多设备鼠标键盘共享"},{"content":"找到主题的layouts/_default/single.html文件\n在{{ define \u0026quot;main\u0026quot; }}后面添加以下内容\n{{ $isnav := eq .title \u0026#34;nav\u0026#34;}} {{ $issearch := eq .title \u0026#34;search\u0026#34;}} {{ $isarchive := eq .title \u0026#34;archive\u0026#34;}} {{ $isabout := eq .title \u0026#34;about\u0026#34;}} {{ $issecrets := eq .section \u0026#34;secrets\u0026#34;}} \u0026lt;!-- 那些不需要文章相关功能（如目录层级，文章切换、字数时长统计等）的页面 --\u0026gt; \u0026lt;!-- {{ $ispurepage := or $isnav $issearch $isarchive $isabout }} --\u0026gt; \u0026lt;!-- 正常博文 --\u0026gt; {{ $ispostpage := and (not $isnav) (not $issearch) (not $isarchive) (not $isabout) }} {{ $iscommentpage := and (not $isnav) (not $issearch) (not $isarchive) }} {{ $is_dev_env := eq .site.baseurl \u0026#34;http://localhost:1313/\u0026#34;}} 在\u0026lt;article\u0026gt;内部的末尾添加\n{{ if and .ispage $iscommentpage (not $issecrets) .site.params.utterances.active (not $is_dev_env) }} {{- partial \u0026#34;partials/comment.html\u0026#34; . -}} {{ end }} 在layouts/partials下添加comment.html文件\n\u0026lt;div class=\u0026#34;container-comment\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;{{.site.params.utterances.repo}}\u0026#34; issue-term=\u0026#34;{{.site.params.utterances.issueterm}}\u0026#34; theme=\u0026#34;{{.site.params.utterances.theme}}\u0026#34; crossorigin=\u0026#34;{{.site.params.utterances.crossorigin}}\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 在配置文件中添加\n[params] # 在开发环境下（http://localhost:1313/），不再启用评论插件， # 如果想在开发环境下启用它，修改服务端口即可，如下 # hugo server -p=1314 [params.utterances] # 是否启用评论插件 active = true # 输入你的仓库名称 repo = \u0026#34;akvicoredwards/blog\u0026#34; issueterm = \u0026#34;pathname\u0026#34; theme = \u0026#34;github-light\u0026#34; crossorigin = \u0026#34;anonymous\u0026#34; ","date":"2024-03-02","permalink":"https://blog.akvicor.com/posts/hugo/add_comment/","summary":"找到主题的layouts/_default/single.html文件 在{{ define \u0026quot;main\u0026quot; }}后面添加以下内容 {{ $IsNav := eq .Title \u0026#34;Nav\u0026#34;}} {{ $IsSearch := eq .Title \u0026#34;Search\u0026#34;}} {{ $IsArchive := eq .Title \u0026#34;Archive\u0026#34;}} {{ $IsAbout := eq .Title \u0026#34;About\u0026#34;}} {{ $IsSecrets := eq .Section \u0026#34;secrets\u0026#34;}}","title":"添加评论功能"},{"content":"special pages interwiki (more information) editors codeeditor (more information) wikieditor (more information) parser hooks categorytree (more information) cite (more information) imagemap (more information) inputbox (more information) math (more information) parserfunctions (more information) poem (more information) scribunto (more information) syntaxhighlight_geshi (more information) templatedata (more information) api pageimages (more information) other multimediaviewer (more information) oathauth (more information) localsettings.php 网站图标 $wgfavicon = \u0026#34;$wgresourcebasepath/resources/assets/snowflake_128.png\u0026#34;; 短url 在编译好的docker镜像中，已经配置好了apache,因此只要修改wiki的配置文件即可\n$wgscriptpath = \u0026#34;\u0026#34;; $wgarticlepath = \u0026#34;/$1\u0026#34;; $wgusepathinfo = true; $wgscriptextension = \u0026#34;.php\u0026#34;; ","date":"2024-02-20","permalink":"https://blog.akvicor.com/posts/wiki/install/","summary":"Special pages Interwiki (more information) Editors CodeEditor (more information) WikiEditor (more information) Parser hooks CategoryTree (more information) Cite (more information) ImageMap (more information) InputBox (more information) Math (more information) ParserFunctions (more information) Poem (more information) Scribunto (more information) SyntaxHighlight_GeSHi (more information) TemplateData (more information) API PageImages (more information) Other MultimediaViewer (more information) OATHAuth (more information) LocalSettings.php 网站图标 $wgFavicon = \u0026#34;$wgResourceBasePath/resources/assets/snowflake_128.png\u0026#34;; 短URL 在编译好的docker镜像","title":"wiki install"},{"content":" m = moveto(m x,y)：起始 将画笔移动到指定的坐标位置 l = lineto(l x,y)：连线 画直线到指定的坐标位置 h = horizontal lineto(h x)：水平线 画水平线到指定的x坐标位置 v = vertical lineto(v y)：垂直线 画垂直线到指定的y坐标位置 c = curveto(c x1,y1,x2,y2,endx,endy)：三次贝塞尔曲线 s = smooth curveto(s x2,y2,endx,endy)：三次贝塞尔曲线 q = quadratic belzier curve(q x,y,endx,endy)：二次贝塞尔曲线 t = smooth quadratic belzier curveto(t endx,endy)：二次贝塞尔曲线 映射 a = elliptical arc(a rx,ry,xrotation,flag1,flag2,x,y)：椭圆弧 弧线 z = closepath()：闭合（从最后一个点连直线到起始点）关闭路径 使用大写字母表示绝对位置，小写字母表示相对位置（相对于起点的位置，向右向下为正）。\n","date":"2024-02-08","permalink":"https://blog.akvicor.com/posts/svg/struct/","summary":"M = moveto(M X,Y)：起始 将画笔移动到指定的坐标位置 L = lineto(L X,Y)：连线 画直线到指定的坐标位置 H = horizontal lineto(H X)：水平线 画水平线到指定的X坐标位置 V = vertical lineto(V Y)：垂直线 画垂直","title":"svg 结构"},{"content":"使触摸板敲击（不是按压）时也产生左键事件\nsudo apt install xserver-xorg-input-synaptics sudo vim /etc/x11/xorg.conf.d/50-synaptics.conf 在文件中添加以下内容\nsection \u0026#34;inputclass\u0026#34; identifier \u0026#34;touchpad catchall\u0026#34; driver \u0026#34;synaptics\u0026#34; matchistouchpad \u0026#34;on\u0026#34; option \u0026#34;tapbutton1\u0026#34; \u0026#34;1\u0026#34; #单指敲击产生左键事件 option \u0026#34;tapbutton2\u0026#34; \u0026#34;2\u0026#34; #双指敲击产生中键事件 option \u0026#34;tapbutton3\u0026#34; \u0026#34;3\u0026#34; #三指敲击产生右键事件 option \u0026#34;vertedgescroll\u0026#34; \u0026#34;on\u0026#34; #滚动操作：横向、纵向、环形 option \u0026#34;verttwofingerscroll\u0026#34; \u0026#34;on\u0026#34; option \u0026#34;horizedgescroll\u0026#34; \u0026#34;on\u0026#34; option \u0026#34;horiztwofingerscroll\u0026#34; \u0026#34;on\u0026#34; option \u0026#34;circularscrolling\u0026#34; \u0026#34;on\u0026#34; option \u0026#34;circscrolltrigger\u0026#34; \u0026#34;2\u0026#34; option \u0026#34;emulatetwofingerminz\u0026#34; \u0026#34;40\u0026#34; #精确度 option \u0026#34;emulatetwofingerminw\u0026#34; \u0026#34;8\u0026#34; option \u0026#34;coastingspeed\u0026#34; \u0026#34;20\u0026#34; #触发快速滚动的滚动速度 option \u0026#34;palmdetect\u0026#34; \u0026#34;1\u0026#34; #避免手掌触发触摸板 option \u0026#34;palmminwidth\u0026#34; \u0026#34;3\u0026#34; #认定为手掌的最小宽度 option \u0026#34;palmminz\u0026#34; \u0026#34;200\u0026#34; #认定为手掌的最小压力值 endsection 键入时禁止触摸板 键入时禁止触摸板可以避免焦点变化，影响当前的输入。 对于使用 startx 来启动的桌面系统，可以修改其 .xinitrc 初始化配置文件来完成：\nsyndaemon -t -k -i 2 -d \u0026amp; 其中的 -i 2 表示两秒空闲，即键盘事件后的两秒内不允许响应触摸板 tap。更多信息请参照手册页：\nman syndaemon 外接鼠标时禁用触摸板 在 arch linux 中，使用 udev 监测硬件的热拔插，通过修改其规则文件，来响应外接鼠标事件，从而禁用和启用触摸板。如下的规则文件，调用了 synclient。\n#file: /etc/udev/rules.d/01-touchpad.rules action==\u0026#34;add\u0026#34;, subsystem==\u0026#34;input\u0026#34;, kernel==\u0026#34;mouse[0-9]\u0026#34;, env{display}=\u0026#34;:0.0\u0026#34;, env{xauthority}=\u0026#34;/home/harttle/.xauthority\u0026#34;, env{id_class}=\u0026#34;mouse\u0026#34;, run+=\u0026#34;/usr/bin/synclient touchpadoff=1\u0026#34; action==\u0026#34;remove\u0026#34;, subsystem==\u0026#34;input\u0026#34;, kernel==\u0026#34;mouse[0-9]\u0026#34;, env{display}=\u0026#34;:0.0\u0026#34;, env{xauthority}=\u0026#34;/home/harttle/.xauthority\u0026#34;, env{id_class}=\u0026#34;mouse\u0026#34;, run+=\u0026#34;/usr/bin/synclient touchpadoff=0\u0026#34; 注意：该文件中每个操作必须单独一行，可以使用 \\ 来折行；subsystem 与 kernel 指定了设备 /dev/input/mouse[0-9]（archwiki的中文页面中此处有误，我会找时间去修改）。了解更多 udev rules 语法：https://wiki.archlinux.org/index.php/udev\n开机时鼠标检测\nps/2 鼠标在开机时不会触发 udev 规则。我们做一个桌面环境的启动脚本，在 .xinitrc，profile 中调用，或者放在 kde 的 autostart 中：\n#!/bin/bash ids=`ls /dev/input/by-id | grep -e \u0026#39;.*-mouse\u0026#39;` [ \u0026#34;$ids\u0026#34; ] \u0026amp;\u0026amp; synclient touchpadoff=1 ","date":"2024-02-06","permalink":"https://blog.akvicor.com/posts/linux/touchpad/","summary":"使触摸板敲击（不是按压）时也产生左键事件 sudo apt install xserver-xorg-input-synaptics sudo vim /etc/X11/xorg.conf.d/50-synaptics.conf 在文件中添加以下内容 Section \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad catchall\u0026#34; Driver \u0026#34;synaptics\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; Option \u0026#34;TapButton1\u0026#34; \u0026#34;1\u0026#34; #单指敲击产生左键事件 Option \u0026#34;TapButton2\u0026#34; \u0026#34;2\u0026#34; #双指敲击产生中键事件 Option \u0026#34;TapButton3\u0026#34; \u0026#34;3\u0026#34; #三指","title":"debian 触摸板 touchpad"},{"content":"暴力删除registry镜像文件\n直接进入这个目录删除仓库 /hhd4/docker/docker_hub/docker/registry/v2/repositories\n进入docker实例执行垃圾回收 /bin/registry garbage-collect /etc/docker/registry/config.yml\n重启registry\n","date":"2024-01-29","permalink":"https://blog.akvicor.com/posts/docker/registry_delete_img/","summary":"暴力删除registry镜像文件 直接进入这个目录删除仓库 /HHD4/docker/docker_hub/docker/registry/v2/repositories 进入docker实例执行垃圾回收 /bin/registry garbage-collect /etc/docker/registry/config.yml 重启registry","title":"暴力删除registry镜像文件"},{"content":"rawmessage scan\u0026amp;value json.rawmessage 以[]byte形式存储json数据，但在父结构体marshal和unmarshal时不会重复序列化，仅仅将数据复制到新json字符串中\n通过继承scanner和valuer实现结构体变量写入和读出数据库\ntype json json.rawmessage func (j *json) scan(value any) error { bytes, ok := value.([]byte) if !ok { return errors.new(fmt.sprint(\u0026#34;failed to unmarshal jsonb value:\u0026#34;, value)) } result := json.rawmessage{} err := json.unmarshal(bytes, \u0026amp;result) *j = json(result) return err } func (j json) value() (driver.value, error) { if len(j) == 0 { return nil, nil } return json.rawmessage(j).marshaljson() } map scan\u0026amp;value type allowappsmodel map[string]bool func (a *allowappsmodel) scan(value any) error { bytes, ok := value.([]byte) if !ok { return errors.new(fmt.sprint(\u0026#34;failed to unmarshal jsonb value:\u0026#34;, value)) } err := json.unmarshal(bytes, a) return err } func (a allowappsmodel) value() (driver.value, error) { return json.marshal(a) } ","date":"2024-01-26","permalink":"https://blog.akvicor.com/posts/golang/gorm/","summary":"RawMessage Scan\u0026amp;Value json.RawMessage 以[]byte形式存储json数据，但在父结构体marshal和unmarshal时不会重复序列化，仅仅将数据复制到新json字符串中 通过继承Scanne","title":"gorm 数据库操作"},{"content":"使用i3的时候终端总是却一些字体,比如fontawesome, 调了半天也没法解决, 无奈只能将所有用到的字体合并成一个字体\n使用fontcreator打开要合并的字体文件\n在characters中选中想要复制的字符，右键复制。\n回到目标字体，edit -\u0026gt; paste special\n等待粘贴完成后，font -\u0026gt; properties... 修改family名称和修改时间\nfont -\u0026gt; export font as导出字体文件\n","date":"2024-01-22","permalink":"https://blog.akvicor.com/posts/font/merge/","summary":"使用i3的时候终端总是却一些字体,比如FontAwesome, 调了半天也没法解决, 无奈只能将所有用到的字体合并成一个字体 使用FontCreator打开要合并的字","title":"合并字体文件"},{"content":"接收端 首先我们有这样一段测试代码来接收 post 请求，并返回其接收到的字段信息。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func urlencodedhandler(w http.responsewriter, r *http.request) { err := r.parseform() if err != nil { log.printf(\u0026#34;r.parseform(): %v\u0026#34;, err) return } result := \u0026#34;\u0026#34; for k, v := range r.form { result += fmt.sprintf(\u0026#34;%s:%v\\n\u0026#34;, k, v) } fmt.fprintf(w, result) } func multiparthandler(w http.responsewriter, r *http.request) { err := r.parsemultipartform(4 * 1024 * 1024) if err != nil { log.printf(\u0026#34;r.parseform(): %v\u0026#34;, err) return } result := \u0026#34;\u0026#34; for k, v := range r.multipartform.value { result += fmt.sprintf(\u0026#34;%s:%v\\n\u0026#34;, k, v) } for k, v := range r.multipartform.file { result += fmt.sprintf(\u0026#34;%s:%v\\n\u0026#34;, k, v) } fmt.fprintf(w, result) } func main() { http.handlefunc(\u0026#34;/urlencoded\u0026#34;, urlencodedhandler) http.handlefunc(\u0026#34;/multipart\u0026#34;, multiparthandler) log.fatal(http.listenandserve(\u0026#34;:8080\u0026#34;, nil)) } 发送 urlencoded 请求 urlencoded 主要用于纯文本请求，代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; ) func main() { payload := url.values{} payload.set(\u0026#34;foo\u0026#34;, \u0026#34;a\u0026#34;) payload.add(\u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) payload.set(\u0026#34;foo2\u0026#34;, \u0026#34;c\u0026#34;) req, err := http.newrequest(http.methodpost, \u0026#34;http://localhost:8080/urlencoded\u0026#34;, strings.newreader(payload.encode())) if err != nil { return } req.header.add(\u0026#34;content-type\u0026#34;, \u0026#34;application/x-www-form-urlencoded; param=value\u0026#34;) resp, err := http.defaultclient.do(req) if err != nil { return } defer resp.body.close() data, _ := ioutil.readall(resp.body) fmt.println(string(data)) } 运行 go run urlencoded.go 输出结果为：\nfoo2:[c] foo:[a b] 发送 multipart 请求 multipart 主要用于发送文件上传的请求，代码如下：\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;mime/multipart\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { buf := new(bytes.buffer) writer := multipart.newwriter(buf) writer.writefield(\u0026#34;foo\u0026#34;, \u0026#34;a\u0026#34;) writer.writefield(\u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) part, err := writer.createformfile(\u0026#34;tmp.png\u0026#34;, \u0026#34;tmp.png\u0026#34;) if err != nil { return } filedata := []byte(\u0026#34;hello,world\u0026#34;) // 此处内容可以来自本地文件读取或云存储 part.write(filedata) if err = writer.close(); err != nil { return } req, err := http.newrequest(http.methodpost, \u0026#34;http://localhost:8080/multipart\u0026#34;, buf) if err != nil { return } req.header.add(\u0026#34;content-type\u0026#34;, writer.formdatacontenttype()) resp, err := http.defaultclient.do(req) if err != nil { return } defer resp.body.close() data, _ := ioutil.readall(resp.body) fmt.println(string(data)) } 运行 go run multipart.go 输出结果为：\nfoo:[a b] tmp.png:[0xc420082410] ","date":"2024-01-20","permalink":"https://blog.akvicor.com/posts/golang/http_get_post/","summary":"接收端 首先我们有这样一段测试代码来接收 POST 请求，并返回其接收到的字段信息。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func urlencodedHandler(w http.ResponseWriter, r *http.Request) { err := r.ParseForm() if err != nil { log.Printf(\u0026#34;r.ParseForm(): %v\u0026#34;, err) return } result := \u0026#34;\u0026#34; for k, v := range r.Form { result += fmt.Sprintf(\u0026#34;%s:%v\\n\u0026#34;, k, v) } fmt.Fprintf(w,","title":"http get/post"},{"content":"右键菜单改回win10(展开) reg add \u0026#34;hkcu\\software\\classes\\clsid\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\inprocserver32\u0026#34; /f /ve taskkill /f /im explorer.exe \u0026amp; start explorer.exe 右键菜单改回win11(折叠) reg delete \u0026#34;hkcu\\software\\classes\\clsid\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\u0026#34; /f taskkill /f /im explorer.exe \u0026amp; start explorer.exe ","date":"2024-01-18","permalink":"https://blog.akvicor.com/posts/windows/windows11_right_click/","summary":"右键菜单改回Win10(展开) reg add \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\u0026#34; /f /ve taskkill /f /im explorer.exe \u0026amp; start explorer.exe 右键菜单改回Win11(折叠) reg delete \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\u0026#34; /f taskkill /f /im explorer.exe \u0026amp; start explorer.exe","title":"还原鼠标右键 restore old right-click context menu in windows 11"},{"content":"介绍 元素为[]byte的队列的golang实现（适用于多线程环境下，当然单线程也能用 如果想更改队列的元素类型，请自行将queue [][]byte中的[]byte替换为其他类型，同时修改函数中的相关代码\n应使用newqueue(size int) *queue来创建队列以初始化队列最大长度 通过互斥锁和信号池保证了在队列非空非满的情况下能够同时push和pop，且在队列空和满的状态下push和pop不会冲突 如果队列为空，则pop会阻塞，同理队列为满时，push会阻塞 由于元素[]byte为slice，deepcopy参数决定push和pop出来的[]byte是深拷贝还是浅拷贝 队列的数据存储使用的循环数组，避免频繁append导致的资源损耗 queue.go package queue import ( \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; ) type queue struct { poolstart chan bool poolend chan bool pushlock sync.mutex poplock sync.mutex maxsize int cursize int32 windex int rindex int queue [][]byte } func newqueue(size int) *queue { return \u0026amp;queue{ // start和end信号池用于保证push和pop操作不会互相干扰 // 每次push和pop操作后，两个信号池中的信号数量都会保持一致 poolstart: make(chan bool, size), poolend: make(chan bool, size), // 保证push操作完整性 pushlock: sync.mutex{}, // 保证pop操作完整性 poplock: sync.mutex{}, // 队列中元素最大数量 maxsize: size, // 队列当前元素数量 cursize: 0, // push指针 windex: 0, // pop指针 rindex: 0, // 元素数组 queue: make([][]byte, size), } } func (q *queue) push(item []byte, deepcopy bool) { q.pushlock.lock() defer func() { // push成功后队列大小+1 atomic.addint32(\u0026amp;q.cursize, 1) q.pushlock.unlock() // 操作必定成功，向end信号池发送一个信号，表示完成此次push q.poolend \u0026lt;- true }() // 操作成功代表队列不满，向start信号池发送一个信号，表示开始push q.poolstart \u0026lt;- true if deepcopy { q.queue[q.windex] = make([]byte, len(item)) copy(q.queue[q.windex], item) } else { q.queue[q.windex] = item } q.windex++ if q.windex \u0026gt;= q.maxsize { q.windex = 0 } } func (q *queue) pop(deepcopy bool) (item []byte) { q.poplock.lock() defer func() { // pop成功后队列大小-1 atomic.addint32(\u0026amp;q.cursize, -1) q.poplock.unlock() // 操作必定成功，当前元素已经成功取出，释放当前位置 \u0026lt;-q.poolstart }() // 操作成功代表队列非空，只有end信号池中有信号，才能保证有完整的元素在队列中 \u0026lt;-q.poolend if deepcopy { item = make([]byte, len(q.queue[q.rindex])) copy(item, q.queue[q.rindex]) } else { item = q.queue[q.rindex] } q.queue[q.rindex] = nil q.rindex++ if q.rindex \u0026gt;= q.maxsize { q.rindex = 0 } return } func (q *queue) size() int32 { return atomic.loadint32(\u0026amp;q.cursize) } func (q *queue) isempty() bool { return atomic.loadint32(\u0026amp;q.cursize) == 0 } queue_test.go package queue import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func testqueue(t *testing.t) { queue := newqueue(3) b1 := []byte{11, 11} b2 := []byte{22, 22} b3 := []byte{33, 33} b4 := []byte{44, 44} fmt.printf(\u0026#34;push b1 cursize:%d\\n\u0026#34;, queue.size()) queue.push(b1, true) fmt.printf(\u0026#34;pushed b1 cursize:%d\\n\u0026#34;, queue.size()) fmt.printf(\u0026#34;push b2 cursize:%d\\n\u0026#34;, queue.size()) queue.push(b2, false) fmt.printf(\u0026#34;pushed b2 cursize:%d\\n\u0026#34;, queue.size()) fmt.printf(\u0026#34;push b3 cursize:%d\\n\u0026#34;, queue.size()) queue.push(b3, false) fmt.printf(\u0026#34;pushed b3 cursize:%d\\n\u0026#34;, queue.size()) // test: push堵塞 go func() { time.sleep(3 * time.second) fmt.printf(\u0026#34;pop b10 cursize:%d\\n\u0026#34;, queue.size()) // test: 深push, 浅pop b1[0] = 22 b10 := queue.pop(false) fmt.printf(\u0026#34;poped b10 [%d,%d] cursize:%d\\n\u0026#34;, b10[0], b10[1], queue.size()) if b10[0] != 11 || b10[1] != 11 { t.errorf(\u0026#34;b10 expected [11,11], but [%d,%d] got\u0026#34;, b10[0], b10[1]) } }() fmt.printf(\u0026#34;push b4 cursize:%d\\n\u0026#34;, queue.size()) queue.push(b4, true) fmt.printf(\u0026#34;pushed b4 cursize:%d\\n\u0026#34;, queue.size()) if queue.size() != 3 { t.errorf(\u0026#34;queue expected 3, but %d got\u0026#34;, queue.size()) } time.sleep(5 * time.second) fmt.printf(\u0026#34;pop b11 cursize:%d\\n\u0026#34;, queue.size()) b11 := queue.pop(true) // test: 浅push, 深pop b2[0] = 33 fmt.printf(\u0026#34;poped b11 [%d,%d] cursize:%d\\n\u0026#34;, b11[0], b11[1], queue.size()) if b11[0] != 22 || b11[1] != 22 { t.errorf(\u0026#34;b11 expected [22,22], but [%d,%d] got\u0026#34;, b11[0], b11[1]) } fmt.printf(\u0026#34;pop b12 cursize:%d\\n\u0026#34;, queue.size()) b12 := queue.pop(false) // test: 浅push, 浅pop b3[0] = 44 fmt.printf(\u0026#34;poped b12 [%d,%d] cursize:%d\\n\u0026#34;, b12[0], b12[1], queue.size()) if b12[0] != 44 || b12[1] != 33 { t.errorf(\u0026#34;b12 expected [44,33], but [%d,%d] got\u0026#34;, b12[0], b12[1]) } fmt.printf(\u0026#34;pop b13 cursize:%d\\n\u0026#34;, queue.size()) b13 := queue.pop(true) // test: 深push, 深pop b4[0] = 55 fmt.printf(\u0026#34;poped b13 [%d,%d] cursize:%d\\n\u0026#34;, b13[0], b13[1], queue.size()) if b13[0] != 44 || b13[1] != 44 { t.errorf(\u0026#34;b13 expected [44,44], but [%d,%d] got\u0026#34;, b13[0], b13[1]) } b5 := []byte{55, 55} // test: pop堵塞 go func() { time.sleep(3 * time.second) fmt.printf(\u0026#34;push b5 cursize:%d\\n\u0026#34;, queue.size()) queue.push(b5, false) fmt.printf(\u0026#34;pushed b5 cursize:%d\\n\u0026#34;, queue.size()) }() fmt.printf(\u0026#34;pop b14 cursize:%d\\n\u0026#34;, queue.size()) b14 := queue.pop(false) // test: 浅push, 浅pop fmt.printf(\u0026#34;poped b14 [%d,%d] cursize:%d\\n\u0026#34;, b14[0], b14[1], queue.size()) if b14[0] != 55 || b14[1] != 55 { t.errorf(\u0026#34;b14 expected [55,55], but [%d,%d] got\u0026#34;, b14[0], b14[1]) } if !queue.isempty() { t.errorf(\u0026#34;queue expected empty, but %v got\u0026#34;, queue.isempty()) } } ","date":"2024-01-06","permalink":"https://blog.akvicor.com/posts/golang/queue/","summary":"介绍 元素为[]byte的队列的golang实现（适用于多线程环境下，当然单线程也能用 如果想更改队列的元素类型，请自行将queue [][]byte中的[]byte","title":"队列 queue"},{"content":"https://github.com/tw93/pake/tree/master\n安装程序\nnpm install pake-cli -g 安装依赖\nsudo apt install libwebkit2gtk-4.0-dev \\ build-essential \\ curl \\ wget \\ file \\ libssl-dev \\ libgtk-3-dev \\ libayatana-appindicator3-dev \\ librsvg2-dev # 安装rust curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -ssf https://sh.rustup.rs | sh 打包网站\n# 打包为appimage可执行程序 pake https://ha.akvicor.com --name \u0026#34;ha\u0026#34; --targets appimage ","date":"2024-01-04","permalink":"https://blog.akvicor.com/posts/linux/pake_webpage_into_desktop_app/","summary":"https://github.com/tw93/Pake/tree/master 安装程序 npm install pake-cli -g 安装依赖 sudo apt install libwebkit2gtk-4.0-dev \\ build-essential \\ curl \\ wget \\ file \\ libssl-dev \\ libgtk-3-dev \\ libayatana-appindicator3-dev \\ librsvg2-dev # 安装rust curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 打包网站 # 打包为appimage可执行程序 pake https://ha.akvicor.com --name \u0026#34;ha\u0026#34; --targets appimage","title":"pake: 打包网页为桌面端应用"},{"content":"nvidia 驱动在linux下, 必须安装 xorg\n查看显卡信息 lspci -k | grep -ea3 \u0026#39;vga|3d|display\u0026#39; lspci | grep vga lspci | grep -i nvidia # 查看指定显卡的详细信息用以下指令 lspci -v -s 00:0f.0 # nvidia自带一个命令行工具可以查看显存的使用情况： nvidia-smi # fan：显示风扇转速，数值在0到100%之间，是计算机的期望转速，如果计算机不是通过风扇冷却或者风扇坏了，显示出来就是n/a； # temp：显卡内部的温度，单位是摄氏度； # perf：表征性能状态，从p0到p12，p0表示最大性能，p12表示状态最小性能； # pwr：能耗表示； # bus-id：涉及gpu总线的相关信息； # disp.a：是display active的意思，表示gpu的显示是否初始化； # memory usage：显存的使用率； # volatile gpu-util：浮动的gpu利用率； # compute m：计算模式； # 如果要周期性的输出显卡的使用情况，可以用watch指令实现 watch -n 10 nvidia-smi # 检测显卡驱动是否正常 sudo apt-get install hwinfo hwinfo --display 安装核显驱动 intel 核显不需要单独安装驱动，系统自带\n# intel 根据驱动官方说法，有功能上的区别。non-free版本是全功能构建版本。 sudo apt install intel-media-va-driver-non-free sudo apt install intel-media-va-driver # amd firmware-amd-graphics 安装nvidia驱动 安装前，可以先安装nvidia的工具检测一下：\nsudo apt install nvidia-detect nvidia-detect sudo apt install nvidia-driver # 安装cuda sudo apt install nvidia-cuda-dev nvidia-cuda-toolkit # 显卡信息查看工具 sudo apt install nvidia-smi 如果出现以下错误是因为secure boot，在主板的bios设置中把这个选项关闭就可以了。\nnvidia-smi has failed because it couldn\u0026#39;t communicate with the nvidia driver. make sure that the latest nvidia driver is installed and running. ","date":"2024-01-03","permalink":"https://blog.akvicor.com/posts/linux/nvidia/","summary":"Nvidia 驱动在Linux下, 必须安装 Xorg 查看显卡信息 lspci -k | grep -EA3 \u0026#39;VGA|3D|Display\u0026#39; lspci | grep VGA lspci | grep -i nvidia # 查看指定显卡的详细信息用以下指令 lspci -v -s 00:0f.0 # Nvidia自带一个命令行工具可以查看显存","title":"nvidia 显卡驱动"},{"content":"修改键盘重复频率和延迟\nxserver startup options as alternative to this tool, you can set defaults for the x server at startup.\nfor the keyboard repeat rate:\n/etc/x11/xinit/xserverrc\nx -ardelay 200 -arinterval 30 # (interval is 1000/rate_in_hz) for this to configure, you need the privileges to edit x launch properties (probably in your login tool like lightdm).\nxserver configuration file xserver since version 21.1.0 supports the option autorepeat. basically you need an xorg config section like this (the second value again 1000/rate_in_hz):\n/etc/x11/xorg.conf.d/\nsection \u0026#34;inputclass\u0026#34; identifier \u0026#34;system-keyboard\u0026#34; matchiskeyboard \u0026#34;on\u0026#34; option \u0026#34;autorepeat\u0026#34; \u0026#34;200 20\u0026#34; endsection ","date":"2024-01-03","permalink":"https://blog.akvicor.com/posts/linux/keyboard_rate/","summary":"修改键盘重复频率和延迟 XServer startup options As alternative to this tool, you can set defaults for the X Server at startup. For the keyboard repeat rate: /etc/X11/xinit/xserverrc X -ardelay 200 -arinterval 30 # (interval is 1000/rate_in_hz) For this to configure, you need the privileges to edit X launch properties (probably in your login tool like lightdm). XServer configuration file XServer since version 21.1.0 supports the option AutoRepeat. Basically you need an xorg","title":"keyboard rate"},{"content":"可以使用xset命令进行操作\nxset dpms force off # 关闭屏幕 xset s 300 #设置屏保时间为300秒，时间单位为秒 xset s 0 #关闭屏幕保护 xset dpms 600 900 1200 # 三个数值分别为standby、suspend、off，具体什么意思就不多说了，单位秒 xset -dpms #关闭电源管理 xset -q # 查看设置情况。 也可以编辑xorg.conf(或者在/etc/x11/xorg.conf.d/添加.conf结尾的配置文件)，添加如下选项把xscreen saver直接关闭:\nsection \u0026#34;serverflags\u0026#34; option \u0026#34;blanktime\u0026#34; \u0026#34;0\u0026#34; #关闭黑屏 option \u0026#34;standbytime\u0026#34; \u0026#34;0\u0026#34; #关闭待机功能 option \u0026#34;suspendtime\u0026#34; \u0026#34;0\u0026#34; #关闭睡眠功能 option \u0026#34;offtime\u0026#34; \u0026#34;0\u0026#34; endsection 修改后重启x即可生效。 编辑xorg.conf文件和使用xset命令效果一样，可使用xset -q查看设置和当前配置。\n","date":"2024-01-03","permalink":"https://blog.akvicor.com/posts/linux/screen/","summary":"可以使用xset命令进行操作 xset dpms force off # 关闭屏幕 xset s 300 #设置屏保时间为300秒，时间单位为秒 xset s 0 #关闭屏幕保护 xset dpms 600 900 1200 # 三个数值分别为Standby、Susp","title":"屏幕保护、息屏"},{"content":"# 安装pptp客户端 apt-get install pptp-linux 编辑配置文件 vim /etc/ppp/chap-secrets\n# secrets for authentication using chap # client\tserver\tsecret\tip addresses your_username pptp your_password home.akvicor.com 在 /etc/ppp/peers/ 下新建一个vpn配置文件，文件名就是vpn的名字 vim /etc/ppp/peers/pptp\npty \u0026#34;pptp home.akvicor.com --nolaunchpppd\u0026#34; name akvicor remotename pptp require-mppe-128 file /etc/ppp/options.pptp ipparam pptp 添加网卡 vim /etc/network/interfaces.d/pptp\nauto ppp0 iface ppp0 inet ppp provider pptp 添加vpn启动脚本，用于修改路由表和dns vim /etc/ppp/ip-up.d/pptp-route\n#!/bin/bash # 关闭vpn时恢复到之前的设置 echo \u0026#34;#!/bin/bash\u0026#34; \u0026gt; /etc/ppp/ip-down.d/pptp-route echo \u0026#34;ip route replace $(ip route show | grep default | head -n 1)\u0026#34; \u0026gt;\u0026gt; /etc/ppp/ip-down.d/pptp-route echo \u0026#34;mv /etc/resolv.conf.viry.bk /etc/resolv.conf\u0026#34; \u0026gt;\u0026gt; /etc/ppp/ip-down.d/pptp-route # 开启vpn时的dns和路由 cp /etc/resolv.conf /etc/resolv.conf.viry.bk echo -e \u0026#34;nameserver 172.16.0.1\\nnameserver 172.16.1.1\u0026#34; \u0026gt; /etc/resolv.conf ip route replace default via 172.16.0.1 dev ppp0 为脚本添加执行权限\nchmod +x /etc/ppp/ip-up.d/pptp-route 开启和关闭vpn\nsudo pon pptp # 开启 sudo poff pptp # 关闭 ","date":"2023-12-29","permalink":"https://blog.akvicor.com/posts/linux/pptp_vpn/","summary":"# 安装PPTP客户端 apt-get install pptp-linux 编辑配置文件 vim /etc/ppp/chap-secrets # Secrets for authentication using CHAP # client server secret IP addresses your_username PPTP your_password home.akvicor.com 在 /etc/ppp/peers/ 下新建一个VPN配置文件，文件名就是VPN的名字 vim /etc/ppp/peers/PPTP pty \u0026#34;pptp home.akvicor.com --nolaunchpppd\u0026#34; name Akvicor remotename PPTP require-mppe-128 file /etc/ppp/options.pptp ipparam PPTP 添加","title":"pptp vpn"},{"content":"官方指导链接 https://github.com/home-assistant/supervised-installer\n安装基础工具 apt update apt upgrade apt install vim screen gcc g++ golang ca-certificates curl gnupg 安装docker # add docker\u0026#39;s official gpg key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fssl https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # add the repository to apt sources: echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$version_codename\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 安装 home assistant supervised 运行于root用户下\n# 安装依赖 apt install \\ apparmor \\ cifs-utils \\ curl \\ dbus \\ jq \\ libglib2.0-bin \\ lsb-release \\ network-manager \\ nfs-common \\ systemd-journal-remote \\ systemd-resolved \\ udisks2 \\ wget -y # 安装docker curl -fssl get.docker.com | sh # os-agent # 教程 https://github.com/home-assistant/os-agent/tree/main#using-home-assistant-supervised-on-debian # 下载 https://github.com/home-assistant/os-agent/releases/latest sudo dpkg -i os-agent_1.0.0_linux_x86_64.deb # 测试是否安装成功（没有报错表示成功 gdbus introspect --system --dest io.hass.os --object-path /io/hass/os # 安装 home assistant supervised wget -o homeassistant-supervised.deb https://github.com/home-assistant/supervised-installer/releases/latest/download/homeassistant-supervised.deb apt install ./homeassistant-supervised.deb # 默认 $data_share 是 /usr/share/hassio，可以通过以下命令更改 data_share=/my/own/homeassistant dpkg --force-confdef --force-confold -i homeassistant-supervised.deb # 如果报错可以通过以下命令查看报错信息 journalctl -f # 安装hacs # 在ha中安装ssh \u0026amp; web terminal并执行（注意修改默认22端口为随机临时端口 wget -o - https://get.hacs.xyz | bash - ","date":"2023-12-12","permalink":"https://blog.akvicor.com/posts/ha/install/","summary":"官方指导链接 https://github.com/home-assistant/supervised-installer 安装基础工具 apt update apt upgrade apt install vim screen gcc g++ golang ca-certificates curl gnupg 安装Docker # Add Docker\u0026#39;s official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # Add the repository to Apt sources: echo \\ \u0026#34;deb [arch=$(dpkg","title":"home assistant install"},{"content":"若拉取时提示无法验证包，可以添加以下环境变量以信任此地址\n关闭指定域名的包验证 export gonosumdb=git.akvicor.com 关闭所有域名的包验证 export gosumdb=off ","date":"2023-11-30","permalink":"https://blog.akvicor.com/posts/golang/private_go_module/","summary":"若拉取时提示无法验证包，可以添加以下环境变量以信任此地址 关闭指定域名的包验证 export GONOSUMDB=git.akvicor.com 关闭所有域名的包验证 export GOSUMDB=off","title":"拉取私有go module"},{"content":"删除指定目录下指定文件\nfind /path -name .svn | xargs rm -rf\n删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r\n分析：\nfind -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录 | xargs rm -r 执行删除指令\n删除目录下所有exe文件\nfind . -name '*.exe' -type f -print -exec rm -rf {} \\;\n. 表示从当前目录开始递归查找 -name '*.exe' 根据名称来查找，要查找所有以.exe结尾的文件夹或者文件 -type f 查找的类型为文件 -print 输出查找的文件目录名 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号. ","date":"2023-09-19","permalink":"https://blog.akvicor.com/posts/linux/search_and_delete/","summary":"删除指定目录下指定文件 find /path -name .svn | xargs rm -rf 删除指定名称的文件或文件夹: find -type d | grep .svn$ | xargs rm -r 分析： find -type d | grep .svn$ 通过此命令查找文件夹 过滤正则表达式中的目录 | xargs rm -r 执行删","title":"使用find和rm搜索并删除文件"},{"content":" 在win10系统下，按住键盘的 “win+r” 组合快捷键，系统将会打开“运行”命令对话窗口。 在打开的运行命令对话框中输入 “gpedit.msc” 命令，然后再点击“确定”按钮。 点击确定按钮后，这个时候会打开 “本地组策略编辑器” 对话窗口， 在本地组策略编辑器窗口的左侧小窗口中，依次展开 “用户配置\u0026ndash;\u0026gt;管理模版\u0026ndash;\u0026gt;windows组件” 选项。 在“windows组件”选项右侧窗口，找到 “文件资源管理器” 选项选中并双击鼠标左键将其打开。 进去到文件资源管理器中，找到 “关闭隐藏的 thumbs.db 文件中的缩略图缓存” 并双击鼠标左键将其打开。 在打开的“关闭隐藏的 thumbs.db 文件中的缩略图缓存”对话窗口中，将其设置更改为 “已启用” 选项，然后在点击“应用\u0026ndash;\u0026gt;确定”按钮退出即可。 ","date":"2023-09-19","permalink":"https://blog.akvicor.com/posts/windows/thumbs/","summary":"在Win10系统下，按住键盘的 “Win+R” 组合快捷键，系统将会打开“运行”命令对话窗口。 在打开的运行命令对话框中输入 “gpedit.msc” 命令，然后再点击“","title":"禁止windows系统生成thumbs.db缩略图缓存"},{"content":"安装配置 # 安装x11vnc apt install x11vnc # 设置开机自动启动连接密码,将密码储存在/etc/x11vnc.pass 下 x11vnc -storepasswd /etc/x11vnc.pass 查看认证服务 ps wwwwaux | grep auth 类似以下信息中的/var/run/lightdm/root/:0\n/usr/lib/xorg/xorg :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch 创建服务 vim /lib/systemd/system/x11vnc.service 添加以下内容\n[unit] description=start x11vnc at startup after=multi-user.target [service] type=simple execstart=/usr/bin/x11vnc -auth /var/run/lightdm/root/:0 -rfbauth /etc/x11vnc.pass -rfbport 5900 [install] wantedby=multi-user.target systemctl enable x11vnc systemctl start x11vnc ","date":"2023-08-09","permalink":"https://blog.akvicor.com/posts/linux/x11vnc_server/","summary":"安装配置 # 安装x11vnc apt install x11vnc # 设置开机自动启动连接密码,将密码储存在/etc/x11vnc.pass 下 x11vnc -storepasswd /etc/x11vnc.pass 查看认证服务 ps wwwwaux | grep auth 类似以下信息中的/var/","title":"x11vnc srver"},{"content":"缺少google api 密钥，因此chromium 的部分功能将无法使用 1. 设置环境变量，屏蔽提示 (会导致无法登录google) setx google_api_key \u0026#34;no\u0026#34; setx google_default_client_id \u0026#34;no\u0026#34; setx google_default_client_secret \u0026#34;no\u0026#34; 2. 配置google api key https://cloud.google.com/console 创建或选择已有项目 -\u0026gt; 左侧边栏 api和服务 -\u0026gt; 凭证 创建凭证(类型为 “api 密钥”,名称随意, 不使用密钥限制,记住生成的key) 再创建一个凭证(类型为 “oauth 客户端 id”, 名称随意, 应用类型选择 “其他”, 记住生成的 “客户端 id” 和 “客户端密钥”) 格式填写自己的 api key setx google_api_key 生成的api密钥 setx google_default_client_id 生成的客户端id setx google_default_client_secret 生成的客户端密钥 ","date":"2023-08-08","permalink":"https://blog.akvicor.com/posts/windows/chromium_tips/","summary":"缺少Google API 密钥，因此Chromium 的部分功能将无法使用 1. 设置环境变量，屏蔽提示 (会导致无法登录Google) setx GOOGLE_API_KEY \u0026#34;no\u0026#34; setx GOOGLE_DEFAULT_CLIENT_ID \u0026#34;no\u0026#34; setx GOOGLE_DEFAULT_CLIENT_SECRET \u0026#34;no\u0026#34; 2. 配置Google API Key https://cloud.google.com/console","title":"chromium tips"},{"content":"编写 将js文件放在主题的static/js文件夹中，css文件放在主题的static/css文件夹中\n在layouts/partials/head.html中添加\n\u0026lt;script src=\u0026#34;/js/hide_and_seek.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/css/hide_and_seek.css\u0026#34;\u0026gt; 编写hide_and_seek.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/hide_and_seek.html --\u0026gt; \u0026lt;hide_and_seek\u0026gt;{{ .inner }}\u0026lt;/hide_and_seek\u0026gt; 使用 {{\u0026lt;hide_and_seek\u0026gt;}} 普通信息 {{\u0026lt;/hide_and_seek\u0026gt;}} {{\u0026lt;hide_and_seek\u0026gt;}} \u0026lt;strong\u0026gt;hello\u0026lt;/strong\u0026gt; ⮞ {{\u0026lt;/hide_and_seek\u0026gt;}} 隐藏的内容在两条分割线之间，若想查看请按照以下方法操作\n电脑：上上下下左右左右baba （上下左右请使用方向键 手机：上上下下左右左右 （上下左右请使用触屏 普通信息 hello ⮞ ","date":"2023-08-05","permalink":"https://blog.akvicor.com/posts/hugo/hide_and_seek/","summary":"编写 将js文件放在主题的static/js文件夹中，css文件放在主题的static/css文件夹中 在layouts/partials/head.html中添加","title":"hide and seek"},{"content":"当页面失去焦点时改变标题，恢复焦点时恢复标题\n将js文件放在主题的static/js文件夹中\n在layouts/partials/head.html中添加\n{{ if .site.params.funnytitle | default false }} \u0026lt;script src=\u0026#34;/js/funny_title.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{- end -}} 此时在hugo.toml中添加以下内容开启\n[params] # 动态标题 funnytitle = true funny_title.js ( function (global) { var vendorprefix=getbrowserprefix(); var eventname=visibilityevent(vendorprefix); document.addeventlistener(eventname,visibilityeventcallback); var titletime; var oldtitle=document.title; function visibilityeventcallback(){ if(document.hidden){ document.title=\u0026#34;╭(°a°`)╮ 页面崩溃啦 ~ 快回来看看~ | \u0026#34;+oldtitle; cleartimeout(titletime); }else{ document.title=\u0026#34;(ฅ\u0026gt;ω\u0026lt;*ฅ) 噫又好了~\u0026#34;; titletime = settimeout(function() { document.title = oldtitle; }, 2000); } } // get browser-specifc prefix function getbrowserprefix() { // check for the unprefixed property. if (\u0026#39;hidden\u0026#39; in document) { return null; } // all the possible prefixes. var browserprefixes = [\u0026#39;moz\u0026#39;, \u0026#39;ms\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;webkit\u0026#39;]; for (var i = 0; i \u0026lt; browserprefixes.length; i++) { var prefix = browserprefixes[i] + \u0026#39;hidden\u0026#39;; if (prefix in document) { return browserprefixes[i]; } } // the api is not supported in browser. return null; } // get browser specific hidden property function hiddenproperty(prefix) { if (prefix) { return prefix + \u0026#39;hidden\u0026#39;; } else { return \u0026#39;hidden\u0026#39;; } } // get browser specific visibility state function visibilitystate(prefix) { if (prefix) { return prefix + \u0026#39;visibilitystate\u0026#39;; } else { return \u0026#39;visibilitystate\u0026#39;; } } // get browser specific event function visibilityevent(prefix) { if (prefix) { return prefix + \u0026#39;visibilitychange\u0026#39;; } else { return \u0026#39;visibilitychange\u0026#39;; } } })(this); ","date":"2023-08-05","permalink":"https://blog.akvicor.com/posts/hugo/funny_title/","summary":"当页面失去焦点时改变标题，恢复焦点时恢复标题 将js文件放在主题的static/js文件夹中 在layouts/partials/head.html中添加 {{ if .Site.Params.funnyTitle | default","title":"funny title"},{"content":"删除图片边框 修改文件 themes/archive/assets/css/main.css，注释掉border: 3px solid #ececec;。\n","date":"2023-07-26","permalink":"https://blog.akvicor.com/posts/hugo/img_style/","summary":"删除图片边框 修改文件 themes/archive/assets/css/main.css，注释掉border: 3px solid #ececec;。","title":"修改图片展示样式"},{"content":"服务端（家庭宽带路由器架设 设置ppt服务器ip为路由器ip 172.16.1.1 客户端分配的ip范围 172.16.1.200-209 设置dns 172.16.1.1 设置用户名和密码 修改防火墙常规设置，转发由拒绝改为接受，否则客户端连接后无法通过服务端访问外部网络。 客户端 安卓 服务器地址 home.akvicor.com 选中 ppp encryption (mppe) 填写用户名和密码 若无网络可以尝试设置以下选项\n方法2会导致本地ip范围以外的访问请求不再经过vpn\ndns servers 172.16.1.1 forwarding routes 172.16.1.0/24 （转发到vpn的目标ip地址范围 windows 服务器地址 home.akvicor.com 选中 ppp encryption (mppe) 填写用户名和密码 若无网络可以尝试设置以下方式\n此种方法会导致本地ip范围以外的访问请求不再经过vpn\n打开控制面板的网络连接，找到vpn创建的网络适配器，右键打开属性，点击网络选项，点开ipv4属性，取消勾选在远程网络上使用默认网关.\n","date":"2023-07-22","permalink":"https://blog.akvicor.com/posts/openwrt/pptp_vpn/","summary":"服务端（家庭宽带路由器架设 设置PPT服务器IP为路由器IP 172.16.1.1 客户端分配的ip范围 172.16.1.200-209 设置DNS 172.16.1.1 设置用户名和密码 修改防火墙常规设置，转发由拒绝改为接受，否则客户端","title":"pptp vpn"},{"content":"编写 编写arrow.html、arrow_colour.html、arrow_?.html或arrow_?_colour.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/arrow.html --\u0026gt; \u0026lt;font color=\u0026#34;#9b59b6\u0026#34;\u0026gt;➤\u0026lt;/font\u0026gt; \u0026lt;!-- layouts/shortcodes/arrow_colour.html --\u0026gt; \u0026lt;font color=\u0026#34;{{ .inner }}\u0026#34;\u0026gt;➤\u0026lt;/font\u0026gt; 使用 {{\u0026lt;arrow\u0026gt;}} {{\u0026lt;arrow_up\u0026gt;}} {{\u0026lt;arrow_down\u0026gt;}} {{\u0026lt;arrow_left\u0026gt;}} {{\u0026lt;arrow_right\u0026gt;}} {{\u0026lt;arrow_colour\u0026gt;}}#7d3c98{{\u0026lt;/arrow_colour\u0026gt;}} {{\u0026lt;arrow_up_colour\u0026gt;}}#7d3c98{{\u0026lt;/arrow_up_colour\u0026gt;}} {{\u0026lt;arrow_down_colour\u0026gt;}}#7d3c98{{\u0026lt;/arrow_down_colour\u0026gt;}} {{\u0026lt;arrow_left_colour\u0026gt;}}#7d3c98{{\u0026lt;/arrow_left_colour\u0026gt;}} {{\u0026lt;arrow_right_colour\u0026gt;}}#7d3c98{{\u0026lt;/arrow_right_colour\u0026gt;}} ➤ ⮝ ⮟ ⮜ ⮞\n➤ ⮝ ⮟ ⮜ ⮞\n","date":"2023-07-10","permalink":"https://blog.akvicor.com/posts/hugo/arrow/","summary":"编写 编写arrow.html、arrow_colour.html、arrow_?.html或arrow_?_colour.html放在layouts/short","title":"arrow"},{"content":"编写 编写tag.html或tag_?.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/tag.html --\u0026gt; \u0026lt;strong style= \u0026#34;background: {{ .get \u0026#34;colour\u0026#34; }};border: 1px solid {{ .get \u0026#34;colour\u0026#34; }};border-radius: 5px;\u0026#34;\u0026gt;{{ .get \u0026#34;tag\u0026#34; }}\u0026lt;/strong\u0026gt; \u0026lt;!-- layouts/shortcodes/tag_academic.html --\u0026gt; \u0026lt;strong style= \u0026#34;background: #33bbff;border: 1px solid #33bbff;border-radius: 5px;\u0026#34;\u0026gt;学术\u0026lt;/strong\u0026gt; 使用 {{\u0026lt; tag colour=\u0026#34;green\u0026#34; tag=\u0026#34;自定义\u0026#34; \u0026gt;}} {{\u0026lt; tag_academic \u0026gt;}} {{\u0026lt; tag_read \u0026gt;}} {{\u0026lt; tag_sport \u0026gt;}} {{\u0026lt; tag_kegel \u0026gt;}} {{\u0026lt; tag_relax \u0026gt;}} {{\u0026lt; tag_bathe \u0026gt;}} {{\u0026lt; tag_play \u0026gt;}} {{\u0026lt; tag_go_out \u0026gt;}} {{\u0026lt; tag_hentai \u0026gt;}} 自定义 学术 阅读 运动 提肛 放松 洗澡 游戏 外出 \u0026nbsp;色色\u0026nbsp;\n","date":"2023-07-09","permalink":"https://blog.akvicor.com/posts/hugo/tag/","summary":"编写 编写tag.html或tag_?.html放在layouts/shortcodes/文件夹中 \u0026lt;!-- layouts/shortcodes/tag.html --\u0026gt; \u0026lt;strong style= \u0026#34;background: {{ .Get \u0026#34;colour\u0026#34; }};border: 1px solid {{ .Get \u0026#34;colour\u0026#34; }};border-radius: 5px;\u0026#34;\u0026gt;{{ .Get \u0026#34;tag\u0026#34; }}\u0026lt;/strong\u0026gt; \u0026lt;!-- layouts/shortcodes/tag_academic.html --\u0026gt; \u0026lt;strong style= \u0026#34;background: #33BBFF;border: 1px solid #33BBFF;border-radius: 5p","title":"tag"},{"content":"1. 下载字体 添加到static/fonts文件夹下，若使用了主题则可以放在主题的fonts文件夹下，如themes/archie/static/fonts。\n2. 添加字体 在fonts.css中添加字体，如themes/archie/assets/css/fonts.css\notf目前可以在大多数浏览器中使用。\n/* notosanssc black */ @font-face { font-family: \u0026#39;notosanssc black\u0026#39;; font-style: black; font-weight: 400; src: url(\u0026#39;../fonts/notosanssc-black.otf\u0026#39;) format(\u0026#39;opentype\u0026#39;); } /* notosanssc bold */ @font-face { font-family: \u0026#39;notosanssc bold\u0026#39;; font-style: bold; font-weight: 400; src: url(\u0026#39;../fonts/notosanssc-bold.otf\u0026#39;) format(\u0026#39;opentype\u0026#39;); } /* notosanssc regular */ @font-face { font-family: \u0026#39;notosanssc regular\u0026#39;; font-style: normal; font-weight: 400; src: url(\u0026#39;../fonts/notosanssc-regular.otf\u0026#39;) format(\u0026#39;opentype\u0026#39;); } 但如果想支持多种浏览器，建议切换到woff和ttf字体。\n可以通过以下工具转换。https://transfonter.org/\n@font-face { font-family: graublauweb; src: url(\u0026#34;path/graublauwebbold.woff\u0026#34;) format(\u0026#34;woff\u0026#34;), url(\u0026#34;path/graublauwebbold.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); } 3. 引用 在archive主题中，可以通过修改themes/archie/assets/css/main.css来修改某个标签的字体或全局字体\nstrong { font-family: \u0026#39;notosanssc bold\u0026#39;, sans-serif; line-height: 1.5; } ","date":"2023-07-08","permalink":"https://blog.akvicor.com/posts/hugo/change_font/","summary":"1. 下载字体 添加到static/fonts文件夹下，若使用了主题则可以放在主题的fonts文件夹下，如themes/archie/static/fonts。 2. 添加","title":"修改字体"},{"content":"hiberfil.sys文件位于系统盘的根目录下，这是一个受保护的操作系统文件，它是 win10 休眠功能（hibernation）中将内存数据与会话数据保存到电脑硬盘、以便于win10计算机断电重新启动后可以快速恢复会话所需的内存镜像文件。在离开计算机一段时间后，计算机将会进入休眠状态。计算机休眠文件就是hiberfil.sys，一般情况它会占用很大存储空间。\n打开管理员cmd命令窗口输入：\n关闭 powercfg -h off 打开 powercfg -h on ","date":"2023-06-28","permalink":"https://blog.akvicor.com/posts/windows/hibernate/","summary":"Hiberfil.sys文件位于系统盘的根目录下，这是一个受保护的操作系统文件，它是 win10 休眠功能（Hibernation）中将内存数据与会话数据保存到电脑硬盘、以","title":"disable windows hibernate"},{"content":"修改/etc/config/ttyd\nconfig ttyd option interface \u0026#39;@lan\u0026#39; option command \u0026#39;/bin/login\u0026#39; option ssl \u0026#39;true\u0026#39; option ssl_cert \u0026#39;/viry/cert/akvicor.com.crt\u0026#39; option ssl_key \u0026#39;/viry/cert/akvicor.com.key\u0026#39; ","date":"2023-06-28","permalink":"https://blog.akvicor.com/posts/openwrt/ttyd_ssl/","summary":"修改/etc/config/ttyd config ttyd option interface \u0026#39;@lan\u0026#39; option command \u0026#39;/bin/login\u0026#39; option ssl \u0026#39;true\u0026#39; option ssl_cert \u0026#39;/viry/cert/akvicor.com.crt\u0026#39; option ssl_key \u0026#39;/viry/cert/akvicor.com.key\u0026#39;","title":"ttyd 开启ssl"},{"content":"暂停uhttpd服务 uhttpd服务占用了80端口，需要先暂停。使用ssh登录openwrt，执行下面命令暂停uhttpd服务：\n/etc/init.d/uhttpd stop /etc/init.d/uhttpd disable 下载caddy 额外功能模块选上aksdb/caddy-cgi/v2\n下载后放到/viry/bin目录下，并重命名为caddy，并给予执行权限：\nchmod +x /viry/bin/caddy 配置caddy 增加下面的配置，并放到/etc/config/caddyfile文件中：\n{ order cgi last } :80 { @notcgi { not path /cgi-bin/* not path / } redir / /cgi-bin/luci file_server @notcgi { root /www } cgi /cgi-bin/luci* /www/cgi-bin/luci { script_name /cgi-bin/luci } } https://op.akvicor.com { encode gzip tls /viry/cert/akvicor.com.crt /viry/cert/akvicor.com.key @notcgi { not path /cgi-bin/* not path / } redir / /cgi-bin/luci file_server @notcgi { root /www } cgi /cgi-bin/luci* /www/cgi-bin/luci { script_name /cgi-bin/luci } } 增加启动脚本 增加自启动脚本，并保存到/etc/init.d/caddy中：\n#!/bin/sh /etc/rc.common start=99 service_use_pid=1 service_write_pid=1 service_daemonize=1 start() { service_start /viry/bin/caddy run --config /etc/config/caddyfile } stop() { service_stop /viry/bin/caddy } 给予执行权限：\nchmod +x /etc/init.d/caddy 运行 执行下面脚本运行caddy服务，并加入到自启动中：\n/etc/init.d/caddy enable /etc/init.d/caddy start 成功启动后，就可以正常访问后台了\n","date":"2023-06-28","permalink":"https://blog.akvicor.com/posts/openwrt/replace_uhttp_with_caddy/","summary":"暂停uhttpd服务 uhttpd服务占用了80端口，需要先暂停。使用ssh登录openwrt，执行下面命令暂停uhttpd服务： /etc/init.d/uhttpd stop /etc/init.d/uhttpd disable 下载caddy 额外功能模","title":"openwrt管理后台使用caddy代替uhttpd"},{"content":"平台 ubuntu 20.04.6 lts 编译环境 sudo apt update -y sudo apt full-upgrade -y sudo apt install -y ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \\ bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \\ git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev \\ libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libreadline-dev libssl-dev libtool lrzsz \\ mkisofs msmtp nano ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 python3-pyelftools \\ libpython3-dev qemu-utils rsync scons squashfs-tools subversion swig texinfo uglifyjs upx-ucl unzip \\ vim wget xmlto xxd zlib1g-dev 编译openwrt # 下载 git clone https://github.com/coolsnowwolf/lede \u0026amp;\u0026amp; cd lede # 添加其他源 echo \u0026#34;src-git kenzo https://github.com/kenzok8/openwrt-packages\u0026#34; \u0026gt;\u0026gt; feeds.conf.default echo \u0026#34;src-git small https://github.com/kenzok8/small\u0026#34; \u0026gt;\u0026gt; feeds.conf.default # 更新源 ./scripts/feeds update -a ./scripts/feeds install -a # 修改默认ip为 10.0.0.2 sed -i \u0026#39;s/192.168.1.1/172.16.1.1/g\u0026#39; package/base-files/files/bin/config_generate # 修改默认主机名 sed -i \u0026#39;/uci commit system/i\\uci set system.@system[0].hostname=\u0026#39;op\u0026#39;\u0026#39; package/lean/default-settings/files/zzz-default-settings # 加入编译者信息 sed -i \u0026#34;s/openwrt /akvicor build $(tz=utc-8 date \u0026#34;+%y.%m.%d\u0026#34;) @ openwrt /g\u0026#34; package/lean/default-settings/files/zzz-default-settings # 修改banner echo -e \u0026#34;-------------------------------------------\\n %d %v, %c\\n-------------------------------------------\u0026#34; \u0026gt; package/base-files/files/etc/banner # 修改ipsec vpn账户名 sed -i \u0026#34;s/ \u0026#39;lean\u0026#39;/ \u0026#39;akvicor\u0026#39;/g\u0026#34; feeds/luci/applications/luci-app-ipsec-vpnd/root/etc/config/ipsec # 配置 make menuconfig # 修改分区大小 target images -\u0026gt; kernel partition size -\u0026gt; 64 target images -\u0026gt; root filesystem partition size -\u0026gt; 4096 # 添加编程语言支持 languages -\u0026gt; go -\u0026gt; golang -\u0026gt; on # 关闭adbyby plus luci -\u0026gt; 3. applications -\u0026gt; luci-app-adbyby-plus -\u0026gt; off # 添加adguardhome luci -\u0026gt; 3. applications -\u0026gt; luci-app-adguardhome -\u0026gt; on # 添加eqos luci -\u0026gt; 3. applications -\u0026gt; luci-app-eqos -\u0026gt; on # 添加passwall代理 luci -\u0026gt; 3. applications -\u0026gt; luci-app-passwall -\u0026gt; on # 添加方糖气球 serverchan luci -\u0026gt; 3. applications -\u0026gt; luci-app-serverchan -\u0026gt; on # 添加watchcat luci -\u0026gt; 3. applications -\u0026gt; luci-app-watchcat -\u0026gt; on # 关闭迅雷快鸟 luci -\u0026gt; 3. applications -\u0026gt; luci-app-xlnetacc -\u0026gt; off # 关闭zerotier (一个开源vpn服务，但是需要通过第三方网站使用 luci -\u0026gt; 3. applications -\u0026gt; luci-app-zerotier -\u0026gt; off # 下载 make download -j8 # 编译 screen -s build make v=s -j1 在esxi测试 # 上传vmdk文件 # ssh连接esxi cd /vmfs/volumes/hhd/op ls *.vmdk vmkfstools -i openwrt-x86-64-generic-squashfs-combined-efi.vmdk opd.vmdk vmkfstools -x 5120m opd.vmdk # 需大于源文件大小 # 更换op虚拟机的硬盘文件 # 配置测试网络 vim /etc/config/network # 修改lan的ip地址 # 重启网络，通过浏览器访问 /etc/init.d/network restart ","date":"2023-06-26","permalink":"https://blog.akvicor.com/posts/openwrt/compile/","summary":"平台 Ubuntu 20.04.6 LTS 编译环境 sudo apt update -y sudo apt full-upgrade -y sudo apt install -y ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \\ bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \\ git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev \\ libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libreadline-dev libssl-dev libtool lrzsz \\ mkisofs msmtp nano ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 python3-pyelftools \\ libpython3-dev qemu-utils rsync scons","title":"compile"},{"content":"配置 端口：11004 5553重定向：使用53端口替换dnsmasq 执行文件路径：/viry/serv/adguardhome/exec/adguardhome 配置文件路径：/viry/serv/adguardhome/data/adguardhome.yaml 工作目录：/viry/serv/adguardhome 运行日志路径：/viry/serv/adguardhome/data/adguardhome.log 无法更新内核 问题出在默认执行文件路径不对，将执行文件路径修改为 /usr/bin/adguardhome/adguardhome\n将adguard home作为dns服务器时无网络问题。 53重定向：使用53端口替换dnsmasq\n问题出在端口无法为客户端提供dns服务器，所以需要手动在dhcp选项中添加。\n接口 -\u0026gt; lan -\u0026gt; dhcp 服务器 -\u0026gt; 高级设置 -\u0026gt; 6,172.16.1.1 接口 -\u0026gt; plan -\u0026gt; dhcp 服务器 -\u0026gt; 高级设置 -\u0026gt; 6,192.168.1.1 ","date":"2023-06-26","permalink":"https://blog.akvicor.com/posts/openwrt/adguard_home/","summary":"配置 端口：11004 5553重定向：使用53端口替换dnsmasq 执行文件路径：/viry/serv/AdGuardHome/exec/AdGuardHome 配","title":"adguard home"},{"content":"将窗口标题中带有指定字符串的窗口置顶，使其显示在所有窗口之上\npackage main import ( \u0026#34;golang.org/x/sys/windows\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;unsafe\u0026#34; ) func alwaysontop() { setwindowalwaysontop(getwindowhandlebywindowname(\u0026#34;title\u0026#34;)) } const swp_nosize = uintptr(0x0001) const swp_nomove = uintptr(0x0002) // this is dumb but go doesn\u0026#39;t like the inline conversion (see above image). func inttouintptr(value int) uintptr { return uintptr(value) } func setwindowalwaysontop(hwnd uintptr) { user32dll := windows.mustloaddll(\u0026#34;user32.dll\u0026#34;) setwindowpos := user32dll.mustfindproc(\u0026#34;setwindowpos\u0026#34;) setwindowpos.call(hwnd, inttouintptr(-1), 0, 0, 100, 100, swp_nosize|swp_nomove) } func getwindowhandlebywindowname(window_name string) uintptr { user32dll := windows.mustloaddll(\u0026#34;user32.dll\u0026#34;) enumwindows := user32dll.mustfindproc(\u0026#34;enumwindows\u0026#34;) var the_handle uintptr window_byte_name := []byte(window_name) // windows will loop over this function for each window. wndenumproc_function := syscall.newcallback(func(hwnd uintptr, lparam uintptr) uintptr { // allocate 100 characters so that it has something to write to. var filename_data [100]uint16 max_chars := uintptr(100) getwindowtextw := user32dll.mustfindproc(\u0026#34;getwindowtextw\u0026#34;) getwindowtextw.call(hwnd, uintptr(unsafe.pointer(\u0026amp;filename_data)), max_chars) // if there\u0026#39;s a match, save the value and return 0 to stop the iteration. if strings.contains(string(windows.utf16tostring([]uint16(filename_data[:]))), string(window_byte_name)) { the_handle = hwnd return 0 } return 1 }) // call the above looping function. enumwindows.call(wndenumproc_function, uintptr(0)) return the_handle } ","date":"2023-06-11","permalink":"https://blog.akvicor.com/posts/golang/windows_always_on_top/","summary":"将窗口标题中带有指定字符串的窗口置顶，使其显示在所有窗口之上 package main import ( \u0026#34;golang.org/x/sys/windows\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;unsafe\u0026#34; ) func AlwaysOnTop() { SetWindowAlwaysOnTop(GetWindowHandleByWindowName(\u0026#34;Title\u0026#34;)) } const SWP_NOSIZE = uintptr(0x0001) const SWP_NOMOVE = uintptr(0x0002) // This is dumb but Go doesn\u0026#39;t like the inline conversion (see above image). func IntToUintptr(value int) uintptr { return uintptr(value) } func SetWindowAlwaysOnTop(hwnd uintptr) { user32dll :=","title":"窗口置顶"},{"content":"常用于go编写的gui项目\ngo build -ldflags \u0026#34;-h windowsgui\u0026#34; ","date":"2023-06-11","permalink":"https://blog.akvicor.com/posts/golang/hide_console/","summary":"常用于go编写的gui项目 go build -ldflags \u0026#34;-H windowsgui\u0026#34;","title":"运行时隐藏控制台"},{"content":"默认的go build -o xxx.exe这样是没有图标的，不怎么好看。\n首先下载文件：\ngit clone https://github.com/akavel/rsrc.git 进入目录,把上面的代码编译一下\ngo build rsrc.go # 然后有个rsrc.exe文件 就在rsrc的目录下创建个ico.manifest，内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;assembly xmlns=\u0026#34;urn:schemas-microsoft-com:asm.v1\u0026#34; manifestversion=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;assemblyidentity version=\u0026#34;1.0.0.0\u0026#34; processorarchitecture=\u0026#34;x86\u0026#34; name=\u0026#34;controls\u0026#34; type=\u0026#34;win32\u0026#34; \u0026gt;\u0026lt;/assemblyidentity\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;dependentassembly\u0026gt; \u0026lt;assemblyidentity type=\u0026#34;win32\u0026#34; name=\u0026#34;microsoft.windows.common-controls\u0026#34; version=\u0026#34;6.0.0.0\u0026#34; processorarchitecture=\u0026#34;*\u0026#34; publickeytoken=\u0026#34;6595b64144ccf1df\u0026#34; language=\u0026#34;*\u0026#34; \u0026gt;\u0026lt;/assemblyidentity\u0026gt; \u0026lt;/dependentassembly\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/assembly\u0026gt; 然后把你想要编译带上的ico文件复制到rsrc文件夹，例如 rc.ico\n执行命令生成：xxx.syso文件\nrsrc.exe -manifest ico.manifest -ico rc.ico -o xxx.syso 把xxx.syso文件复制到你要编译的项目\n执行编译 go build -o main.exe 正常编译即可\n在这里编译需要注意的是：不能指定编译某个go文件如：go build -o main.exe main.go 这样是不会带上图标的，直接这样编译 go build -o main.exe\n","date":"2023-06-11","permalink":"https://blog.akvicor.com/posts/golang/build_with_ico/","summary":"默认的go build -o xxx.exe这样是没有图标的，不怎么好看。 首先下载文件： git clone https://github.com/akavel/rsrc.git 进入目录,把上面的代码编译一下 go build rsrc.go # 然后有个rsrc.exe文件 就在rsrc的目","title":"go编译文件带上图标"},{"content":"描述 cp和scp是ubuntu中文件拷贝常用的两个命令，一般在同一台服务器上我们是用cp命令，跨服务时使用过scp命令，但是如果做文件同步的话，rsync要比上述两个命令更好用一些，跨不跨服务器都是如此。\n使用 因为rsync可以只同步需要更新的文件，而不是将所有的指定路径内的文件都拷贝一份，然后再目标路径下去覆盖源文件，比如本地的/mnt/tem文件夹要和远程xx.xx.xx.123的/mnt/tem路径做同步，可以使用：\nrsync -avu --progress /mnt/tem/ xx@xx.xx.xx.123:/mnt/tem rsync命令会根据源目录是否使用斜杠/，而又不同的处理方式。\n如果在源目录尾部添加斜杠，rsync会将目录的内容复制到目标目录。在省略斜杠，rsync则会将源目录复制到目标目录。\n参数 常用\n-v 详细输出 -a 归档模式，表示以递归方式传输文件，并保持所有文件属性，如果文件属性变了，认为是不同文件 -u 选项忽略重复的数据 全部\n-v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgod。 -r, --recursive 对子目录以递归模式处理。 -r, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。 --backup-dir 将备份文件(如~filename)存放在在目录下。 -suffix=suffix 定义备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于dst，并且文件时间晚于要备份的文件，不覆盖更新的文件。 -l, --links 保留软链结。 -l, --copy-links 想对待常规文件一样处理软链结。 --copy-unsafe-links 仅仅拷贝指向src路径目录树以外的链结。 --safe-links 忽略指向src路径目录树以外的链结。 -h, --hard-links 保留硬链结。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -d, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -s, --sparse 对稀疏文件进行特殊处理以节省dst的空间。 -n, --dry-run现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -b, --block-size=size 检验算法使用的块尺寸，默认是700字节。 -e, --rsh=command 指定使用rsh、ssh方式进行数据同步。 --rsync-path=path 指定远程服务器上的rsync命令所在路径信息。 -c, --cvs-exclude 使用和cvs一样的方法自动忽略文件，用来排除那些不希望传输的文件。 --existing 仅仅更新那些已经存在于dst的文件，而不备份那些新创建的文件。 --delete 删除那些dst中src没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现io错误也进行删除。 --max-delete=num 最多删除num个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组id匹配为用户名和组名。 --timeout=time ip超时时间，单位为秒。 -i, --ignore-times 不跳过那些有同样的时间和长度的文件。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=num 决定文件是否时间相同时使用的时间戳窗口，默认为0。 -t --temp-dir=dir 在dir中创建临时文件。 --compare-dest=dir 同样比较dir中的文件来决定是否需要备份。 -p 等同于 --partial。 --progress 显示备份过程。 -z, --compress 对备份的文件在传输时进行压缩处理。 --exclude=pattern 指定排除不需要传输的文件模式。 --include=pattern 指定不排除而需要传输的文件模式。 --exclude-from=file 排除file中指定模式的文件。 --include-from=file 不排除file指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=file 指定其他的配置文件，不使用默认的rsyncd.conf文件。 --port=port 指定其他的rsync服务端口。 --blocking-io 对远程shell使用阻塞io。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=format 指定日志文件格式。 --password-file=file 从file中得到密码。 --bwlimit=kbps 限制i/o带宽，kbytes per second。 -h, --help 显示帮助信息。 使用crontab # 同步远程目录，同时指定ssh密码 */1 * * * * sshpass -p \u0026#39;mypassword\u0026#39; rsync -avu --progress --delete /path/to/source/ cynocu@192.168.1.1:/path/to/destination/ # 同步本地目录 10 */1 * * * rsync -avu --progress --delete /hhd5/sync/ /hhd4/syncmirror/ ","date":"2023-05-29","permalink":"https://blog.akvicor.com/posts/linux/rsync/","summary":"描述 cp和scp是ubuntu中文件拷贝常用的两个命令，一般在同一台服务器上我们是用cp命令，跨服务时使用过scp命令，但是如果做文件同步的话，rsync要比上","title":"rsync 文件夹同步"},{"content":"安装 fail2ban apt-get install fail2ban fail2ban 默认启用 ssh 的过滤器，可以在 /etc/fail2ban/jail.conf 查看，但是 fail2ban 更新会覆盖此文件，建议复制一个 jail.local 进行编辑。\ncp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local 此后建议编辑 jail.local\n对于 jail.local，你能找到许多 unit\n例如 sshd 在文件中如此显示\n[sshd] #mode = normal port = ssh logpath = %(sshd_log)s backend = %(sshd_backend)s 输入\nfail2ban-client status status |- number of jail: 1 `- jail list: sshd 可以看到，sshd的过滤器已经默认启动了。\n更改默认配置 默认配置在 jail.local 的 [default] 下，推荐至少在 ignoreip 中加入自己常用的 ip，（如果不常用有固定公网 ip 登录的倒是无所谓）其他一些配置可以根据自己的需要酌情修改\n默认日志路径配置（如mail、authpriv、user、ftp等等），依据系统而定，fail2ban在/etc/fail2ban/目录下提供了多种系统日志配置文件\nbefore = paths-fedora.conf # before = paths-debian.conf [default] #全局配置 ignoreip = 127.0.0.1 #忽略的ip列表，该ip表将不受限制 bantime = 600 #被屏蔽时间， 单位：秒 findtime = 600 #时间间隔，这个时间段内超过规定次数的主机将会被屏蔽 maxretry = 5 #最大尝试此时 enabled = false #全局禁止，在jail.local或jail.d/*.conf中开启相关联的配置 destemail = root@localhost #邮件接收人 sender = root@localhost #邮件发送人 # action：触发后的动作 #只屏蔽主机 action_ = %(banaction)s[name=%(__name__)s, bantime=\u0026#34;%(bantime)s\u0026#34;, port=\u0026#34;%(port)s\u0026#34;, proto col=\u0026#34;%(protocol)s\u0026#34;, chain=\u0026#34;%(chain)s\u0026#34;] #屏蔽主机 并发送邮件 action_mw = %(banaction)s[name=%(__name__)s, bantime=\u0026#34;%(bantime)s\u0026#34;, port=\u0026#34;%(port)s\u0026#34;, pro tocol=\u0026#34;%(protocol)s\u0026#34;, chain=\u0026#34;%(chain)s\u0026#34;] %(mta)s-whois[name=%(__name__)s, sender=\u0026#34;%(sender)s\u0026#34;, dest=\u0026#34;%(destemail)s\u0026#34;, protocol=\u0026#34;%(protocol)s\u0026#34;, chain=\u0026#34;%(chain)s\u0026#34;] ....... action = %(action_)s #默认动作为只屏蔽主机，如需修改，只需在特定服务下配置该属性即可 #服务配置， 以sshd 为例 [sshd] # 开启防护 enabled = true # 动作，只屏蔽（action_为默认动作，可省略） action = %(action_)s # 时间范围（s） findtim = 120 # 时间范围内最大尝试次数 maxretry = 3 # 屏蔽时间（s） bantime = 180 port = ssh logpath = %(sshd_log)s backend = %(sshd_backend)s 保存后启动fail2ban\nsystemctl start fail2ban 添加配置： jail.local 中本来就预设了一些配置，如需添加只需按照自己服务器的情况添加配置，同时添加 enabled = true 以启用此 jail\nnginx 认证登录监控 [nginx-http-auth] enabled = true filter = nginx-http-auth port = http,https logpath = /var/log/nginx/error.log 禁止一些恶意机器人 [nginx-badbots] enabled = true port = http,https filter = nginx-badbots logpath = /var/log/nginx/access.log maxretry = 2 如果网络服务没有提供根目录的服务，可以开启以禁止访问根目录 [nginx-nohome] enabled = true port = http,https filter = nginx-nohome logpath = /var/log/nginx/access.log maxretry = 2 防止被当作代理服务器 [nginx-noproxy] enabled = true port = http,https filter = nginx-noproxy logpath = /var/log/nginx/access.log maxretry = 2 需要确认打开 nginx 的 log 记录，并且正确填写目录\nhttp 和 https 对应你在前文 nfw 中设置的 app\n重启以应用更新 systemctl restart fail2ban 以启用这些 jails\n","date":"2023-05-11","permalink":"https://blog.akvicor.com/posts/linux/fail2ban/","summary":"安装 Fail2ban apt-get install fail2ban Fail2ban 默认启用 ssh 的过滤器，可以在 /etc/fail2ban/jail.conf 查看，但是 Fail2ban 更新会覆盖此文件，建议复制一个 jail.local 进行编辑。 cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local 此后建议编辑 jail.local 对于 jail.local，你能找到许多 unit 例如","title":"fail2ban"},{"content":"开启ssh 管理 -\u0026gt; 服务 -\u0026gt; tsm-ssh\n使用ssh登录到esxi\n修改的固件vmdk大小 cd /vmfs/volumes/datastore1 ls *.vmdk vmkfstools -i openwrt.vmdk 123.vmdk vmkfstools -x 1024m 123.vmdk # 需大于源文件大小 添加硬盘 根据实际情况选择efi或bios引导\n","date":"2023-05-05","permalink":"https://blog.akvicor.com/posts/openwrt/esxi/","summary":"开启SSH 管理 -\u0026gt; 服务 -\u0026gt; TSM-SSH 使用SSH登录到ESXI 修改的固件vmdk大小 cd /vmfs/volumes/datastore1 ls *.vmdk vmkfstools -i openwrt.vmdk 123.vmdk vmkfstools -X 1024M 123.vmdk # 需大于源文件大小 添加硬盘 根据实际情况选择EFI或BIOS引导","title":"vmdk for esxi"},{"content":"1.卸载磁盘 umount -l /data 若提示磁盘忙，使用fuser找出将正在使用磁盘的程序并结束掉。\nfuser -m -v /data fuser -m -v -i -k /data 2.磁盘分区 使用fdisk命令重新调整磁盘分区大小\nfdisk -l fdisk /dev/sdb p #查看磁柱号 ，记住，后面要用到 d #删除之前的分区 n #建立新分区 p #主分区 1 #第一个主分区 删除之前的分区，然后建立新分区，注意开始的磁柱号要和原来的一致（保证数据不丢失的关键步骤），结束的磁柱号默认回车使用全部磁盘。\nwq #保存分区信息并退出 3.调整分区 e2fsck -f /dev/sdb1 #检查分区信息 resize2fs /dev/sdb1 #调整分区大小 4.重新挂载分区 mount /data ","date":"2023-05-04","permalink":"https://blog.akvicor.com/posts/linux/resize_partition/","summary":"1.卸载磁盘 umount -l /data 若提示磁盘忙，使用fuser找出将正在使用磁盘的程序并结束掉。 fuser -m -v /data fuser -m -v -i -k /data 2.磁盘分区 使用fdisk命令重新调整磁盘分区大小 fdisk -l fdisk /dev/sdb p","title":"resize partition"},{"content":"一般来说可以按照如下规则设置swap大小：\n4g以内的物理内存，swap 设置为内存的2倍。 4-8g的物理内存，swap 等于内存大小。 8-64g 的物理内存，swap 设置为8g。 64-256g物理内存，swap 设置为16g。 实际上，系统中交换分区的大小并不取决于物理内存的量，而是取决于系统中内存的负荷，所以在安装系统时要根据具体的业务来设置swap的值。\n一般linux桌面系统的swap设置的会相对大一点，而linux服务器，特别是生产环境，swap可能只有一点点，1-2g，很多甚至都没有swap。\n添加swap交换分区 查看当前内存和swap空间大小 free -mh 创建swap交换分区文件/swap/swapfile，大小为8g mkdir /swap dd if=/dev/zero of=/swap/swapfile bs=1g count=8 格式化swap分区： mkswap /swap/swapfile 4.设置交换分区：\nmkswap -f /swap/swapfile 修改权限： chmod 600 /swap/swapfile 激活swap分区： swapon /swap/swapfile 设为开机自动启用： vim /etc/fstab 在该文件底部添加如下内容：\n/swap/swapfile swap swap default 0 0 删除swap交换分区 停止正在使用的swap分区： swapoff /swap/swapfile 删除swap分区文件： rm /swap/swapfile 删除或注释在/etc/fstab文件中的以下开机自动挂载内容： /swap/swapfile swap swap default 0 0 ","date":"2023-05-04","permalink":"https://blog.akvicor.com/posts/linux/swap/","summary":"一般来说可以按照如下规则设置swap大小： 4G以内的物理内存，SWAP 设置为内存的2倍。 4-8G的物理内存，SWAP 等于内存大小。 8-64G 的物理内存，SWAP 设置为8","title":"增加swap分区"},{"content":" 单击 “开始”，指向 “运行”，键入 regedit，然后单击 “确定”。 在注册表编辑器中，找到以下注册表子项： hkey_current_user\\software\\microsoft\\windows\\currentversion\\explorer\\mountpoints2 右键单击要删除的映射驱动器。 例如，右键单击 ##server_name#share_name，然后单击 “删除”。 ","date":"2023-03-28","permalink":"https://blog.akvicor.com/posts/windows/network_connection_does_not_exist/","summary":"单击 “开始”，指向 “运行”，键入 regedit，然后单击 “确定”。 在注册表编辑器中，找到以下注册表子项： HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2 右键单击要删除的映射驱动器。 例如，右键单击 ##Serv","title":"无法删除网络驱动器：此网络连接不存在"},{"content":"通过命令行控制软件的声音\n安装 sudo apt install playerctl 使用 控制当前 playerctl play playerctl pause playerctl play-pause # toggle playerctl stop playerctl next playerctl previous playerctl volume 控制指定软件 获取软件列表\nplayerctl status -l 控制指定软件，如网易云音乐\nplayerctl --player=netease-cloud-music play-pause ","date":"2023-03-22","permalink":"https://blog.akvicor.com/posts/linux/music_player_control/","summary":"通过命令行控制软件的声音 安装 sudo apt install playerctl 使用 控制当前 playerctl play playerctl pause playerctl play-pause # toggle playerctl stop playerctl next playerctl previous playerctl volume 控制指定软件 获取软件列表 playerctl status -l 控制指定软件，如网易云音乐 playerctl --player=netease-cloud-music play-pause","title":"music player control"},{"content":"系统挂载的一些限制 根目录/是必须挂载的，而且一定要先于其他mount point被挂载进来。 其他挂载点必须为已新建的目录，可任意指定，但一定要遵守必需的系统目录架构原则 所有挂载点在同一时间之内，只能挂载一次 所有分区在同一时间内，只能挂载一次 如若进行卸载，必须先将工作目录移到挂载点（及其子目录）以外。 /etc/fstab（file system table） # \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; # / was on /dev/sda2 during installation uuid=0b15699d-6b0c-4c41-91e8-b2a5fe113366 / ext4 errors=remount-ro 0 1 # /boot/efi was on /dev/sda1 during installation uuid=dbf9-feca /boot/efi vfat umask=0077 0 1 # swap was on /dev/sda3 during installation uuid=2126dcda-b478-4b0f-bfc6-a29189440e46 none swap sw 0 0 label=hhd1 /hhd1 ext4 noexec 0 2 label=hhd2 /hhd2 ext4 noexec 0 2 label=phhd1 /phhd1 ext4 noexec 0 2 语法 [device] [mount point] [file system type] [options] [dump] [pass]\n设置label e2label /dev/sdb hhd1 查看uuid blkid /dev/sdb \u0026lt;device\u0026gt; the device/partition (by /dev location, label or uuid) that contain a file system. \u0026lt;mount point\u0026gt; the directory on your root file system (aka mount point) from which it will be possible to access the content of the device/partition (note: swap has no mount point). mount points should not have spaces in the names. \u0026lt;file system type\u0026gt; type of file system (auto, vfat, ntfs, ntfs-3g, ext4, ext3, ext2, jfs, iso9660, swap) \u0026lt;options\u0026gt; mount options of access to the device/partition (see the man page for mount). \u0026lt;dump\u0026gt; enable or disable backing up of the device/partition (the command dump). this field is usually set to 0, which disables it. \u0026lt;pass num\u0026gt; controls the order in which fsck checks the device/partition for errors at boot time. the root device should be 1. other partitions should be 2, or 0 to disable checking. options n the names. 3. \u0026lt;file system type\u0026gt; type of file system (auto, vfat, ntfs, ntfs-3g, ext4, ext3, ext2, jfs, iso9660, swap) 4. \u0026lt;options\u0026gt; mount options of access to the device/partition (see the man page for mount). 5. \u0026lt;dump\u0026gt; enable or disable backing up of the device/partition (the command dump). this field is usually set to 0, which disables it. 6. \u0026lt;pass num\u0026gt; controls the order in which fsck checks the device/partition for errors at boot time. the root device should be 1. other partitions should be 2, or 0 to disable checking.\noptions bai\nsync/async - all i/o to the file system should be done (a)synchronously. auto - the filesystem can be mounted automatically (at bootup, or when mount is passed the -a option). this is really unnecessary as this is the default action of mount -a anyway. noauto - the filesystem will not be automatically mounted at startup, or when mount passed -a. you must explicitly mount the filesystem. dev/nodev - interpret/do not interpret character or block special devices on the file system. exec/noexec - permit/prevent the execution of binaries from the filesystem. suid/nosuid - permit/block the operation of suid, and sgid bits. ro - mount read-only. rw - mount read-write. user - permit any user to mount the filesystem. this automatically implies noexec, nosuid,nodev unless overridden. nouser - only permit root to mount the filesystem. this is also a default setting. uid - set the owner and group of all files. (default: the uid and gid of the current process.) gid - set the owner and group of all files. (default: the uid and gid of the current process.) umask - set the umask (the bitmask of the permissions that are not present). the default is the umask of the current process. the value is given in octal. dmask - set the umask applied to directories only. the default is the umask of the current process. the value is given in octal. fmask - set the umask applied to regular files only. the default is the umask of the current process. the value is given in octal. defaults - use default settings. equivalent to rw, suid, dev, exec, auto, nouser, async. _netdev - this is a network device, mount it after bringing up the network. only valid with fstype nfs. dump \u0026amp; pass num / 一般为 1 1 swap 一般为 0 0 其他分区 一般为 1 2 云硬盘 一般为 0 2 ","date":"2023-03-08","permalink":"https://blog.akvicor.com/posts/linux/fstab/","summary":"系统挂载的一些限制 根目录/是必须挂载的，而且一定要先于其他mount point被挂载进来。 其他挂载点必须为已新建的目录，可任意指定，但一定要遵守必需的系统目录架","title":"fstab"},{"content":"unreal mode consists of breaking the 64kib limit of real mode segments (while retaining 16-bit instructions and the segment * 16 + offset addressing mode) by tweaking the descriptor caches.\n","date":"2023-02-27","permalink":"https://blog.akvicor.com/posts/aos/unreal_mode/","summary":"Unreal mode consists of breaking the 64KiB limit of real mode segments (while retaining 16-bit instructions and the segment * 16 + offset addressing mode) by tweaking the descriptor caches.","title":"unreal mode"},{"content":"https://www.mediawiki.org/wiki/mediawiki_and_latex_on_a_host_with_shell_access\n安装texlive，使用 which latex 和 which dvipng 检查是否安装\n按照注释中操作 \u0026lt;?php # place this file in extension directory as mtag.php # add the following line to localsettings.php: # include \u0026#39;./extensions/mtag.php\u0026#39;; # mediawiki will render as latex the code within \u0026lt;m\u0026gt; \u0026lt;/m\u0026gt; tags. $wgextensionfunctions[] = \u0026#34;wfmtag\u0026#34;; function wfmtag() { global $wgparser; $wgparser-\u0026gt;sethook( \u0026#34;m\u0026#34;, \u0026#34;returnmtagged\u0026#34; ); } function returnmtagged( $code, $argv) { # if you have mathtex.cgi installed: $txt=\u0026#39;\u0026lt;img src=\u0026#34;/cgi-bin/mathtex.cgi?\u0026#39;.$code.\u0026#39;\u0026#34;\u0026gt;\u0026#39;; # or if you want to temporarily test a public mathtex.cgi: # $txt=\u0026#39;\u0026lt;img src=\u0026#34;http://www.forkosh.com/mathtex.cgi?\u0026#39;.$code.\u0026#39;\u0026#34;\u0026gt;\u0026#39;; return $txt; } ?\u0026gt; 下载并解压 mathtex.zip https://via.akvicor.com/file?f=1241\n# 编译 cc mathtex.c -dlatex=\\\u0026#34;$(which latex)\\\u0026#34; -ddvipng=\\\u0026#34;$(which dvipng)\\\u0026#34; -o mathtex.cgi # 移动cgi文件 mv mathtex.cgi /var/www/mediawiki/cgi-bin cd /var/www/mediawiki/cgi-bin # 更改权限 chmod 775 mathtex.cgi chown caddy:caddy mathtex.cgi # 测试 ./mathtex.cgi \u0026#34;x^2+y^2\u0026#34; –m 9 –o test 配置于wiki localsettings.php\ninclude \u0026#39;./extensions/mtag.php\u0026#39;; $wgtrustedmathmimetexurl = \u0026#39;https://wiki.akvicor.com/cgi-bin/mathtex.cgi?\u0026#39;; ","date":"2023-02-27","permalink":"https://blog.akvicor.com/posts/opensource/mathtex/","summary":"https://www.mediawiki.org/wiki/MediaWiki_and_LaTeX_on_a_host_with_shell_access 安装TexLive，使用 which latex 和 which dvipng 检查是否安装 按照注释中操作 \u0026lt;?php # Place this file in extension directory as Mtag.php # Add the following line to LocalSettings.php: # include \u0026#39;./extensions/Mtag.php\u0026#39;; # Mediawiki will render as LaTeX the code within \u0026lt;m\u0026gt; \u0026lt;/m\u0026gt; tags. $wgExtensionFunctions[] = \u0026#34;wfMtag\u0026#34;; function wfMtag() { global $wgParser; $wgParser-\u0026gt;setHook( \u0026#34;m\u0026#34;, \u0026#34;returnMtagged\u0026#34; ); } function returnMtagged( $code, $argv)","title":"mathtex"},{"content":"the cpu in modern computer hardware performs reads and writes to memory most efficiently when the data is naturally aligned, which generally means that the data\u0026rsquo;s memory address is a multiple of the data size. for instance, in a 32-bit architecture, the data may be aligned if the data is stored in four consecutive bytes and the first byte lies on a 4-byte boundary.\nif the highest and lowest bytes in a datum are not within the same memory word the computer must split the datum access into multiple memory accesses. this requires a lot of complex circuitry to generate the memory accesses and coordinate them. to handle the case where the memory words are in different memory pages the processor must either verify that both pages are present before executing the instruction or be able to handle a tlb miss or a page fault on any memory access during the instruction execution.\n#include \u0026lt;stdio.h\u0026gt; typedef struct structa_tag { // a char c; short int s; } structa_t; typedef struct structb_tag { // b short int s; char c; int i; } structb_t; typedef struct structc_tag { // c char c; double d; int s; } structc_t; typedef struct structd_tag { // d double d; int s; char c; } structd_t; int main() { printf(\u0026#34;sizeof(structa_t) = %d\\n\u0026#34;, sizeof(structa_t)); printf(\u0026#34;sizeof(structb_t) = %d\\n\u0026#34;, sizeof(structb_t)); printf(\u0026#34;sizeof(structc_t) = %d\\n\u0026#34;, sizeof(structc_t)); printf(\u0026#34;sizeof(structd_t) = %d\\n\u0026#34;, sizeof(structd_t)); return 0; } /** output sizeof(structa_t) = 4 sizeof(structb_t) = 8 sizeof(structc_t) = 24 sizeof(structd_t) = 16 **/ // alignment requirements // (typical 64 bit machine) // char 1 byte // short int 2 bytes // int 4 bytes // double 8 bytes output of above program:\nfor the sake of convenience, assume every structure type variable is allocated on 4 byte boundary (say 0x0000), i.e. the base address of structure is multiple of 4 (need not necessary always, see explanation of structc_t).\nstructure a\nthe structa_t first element is char which is one byte aligned, followed by short int. short int is 2 byte aligned. if the the short int element is immediately allocated after the char element, it will start at an odd address boundary. the compiler will insert a padding byte after the char to ensure short int will have an address multiple of 2 (i.e. 2 byte aligned). the total size of structa_t will be sizeof(char) + 1 (padding) + sizeof(short), 1 + 1 + 2 = 4 bytes.\nstructure b\nthe first member of structb_t is short int followed by char. since char can be on any byte boundary no padding required in between short int and char, on total they occupy 3 bytes. the next member is int. if the int is allocated immediately, it will start at an odd byte boundary. we need 1 byte padding after the char member to make the address of next int member is 4 byte aligned. on total, the structb_t requires 2 + 1 + 1 (padding) + 4 = 8 bytes.\nstructure c – every structure will also have alignment requirements\napplying same analysis, structc_t needs sizeof(char) + 7 byte padding + sizeof(double) + sizeof(int) = 1 + 7 + 8 + 4 = 20 bytes. however, the sizeof(structc_t) will be 24 bytes. it is because, along with structure members, structure type variables will also have natural alignment. let us understand it by an example. say, we declared an array of structc_t as shown below\nstructc_t structc_array[3]; assume, the base address of structc_array is 0x0000 for easy calculations. if the structc_t occupies 20 (0x14) bytes as we calculated, the second structc_t array element (indexed at 1) will be at 0x0000 + 0x0014 = 0x0014. it is the start address of index 1 element of array. the double member of this structc_t will be allocated on 0x0014 + 0x1 + 0x7 = 0x001c (decimal 28) which is not multiple of 8 and conflicting with the alignment requirements of double. as we mentioned on the top, the alignment requirement of double is 8 bytes.\ninorder to avoid such misalignment, compiler will introduce alignment requirement to every structure. it will be as that of the largest member of the structure. in our case alignment of structa_t is 2, structb_t is 4 and structc_t is 8. if we need nested structures, the size of largest inner structure will be the alignment of immediate larger structure.\nin structc_t of the above program, there will be padding of 4 bytes after int member to make the structure size multiple of its alignment. thus the sizeof (structc_t) is 24 bytes. it guarantees correct alignment even in arrays. you can cross check.\nstructure d – how to reduce padding?\nby now, it may be clear that padding is unavoidable. there is a way to minimize padding. the programmer should declare the structure members in their increasing/decreasing order of size. an example is structd_t given in our code, whose size is 16 bytes in lieu of 24 bytes of structc_t.\ntypical alignments\nthe following typical alignments are valid for compilers from microsoft (visual c++), borland/codegear (c++builder), digital mars (dmc), and gnu (gcc) when compiling for 32-bit x86:\na char (one byte) will be 1-byte aligned. a short (two bytes) will be 2-byte aligned. an int (four bytes) will be 4-byte aligned. a long (four bytes) will be 4-byte aligned. a float (four bytes) will be 4-byte aligned. a double (eight bytes) will be 8-byte aligned on windows and 4-byte aligned on linux (8-byte with -malign-double compile time option). a long long (eight bytes) will be 4-byte aligned. a long double (ten bytes with c++builder and dmc, eight bytes with visual c++, twelve bytes with gcc) will be 8-byte aligned with c++builder, 2-byte aligned with dmc, 8-byte aligned with visual c++, and 4-byte aligned with gcc. any pointer (four bytes) will be 4-byte aligned. (e.g.: char*, int*) the only notable differences in alignment for an lp64 64-bit system when compared to a 32-bit system are:\na long (eight bytes) will be 8-byte aligned. a double (eight bytes) will be 8-byte aligned. a long long (eight bytes) will be 8-byte aligned. a long double (eight bytes with visual c++, sixteen bytes with gcc) will be 8-byte aligned with visual c++ and 16-byte aligned with gcc. any pointer (eight bytes) will be 8-byte aligned. ","date":"2023-02-27","permalink":"https://blog.akvicor.com/posts/c/data_structure_alignment/","summary":"The CPU in modern computer hardware performs reads and writes to memory most efficiently when the data is naturally aligned, which generally means that the data\u0026rsquo;s memory address is a multiple of the data size. For instance, in a 32-bit architecture, the data may be aligned if the data is stored in four consecutive bytes and the first byte lies on a 4-byte boundary.\nIf the highest and lowest bytes in a datum are not within the same memory word the computer must split the datum access into multiple memory accesses.","title":"data structure alignment"},{"content":"img file make dd if=/dev/zero of=fdimage.img count=2880 # or dd if=/dev/zero of=fdimage.img bs=1024 count=1440 format mkfs.msdos fdimage.img mount mount -o loop *.img /mnt bootable 因为制作可启动镜像一定会用到虚拟机，推荐用 virtualbox，先到网上下个 dos 启动盘来引导。用 dos 的 sys 命令传递系统。推荐使用 freedos，属自由软件。也可用 dd 命令 来传递引导引导信息，并复制启动启动时所需文件来做启动盘。以 freedos 为例，传递启动信息用以下命令，其中下载的启动盘为balder10.img 文件\ndd if=balder10.img of=fdimage.img bs=512 count=1 conv=notrunc 多系统用 grub4dos\n用 grub.exe 引导多系统 安装 grub 到mbr，用 grldr 来引导多系统。当然也可用同上面一样的办法用 dd 直接写入引导信息。 bootlace.com –floppy –chs 0×00 注：dd 命令只能从逻辑扇区开始 copy，先前我想可否用 dd 来将 grldr.mbr 写入 u 盘，我用自己的 u 盘试了，结果不能打开了。因为我的 u 盘为 fat16 格式，逻辑扇区开始是obr，接着是fat表，结果把 fat1 表给盖了，那时还没有想到还有 fat2 呢，就格了，现在想起来郁闷啊，好多东西都没有了。为什么软盘可以呢，因为它就没有前面的63个扇区，直接从逻辑0扇区开始的。\niso file make mkisofs -r -o cdimage.iso /home/xxx/cddir format 用mkiso制作的 iso 已有文件系统 iso9660\nbootable 无论是引导单系统还是引导多系统都还是用 mkisofs 这个工具，只是加载到光盘的 boot loader 不一样而已。当然也可以将 dos 的引导器 (也就是它的引导扇区) 或 windows 的引导器 ( xp 系统的是 ntldr ) 放入让光盘引导。下面只讨论 grub4dos 的使用\n用 grub.exe 引导多系统 用 dos 加载 grub.exe 引导多系统 将 grub 安装到光盘 mbr 在制作时可用下面的命令直接生成可启动镜像，其中 grldr, menu.lst 要放在 cddir 目录下，也就是在 cd 根目录。 mkisofs -r -b grldr -no-emul-boot -boot-load-seg 0×1000 -o cdimage.iso cddir mkisofs -r -b grldr -no-emul-boot -boot-load-size 4 -o cdimage.iso cddir ","date":"2023-02-27","permalink":"https://blog.akvicor.com/posts/linux/create_iso_images/","summary":"IMG file Make dd if=/dev/zero of=fdimage.img count=2880 # or dd if=/dev/zero of=fdimage.img bs=1024 count=1440 Format mkfs.msdos fdimage.img Mount mount -o loop *.img /mnt Bootable 因为制作可启动镜像一定会用到虚拟机，推荐用 Virtualbox，先到网上下个 DOS 启动盘来引导。用 DOS 的 sys 命令传递系统","title":"creating iso images with dd and mkisofs"},{"content":"文件所在路径 vim /usr/lib/systemd/system/service_name.service 服务模板 [unit] description=viry service after=network.target auditd.service [service] user=root type=oneshot remainafterexit=true execstart=/viry/serv/serv.sh execstop=/bin/true [install] wantedby=multi-user.target alias=viry.service serv.sh #!/bin/bash echo \u0026#34;sync time\u0026#34; ntpdate 172.16.1.1 hwclock -w time=$(tz=utc-8 date \u0026#34;+%y-%m-%d %h:%m:%s\u0026#34;) log=\u0026#34;/viry/serv/serv.log\u0026#34; echo \u0026#34;ready\u0026#34; echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; $log echo $time \u0026gt;\u0026gt; $log echo \u0026#34;start demo\u0026#34; echo \u0026#34;start demo\u0026#34; \u0026gt;\u0026gt; $log sh /viry/serv/demo/demo.sh echo \u0026#34;finished\u0026#34; echo \u0026#34;finished\u0026#34; \u0026gt;\u0026gt; $log demo.sh #!/bin/bash cd /viry/serv/demo/exec/ screen_name=\u0026#34;demo\u0026#34; screen -s /usr/bin/bash -dms $screen_name cmd1=\u0026#34;\u0026#34; cmd2=\u0026#34;./demo\u0026#34; screen -x -s $screen_name -p 0 -x stuff \u0026#34;$cmd1\\n\u0026#34; screen -x -s $screen_name -p 0 -x stuff \u0026#34;$cmd2\\n\u0026#34; echo \u0026#34;demo started\u0026#34; exit 0 ","date":"2023-02-27","permalink":"https://blog.akvicor.com/posts/linux/service/","summary":"文件所在路径 vim /usr/lib/systemd/system/SERVICE_NAME.service 服务模板 [Unit] Description=Viry Service After=network.target auditd.service [Service] User=root Type=oneshot RemainAfterExit=true ExecStart=/viry/serv/serv.sh ExecStop=/bin/true [Install] WantedBy=multi-user.target Alias=viry.service serv.sh #!/bin/bash echo \u0026#34;Sync Time\u0026#34; ntpdate 172.16.1.1 hwclock -w TIME=$(TZ=UTC-8 date \u0026#34;+%Y-%m-%d %H:%M:%S\u0026#34;) LOG=\u0026#34;/viry/serv/serv.log\u0026#34; echo \u0026#34;Ready\u0026#34; echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; $LOG echo $TIME \u0026gt;\u0026gt; $LOG echo \u0026#34;Start DEMO\u0026#34; echo \u0026#34;Start DEMO\u0026#34; \u0026gt;\u0026gt; $LOG sh /viry/serv/demo/demo.sh echo \u0026#34;Finished\u0026#34; echo \u0026#34;Finished\u0026#34; \u0026gt;\u0026gt; $LOG demo.sh #!/bin/bash cd /viry/serv/demo/exec/ screen_name=\u0026#34;demo\u0026#34; screen -s /usr/bin/bash -dmS $screen_name cmd1=\u0026#34;\u0026#34; cmd2=\u0026#34;./demo\u0026#34; screen -x","title":"create systemd service unit"},{"content":"\n\u0026lt;div class=\u0026#34;wheelplayer wheelanimate\u0026#34;\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .wheelplayer{ padding: 20px 0; margin: auto; width: 350px; } .wheelplayer div{ position: relative; height: 25px; line-height: 26px; width: 70px; text-align: center; border: 1px solid gray; } .wheelanimate div{ animation: whellplayer 9s infinite; -moz-animation: whellplayer 9s infinite; -webkit-animation: whellplayer 9s infinite; } .wheelplayer div:nth-of-type(1){ animation-delay: -6s; -moz-animation-delay: -6s; -webkit-animation-delay: -6s; } .wheelplayer div:nth-of-type(2){ animation-delay: -3s; -moz-animation-delay: -3s; -webkit-animation-delay: -3s; margin-top: -27px; } .wheelplayer div:nth-of-type(3){ animation-delay: -0s; -moz-animation-delay: 0s; -webkit-animation-delay: 0s; margin-top: -27px; } ","date":"2023-02-25","permalink":"https://blog.akvicor.com/posts/css/carousel/","summary":"\n\u0026lt;div class=\u0026#34;wheelPlayer wheelAnimate\u0026#34;\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .wheelPlayer{ padding: 20px 0; margin: auto; width: 350px; } .wheelPlayer div{ position: relative; height: 25px; line-height: 26px; width: 70px; text-align: center; border: 1px solid gray; } .wheelAnimate div{ animation: whellPlayer 9s infinite; -moz-animation: whellPlayer 9s infinite; -webkit-animation: whellPlayer 9s infinite; } .wheelPlayer div:nth-of-type(1){ animation-delay: -6s; -moz-animation-delay: -6s; -webkit-animation-delay: -6s; } .wheelPlayer div:nth-of-type(2){ animation-delay: -3s; -moz-animation-delay: -3s; -webkit-animation-delay: -3s; margin-top: -27px; } .wheelPlayer div:nth-of-type(3){ animation-delay: -0s; -moz-animation-delay: 0s; -webkit-animation-delay: 0s; margin-top: -27px; } ","title":"css-only carousel"},{"content":"向剪切板写入 图片等任意的数据到剪贴板。 这个方法可以用于实现剪切和复制的功能,是异步的\ndocument.body.addeventlistener( \u0026#39;click\u0026#39;, async (e) =\u0026gt; { await navigator.clipboard.writetext(\u0026#39;yo\u0026#39;) } ) clipboard.read()用于读取剪切板的数据，也是异步的成功返回数据\nasync function getclipboardcontents() { try { const text = await navigator.clipboard.readtext(); console.log(\u0026#39;pasted content: \u0026#39;, text); } catch (err) { console.error(\u0026#39;failed to read clipboard contents: \u0026#39;, err); } } ","date":"2023-02-23","permalink":"https://blog.akvicor.com/posts/js/clipboard/","summary":"向剪切板写入 图片等任意的数据到剪贴板。 这个方法可以用于实现剪切和复制的功能,是异步的 document.body.addEventListener( \u0026#39;click\u0026#39;, async (e) =\u0026gt; { await navigator.clipboard.writeText(\u0026#39;Yo\u0026#39;) } ) Clipboard.read()用于读取剪切板的数据，也","title":"clipboard"},{"content":"vim ~/.xresource 填写配置\nxterm.termname: xterm-256color xterm*locale:true xterm.utf8: true xterm*utf8title: true !fix alt key input !xterm*eightbitinput: false !xterm*altsendsescape: true !xterm*scrollbar: true !xterm*rightscrollbar: true xterm*savelines: 4096 !xterm*background: black !xterm*foreground: green xterm*printattributes: 0 xterm*printercommand: cat \u0026gt; ~/xtermdump !xterm*vt100.translations: #override \u0026lt;btn1up\u0026gt;: select-end(primary, clipboard, cut_buffer0) xterm*vt100.translations: #override \\ ctrl \u0026lt;keypress\u0026gt; v: insert-selection(clipboard,primary,cut_buffer0) \\n\\ \u0026lt;btnup\u0026gt;: select-end(clipboard,primary,cut_buffer0) \\n\\ ctrl \u0026lt;keypress\u0026gt; p: print() \\n xterm*facename: ubuntu bold:antialias=true:pixelsize=12 xterm*facenamedoublesize:noto sans mono cjk sc:antialias=true:pixelsize=12 ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/xterm/","summary":"vim ~/.Xresource 填写配置 xterm.termName: xterm-256color xterm*locale:true xterm.utf8: true xterm*utf8Title: true !fix alt key input !xterm*eightBitInput: false !xterm*altSendsEscape: true !xterm*scrollBar: true !xterm*rightScrollBar: true xterm*SaveLines: 4096 !xterm*background: black !xterm*foreground: green xterm*printAttributes: 0 xterm*printerCommand: cat \u0026gt; ~/xtermdump !xterm*VT100.translations: #override \u0026lt;Btn1UP\u0026gt;: select-end(PRIMARY, CLIPBOARD, CUT_BUFFER0) xterm*VT100.translations: #override \\ Ctrl \u0026lt;KeyPress\u0026gt; V: insert-selection(CLIPBOARD,PRIMARY,CUT_BUFFER0) \\n\\ \u0026lt;BtnUp\u0026gt;: select-end(CLIPBOARD,PRIMARY,CUT_BUFFER0) \\n\\ Ctrl \u0026lt;KeyPress\u0026gt; P: print() \\n xterm*faceName: Ubuntu Bold:antialias=True:pixelsize=12 xterm*faceNameDoublesize:Noto Sans Mono CJK SC:antialias=True:pixelsize=12","title":"xterm"},{"content":"apt install sudo cd /etc/sudoers.d vim user # akvicor all=(all)nopasswd:all ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/sudo/","summary":"apt install sudo cd /etc/sudoers.d vim user # Akvicor ALL=(ALL)NOPASSWD:ALL ","title":"sudo"},{"content":"https://wiki.ubuntu.org.cn/ufw%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97\n安装 默认ufw的规则是放通全部端口\napt-get install ufw 设置默认规则 首先设置拒绝所有传入并允许所有传出。\n请勿运行以下命令后直接应用，否则会直接锁定你的服务器。确保在应用默认规则前放通了ssh和其他关键服务的端口。\nsudo ufw default allow outgoing sudo ufw default deny incoming 添加基本规则 有两种方式添加规则: 端口号或服务名。\n例如要允许 ssh 的22 端口的传入传出连接，你可以运行:\nufw allow ssh 或者是:\nufw allow 22 同样，如果你要阻止特定端口上的流量，例如1234，你可运行:\nufw deny 1234 为了适应不同的需求，你还可以设置基于tcp或upd的规则，例如允许80端口的tcp传入传出连接:\nufw allow 80/tcp ufw allow http/tcp 下面的例子会允许来自 2000 端口上的 udp 包:\nufw allow 2000/udp 添加高级规则 除了简单的基于端口或协议的规则，ufw 还允许按照ip地址、子网、端口、协议的不同组合来设置高级规则。\n例如允许从一个ip连接:\nufw allow from 192.168.1.1 允许特定子网的连接:\nufw allow from 192.168.1.0/24 允许 ip + 端口 + 协议的组合:\nufw allow from 192.168.1.1 to any port 80 proto tcp 允许来自192.168.0.0-192.168.255.255的数据通过eth0网卡进入主机\nufw allow in on eth0 from 192.168.0.0/16 允许指向10.0.0.0-10.255.255.255的数据通过eth1网卡从本机发出\nufw allow out on eth1 to 10.0.0.0/8 允许来自192.168.0.0-192.168.255.255通过eth0网卡收入的数据且指向10.0.0.0-10.255.255.255通过eth1网卡发出的数据经本机路由\nufw route allow in on eth0 out on eth1 to 10.0.0.0/8 from 192.168.0.0/16 所有例子的allow都可以根据需求改为deny，proto tcp也可以根据你的需求改为proto udp\n删除规则 要删除某一条规则，就在相应的规则前加入delete。例如你想要拒绝 http 的流量你可以运行:\nufw delete allow 80 同样的，可以使用服务名删除规则。\n还有另一种方法删除规则，首先运行命令:\nufw status numbered 它会将所有正在使用的规则列出来，并且前面标上了序号\n如果你想要删除某一个规则，输入ufw delete [规则号码]即可，例如:\nufw delete 2 编辑 ufw 的配置文件 虽然可以直接通过命令行添加规则，但是如果你有需要添加更高级或特殊的规则可以编辑配置文件，ufw 有三个配置文件。\nbefore.rules /etc/ufw/before.rules 在运行你通过命令行设置的规则 【前】 运行的任何规则。同目录中的 before6.rules 文件用于 ipv6 。\nafter.rules /etc/ufw/after.rules 在运行你通过命令行设置的规则 【后】 运行的任何规则。同目录中的 after6.rules 文件用于 ipv6 。\n默认配置文件 /etc/default/ufw 从此处可以设置是否启用 ipv6，可以设置默认规则，并可以设置 ufw 以管理内置防火墙链。\n自定义应用 所有配置都在 /etc/ufw/applications.d/，同一文件中可配置多个应用，如需修改，前往此目录修改即可。\n例如以下文件内容，同时设置了openssh 和 www full。\n[openssh] title=secure shell server, an rshd replacement description=openssh is a free implementation of the secure shell protocol. ports=22/tcp [www full] title=web server (http,https) description=web server (http,https) ports=80,443/tcp 如果你的 ssh 端口自定义了，也可以直接修改。如果 ufw 运行中修改文件，修改保存后，需要执行 ufw reload 应用规则。\n查看应用程序配置文件 ufw app list 查看 app 具体信息 ufw app info openssh 快捷开放某个程序需要的防火墙设置 ufw allow openssh 查看 ufw 状态 该命令会显示所有规则列表，以及当前是否激活。\nufw status 启用关闭防火墙 当你设定好规则后，第一次运行ufw status可能会提示status: inactive。这时候就要使用以下命令激活防火墙规则了。\nufw enable 若要禁用防火墙规则使用以下命令:\nufw disable 日志 如需启用日志记录，使用以下命令:\nufw logging on 启用日志后可以使用 ufw logging low|medium|high 设置日志级别，默认是low。\n日志文件储存在 /var/logs/ufw\n每个值的意思分别是:\n[ufw block]: 这是记录事件的描述开始的位置。在此例中，它表示阻止了连接。 in: 如果它包含一个值，那么代表该事件是传入事件 out: 如果它包含一个值，那么代表事件是传出事件 mac: 目的地和源 mac 地址的组合 src: 包源的 ip dst: 包目的地的 ip len: 数据包长度 ttl: 数据包 ttl，或称为 time to live。 在找到目的地之前，它将在路由器之间跳跃，直到它过期。 proto: 数据包的协议 spt: 包的源端口 dpt: 包的目标端口 window: 发送方可以接收的数据包的大小 syn urgp: 指示是否需要三次握手。 0 表示不需要。 ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/ufw/","summary":"https://wiki.ubuntu.org.cn/Ufw%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97 安装 默认UFW的规则是放通全部端口 apt-get install ufw 设置默认规则 首先设置拒绝所有传入并允许所有传出。 请勿运行以下命令后直接应用，否则会直接锁定你的服务器。确保在应用默认规","title":"ufw"},{"content":"environment add mingw environment to path: c:\\mingw\\bin\nopen notepad++ plug-\u0026gt;plugin manager-\u0026gt;show plugin manager\nat available, double click \u0026lsquo;downloading list\u0026rsquo;\nsearch \u0026lsquo;nppexec\u0026rsquo;, install and restart\nopen console plug-\u0026gt;nppexec-\u0026gt;show console\ncompile plug-\u0026gt;nppexec-\u0026gt;execute\ncompile input: g++ $(full_current_path) -g -o $(current_directory)\\$(name_part).exe click save, input: compile run input: $(current_directory)\\$(name_part).exe click save, input: run gdb input: gdb $(current_directory)\\$(name_part).exe click save, input: gdb add to macros submenu plug-\u0026gt;nppexec-\u0026gt;advanced options\nat associated script:\nadd-\u0026gt; compile and run and gbd menu items -\u0026gt; place to the macros submenu ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/windows/notepad_compile/","summary":"Environment Add MinGW environment to Path: C:\\MinGW\\bin\nOpen Notepad++ Plug-\u0026gt;Plugin Manager-\u0026gt;Show Plugin Manager\nat Available, double click \u0026lsquo;downloading list\u0026rsquo;\nSearch \u0026lsquo;Nppexec\u0026rsquo;, install and restart\nOpen Console Plug-\u0026gt;NppExec-\u0026gt;Show Console\nCompile Plug-\u0026gt;NppExec-\u0026gt;Execute\nCompile input: g++ $(FULL_CURRENT_PATH) -g -o $(CURRENT_DIRECTORY)\\$(NAME_PART).exe click save, input: Compile Run input: $(CURRENT_DIRECTORY)\\$(NAME_PART).exe click save, input: Run GDB input: gdb $(CURRENT_DIRECTORY)\\$(NAME_PART).exe click save, input: GDB Add to Macros submenu Plug-\u0026gt;NppExec-\u0026gt;Advanced Options\nat Associated script:\nAdd-\u0026gt; Compile and Run and GBD Menu items -\u0026gt; Place to the Macros submenu ","title":"notepad compile"},{"content":"1 vim /etc/systemd/system/network-online.target.wants/networking.service timeoutstartsec=2sec 2 vim /etc/dhcp/dhclient.conf timeout 15 1 change auto eth0 to allow-hotplug eth0\n","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/networking_timeout/","summary":"1 vim /etc/systemd/system/network-online.target.wants/networking.service TimeoutStartSec=2sec 2 vim /etc/dhcp/dhclient.conf timeout 15 1 change auto eth0 to allow-hotplug eth0","title":"networking timeout"},{"content":"开机时间\nsystemd-analyze ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/analyzeblame/","summary":"开机时间 systemd-analyze","title":"analyzeblame"},{"content":"# 查看系统tcp连接中各个状态的连接数。 netstat -an|awk \u0026#39;/^tcp/ {++s[$nf]} end {for(a in s ) print a,s[a]}\u0026#39; # 查看和本机23端口建立连接并状态在established的所有ip netstat -an|grep 80|grep esta|awk \u0026#39;{print $5}\u0026#39;|awk \u0026#39;begin {fs=\u0026#34;:\u0026#34;} {print $1 \u0026#34;\\n\u0026#34;}\u0026#39;|sort|uniq -c ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/netstat/","summary":"# 查看系统tcp连接中各个状态的连接数。 netstat -an|awk \u0026#39;/^tcp/ {++s[$NF]} END {for(a in s ) print a,s[a]}\u0026#39; # 查看和本机23端口建立连接并状态在established的所有ip netstat -an|grep 80|grep ESTA|awk \u0026#39;{print $5}\u0026#39;|awk \u0026#39;BEGIN {FS=\u0026#34;:\u0026#34;} {print $1 \u0026#34;\\n\u0026#34;}\u0026#39;|sort|uniq -c","title":"netstat"},{"content":"only permit china ip systemctl stop firewalld.service systemctl disable firewalld.service yum install ipset yum install iptables-services 清空之前的规则 iptables -p input accept iptables -f 创建一个名为cnip的规则 ipset -n cnip hash:net ipset save # 下载国家ip段，这里以中国为例 wget -p . http://www.ipdeny.com/ipblocks/data/countries/cn.zone # 将ip段添加到cnip规则中 for i in $(cat /root/cn.zone ); do ipset -a cnip $i; done ipset save cnip -f /etc/ipset.cnip /sbin/ipset restore -f /etc/ipset.cnip 放行ip段 iptables -a input -p tcp -m set --match-set cnip src -j accept 关掉指定端口 iptables -p input drop # 关闭指定端口，比如80/443 iptables -a input -p tcp --dport 80 -j drop iptables -a input -p tcp --dport 443 -j drop # 将参数里的-a改成-d就是删除规则了，如 iptables -d input -p tcp -m set --match-set cnip src -j accept iptables -d input -p tcp --dport 443 -j drop # save iptables-save \u0026gt; /etc/sysconfig/iptalbes iptables-save \u0026gt; /etc/iptables-script # restore iptables-restore \u0026gt; /etc/sysconfig/iptables iptables-restore \u0026gt; /etc/iptables-script 接受全部中国ip #全部接受中国ip -a input -m set --match-set china src -j accept #接受中国ip访问本机特定端口特定协议（例如5060udp协议），freeswitch一般要用这条，直接具体到端口协议 -a input -m set --match-set china src -p udp -m udp --dport 5060 -j accept #接受中国ip的ping响应 -a input -m set --match-set china src -p icmp -j accept #!/bin/bash ipset create china hash:net hashsize 1024 maxelem 65536 rm -f cn.zone wget http://www.ipdeny.com/ipblocks/data/countries/cn.zone for i in `cat cn.zone` do ipset add china $i done #!/bin/bash ipset create hongkong hash:net hashsize 1024 maxelem 65536 rm -f hk.zone wget http://www.ipdeny.com/ipblocks/data/countries/hk.zone for i in `cat hk.zone` do ipset add hongkong $i done 配置文件 vim /etc/sysconfig/iptables *filter :input accept [0:0] :forward accept [0:0] :output accept [0:0] -a input -m set --match-set cnip src -j accept -i input -m set --match-set hongkong src -j drop -i input -p tcp --dport 80 --syn -m recent --name syn_flood --update --seconds 60 --hitcount 10 -j reject -i input -p tcp --syn -m limit --limit 1/s -j accept -a input -j drop commit # completed on sun mar 27 20:29:24 2022 ipset save \u0026gt; /etc/ipset.cn.hk /sbin/ipset restore -f /etc/ipset.cn.hk systemctl restart iptables iptables -l -n --line-number iptables -vnl netstat -an | awk \u0026#39;/^tcp/ {++s[$nf]} end {for(a in s ) print a,s[a]}\u0026#39; 限制 syn 并发数为每秒 1 次 iptables -a input -p tcp --syn -m limit --limit 1/s -j accept 限制单个 ip 在 60 秒新建立的连接数为 10 iptables -i input -p tcp --dport 80 --syn -m recent --name syn_flood --update --seconds 60 --hitcount 10 -j reject ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/iptables_deny_ip/","summary":"only permit china ip systemctl stop firewalld.service systemctl disable firewalld.service yum install ipset yum install iptables-services 清空之前的规则 iptables -P INPUT ACCEPT iptables -F 创建一个名为cnip的规则 ipset -N cnip hash:net ipset save # 下载国家IP段，这里以中国为例 wget -P . http://www.ipdeny.com/ipblocks/data/countries/cn.zone # 将IP段添加到cnip","title":"iptables deny ip"},{"content":"取消笔记本合盖后挂起\nvim /etc/systemd/logind.conf 修改\n# handlelidswitch=suspend handlelidswitch=ignore # handlepowerkey=poweroff handlepowerkey=ignore 修改屏幕保护\n","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/logind/","summary":"取消笔记本合盖后挂起 vim /etc/systemd/logind.conf 修改 # HandleLidSwitch=suspend HandleLidSwitch=ignore # HandlePowerKey=poweroff HandlePowerKey=ignore 修改屏幕保护","title":"debian 笔记本合盖和电源键作用"},{"content":"连接远程调试 target remote localhost:1234 查看内存 x/\u0026lt;n/f/u\u0026gt; \u0026lt;addr\u0026gt; x /8xb 0xffff80000002fff0 # 以16进制方式查看0xffff80000002fff0处8字节内容 n 从当前地址往后请求的字节数，如果不指定的话，gdb默认是4个bytes。\nf x 按十六进制格式显示变量 d 按十进制格式显示变量 u 按十十进制格式显示无符号变量 o 按十八进制格式显示变量 t 按十二进制格式显示变量 a 按十十六进制格式显示变量 i 指令地址格式 c 按字符格式显示变量 f 按浮点数格式显示变量 u 表示一个地址单元的长度\nb 表示单字节 h 表示双字节 w 表示四字节 g 表示八字节 断点 break 16 # 在源程序第16行 break func # 在函数func()入口处 break *address # 在地址address处 查看断点信息 info break # 查看断点信息 清除断点 delete n # 清除n号断点 运行程序 r/run 单条语句调试 n/next 继续运行程序 c/continue 打印变量的值 p i print i 查看函数堆栈 bt 退出gdb q 暂停 ctrl+c 单步运行 si/ni 查看当前寄存器和断点 info reg/registers info b/break 查看当前执行以及之后的汇编指令 display /8i $pc # 8行 display /10i $pc # 10行 layout layout src：显示源代码窗口 layout asm：显示汇编窗口 layout regs：显示源代码/汇编和寄存器窗口 layout split：显示源代码和汇编窗口 layout next：显示下一个layout layout prev：显示上一个layout ctrl + l：刷新窗口 ctrl + x，再按1：单窗口模式，显示一个窗口 ctrl + x，再按2：双窗口模式，显示两个窗口 ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。 ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/gdb/","summary":"连接远程调试 target remote localhost:1234 查看内存 x/\u0026lt;n/f/u\u0026gt; \u0026lt;addr\u0026gt; x /8xb 0xffff80000002fff0 # 以16进制方式查看0xffff80000002fff0处8字节内容 n 从当前地址往后请求的字节数，如果不指定的话，GDB默认","title":"gdb usage"},{"content":"curl -s url | sudo gpg --no-default-keyring --keyring gnupg-ring:/etc/apt/trusted.gpg.d/name.gpg --import sudo chmod 644 /etc/apt/trusted.gpg.d/name.gpg google-chrome curl -s https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --no-default-keyring --keyring gnupg-ring:/etc/apt/trusted.gpg.d/google_linux_signing_key.gpg --import sudo chmod 644 /etc/apt/trusted.gpg.d/google_linux_signing_key.gpg ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/apt_key_deprecated/","summary":"curl -s URL | sudo gpg --no-default-keyring --keyring gnupg-ring:/etc/apt/trusted.gpg.d/NAME.gpg --import sudo chmod 644 /etc/apt/trusted.gpg.d/NAME.gpg google-chrome curl -s https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --no-default-keyring --keyring gnupg-ring:/etc/apt/trusted.gpg.d/google_linux_signing_key.gpg --import sudo chmod 644 /etc/apt/trusted.gpg.d/google_linux_signing_key.gpg ","title":"apt key deprecated"},{"content":"apt install bochs bochs-x ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/bochs/install/","summary":"apt install bochs bochs-x ","title":"bochs install"},{"content":"声音控制\napt install alsa-tools amixer set \u0026#39;master\u0026#39; unmute 更换默认card 找到对应card序号\ncat /proc/asound/cards 创建此文件 /etc/asound.conf 添加以下内容\n# 1 应改为对应card序号 defaults.pcm.card 1 defaults.ctl.card 1 查看cardid或名字 # 列出映射设备 aplay -l # 查看card信息 amixer -c generic_1 scontrols amixer -c 1 scontrols ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/alsa/","summary":"声音控制 apt install alsa-tools amixer set \u0026#39;Master\u0026#39; unmute 更换默认card 找到对应card序号 cat /proc/asound/cards 创建此文件 /etc/asound.conf 添加以下内容 # 1 应改为对应card序号 defaults.pcm.card 1 defaults.ctl.card 1 查看cardID或名字 # 列出映射设备 aplay -l","title":"alsa"},{"content":"# 使用utc时间 cp /usr/share/zoneinfo/utc /etc/localtime # 使用gmt-8时间，即北京时间 cp /usr/share/zoneinfo/etc/gmt-8 /etc/localtime # 查看当前时间 date \u0026#34;+%y-%m-%d %h:%m:%s\u0026#34; tz=utc-8 date +%c%:::z # 同步时间到硬件 hwclock -w ","date":"2023-02-15","permalink":"https://blog.akvicor.com/posts/linux/zoneinfo/","summary":"# 使用UTC时间 cp /usr/share/zoneinfo/UTC /etc/localtime # 使用GMT-8时间，即北京时间 cp /usr/share/zoneinfo/Etc/GMT-8 /etc/localtime # 查看当前时间 date \u0026#34;+%Y-%m-%d %H:%M:%S\u0026#34; TZ=UTC-8 date +%c%:::z # 同步时间到硬件 hwclock -w","title":"debian zoneinfo"},{"content":"debian 官方安装文档https://docs.docker.com/engine/install/debian/\nuninstall old versions apt-get remove docker docker-engine docker.io containerd runc set up the repository # add docker\u0026#39;s official gpg key: apt-get update apt-get install ca-certificates curl install -m 0755 -d /etc/apt/keyrings curl -fssl https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc chmod a+r /etc/apt/keyrings/docker.asc # add the repository to apt sources: echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$version_codename\u0026#34;) stable\u0026#34; | \\ tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null apt-get update install docker engine apt-get update apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin portainer管理多台服务器的docker vim /usr/lib/systemd/system/docker.service #找到execstart这行 在后面加上-h tcp://0.0.0.0:2375 其它方式一会docker就挂了 而且重启无效 execstart=/usr/bin/dockerd -h fd:// --containerd=/run/containerd/containerd.sock -h tcp://0.0.0.0:2375 systemctl daemon-reload systemctl restart docker ","date":"2023-02-14","permalink":"https://blog.akvicor.com/posts/docker/install/","summary":"Debian 官方安装文档https://docs.docker.com/engine/install/debian/ Uninstall old versions apt-get remove docker docker-engine docker.io containerd runc Set up the repository # Add Docker\u0026#39;s official GPG key: apt-get update apt-get install ca-certificates curl install","title":"docker install"},{"content":"官方安装文档https://caddyserver.com/docs/install\ndebian, ubuntu, raspbian apt install -y debian-keyring debian-archive-keyring apt-transport-https curl curl -1slf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1slf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | tee /etc/apt/sources.list.d/caddy-stable.list apt update apt install caddy compile go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest ~/go/bin/xcaddy build --with github.com/mholt/caddy-webdav --with github.com/aksdb/caddy-cgi/v2 module cgi cgi模块：cgi能够让浏览者与服务器进行交互\n在官网下载（或自行编译）可执行文件，替换掉bin目录下原有的caddy可执行文件 执行systemctl restart caddy\n{ order cgi last } akvicor.com { encode gzip tls pem key reverse_proxy localhost:8080 { header_up host {host} header_up x-real-ip {remote} header_up x-forwarded-for {remote} header_up x-forwarded-proto {scheme} } } akvicor.com { cgi /cgi-bin/mathtex.cgi /www/cgi-bin/mathtex.cgi root * /www/wiki/mediawiki encode gzip php_fastcgi unix//run/php-fpm/www.sock file_server } ","date":"2023-02-12","permalink":"https://blog.akvicor.com/posts/caddy/install/","summary":"官方安装文档https://caddyserver.com/docs/install Debian, Ubuntu, Raspbian apt install -y debian-keyring debian-archive-keyring apt-transport-https curl curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | tee /etc/apt/sources.list.d/caddy-stable.list apt update apt install caddy Compile go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest ~/go/bin/xcaddy build --with github.com/mholt/caddy-webdav --with","title":"caddy install"},{"content":"foreach变量 错误代码 for _, v := range histories { insertbyhistory(\u0026amp;v) } 正确代码 for _, v := range histories { h := v insertbyhistory(\u0026amp;h) } 笔记 如以上代码，传递指针时必须声明一个新变量存储v，否则会导致传递给函数的是histories最后一个元素的首地址\n","date":"2023-02-10","permalink":"https://blog.akvicor.com/posts/golang/note/","summary":"foreach变量 错误代码 for _, v := range histories { InsertByHistory(\u0026amp;v) } 正确代码 for _, v := range histories { h := v InsertByHistory(\u0026amp;h) } 笔记 如以上代码，传递指针时必须声明一个新变量存储v，否则会导致传递给函数的是hist","title":"note"},{"content":"已不可用\nssl2buy 生成csr openssl req -nodes -newkey rsa:2048 -keyout key -out csr # c = us # st = california # l = san jose # o = kayuwki # cn = *.kayuwki.com # emailaddress = admin@kayuwki.com 补全并安装证书 由于 alphassl 是中级证书商，因此需要把它的中级证书和签发给我的证书合并。\n下载 alphassl 的名为globalsign gcc r6 alphassl ca 2023的证书\n格式如下：\n-----begin certificate----- 你收到的邮件中提供的证书 -----end certificate----- -----begin certificate----- 官方提供的 alphassl 中间证书 -----end certificate----- 已失效 该方法基于 萌咖 提供的api。\n生成 csr openssl req -nodes -newkey rsa:2048 -keyout kayuki.org.key -out kayuki.org.csr # 域名填写 *.kayuki.org 使用openssl生成或使用此网址。必须加上 *. 才可以申请到泛域名证书\nhttps://api.moeclub.org/ssl/csr\n例如 *.kayuki.org\n获取 token 打开 萌咖 杂货店 点击 alphassl apply token 的 立即订购。\n购买后获得token\n确保域名可以接受邮件 需要停用域名的所有cname解析，否则无法收到邮件\n确保你要申请证书的域名有一个名为admin的邮件账号（如 admin@kayuki.org），若没有可以使用腾讯企业邮箱\n申请证书 前往 alphassl 或 alphassl2 输入我们在第一步生成的 csr 和第二步购买的token，点击 get alphassl!\n确认邮件 登录 admin@kayuki.org 邮箱，一般在1-30分钟内会受到 alphassl 发送的一封邮件，点击其中的链接完成申请。\n随后 alphassl 会再发来一封邮件，在这封邮件的底部便是我们申请的ssl证书（的一部分，需要补全）\n补全并安装证书 由于 alphassl 是中级证书商，因此需要把它的中级证书和签发给我的证书合并。\n格式如下：\n-----begin certificate----- 你收到的邮件中提供的证书 -----end certificate----- -----begin certificate----- 官方提供的 alphassl 中间证书 -----end certificate----- alphassl 官方网站提供了他们的中级证书，注意有效期，最上面的那个是有效的\n部署 上面的 key 文件 和 合并好的 crt 文件部署上服务器就可以了\n","date":"2023-01-29","permalink":"https://blog.akvicor.com/posts/ssl/alpha_ssl/","summary":"已不可用 SSL2BUY 生成CSR openssl req -nodes -newkey rsa:2048 -keyout key -out csr # C = US # ST = California # L = San Jose # O = Kayuwki # CN = *.kayuwki.com # emailAddress = admin@kayuwki.com 补全并安装证书 由于 AlphaSSL 是中级证书商，因此需要把它的中级证书和签发给我的证书","title":"alphassl"},{"content":"修改uhttpd配置文件 /etc/config/uhttpd\noption cert /viry/cert/akvicor.com.crt option key /viry/cert/akvicor.com.key 重启uhttpd服务 /etc/init.d/uhttpd restart\n","date":"2023-01-29","permalink":"https://blog.akvicor.com/posts/openwrt/enable_https/","summary":"修改uhttpd配置文件 /etc/config/uhttpd option cert /viry/cert/akvicor.com.crt option key /viry/cert/akvicor.com.key 重启uhttpd服务 /etc/init.d/uhttpd restart","title":"enable https"},{"content":"debian # debian/ubuntu/gentoo # - 安装 sudo cp root_ca.crt /usr/local/share/ca-certificates/root_ca.crt # update-ca-certificates 会添加 /etc/ca-certificates.conf 配置文件中指定的证书 # 另外所有 /usr/local/share/ca-certificates/*.crt 会被列为隐式信任 sudo update-ca-certificates # - 删除 sudo rm /usr/local/share/ca-certificates/root_ca.crt sudo update-ca-certificates --fresh rhel # centos/fedora/rhel yum install ca-certificates # 启用动态 ca 配置功能： update-ca-trust force-enable cp root_ca.crt /etc/pki/ca-trust/source/anchors/ update-ca-trust macos # 安装 root_ca.crt sudo security add-trusted-cert -d -r trustroot -k /library/keychains/system.keychain ~/root_ca.crt # 删除指定的证书 sudo security delete-certificate -c \u0026#34;\u0026lt;name of existing certificate\u0026gt;\u0026#34; windows 在根证书文件点鼠标右键，选择“安装证书” 选择“当前用户”或者“本地计算机”，下一步 “将所有的证书都放入下列存储”，“浏览”，“受信任的根证书颁发机构”，“确定”，下一步 完成，“是”，确定 ","date":"2023-01-26","permalink":"https://blog.akvicor.com/posts/linux/trust_ca/","summary":"Debian # Debian/Ubuntu/Gentoo # - 安装 sudo cp root_ca.crt /usr/local/share/ca-certificates/root_ca.crt # update-ca-certificates 会添加 /etc/ca-certificates.conf 配置文件中指定的证书 # 另外所有 /usr/local/share/ca-certificates/*.crt 会被列为隐式信任 sudo update-ca-certificates # - 删除 sudo rm /usr/local/share/ca-certificates/root_ca.crt sudo update-ca-certificates --fresh RHEL # CentOS/Fedora/RHEL yum install ca-certificates # 启用动态 CA 配置功能： update-ca-trust force-enable cp root_ca.crt /etc/pki/ca-trust/source/anchors/ update-ca-trust MacOS # 安装","title":"trust ca certificates"},{"content":"compile from source git clone github.com/librespeed/speedtest-go cd speedtest-go go build -ldflags \u0026#34;-w -s\u0026#34; -trimpath -o speedtest main.go setting 将settings.toml文件中的assets_path设置为web/assets目录（也可以将assets目录和可执行文件移动到其他位置）\nmodify 生成图片的水印定义在results/telemetry.go中的watermark变量 主页标题在web/assets/index.html文件中。 ","date":"2022-11-17","permalink":"https://blog.akvicor.com/posts/opensource/librespeed/","summary":"Compile from source git clone github.com/librespeed/speedtest-go cd speedtest-go go build -ldflags \u0026#34;-w -s\u0026#34; -trimpath -o speedtest main.go Setting 将settings.toml文件中的assets_path设置为web/assets目录（也可以将assets目录和可执行文","title":"librespeed"},{"content":"使用golang编译程序遇到的问题\n# runtime/cgo /usr/bin/ld: cannot find -lpthread collect2: error: ld returned 1 exit status pthread primitives are part of the core libc.so library. to satisfy -lpthread, create an empty ar archive somewhere in the library search path.\nar -rc /usr/lib/libpthread.a ","date":"2022-11-17","permalink":"https://blog.akvicor.com/posts/openwrt/lpthread/","summary":"使用golang编译程序遇到的问题 # runtime/cgo /usr/bin/ld: cannot find -lpthread collect2: error: ld returned 1 exit status pthread primitives are part of the core libc.so library. to satisfy -lpthread, create an empty AR archive somewhere in the library search path. ar -rc /usr/lib/libpthread.a","title":"/usr/bin/ld: cannot find -lpthread"},{"content":"此方法仅适合刚把镜像写入磁盘还未启动以及还未将镜像写入磁盘这两种情况，一旦系统启动，squashfs分区大小就已经确定了，如果要更改只能使用losetup挂载并执行resize.f2fs扩展大小。\n1. 扩展镜像文件 如果要修改的是img文件，需要先使用dd命令扩展文件的大小，如果img已经写入了磁盘则直接从第2步开始\ndd if=/dev/zero bs=1m count=1024 \u0026gt;\u0026gt; openwrt-squashfs.img 2. 使用fdisk编辑 输入命令 fdisk openwrt-squashfs.img 并按回车进入分区状态，如果img已经写入了磁盘则将文件路径改为磁盘路径即可，例如fdisk /dev/sda\n输入p并按回车，显示当前分区表 记下第二个分区的起始位置 输入d并按2次回车删除第二分区 输入n并按3次回车创建新分区 输入刚才记下的起始位置并按回车 输入新分区的大小并按回车，例如+1g为分配1g大小的分区，注意分配的大小不可超过上面dd所扩展的大小或磁盘大小，如果要使用所有未使用的空间直接留空按回车即可 输入n并按回车保留当前squashfs分区的签名 再次输入p并按回车确认分区是否正确，如果不正确输入q并按回车退出重新开始分区 输入w并按回车保存更改 修改完成后将img文件直接写入磁盘并重启即可，如果img已经写入了磁盘则直接重启系统开始自动安装\n","date":"2022-11-16","permalink":"https://blog.akvicor.com/posts/openwrt/squashfs_resize/","summary":"此方法仅适合刚把镜像写入磁盘还未启动以及还未将镜像写入磁盘这两种情况，一旦系统启动，squashfs分区大小就已经确定了，如果要更改只能使用losetup挂载并","title":"squashfs镜像扩容"},{"content":"input输入框占位符变化：输入框处于聚焦状态时，输入框的占位符内容以动画形式移动到左上角作为标题 \u0026lt;div class=\u0026#34;input-box\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;input-control input-outline\u0026#34; placeholder=\u0026#34;账号\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;input-label\u0026#34;\u0026gt;账号\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; 首先：让浏览器默认的placeholder效果不可见\n.input-control:placeholder-shown::placeholder { color: transparent; } 其次：使用.input-label元素代替浏览器原声的占位符\n.input-box{ position: relative; } .input-label { position: absolute; left: 16px; top: 14px; pointer-events: none; } 最后，在输入框聚焦以及占位符不显示的时候对\u0026lt;label\u0026gt;元素进行重定位，效果是缩小并移动到上方\n.input-control:not(:placeholder-shown) ~ .input-label, .input-control:focus ~ .input-label { color: #2486ff; transform: scale(0.75) translate(-2px, -32px); } ","date":"2022-10-11","permalink":"https://blog.akvicor.com/posts/html/placeholder/","summary":"input输入框占位符变化：输入框处于聚焦状态时，输入框的占位符内容以动画形式移动到左上角作为标题 \u0026lt;div class=\u0026#34;input-box\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;input-control input-outline\u0026#34; placeholder=\u0026#34;账号\u0026#34;\u0026g","title":"placeholder"},{"content":"windows https://learn.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys?source=recommendations\nwindows server 2022 操作系统版本 kms 客户端安装程序密钥 windows server 2022 datacenter wx4nm-kywyw-qjjr4-xv3qb-6vm33 windows server 2022 standard vdybn-27wpp-v4hqt-9vmd4-vmk7h windows server 2019 操作系统版本 kms 客户端安装程序密钥 windows server 2019 datacenter wmdgn-g9pqg-xvvxx-r3x43-63dfg windows server 2019 standard n69g4-b89j2-4g8f4-wwycc-j464c windows server 2019 essentials wvdhn-86m7x-466p6-vhxv7-yy726 windows server 2016 操作系统版本 kms 客户端安装程序密钥 windows server 2016 datacenter cb7kf-bwn84-r7r2y-793k2-8xddg windows server 2016 standard wc2bq-8nrm3-fddyy-2bfgv-khkqy windows server 2016 essentials jckrf-n37p4-c2d82-9yxrt-4m63b windows 11 操作系统版本 kms 客户端安装程序密钥 windows 11 专业版 w269n-wfgwx-yvc9b-4j6c9-t83gx windows 11 专业版 n mh37w-n47xk-v7xm9-c7227-gcqg9 windows 11 专业工作站版 nrg8b-vkk3q-cxvcj-9g2xf-6q84j windows 11 专业工作站版 n 9fnhh-k3hbt-3w4td-6383h-6xywf windows 11 专业教育版 6tp4r-gnptd-kyyhq-7b7dp-j447y windows 11 专业教育版 n yvwgf-bxnmc-htqyq-cpq99-66qfc windows 11 教育版 nw6c2-qmpvw-d7kkk-3gkt6-vcfb2 windows 11 教育版 n 2wh4n-8qgbv-h22jp-ct43q-mdwwj windows 11 企业版 nppr9-fwdcx-d2c8j-h872k-2yt43 windows 11 企业版 n dph2v-ttnvb-4x9q3-tjr4h-khjw4 windows 11 企业版 g yyvx9-ntfwv-6mdm3-9pt4t-4m68b windows 11 企业版 g n 44rpn-fty23-9vttb-mp9bx-t84fv windows 10 操作系统版本 kms 客户端安装程序密钥 windows 10 专业版 w269n-wfgwx-yvc9b-4j6c9-t83gx windows 10 专业版 n mh37w-n47xk-v7xm9-c7227-gcqg9 windows 10 专业工作站版 nrg8b-vkk3q-cxvcj-9g2xf-6q84j windows 10 专业工作站版 n 9fnhh-k3hbt-3w4td-6383h-6xywf windows 10 专业教育版 6tp4r-gnptd-kyyhq-7b7dp-j447y windows 10 专业教育版 n yvwgf-bxnmc-htqyq-cpq99-66qfc windows 10 教育版 nw6c2-qmpvw-d7kkk-3gkt6-vcfb2 windows 10 教育版 n 2wh4n-8qgbv-h22jp-ct43q-mdwwj windows 10 企业版 nppr9-fwdcx-d2c8j-h872k-2yt43 windows 10 企业版 n dph2v-ttnvb-4x9q3-tjr4h-khjw4 windows 10 企业版 g yyvx9-ntfwv-6mdm3-9pt4t-4m68b windows 10 企业版 g n 44rpn-fty23-9vttb-mp9bx-t84fv windows 10 ltsc 2021 操作系统版本 kms 客户端安装程序密钥 windows 10 企业版 ltsc 2021 m7xtq-fn8p6-ttkyv-9d4cc-j462d windows 10 企业版 n ltsc 2021 92nfx-8djqp-p6bbq-thf9c-7cg2h windows 10 ltsc 2019 操作系统版本 kms 客户端安装程序密钥 windows 10 企业版 ltsc 2019 m7xtq-fn8p6-ttkyv-9d4cc-j462d windows 10 企业版 n ltsc 2019 92nfx-8djqp-p6bbq-thf9c-7cg2h windows 10 ltsb 2016 操作系统版本 kms 客户端安装程序密钥 windows 10 企业版 ltsb 2016 dcphk-nfmtc-h88mj-pfhpy-qj4bj windows 10 企业版 n ltsb 2016 qffdn-grt3p-vkwwx-x7t3r-8b639 windows 7 操作系统版本 kms 客户端安装程序密钥 windows 7 专业版 fj82h-xt6cr-j8d7p-xqjj2-gpdd4 windows 7 专业版 n mrpkt-ytg23-k7d7t-x2jmm-qy7mg windows 7 专业版 e w82yf-2q76y-63hxb-fgjg9-gf7qx windows 7 企业版 33pxh-7y6kf-2vjc9-xbbr8-hvthh windows 7 企业版 n ydrbp-3d83w-ty26f-d46b2-xckrj windows 7 企业版 e c29wb-22cc8-vj326-ghfjw-h9dh4 windows xp 操作系统版本 kms 客户端安装程序密钥 windows xp 专业版 mrx3f-47b9t-2487j-kwkmf-rpwby office https://learn.microsoft.com/zh-cn/deployoffice/vlactivation/gvlks?redirectedfrom=msdn\ngvlk for office ltsc 2021 product gvlk office ltsc 专业增强版 2021 fxytk-njj8c-gb6dw-3dyqt-6f7th office ltsc 标准版 2021 kdx7x-bnvr8-txxgx-4q7y8-78vt3 project professional 2021 ftnwt-c6wbt-8hmgf-k9prx-qv9h8 project standard 2021 j2jdc-njcyy-9rgq4-yxwmh-t3d4t visio ltsc professional 2021 knh8d-fght4-t8rk3-ctdyj-k2ht4 visio ltsc standard 2021 mjvny-bywpy-cwv6j-2rkrt-4m8qg access ltsc 2021 wm8yg-yngdd-4jhdc-pg3f4-fc4t4 excel ltsc 2021 nwg3x-87c9k-tc7yy-bc2g7-g6rvc outlook ltsc 2021 c9fm6-3n72f-hfjxb-tm3v9-t86r9 powerpoint ltsc 2021 ty7xf-nfrbr-kj44c-g83kf-gx27k publisher ltsc 2021 2mw9d-n4bxm-9vbpg-q7w6m-kfbgq skype for business ltsc 2021 hwcxn-k3wbt-wjbky-r8bd9-xk29p word ltsc 2021 tn8h9-m34d3-y64v9-tr72v-x79kv gvlk for office ltsc 2019 product gvlk office 专业增强版 2019 nmmkj-6rk4f-kmjvx-8d9mj-6mwkp office 标准版 2019 6nwwj-yqwmr-qkgcb-6tmb3-9d9hk project 专业版 2019 b4npr-3fkk7-t2mbv-frq4w-pkd2b project 标准版 2019 c4f7p-ncp8c-6cqpt-mqhv9-jxd2m visio 专业版 2019 9bgnq-k37yr-rqhf2-38rq3-7vcbb visio 标准版 2019 7tqnq-k3yqq-3pfh7-ccppm-x4vq2 access 2019 9n9pt-27v4y-vj2pd-yxfmf-ytfqt excel 2019 tmjwt-yynmb-3bktf-644fc-rvxbd outlook 2019 7hd7k-n4pvk-bhbcq-ywqrw-xw4vk powerpoint 2019 rrncx-c64hy-w2mm7-mch9g-tjhmq publisher 2019 g2kwx-3nw6p-py93r-jxk2t-c9y9v skype for business 2019 ncj33-jhbby-htk98-mycv8-hmkhj word 2019 pbx3g-nwmt6-q7xbw-pyjgg-wxd33 ","date":"2022-10-08","permalink":"https://blog.akvicor.com/posts/windows/kms/","summary":"Windows https://learn.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys?source=recommendations Windows Server 2022 操作系统版本 KMS 客户端安装程序密钥 Windows Server 2022 Datacenter WX4NM-KYWYW-QJJR4-XV3QB-6VM33 Windows Server 2022 Standard VDYBN-27WPP-V4HQT-9VMD4-VMK7H Windows Server 2019 操作系统版本 KMS 客户端安装程序密钥 Windows Server 2019 Datacenter WMDGN-G9PQG-XVVXX-R3X43-63DFG Windows Server 2019 Standard N69G4-B89J2-4G8F4-WWYCC-J464C Windows Server 2019 Essentials WVDHN-86M7X-466P6-VHXV7-YY726 Windows Server 2016 操作系统版本 KMS 客户端安装","title":"kms \u0026 gvlk"},{"content":"kms激活windows 首先用管理员权限打开命令提示符 卸载当前系统秘钥：slmgr.vbs /upk 写入kms的gvlk秘钥：slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx-xxxxx 写入kms服务器地址：slmgr /skms home.akvicor.com 连接kms服务器激活：slmgr /ato 查看激活状态：slmgr.vbs -dlv kms激活office 首先用管理员权限打开命令提示符 切换到office的安装路径，例如：c:\\program files\\microsoft office\\office16 查看当前密钥最后五位数：cscript ospp.vbs /dstatus 卸载当前密钥：cscript ospp.vbs /unpkey:xxxxx 安装kms密钥：cscript ospp.vbs /inpkey:xxxxx-xxxxx-xxxxx-xxxxx-xxxxx 设置激活kms服务器：cscript ospp.vbs /sethst:home.akvicor.com 执行激活命令：cscript ospp.vbs /act download office office deployment tool简称odt，是微软官方提供的office部署工具。下载地址为：https://www.microsoft.com/en-us/download/details.aspx?id=49117或http://pi.akvicor.com:7021/file?f=1284\n运行下载的程序，将内容解压到指定目录，并进入此目录\nconfiguration-office365-x64：里面包含了用于安装64位版本的office 365的默认配置信息。 configuration-office365-x86：里面包含了用于安装32位版本的office 365的默认配置信息。 configuration-office2019enterprise：里面包含了用于安装office 2019专业增强版、企业版的默认配置信息。 configuration-office2021enterprise：里面包含了用于安装office 2021专业增强版、企业版的默认配置信息。 可以使用官方配置工具生成配置文件\nhttps://config.office.com/ https://config.office.com/deploymentsettings 也可以手动编辑configuration-office2021enterprise.xml文件\nofficeclientedition=\u0026quot;64\u0026quot;意思是64位版本。 product id=\u0026quot;proplus2019volume\u0026quot;意思为office 2019专业增强版、企业版。 product id=\u0026quot;visiopro2019volume\u0026quot;为visio 2019专业版、企业版。 product id=\u0026quot;projectpro2019volume\u0026quot;为project 2019专业版、企业版。 visio和project均为office家族中的软件。但是visio和project均是单独发布的office产品，不包含在office 2019专业增强版中，因此配置信息会单独列出。 language id=\u0026quot;en-us\u0026quot;代表语言版本为美式英语，如果你需要简体中文，则需要将其中的en-us修改为zh-cn，你还可以将en-us改为matchos，意思是让程序自动匹配系统语言版本，如果你的系统为英文版，则安装英文版，如果为中文版，则安装中文版。 \u0026lt;excludeapp id=\u0026quot;publisher\u0026quot; /\u0026gt;代表不安装publisher，同样还可以设置onedrive、outlook、access、skype、onenote。 \u0026lt;!-- office 2021 enterprise client configuration file sample. to be used for office 2021 enterprise volume licensed products only, including office 2021 professional plus, visio 2021, and project 2021. do not use this sample to install office 365 products. for detailed information regarding configuration options visit: http://aka.ms/odt. to use the configuration file be sure to remove the comments the following sample allows you to download and install office 2021 professional plus, visio 2021 professional, and project 2021 professional directly from the office cdn. this configuration file will remove all other click-to-run products in order to avoid product conflicts and ensure successful setup. --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;add officeclientedition=\u0026#34;64\u0026#34; channel=\u0026#34;perpetualvl2021\u0026#34;\u0026gt; \u0026lt;product id=\u0026#34;proplus2021volume\u0026#34;\u0026gt; \u0026lt;language id=\u0026#34;zh-cn\u0026#34; /\u0026gt; \u0026lt;language id=\u0026#34;en-us\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;lync\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;groove\u0026#34;/\u0026gt; \u0026lt;excludeapp id=\u0026#34;bing\u0026#34;/\u0026gt; \u0026lt;excludeapp id=\u0026#34;publisher\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;onedrive\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;outlook\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;teams\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;access\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;skype\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;onenote\u0026#34; /\u0026gt; \u0026lt;/product\u0026gt; \u0026lt;product id=\u0026#34;visiopro2021volume\u0026#34;\u0026gt; \u0026lt;language id=\u0026#34;zh-cn\u0026#34; /\u0026gt; \u0026lt;language id=\u0026#34;en-us\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;lync\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;groove\u0026#34;/\u0026gt; \u0026lt;excludeapp id=\u0026#34;bing\u0026#34;/\u0026gt; \u0026lt;excludeapp id=\u0026#34;publisher\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;onedrive\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;outlook\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;teams\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;access\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;skype\u0026#34; /\u0026gt; \u0026lt;excludeapp id=\u0026#34;onenote\u0026#34; /\u0026gt; \u0026lt;/product\u0026gt; \u0026lt;product id=\u0026#34;languagepack\u0026#34;\u0026gt; \u0026lt;language id=\u0026#34;zh-cn\u0026#34; /\u0026gt; \u0026lt;language id=\u0026#34;en-us\u0026#34; /\u0026gt; \u0026lt;/product\u0026gt; \u0026lt;/add\u0026gt; \u0026lt;remove all=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- \u0026lt;removemsi all=\u0026#34;true\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;display level=\u0026#34;none\u0026#34; accepteula=\u0026#34;true\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;autoactivate\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;/configuration\u0026gt; 在此目录打开powershell，执行cmd，然后执行setup.exe /download configuration-office2021enterprise.xml开始下载。\n执行setup.exe /configure configuration-office2021enterprise.xml开始安装\n","date":"2022-10-08","permalink":"https://blog.akvicor.com/posts/windows/windows_product_activation/","summary":"KMS激活Windows 首先用管理员权限打开命令提示符 卸载当前系统秘钥：slmgr.vbs /upk 写入KMS的GVLK秘钥：slmgr /ipk XXXXX-XXXXX-XXXXX-XXXXX-XXXXX 写入KMS服务器地址：slm","title":"windows product activation"},{"content":" setting/tools/action and save/reformat code: 自动格式化代码 setting/tools/action and save/optimize imports: 自动优化import setting/editor/inspections/go/code style issues/usage of snake_case: 关闭snakecase变量名 setting/editor/general/code folding/: 关闭代码折叠 ","date":"2022-10-07","permalink":"https://blog.akvicor.com/posts/idea/goland/","summary":"Setting/Tools/Action and Save/Reformat Code: 自动格式化代码 Setting/Tools/Action and Save/Optimize imports: 自动优化import Setting/Editor/Inspections/Go/Code Style issues/Usage of Snake_Case: 关闭SnakeCase变量名 Setting/Editor/General/Code Folding/: 关闭代码折叠","title":"goland"},{"content":"make windows use utc time filename: make windows use utc time.reg\nwindows registry editor version 5.00 [hkey_local_machine\\system\\currentcontrolset\\control\\timezoneinformation] \u0026#34;realtimeisuniversal\u0026#34;=dword:00000001 以管理员身份打开 「powershell」，输入以下命令\nreg add hklm\\system\\currentcontrolset\\control\\timezoneinformation /v realtimeisuniversal /t reg_dword /d 1 make windows use local time filename: make windows use local time.reg\nwindows registry editor version 5.00 [hkey_local_machine\\system\\currentcontrolset\\control\\timezoneinformation] \u0026#34;realtimeisuniversal\u0026#34;=- ","date":"2022-10-04","permalink":"https://blog.akvicor.com/posts/windows/fix_windows_and_linux_showing_different_times_when_dual_booting/","summary":"Make Windows Use UTC Time Filename: Make Windows Use UTC Time.reg Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation] \u0026#34;RealTimeIsUniversal\u0026#34;=dword:00000001 以管理员身份打开 「PowerShell」，输入以下命令 Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 Make Windows Use Local Time Filename: Make Windows Use Local Time.reg Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation] \u0026#34;RealTimeIsUniversal\u0026#34;=-","title":"fix windows and linux showing different times when dual booting"},{"content":"每隔30秒钟检查一次网络状态，如果网络异常则重启网卡，然后刷新dns缓存。\n@echo off echo \u0026#34;正在监听网络状态....\u0026#34; cd c:\\opt\\netcheck :begin ping akvicor.com \u0026gt; ping.txt rem echo %errorlevel% if %errorlevel% == 1 goto ping2 goto loop :ping2 ping baidu.com \u0026gt; ping.txt if %errorlevel% == 1 goto reboot goto loop :reboot echo %date% %time% \u0026#34;网络异常\u0026#34; \u0026gt;\u0026gt; errlog.log echo %date% %time% \u0026#34;正在停用网卡\u0026#34; netsh interface set interface \u0026#34;wlan\u0026#34; disabled timeout /t 3 /nobreak echo %date% %time% \u0026#34;正在启用网卡\u0026#34; netsh interface set interface \u0026#34;wlan\u0026#34; enable echo %date% %time% \u0026#34;网卡已重新启动....\u0026#34; echo %date% %time% \u0026#34;网卡已重新启动\u0026#34; \u0026gt;\u0026gt; errlog.log goto loop :loop ipconfig /flushdns \u0026gt; nul timeout /t 30 \u0026gt; nul goto begin ","date":"2022-09-26","permalink":"https://blog.akvicor.com/posts/windows/auto_restart_network_interface/","summary":"每隔30秒钟检查一次网络状态，如果网络异常则重启网卡，然后刷新DNS缓存。 @echo off echo \u0026#34;正在监听网络状态....\u0026#34; cd C:\\opt\\netcheck :begin ping akvicor.com \u0026gt; ping.txt rem echo %errorlevel% if %ERRORLEVEL% == 1 goto ping2 goto loop","title":"auto restart network interface"},{"content":"gcc会在call指令之前让rsp按16字节对齐。\ncpu在call的时候将rip压栈rsp -= 8，所以进入被调用者之后rsp = 8 (mod 16)。如果在这个函数里面还要call其他函数的话就要将rsp减掉奇数个8让它重新16字节对齐。\n","date":"2022-08-23","permalink":"https://blog.akvicor.com/posts/aos/stack_alignment_in_x64_assembly/","summary":"gcc会在call指令之前让rsp按16字节对齐。 cpu在call的时候将rip压栈rsp -= 8，所以进入被调用者之后rsp = 8 (mod 16)。如果在这个函数里面还要c","title":"stack alignment in x64 assembly"},{"content":"初始化寄存器 我将物理地址0x050000-0x070008之间的内存分配给了堆栈。栈顶设置为0x070008的原因是，kernel函数在编译后会在函数开头加上这样一行汇编代码sub $0x8,%rsp，将栈顶设置为0x070008可以保证在经过此操作后，栈顶为0x070000。\n段寄存器 cs: 指向存放程序的内存段，ip用来存放下条待执行的指令在该段的偏移量。cs:ip所指向的指令就是下次要执行的指令。 ss: 指向用于堆栈的内存段，sp用来指向该堆栈的栈顶。 ds: 指向数据段 es: 指向附加段 (辅助段寄存器) fs: 指向标志段 (辅助段寄存器) gs: 指向全局段 (辅助段寄存器) 缺省段寄存器 当偏移量用到了指针寄存器bp，则其缺省的段寄存器也是ss，并且用bp可访问整个堆栈，不仅仅是只访问栈顶。 通常，缺省的数据段寄存器是ds 在进行串操作时，其目的地址的段寄存器规定为es 代码 use this command to check your usb stick fat32 fields\nsudo hexdump -c -n 512 /dev/sdb write the bootloader to first 512 bytes of the usb stick\nsudo dd if=boot.bin of=/dev/sdb conv=notrunc boot.asm\n[bits 16] [org 0x7c00] ;----------------------------------------------- [jump instruction; offset: 0x00; length: 3 bytes] jmp short label_start ; 2 bytes nop ; 1 bytes ;----------------------------------------------- [fat32; offset: 0x03; length: 87 bytes] %include \u0026#34;fat32.asm\u0026#34; ;----------------------------------------------- [bootstrap code; offset: 0x5a; length: 420 bytes] label_start: call print_startboot mov sp, baseofstack push cs pop ds ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; search and read \u0026#34;loader.bin\u0026#34; ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; and byte [bs_rootdirectorystart+3], 0x0f ; mask cluster value mov esi, [bs_rootdirectorystart] ; esi=cluster # of root dir rootdirreadcontinue: push baseofloader pop es xor bx, bx call readcluster ; read one cluster of root dir push esi ; save esi=next cluster # of root dir pushf ; save carry=\u0026#34;not last cluster\u0026#34; flag ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; look for the loader file to load and run ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; push baseofloader pop es xor di, di ; es:di -\u0026gt; root entries array mov si, filename_loader ; ds:si -\u0026gt; program name mov al, [bpb_sectorspercluster] cbw mul word [bpb_bytespersector] ; ax = bytes per cluster shr ax, 5 mov dx, ax ; dx = # of dir entries to search in ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; looks for a file/dir by its name ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; input: ds:si -\u0026gt; file name (11 chars) ;; ;; es:di -\u0026gt; root directory array ;; ;; dx = number of root entries ;; ;; output: esi = cluster number ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; mov cx, 11 ; the length of loader filename findnamecycle: cmp byte [es:di], 0xc jne findnamenotend jmp print_error_noloader ; end of root directory (null entry found) findnamenotend: pusha repe cmpsb popa je findnamefound add di, 32 dec dx jnz findnamecycle ; next root entry popf ; restore carry=\u0026#34;not last cluster\u0026#34; flag pop esi ; restore esi=next cluster # of root dir jc rootdirreadcontinue ; continue to the next root dir cluster jmp print_error_noloader ; end of root directory (dir end reached) findnamefound: push word [es:di+0x14] push word [es:di+0x1a] pop esi ; si = cluster no. ;;;;;;;;;;;;;;;;;;;;;;;;;; ;; load the entire file ;; ;;;;;;;;;;;;;;;;;;;;;;;;;; push baseofloader pop es xor bx, bx filereadcontinue: call readcluster ; read one cluster of root dir pushf pusha inc byte [clu] mov ax, 0xb800 mov gs, ax mov ah, 0x0f ; 0000: 黑底 1111: 白字 mov al, [clu] mov [gs:((80 * 0 + 39) * 2)], ax ; 屏幕第 0 行, 第 39 列。 popa popf jc filereadcontinue enterloader: mov bl, byte [line] ; save line number jmp baseofloader:offsetofloader ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; reads a fat32 cluster ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; inout: es:bx -\u0026gt; buffer ;; ;; esi = cluster no ;; ;; output: esi = next cluster ;; ;; es:bx -\u0026gt; next addr ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; readcluster: mov ax, [bpb_bytespersector] shr ax, 2 ; ax=# of fat32 entries per sector cwde mov ebp, esi ; ebp=esi=cluster # xchg eax, esi cdq div esi ; eax=fat sector #, edx=entry # in sector movzx edi, word [bpb_reservedsectors] add edi, [bpb_hiddensectors] add eax, edi push dx ; save dx=entry # in sector on stack mov cx, 1 call readsectorlba ; read 1 fat32 sector pop si ; si=entry # in sector add si, si add si, si and byte [es:si+3], 0x0f ; mask cluster value mov esi, [es:si] ; esi=next cluster # lea eax, [ebp-2] movzx ecx, byte [bpb_sectorspercluster] mul ecx mov ebp, eax movzx eax, byte [bpb_totalfats] mul dword [bs_bigsectorsperfat] add eax, ebp add eax, edi call readsectorlba mov ax, [bpb_bytespersector] shr ax, 4 ; ax = paragraphs per sector mul cx ; ax = paragraphs read mov cx, es add cx, ax mov es, cx ; es:bx updated cmp esi, 0x0ffffff8 ; carry=0 if last cluster, and carry=1 otherwise ret ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; reads a sector using bios int 13h fn 42h ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; input: eax = lba ;; ;; cx = sector count ;; ;; es:bx -\u0026gt; buffer address ;; ;; output: cf = 1 if error ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; readsectorlba: pushad readsectorlbanext: pusha push byte 0 push byte 0 ; 32-bit lba only: up to 2tb disks push eax push es push bx push byte 1 ; sector count word = 1 push byte 16 ; packet size byte = 16, reserved byte = 0 mov ah, 42h mov dl, [bs_drivenumber] mov si, sp push ss pop ds int 13h push cs pop ds jc short print_error_read add sp, 16 ; the two instructions are swapped so as not to overwrite carry flag popa dec cx jz readsectorlbadone2 ; last sector add bx, [bpb_bytespersector] ; adjust offset for next sector add eax, byte 1 ; adjust lba for next sector jmp short readsectorlbanext readsectorlbadone2: popad ret print_startboot: pusha mov cx, 10 mov bp, message_startboot mov bx, 0x000f call message_print_end popa ret print_error_read: mov cx, 11 mov bp, message_readerror mov bx, 0x000f call message_print_end jmp $ print_error_noloader: mov cx, 15 mov bp, message_noloader mov bx, 0x000c call message_print_end jmp $ message_print_end: push es push ds mov ax, 0 mov ds, ax mov es, ax mov ax, 0x1301 mov dl, 0 mov dh, [line] inc byte [line] int 10h pop ds pop es ret baseofloader: equ 0x1000 offsetofloader: equ 0x0000 baseofstack: equ 0x7c00 message_startboot: db \u0026#34;start boot\u0026#34; ; 10 message_readerror: db \u0026#34;error: read\u0026#34; ; 11 message_noloader: db \u0026#34;no loader found\u0026#34; ; 15 filename_loader: db \u0026#34;loader bin\u0026#34; ; 11 line: db 0x00 clu: db 0x41 times 510 - ($ - $$) db 0 ;----------------------------------------------- [end of sector marker; offset: 0x1fe; length: 2 bytes] dw 0xaa55 ","date":"2022-08-22","permalink":"https://blog.akvicor.com/posts/aos/boot/","summary":"初始化寄存器 我将物理地址0x050000-0x070008之间的内存分配给了堆栈。栈顶设置为0x070008的原因是，kernel函数在编译后会在函数开头加上这","title":"boot: 从fat32分区搜索并读取loader"},{"content":"修改文件或目录所有者 # 修改文件的所有者为root chown root \u0026lt;file\u0026gt; # 修改文件的所有者和所有组为root chown root: \u0026lt;file\u0026gt; # 修改文件的所有者为root，所有组为akvicor chown root:akvicor \u0026lt;file\u0026gt; # 修改文件的所有组为root chown :root \u0026lt;file\u0026gt; 修改文件或目录的访问权限 # chmod \u0026lt;xxx\u0026gt; \u0026lt;file/dir\u0026gt; chmod 777 file # chmod \u0026lt;u/g/o/a\u0026gt;\u0026lt;+/-\u0026gt;\u0026lt;r/w/x\u0026gt; \u0026lt;file/dir\u0026gt; chmod u+x file 目标 u: 用户 g: 组 o: 其他用户 a: 全部 操作 +: 加 -: 减 权限 r: 读 w: 写 x: 执行 特殊权限 s: -\u0026gt;u组，简称suid的特殊权限。当执行该文件时将具有该文件所有者的权限。 s: -\u0026gt;g组，简称sgid的特殊权限。在该目录下创建的文件和目录都属于该目录所属的组 t: -\u0026gt;o组，简称sbit的特殊权限。只能让所属主以及root可以删除/移动/重命名该目录下的文件 其中sudo命令就是通过u组的s权限实现的。\nsudo原理 源码 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc, char* argv[]) { printf(\u0026#34;ruid: %d\\n\u0026#34;,getuid()); printf(\u0026#34;euid: %d\\n\u0026#34;,geteuid()); if(execvp(argv[1], argv+1) == -1) { perror(\u0026#34;execvp error\u0026#34;); }; return 0; } 编译 查看文件权限\n-rwxr-xr-x 1 vivc vivc 17k aug 19 16:32 main 运行 可以看到文件ruid和euid均为自己\nruid: 1001 euid: 1001 segmentation fault 修改文件所有者 sudo chown akvicor main 查看文件权限 -rwxr-xr-x 1 akvicor vivc 17k aug 19 16:32 main 运行 可以看到文件ruid和euid均为自己\nruid: 1001 euid: 1001 segmentation fault 添加s权限 chmod u+s main 运行 可以看到ruid为自己，euid则与文件拥有者相同，此时这个程序运行时将具有euid用户的权限\nruid: 1001 euid: 1000 segmentation fault 测试权限 由于代码中固定需要两个参数，因此使用rm file测试。\n-rw------- 1 akvicor akvicor 0 aug 19 16:49 file file文件属于akvicor，只有akvicor有权限删除。而main程序由于具有s特殊权限且属于用户akvicor，因此通过main来执行rm命令便可以删除file文件\n./main rm file ","date":"2022-08-19","permalink":"https://blog.akvicor.com/posts/linux/file_permission/","summary":"修改文件或目录所有者 # 修改文件的所有者为root chown root \u0026lt;file\u0026gt; # 修改文件的所有者和所有组为root chown root: \u0026lt;file\u0026gt; # 修改文件的所有者为root，所有组为akvicor chown root:akvicor \u0026lt;file\u0026gt; # 修改","title":"file permission"},{"content":"oh-my-zsh主题显示执行时间 oh-my-zsh主题显示执行时间\n进入主题目录~/.oh-my-zsh/themes\n在想要修改的主题文件中添加如下代码：\nfunction preexec() { timer=${timer:-$seconds} } function precmd() { if [ $timer ]; then timer_show=$(($seconds - $timer)) if [[ $timer_show -ge $min_show_time ]]; then rprompt=\u0026#39;%{$fg_bold[red]%}(${timer_show}s)%f%{$fg_bold[white]%}[%*]%f %{$reset_color%}%\u0026#39; else rprompt=\u0026#39;%{$fg_bold[white]%}[%*]%f\u0026#39; fi unset timer fi } autoload -uz add-zsh-hook add-zsh-hook preexec preexec add-zsh-hook precmd precmd ","date":"2022-08-09","permalink":"https://blog.akvicor.com/posts/linux/zsh/","summary":"oh-my-zsh主题显示执行时间 oh-my-zsh主题显示执行时间 进入主题目录~/.oh-my-zsh/themes 在想要修改的主题文件中添加如下代码： function preexec() {","title":"zsh"},{"content":"概念和相关文件 在 linux 用户系统中存在两类组。第一类是主要用户组（主组），第二类是附加用户组（附属组）。\n主组：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组。 附属组：也被称为secondary group或supplementary group，用户的附加组。 存储文件 用户帐户及相关信息都存储在/etc/passwd文件中， 用户组信息存储在/etc/shadow和/etc/group文件。 id命令 通过id命令查看用户的主组和附属组\nid root # uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel) id gg # uid=503(gg) gid=503(gg) groups=503(gg) id mm # uid=502(mm) gid=500(jww) groups=500(jww) gid标识主组，groups表示用户所属的全部组（主组和附属组）\n用户必须有且只能有一个主组，可以有0个、1个或多个附属组\n新增一个用户并添加到指定用户组 #检查用户组是否存在，如果组存在则会输出组信息，否则没有任何输出 grep \u0026lt;用户组名称\u0026gt; /etc/group #如果用户组不存在则使用如下命令新建用户组： groupadd \u0026lt;用户组名称\u0026gt; #新建用户并将其加入指定用户组,作为其主用户组（每个用户有且只有一个主用户组） useradd -g \u0026lt;用户组名称\u0026gt; \u0026lt;用户名称\u0026gt; #或者 新建用户并将其加入指定附属用户组，附属用户组可以有多个，多个附属组名称用逗号分隔即可 useradd -g \u0026lt;用户组名称\u0026gt; \u0026lt;用户名称\u0026gt; #设置用户密码 passwd \u0026lt;用户名称\u0026gt; #查看用户属性，检查是否添加到正确的用户组 id \u0026lt;用户名称\u0026gt; 常用添加用户命令（添加用户并添加到主组）：useradd -g \u0026lt;用户组名称\u0026gt; \u0026lt;用户名称\u0026gt;\n将已有用户添加到指定用户组 #将已有用户添加到指定用户组，作为其附属用户组 # -a 代表append，和 -g 一起使用，将用户添加到新用户组中而不必来开原有的其他用户组 usermod -a -g \u0026lt;用户组名称\u0026gt; \u0026lt;用户名称\u0026gt; #将已有用户的主用户组改为新的用户组 usermod -g \u0026lt;新的用户组名称\u0026gt; \u0026lt;用户名称\u0026gt; 添加用户，并创建家目录、登录shell等信息 # -m 自动建立用户家目录 # -m 不自动创建家目录 # -d \u0026lt;dir\u0026gt; 使用指定目录作为家目录 # -g \u0026lt;gid\u0026gt; 指定用户所在的主组 # -u 自动创建同名主组 # -g \u0026lt;gid1\u0026gt;,\u0026lt;gid2\u0026gt; 指定用户所属的组 # -s \u0026lt;shell\u0026gt; 指定用户登录的shell useradd -m -s /bin/bash \u0026lt;用户名称\u0026gt; 将一个用户从某个用户组删除 #将用户从该用户的附属组中删除 gpasswd -d \u0026lt;用户名称\u0026gt; \u0026lt;用户组名称\u0026gt; 删除用户 #永久性删除用户账号 userdel \u0026lt;用户名称\u0026gt; ","date":"2022-08-09","permalink":"https://blog.akvicor.com/posts/linux/user_group/","summary":"概念和相关文件 在 Linux 用户系统中存在两类组。第一类是主要用户组（主组），第二类是附加用户组（附属组）。 主组：也被称为primary group、first group或","title":"linux user/group"},{"content":"赋予用户组操作usb设备的权限\n创建用户组并添加用户到用户组 # 创建用户组 groupadd usbfs # 查看usbfs用户组的id # usbfs:x:1001: cat /dev/group | grep usbfs # 把akvicor添加到用户组 useradd -g usbfs akvicor # 或 vim /etc/group # 修改 usbfs:x:1001: # 为 usbfs:x:1001:akvicor 添加访问权限 # 进入目录 cd /etc/udev/rules.d # 创建配置文件 vim xxx.rules # 写入信息到配置文件 允许用户组usbfs访问usb设备\ngroup 设置usb设备的所属用户组为usbfs mode 设置usb设备的访问权限为0777 subsystems==\u0026#34;usb\u0026#34;,group=\u0026#34;usbfs\u0026#34;,mode=\u0026#34;0777\u0026#34; subsystems==\u0026#34;usb\u0026#34;,group=\u0026#34;usbfs\u0026#34; 允许用户akvicor访问usb设备\nowner 设置usb设备的所有者为akvicor mode 设置usb设备的访问权限为0777 subsystems==\u0026#34;usb\u0026#34;,owner=\u0026#34;akvicor\u0026#34;,mode=\u0026#34;0777\u0026#34; ","date":"2022-08-09","permalink":"https://blog.akvicor.com/posts/linux/usbfs/","summary":"赋予用户组操作usb设备的权限 创建用户组并添加用户到用户组 # 创建用户组 groupadd usbfs # 查看usbfs用户组的id # usbfs:x:1001: cat /dev/group | grep usbfs # 把akvicor添加到用户组 useradd -G usbfs akvicor # 或 vim","title":"usbfs"},{"content":"debian安装说明\ndebian 源 wget https://paste.akvicor.com/api/106 debian 12 + i3 修改时区 # 修改时区 ln -sf /usr/share/zoneinfo/etc/gmt-8 /etc/localtime # 同步硬件时间 hwclock -w 配置源 curl https://paste.akvicor.com/api/101 \u0026gt; /etc/apt/sources.list # 注释掉不需要用到的源，如 bookworm-proposed-updates(介于stable和testing之间), bookworm-backports(新特性移植到旧版本) apt update apt upgrade reboot 安装基础工具 apt install apt-transport-https ca-certificates apt install vim curl wget git gcc g++ make screen bc jq zsh 添加基础bash命令 # 添加ll命令.bashrc alias l=\u0026#39;ls -al --color=auto\u0026#39; alias ll=\u0026#39;ls -alh --color=auto\u0026#39; 笔记本电源操作 vim /etc/systemd/logind.conf handlelidswitch=ignore # 合上屏幕 handlepowerkey=ignore # 电源按键 修改启动展示信息 ssh登录信息\n# 修改登录显示信息 vim /etc/update-motd.d/10-uname # 注释掉原有内容，添加以下内容 printf \u0026#34;\\033c\u0026#34; # 清空motd内容 vim /etc/motd 关闭grub引导界面\n# 关闭grub引导界面 vim /etc/default/grub 修改grub_timeout为0 grub_timeout=0 # 更新 update-grub reboot 为用户添加sudo权限 # 为用户添加sudo权限 apt install sudo cd /etc/sudoers.d vim user # 填入以下内容 akvicor all=(all)nopasswd:all 配置root用户的git 修改git用户信息 git config --global user.name \u0026#34;akvicor\u0026#34; git config --global user.email akvicor@akvicor.com 或\ngit config --global --edit 修改git默认编辑器 git config --global core.editor vim 支持smb挂载 apt install cifs-utils mkdir /smb/hhdx mount -t cifs -o username=root //172.16.1.1/hhdx /smb/hhdx 安装桌面环境 apt install xorg i3 i3blocks terminator libnotify-bin notify-osd 配置sddm刷新率 vim /usr/share/sddm/scripts/xsetup 增加下面内容\nxset r rate 200 30 配置桌面环境 # 配置桌面环境 cp /etc/x11/xinit/xinitrc ~/.xinitrc # 添加以下内容到 ~/.xinitrc exec i3 添加快捷命令 # 添加以下内容到 .bashrc / .zshrc alias l=\u0026#39;ls -al --color=auto\u0026#39; alias ll=\u0026#39;ls -alh --color=auto\u0026#39; alias ui=\u0026#39;startx\u0026#39; 安装字体 从备份恢复 # 下载fonts.tgz https://via.akvicor.com/file?f=1581 mv fonts.tgz /usr/local/share/fonts cd /usr/local/share/fonts tar -zxvf fonts.tgz rm fonts.tgz # 更新字体缓存 fc-cache -fv 字体配置文件 将以下文件放在~/.config/fontconfig中，以改变字体生效顺序，防止出现不必要的乱码或识别错误\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!doctype fontconfig system \u0026#34;urn:fontconfig:fonts.dtd\u0026#34;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;!-- default system-ui fonts --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;system-ui\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- default sans-serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;noto sans sc\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;font awesome 6 pro\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- default serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;noto serif sc\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;noto serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- default monospace fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;monospace\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;jetbrainsmono nerd font mono\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;hack nerd font mono\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;/fontconfig\u0026gt; awesome字体 在这里面搜索字体并使用\nhttps://fontawesome.com/search\n# 执行以下命令更新字体缓存 fc-cache -fv # 若字体文件未生效，切换至用户，执行以下命令删除旧缓存 rm -rf ~/.cache/fontconfig/ # fontawesome-pro_v6.4.0_package.zip # 将otf字体放到系统指定目录中使用 https://via.akvicor.com/file?f=1496 # 全部字体，可自选放入系统中，配合fontconfig设置每个字体的顺序 https://via.akvicor.com/file?f=1497 # 修改i3默认字体为google noto sans 常用命令 #lists fonts fc-list # show an ordered list of fonts matching a certain name or pattern fc-match -s helvetica # rebuilds cached list of fonts (in `~/.cache/fontconfig`, older caches may also be in `~/.fontconfig`) fc-cache -fv 配置user用户的git 修改git用户信息 git config --global user.name \u0026#34;akvicor\u0026#34; git config --global user.email akvicor@akvicor.com 或\ngit config --global --edit 修改git默认编辑器 git config --global core.editor vim 安装中文输入法 apt install fcitx5 fcitx5-pinyin fcitx5-configtool # 添加pinyin输入法 im-config # 修改默认输入法，如果报错安装 zenity 安装环境 golang node rust python 安装拓展工具 rdesktop windows远程桌面\n安装\napt install rdesktop xclip 剪切板\n安装\napt install xclip xbacklight 屏幕背光亮度\n安装\napt install xbacklight picom 窗口背景透明\n安装\napt install picom !废弃 compton 窗口背景透明\n安装\napt install compton light 屏幕背光亮度\n安装\napt install light rofi 应用程序窗口选择器，运行对话框\n安装\napt install rofi feh 图片查看器\n安装\napt install feh poppler-utils pdf工具集\n安装\napt install poppler-utils caca-utils 命令行图形库\n安装\napt install caca-utils highlight 高亮显示源代码的命令行工具\n安装\napt install highlight atool 归档文件管理工具\n安装\napt install atool imagemagick 图像处理工具集\n安装\napt install imagemagick ethtool 网络管理工具\n安装\napt install ethtool scrot 截图工具\n安装\napt install scrot ranger 命令行文件管理工具\n安装\napt install ranger alsa-utils 声音控制\n安装\napt install alsa-utils !废弃 pulseaudio, pavucontrol 声音控制\n安装\napt install pulseaudio apt install pavucontrol smartmontools 硬盘管理工具\n安装\napt install smartmontools 用法\nsudo smartctl -a /dev/sda sudo smartctl -h /dev/sda tcptrack monitor tcp connections on the network\n安装\nsudo apt-get install tcptrack 用法\ntcptrack -i wlp2s0 proxychains 通过代理运行程序\n安装\napt-get install proxychains sudo find / -name \u0026#34;libproxychains.so.3\u0026#34; # get path sudo vim /usr/bin/proxychains # change 用法\nsudo proxychains apt-get update proxychains google-chrome privoxy convert socks to http proxy\n安装\nsudo apt-get install privoxy sudo vim /etc/privoxy/config # port: 8118 # forward-socks5 / 127.0.0.1:1080 . 用法\nsudo systemctl start privoxy uget + aria2 多线程下载工具\n安装\nsudo apt-get install uget aria2 # config uget: plug-in use aria2 ufw firewall 防火墙\n安装\nsudo apt-get install ufw sudo ufw enable sudo systemctl enable ufw sudo systemctl restart ufw sudo ufw status 用法\nsudo ufw allow 22 sudo ufw deny 80 mesa-utils opengl工具包\n安装\napt install mesa-utils 用法\nglxgears # 显示一个旋转的齿轮动画, 用于测试opengl性能, 在控制台输出帧率 glxheads # 显示所有当前连接到的x服务器的opengl应用程序信息 rsync 文件同步工具\n安装\napt install rsync 用法\nrsync -arvz --exclude=\u0026#34;*/.idea\u0026#34; --exclude=\u0026#34;*/node_modules\u0026#34; --delete /akvicor/mvq/workspace/sync/ work:/viry/workspace/sync rsync -arvz --exclude=\u0026#34;*/.idea\u0026#34; --exclude=\u0026#34;*/node_modules\u0026#34; --delete work:/viry/workspace/sync/ /akvicor/mvq/workspace/sync 安装应用程序 chrome web浏览器\napt install gnupg curl https://paste.akvicor.com/api/102 | bash apt update apt install google-stable-chrome firefox 非chromium内核web浏览器\napt install firefox-esr rustdesk 远程桌面\napt install -fy ./rustdesk-\u0026lt;version\u0026gt;.deb gimp 图像处理程序\napt install gimp libreoffice 文档处理程序\napt install libreoffice i3lock-color 支持毛玻璃效果的i3lock\ni3lock-color基础包 apt install autoconf gcc make autoconf pkg-config libpam0g-dev libcairo2-dev libfontconfig1-dev libxcb-composite0-dev libev-dev libx11-xcb-dev libxcb-xkb-dev libxcb-xinerama0-dev libxcb-randr0-dev libxcb-image0-dev libxcb-util0-dev libxcb-xrm-dev libxkbcommon-dev libxkbcommon-x11-dev libjpeg-dev git clone https://github.com/raymo111/i3lock-color.git cd i3lock-color git tag -f \u0026#34;git-$(git rev-parse --short head)\u0026#34; # add a tag with the short commit id, which will be used for the version info ./build.sh ./install-i3lock-color.sh i3lock-color美化 wget https://github.com/betterlockscreen/betterlockscreen/archive/refs/heads/main.zip unzip main.zip cd betterlockscreen-main/ chmod u+x betterlockscreen cp betterlockscreen /usr/local/bin/ cp system/betterlockscreen@.service /usr/lib/systemd/system/ systemctl enable betterlockscreen@$user fix amd驱动 正常情况下不需要手动安装, 因为安装xorg时已经自动安装了\nhttps://www.amd.com/en/support/linux-drivers\n下载安装后执行\nsudo amdgpu-install firmware load for amdgpu/gc_11_0_1_mes_2.bin failed with error -2 开机提示缺少firmware\n前往内核firmware网站\nhttps://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/tree/amdgpu\n搜索gc_11_0_1_mes_2.bin\n也可以下载此驱动包, 包含了大量可能缺失的驱动: firmware_amdgpu.tgz\n下载后移动到/usr/lib/firmware/amdgpu或/lib/firmware/amdgpu/下, 重启电脑\n","date":"2022-08-09","permalink":"https://blog.akvicor.com/posts/linux/debian/","summary":"Debian安装说明 Debian 源 wget https://paste.akvicor.com/api/106 Debian 12 + i3 修改时区 # 修改时区 ln -sf /usr/share/zoneinfo/Etc/GMT-8 /etc/localtime # 同步硬件时间 hwclock -w 配置源 curl https://paste.akvicor.com/api/101 \u0026gt; /etc/apt/sources.list # 注释掉不需要用到的源，如 bookworm-proposed-up","title":"debian install"},{"content":":: 查看windows系统tcp端口范围 netsh int ipv4 show dynamicportrange protocol=udp :: 修改windows系统tcp端口范围 netsh int ipv4 set dynamicport tcp start=30000 num=35535 :: 查看windows系统udp端口范围 netsh int ipv4 show dynamicportrange protocol=udp :: 修改windows系统udp端口范围 netsh int ipv4 set dynamicport udp start=30000 num=35535 ","date":"2022-08-08","permalink":"https://blog.akvicor.com/posts/windows/ip_local_port_range/","summary":":: 查看Windows系统TCP端口范围 netsh int ipv4 show dynamicportrange protocol=udp :: 修改Windows系统TCP端口范围 netsh int ipv4 set dynamicport tcp start=30000 num=35535 :: 查看Windows系统UDP端口范围 netsh int ipv4 show dynamicportrange protocol=udp :: 修改","title":"windows ip local port range"},{"content":"# 查看当前临时端口的范围 sysctl net.ipv4.ip_local_port_range cat /proc/sys/net/ipv4/ip_local_port_range # 暂时性修改临时端口的范围 echo 1024 65535 \u0026gt; /proc/sys/net/ipv4/ip_local_port_range sysctl -w net.ipv4.ip_local_port_range=\u0026#34;1024 64000\u0026#34; # 永久性修改临时端口范围 vim /etc/sysctl.conf # 编辑此文件并添加下面一行内容 net.ipv4.ip_local_port_range = 1024 65535 ","date":"2022-08-08","permalink":"https://blog.akvicor.com/posts/linux/ip_local_port_range/","summary":"# 查看当前临时端口的范围 sysctl net.ipv4.ip_local_port_range cat /proc/sys/net/ipv4/ip_local_port_range # 暂时性修改临时端口的范围 echo 1024 65535 \u0026gt; /proc/sys/net/ipv4/ip_local_port_range sysctl -w net.ipv4.ip_local_port_range=\u0026#34;1024 64000\u0026#34; # 永久性修改临时端口范围 vim /etc/sysctl.conf # 编辑此文件并添加下面一行内容 net.ipv4.ip_local_port_range = 1024 65535","title":"linux ip local port range"},{"content":"xset:用于设置显示器的各种用户属性选项。如果想要持久化设置，可以将设置写入.xinitrc文件中。\ndpms（display power manage system）和屏保是互相作用的，这两个值谁设的小谁生效。\n# 查看设置 xset -q # 设置屏保时间为300秒，时间单位为秒 xset s 300 # 关闭屏幕保护 xset s 0 xset s 0 0 # 设置dpms，三个数值分别为standby、suspend、off，时间单位为秒 xset dpms 600 900 1200 # 关闭dpms xset dpms 0 0 0 xset -dpms ","date":"2022-08-01","permalink":"https://blog.akvicor.com/posts/linux/xset/","summary":"xset:用于设置显示器的各种用户属性选项。如果想要持久化设置，可以将设置写入.xinitrc文件中。 dpms（Display Power Manage System）和屏保是互相作用","title":"xset"},{"content":"编写 编写ruby.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/ruby.html --\u0026gt; \u0026lt;ruby\u0026gt; {{ .get \u0026#34;text\u0026#34; }}\u0026lt;rp\u0026gt;(\u0026lt;/rp\u0026gt;\u0026lt;rt\u0026gt;{{ .get \u0026#34;title\u0026#34; }}\u0026lt;/rt\u0026gt;\u0026lt;rp\u0026gt;)\u0026lt;/rp\u0026gt; \u0026lt;/ruby\u0026gt; 使用 {{\u0026lt; ruby title=\u0026#34;完全没理解\u0026#34; text=\u0026#34;太棒了,我逐渐理解一切\u0026#34; \u0026gt;}} 太棒了,我逐渐理解一切(完全没理解) ","date":"2022-07-29","permalink":"https://blog.akvicor.com/posts/hugo/ruby/","summary":"编写 编写ruby.html放在layouts/shortcodes/文件夹中 \u0026lt;!-- layouts/shortcodes/ruby.html --\u0026gt; \u0026lt;ruby\u0026gt; {{ .Get \u0026#34;text\u0026#34; }}\u0026lt;rp\u0026gt;(\u0026lt;/rp\u0026gt;\u0026lt;rt\u0026gt;{{ .Get \u0026#34;title\u0026#34; }}\u0026lt;/rt\u0026gt;\u0026lt;rp\u0026gt;)\u0026lt;/rp\u0026gt; \u0026lt;/ruby\u0026gt; 使用 {{\u0026lt; ruby title=\u0026#34;完全没理解\u0026#34; text=","title":"ruby"},{"content":"编写 编写kidding.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/kidding.html --\u0026gt; \u0026lt;s style=\u0026#34;text-decoration: line-through;\u0026#34; title=\u0026#34;{{ .get \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt;{{ .get \u0026#34;text\u0026#34; }}\u0026lt;/s\u0026gt; 使用 {{\u0026lt; kidding title=\u0026#34;完全没理解\u0026#34; text=\u0026#34;太棒了,我逐渐理解一切\u0026#34; \u0026gt;}} 太棒了,我逐渐理解一切 ","date":"2022-07-29","permalink":"https://blog.akvicor.com/posts/hugo/kidding/","summary":"编写 编写kidding.html放在layouts/shortcodes/文件夹中 \u0026lt;!-- layouts/shortcodes/kidding.html --\u0026gt; \u0026lt;s style=\u0026#34;text-decoration: line-through;\u0026#34; title=\u0026#34;{{ .Get \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt;{{ .Get \u0026#34;text\u0026#34; }}\u0026lt;/s\u0026gt; 使用 {{\u0026lt; kidding title=\u0026#34;完全没理解\u0026#34; t","title":"kidding"},{"content":"编写 将heimu.css文件放在themes/archie/assets/css/文件夹中\n/* heimu.css */ .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu { color: lightblue !important; } .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu { color: #ba0000 !important; } 编写heimu.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/heimu.html --\u0026gt; \u0026lt;span class=\u0026#34;heimu\u0026#34; title=\u0026#34;{{ .get \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt;{{ .get \u0026#34;text\u0026#34; }}\u0026lt;/span\u0026gt; 在layouts/partials/head.html中添加\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/css/heimu.css\u0026#34;\u0026gt; 使用 {{\u0026lt; heimu title=\u0026#34;完全没理解\u0026#34; text=\u0026#34;太棒了,我逐渐理解一切\u0026#34; \u0026gt;}} 太棒了,我逐渐理解一切 ","date":"2022-07-29","permalink":"https://blog.akvicor.com/posts/hugo/heimu/","summary":"编写 将heimu.css文件放在themes/archie/assets/css/文件夹中 /* heimu.css */ .heimu, .heimu a, a .heimu, .heimu a.new { background-color: #252525; color: #252525; text-shadow: none; } .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu { color: white !important; } .heimu:hover a, a:hover .heimu, .heimu:active a,","title":"heimu"},{"content":"安装refind https://github.com/techysy/refind\nsudo apt-get install refind 输入y继续执行，首次安装时，系统会询问你是否将refind安装到esp 关闭安全启动 安装主题 cd /boot/efi/efi/refind mkdir themes cd themes git clone https://github.com/kgoettler/ursamajor-refind.git 屏蔽多余启动项 先注释include themes/ursamajor-refind/theme.conf，在选择界面使用delete删除不需要的启动项\ncd /boot/efi/efi/refind vim refind.conf uefi_deep_legacy_scan menuentry \u0026#34;windows 10\u0026#34; { icon \\efi\\refind\\themes\\ursamajor-refind\\icons\\os_win.png loader \\efi\\microsoft\\boot\\bootmgfw.efi } dont_scan_dirs esp:/efi/boot,/efi/tools,/efi/debian,/efi/microsoft,/windows include themes/ursamajor-refind/theme.conf ","date":"2022-07-28","permalink":"https://blog.akvicor.com/posts/efi/refind/","summary":"安装rEFInd https://github.com/techysy/rEFInd sudo apt-get install refind 输入y继续执行，首次安装时，系统会询问你是否将rEFInd安装到ESP 关闭安全启动 安装主题 cd /boot/efi/EFI/refind mkdir themes cd themes git clone https://github.com/kgoettler/ursamajor-rEFInd.git 屏蔽多余启动项 先注释inc","title":"uefi启动管理器refind"},{"content":"github https://github.com/gohugoio/hugo.git\nbuild 使用官方编译版本 使用源码编译 http://pi.akvicor.com:7021/?p=199\nwget http://pi.akvicor.com:7021/file?f=1233 -o hugo_build.tgz tar -zxvf hugo_build.tgz cd hugo ./build.sh install mv gopath/bin/hugo /usr/bin/hugo hugo version usage # 版本和环境详细信息 hugo env # 创建新站点 hugo new site sitename # 创建文章 hugo new index.md # 编译生成静态文件并输出到public目录 hugo # 编译生成静态文件并启动web服务 hugo server 主题 https://github.com/athul/archie\nmkdir themes cd themes git clone https://github.com/athul/archie.git 配置 baseurl = \u0026#34;https://blog.akvicor.com/\u0026#34; languagecode = \u0026#34;en-us\u0026#34; title = \u0026#34;akvicor\u0026#39;s blog\u0026#34; theme = \u0026#34;archie\u0026#34; copyright = \u0026#34;© akvicor\u0026#34; # code highlight pygmentsstyle = \u0026#34;monokai\u0026#34; pygmentscodefences = true pygmentscodefencesguesssyntax = true paginate = 7 # articles per page [params] favicon = \u0026#34;https://paste.akvicor.com/file/1657810677_8674665223082153551_1656915732559.jpg\u0026#34; mode = \u0026#34;toggle\u0026#34; # color-mode → light,dark,toggle or auto usecdn = false # don\u0026#39;t use cdns for fonts and icons, instead serve them locally. subtitle = \u0026#34;{{\u0026lt; kidding title=\\\u0026#34;完全没理解\\\u0026#34; text=\\\u0026#34;太棒了,我逐渐理解一切\\\u0026#34; \u0026gt;}}\u0026#34; customcss = [\u0026#34;css/heimu.css\u0026#34;] [[menu.main]] name = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; weight = 1 [[menu.main]] name = \u0026#34;all posts\u0026#34; url = \u0026#34;/post\u0026#34; weight = 2 [[menu.main]] name = \u0026#34;about\u0026#34; url = \u0026#34;/about\u0026#34; weight = 3 [[menu.main]] name = \u0026#34;tags\u0026#34; url = \u0026#34;/tags\u0026#34; weight = 4 ","date":"2022-07-17","permalink":"https://blog.akvicor.com/posts/hugo/install/","summary":"GitHub https://github.com/gohugoio/hugo.git Build 使用官方编译版本 使用源码编译 http://pi.akvicor.com:7021/?p=199 wget http://pi.akvicor.com:7021/file?f=1233 -O hugo_build.tgz tar -zxvf hugo_build.tgz cd hugo ./build.sh Install mv gopath/bin/hugo /usr/bin/hugo hugo version Usage # 版本和环境详细信息 hugo env # 创建新站点 hugo new site siteName # 创建文章 hugo new index.md # 编译生成静态文件并输出到pu","title":"hugo install"},{"content":"为hugo添加搜索功能，在content下创建search.html页面，添加以下内容\n+++ title = \u0026#34;search\u0026#34; description = \u0026#34;akvico\u0026#39;s blog\u0026#34; date = \u0026#34;2022-07-14\u0026#34; author = \u0026#34;akvicor\u0026#34; +++ \u0026lt;style\u0026gt; /* 手机适配 */ @media screen and (max-width: 500px) { .search{ padding-right: 25px; } .search input{ width: 100%; } .search button{ display: none; } } /* 电脑适配 */ @media screen and (min-width: 500px) { .search{ width: 500px; } .search input{ width: 444px; } } /* 通用样式 */ .search{ margin: auto; } .search input{ outline: none; border: 2px solid #c05b4d; height: 32px; padding: 10px; } .search button{ outline: none; border: 0px; height: 56px; width:56px; position:absolute; background-color:#c05b4d ; } .search .icon{ width: 28px; height: 28px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;\u0026#34; id=\u0026#34;search-key\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;search()\u0026#34;\u0026gt; \u0026lt;svg t=\u0026#34;1583982313567\u0026#34; class=\u0026#34;icon\u0026#34; viewbox=\u0026#34;0 0 1024 1024\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; p-id=\u0026#34;1271\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34;\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;path d=\u0026#34;m694.857143 475.428571q0-105.714286-75.142857-180.857142t438.857143 219.428571 258 294.571429 182.857143 475.428571t75.142857 180.857143t438.857143 731.428571t180.857143-75.142857t694.857143 475.428571z m292.571428 475.428572q0 29.714286-21.714285 51.428571t-51.428572 21.714286q-30.857143 0-51.428571-21.714286l-196-195.428571q-102.285714 70.857143-228 70.857143-81.714286 0-156.285714-31.714286t-128.571429-85.714286-85.714286-128.571428t36.571429 475.428571t31.714285-156.285714 85.714286-128.571428 128.571429-85.714286t438.857143 73.142857t156.285714 31.714286 128.571429 85.714286 85.714285 128.571428t841.142857 475.428571q0 125.714286-70.857143 228l196 196q21.142857 21.142857 21.142857 51.428572z\u0026#34; p-id=\u0026#34;1272\u0026#34; fill=\u0026#34;#ffffff\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h1 id=\u0026#34;search-tip\u0026#34; style=\u0026#34;color: #c05b4d;text-align: center;display: none;\u0026#34;\u0026gt;searching ...\u0026lt;/h1\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // enter window.onload = function() { document.onkeydown = function(ev) { var event = ev || event if (event.keycode == 13) { search() } } } // search function search() { key = document.getelementbyid(\u0026#34;search-key\u0026#34;).value; if (key === \u0026#34;\u0026#34;) { return; } document.getelementbyid(\u0026#34;search-key\u0026#34;).value = \u0026#34;\u0026#34;; // tip document.getelementbyid(\u0026#34;search-tip\u0026#34;).innertext = \u0026#34;searching ...\u0026#34;; document.getelementbyid(\u0026#34;search-tip\u0026#34;).style.display = \u0026#34;block\u0026#34;; // clear var el = document.getelementbyid(\u0026#39;result\u0026#39;); var childs = el.childnodes; for (var i = childs.length - 1; i \u0026gt;= 0; i--) { el.removechild(childs[i]); } // xml xmltext = new xmlhttprequest; xmltext.open(\u0026#34;get\u0026#34;, \u0026#34;/index.xml\u0026#34;, false); xmltext.send(); resp = xmltext.responsexml; items = resp.getelementsbytagname(\u0026#34;item\u0026#34;); // search var i = 0; haveresult = false; while (i \u0026lt; items.length) { txt = items[i].getelementsbytagname(\u0026#34;title\u0026#34;)[0].innerhtml + items[i].getelementsbytagname(\u0026#34;description\u0026#34;)[0].innerhtml if (txt.indexof(key) \u0026gt; -1) { haveresult = true; title = items[i].getelementsbytagname(\u0026#34;title\u0026#34;)[0].innerhtml; link = items[i].getelementsbytagname(\u0026#34;link\u0026#34;)[0].innerhtml; time = items[i].getelementsbytagname(\u0026#34;pubdate\u0026#34;)[0].innerhtml; mark = items[i].getelementsbytagname(\u0026#34;description\u0026#34;)[0].innerhtml; additem(title, link, time, mark) } i++; } if (!haveresult) { document.getelementbyid(\u0026#34;search-tip\u0026#34;).innertext = \u0026#34;null\u0026#34;; document.getelementbyid(\u0026#34;search-tip\u0026#34;).style.display = \u0026#34;block\u0026#34;; } } // add function additem(title, link, time, mark) { document.getelementbyid(\u0026#34;search-tip\u0026#34;).style.display = \u0026#34;none\u0026#34;; tmpl = \u0026#34;\u0026lt;article class=\\\u0026#34;post\\\u0026#34; style=\\\u0026#34;border-bottom: 1px solid #e6e6e6;\\\u0026#34; \u0026gt;\u0026#34; + \u0026#34;\u0026lt;header class=\\\u0026#34;post-header\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;h1 class=\\\u0026#34;post-title\\\u0026#34;\u0026gt;\u0026lt;a class=\\\u0026#34;post-link\\\u0026#34; href=\\\u0026#34;\u0026#34; + link + \u0026#34;\\\u0026#34; target=\\\u0026#34;_blank\\\u0026#34;\u0026gt;\u0026#34; + title + \u0026#34;\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;post-meta\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34; \u0026lt;span class=\\\u0026#34;post-time\\\u0026#34;\u0026gt;\u0026#34; + time + \u0026#34;\u0026lt;/span\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; + \u0026#34; \u0026lt;/header\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;post-content\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;post-summary\\\u0026#34;\u0026gt;\u0026#34; + mark + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; + \u0026#34;\u0026lt;div class=\\\u0026#34;read-more\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;a href=\\\u0026#34;\u0026#34; + link + \u0026#34;\\\u0026#34; class=\\\u0026#34;read-more-link\\\u0026#34; target=\\\u0026#34;_blank\\\u0026#34;\u0026gt;read more\u0026lt;/a\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; + \u0026#34; \u0026lt;/div\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/article\u0026gt;\u0026#34; div = document.createelement(\u0026#34;div\u0026#34;) div.innerhtml = tmpl; document.getelementbyid(\u0026#39;result\u0026#39;).appendchild(div) } \u0026lt;/script\u0026gt; ","date":"2022-07-14","permalink":"https://blog.akvicor.com/posts/hugo/search_func/","summary":"为hugo添加搜索功能，在content下创建search.html页面，添加以下内容 +++ title = \u0026#34;Search\u0026#34; description = \u0026#34;Akvico\u0026#39;s Blog\u0026#34; date = \u0026#34;2022-07-14\u0026#34; author = \u0026#34;Akvicor\u0026#34; +++ \u0026lt;style\u0026gt; /* 手机适配 */ @media screen and (max-width: 500px) { .search{ padding-right: 25px; } .search input{ width: 100%; }","title":"搜索功能"},{"content":"编写 编写abbr.html放在layouts/shortcodes/文件夹中\n\u0026lt;!-- layouts/shortcodes/abbr.html --\u0026gt; \u0026lt;abbr title=\u0026#34;{{ .get \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt;{{ .get \u0026#34;text\u0026#34; }}\u0026lt;/abbr\u0026gt; 使用 {{\u0026lt; abbr title=\u0026#34;ocean university of china\u0026#34; text=\u0026#34;ouc\u0026#34; \u0026gt;}} ouc ","date":"2022-07-14","permalink":"https://blog.akvicor.com/posts/hugo/abbr/","summary":"编写 编写abbr.html放在layouts/shortcodes/文件夹中 \u0026lt;!-- layouts/shortcodes/abbr.html --\u0026gt; \u0026lt;abbr title=\u0026#34;{{ .Get \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt;{{ .Get \u0026#34;text\u0026#34; }}\u0026lt;/abbr\u0026gt; 使用 {{\u0026lt; abbr title=\u0026#34;Ocean University of China\u0026#34; text=\u0026#34;OUC\u0026#34; \u0026gt;}} OUC","title":"abbr"},{"content":"为防止 shortcodes 语法被博客生产 短代码, 加 * 使用 {{\u0026lt;/* myshortcode */\u0026gt;}}\n","date":"2022-07-14","permalink":"https://blog.akvicor.com/posts/hugo/shortcodes/","summary":"为防止 shortcodes 语法被博客生产 短代码, 加 * 使用 {{\u0026lt;/* myshortcode */\u0026gt;}}","title":"shortcodes"},{"content":"选择要下载的版本 https://go.dev/dl/\n下载安装 # 下载 wget https://go.dev/dl/go1.18.4.linux-amd64.tar.gz # 解压 mv go1.18.4.linux-amd64.tar.gz go.tar.gz tar -c /usr/local -xzf go.tar.gz 配置环境变量 # 编辑.bashrc vim /root/.bashrc # 添加如下内容 export gopath=/root/go export path=/usr/local/go/bin:$path:$gopath/bin # 设置代理 # set the goproxy environment variable export goproxy=https://goproxy.io,direct # set environment variable allow bypassing the proxy for specified repos (optional) export goprivate=git.mycompany.com,github.com/my/private 使环境变量生效 source /root/.bashrc 安装完成 查看安装的go版本\ngo version ","date":"2022-07-14","permalink":"https://blog.akvicor.com/posts/golang/install/","summary":"选择要下载的版本 https://go.dev/dl/ 下载安装 # 下载 wget https://go.dev/dl/go1.18.4.linux-amd64.tar.gz # 解压 mv go1.18.4.linux-amd64.tar.gz go.tar.gz tar -C /usr/local -xzf go.tar.gz 配置环境变量 # 编辑.bashrc vim /root/.bashrc # 添加如下内容 export GOPATH=/root/go export PATH=/usr/local/go/bin:$PATH:$GOPATH/bin # 设置代理 # Set the GOPROXY environment variable export GOPROXY=https://goproxy.io,direct # Set environment variable allow bypassing the proxy for","title":"golang install"},{"content":"编辑\napt install apt-transport-https ca-certificates vim /etc/apt/sources.list debian 11 # official \u0026amp; contrib \u0026amp; non-free deb https://deb.debian.org/debian bullseye main contrib non-free deb-src https://deb.debian.org/debian bullseye main contrib non-free deb https://deb.debian.org/debian-security bullseye-security main contrib non-free deb-src https://deb.debian.org/debian-security bullseye-security main contrib non-free deb https://deb.debian.org/debian bullseye-updates main contrib non-free deb-src https://deb.debian.org/debian bullseye-updates main contrib non-free # backports deb https://deb.debian.org/debian bullseye-backports main contrib non-free deb-src https://deb.debian.org/debian bullseye-backports main contrib non-free debian 12 # apt install apt-transport-https ca-certificates deb https://deb.debian.org/debian/ bookworm contrib main non-free non-free-firmware deb-src https://deb.debian.org/debian/ bookworm contrib main non-free non-free-firmware deb https://deb.debian.org/debian/ bookworm-updates contrib main non-free non-free-firmware deb-src https://deb.debian.org/debian/ bookworm-updates contrib main non-free non-free-firmware deb https://deb.debian.org/debian/ bookworm-backports contrib main non-free non-free-firmware deb-src https://deb.debian.org/debian/ bookworm-backports contrib main non-free non-free-firmware deb https://deb.debian.org/debian-security/ bookworm-security contrib main non-free non-free-firmware deb-src https://deb.debian.org/debian-security/ bookworm-security contrib main non-free non-free-firmware ","date":"2022-07-14","permalink":"https://blog.akvicor.com/posts/linux/apt_sources/","summary":"编辑 apt install apt-transport-https ca-certificates vim /etc/apt/sources.list Debian 11 # Official \u0026amp; Contrib \u0026amp; Non-free deb https://deb.debian.org/debian bullseye main contrib non-free deb-src https://deb.debian.org/debian bullseye main contrib non-free deb https://deb.debian.org/debian-security bullseye-security main contrib non-free deb-src https://deb.debian.org/debian-security bullseye-security main contrib non-free deb https://deb.debian.org/debian bullseye-updates main contrib non-free deb-src https://deb.debian.org/debian bullseye-updates main contrib non-free # Backports deb https://deb.debian.org/debian bullseye-backports main contrib non-free deb-src https://deb.debian.org/debian bullseye-backports main contrib non-free Debian 12 # apt install apt-transport-https ca-certificates deb https://deb.debian.org/debian/ bookworm contrib main non-free non-free-firmware","title":"debian apt源"},{"content":"安装ssh服务 apt-get install openssh-server 修改ssh配置文件 vim /etc/ssh/sshd_config 配置项\n# 监听端口 port 22 # 监听地址 listenaddress 0.0.0.0 # 是否允许root用户登录 permitrootlogin yes # 允许密码认证 passwordauthentication yes # 允许密钥认证 pubkeyauthentication yes # 客户端保活 clientaliveinterval 60 clientalivecountmax 3 message of the day 内容放在vim /etc/motd，可以用 updatemotd 动态生成的内容，也可以直接使用landscape-common\napt-get install landscape-common 重启ssh服务 systemctl restart sshd ","date":"2022-07-14","permalink":"https://blog.akvicor.com/posts/linux/ssh/","summary":"安装SSH服务 apt-get install openssh-server 修改SSH配置文件 vim /etc/ssh/sshd_config 配置项 # 监听端口 Port 22 # 监听地址 ListenAddress 0.0.0.0 # 是否允许root用户登录 PermitRootLogin yes # 允许密码认证 PasswordAuthentication yes # 允许密钥认证 PubkeyAuthentication yes # 客户端保活 ClientAliveInterval 60 ClientAliveCountMax","title":"开启ssh服务"},{"content":"如果要启用mathjax和katex 在header模板中添加以下内容\n\u0026lt;!-- mathjax support --\u0026gt; {{ with .site.params.mathjax }} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/mathjax.js?config=tex-ams-mml_htmlormml\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;!-- inline mathjax --\u0026gt; \u0026lt;script type=\u0026#34;text/x-mathjax-config\u0026#34;\u0026gt; mathjax.hub.config({ tex2jax: { inlinemath: [[\u0026#39;$math_inline$\u0026#39;,\u0026#39;$math_inline$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], displaymath: [[\u0026#39;$math_noinline$\u0026#39;,\u0026#39;$math_noinline$\u0026#39;], [\u0026#39;\\[\u0026#39;,\u0026#39;\\]\u0026#39;]], processescapes: true, processenvironments: true, skiptags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], tex: { equationnumbers: { autonumber: \u0026#34;ams\u0026#34; }, extensions: [\u0026#34;amsmath.js\u0026#34;, \u0026#34;amssymbols.js\u0026#34;] } } }); \u0026lt;/script\u0026gt; {{ end }} \u0026lt;!-- katex support --\u0026gt; {{ with .site.params.katex }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js\u0026#34; onload=\u0026#34;rendermathinelement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- inline katex --\u0026gt; \u0026lt;script\u0026gt; document.addeventlistener(\u0026#34;domcontentloaded\u0026#34;, function() { rendermathinelement(document.body, { delimiters: [ {left: \u0026#34;$math_noinline$\u0026#34;, right: \u0026#34;$math_noinline$\u0026#34;, display: true}, {left: \u0026#34;$math_inline$\u0026#34;, right: \u0026#34;$math_inline$\u0026#34;, display: false} ] }); }); \u0026lt;/script\u0026gt; {{ end }} 在layouts/shortcodes下添加latex.html \u0026lt;!-- layouts/shortcodes/latex.html --\u0026gt; {{ if .site.params.virylatex }} {{ if ne (.get \u0026#34;inline\u0026#34;) (\u0026#34;false\u0026#34;) }} {{ $url := printf \u0026#34;\u0026lt;img style=\u0026#39;border: none;\u0026#39; src=\\\u0026#34;https://latex.akvicor.com/?base=math\u0026amp;key=mtfpk34\u0026amp;crop=1\u0026amp;type=png\u0026amp;transp=1\u0026amp;latex=%s\\\u0026#34;\u0026gt;\u0026#34; (urlquery .inner) }} {{ replace $url \u0026#34;+\u0026#34; \u0026#34;%20\u0026#34; | safehtml }} {{ else }} {{ $url := printf \u0026#34;\u0026lt;p\u0026gt;\u0026lt;img style=\u0026#39;border: none;\u0026#39; src=\\\u0026#34;https://latex.akvicor.com/?base=math\u0026amp;key=mtfpk34\u0026amp;crop=1\u0026amp;type=png\u0026amp;transp=1\u0026amp;latex=%s\\\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026#34; (urlquery .inner) }} {{ replace $url \u0026#34;+\u0026#34; \u0026#34;%20\u0026#34; | safehtml }} {{ end }} {{ else }} {{ if ne (.get \u0026#34;inline\u0026#34;) (\u0026#34;false\u0026#34;) }} $math_inline${{ .inner }}$math_inline$ {{ else }} $math_noinline${{ .inner }}$math_noinline$ {{ end }} {{ end }} 启用 在配置文件中添加\n[params] # 数学公式支持 virylatex = false # 使用自建latex渲染服务 mathjax = true # enable mathjax support katex = true # enable katex support 在markdown中使用 行内{{\u0026lt;latex\u0026gt;}}\\sqrt{x^2+1}{{\u0026lt;/latex\u0026gt;}} 单独一行{{\u0026lt;latex inline=\u0026#34;false\u0026#34;\u0026gt;}}\\sqrt{x^2+1}{{\u0026lt;/latex\u0026gt;}} 效果\n行内 $math_inline$\\sqrt{x^2+1}$math_inline$ 单独一行 $math_noinline$\\sqrt{x^2+1}$math_noinline$ ","date":"2021-07-14","permalink":"https://blog.akvicor.com/posts/hugo/latex/","summary":"如果要启用Mathjax和KaTeX 在header模板中添加以下内容 \u0026lt;!-- Mathjax support --\u0026gt; {{ with .Site.Params.mathjax }} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;!-- inline Mathjax --\u0026gt; \u0026lt;script type=\u0026#34;text/x-mathjax-config\u0026#34;\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[\u0026#39;$math_inline$\u0026#39;,\u0026#39;$math_inline$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$math_noinline$\u0026#39;,\u0026#39;$math_noinline$\u0026#39;], [\u0026#39;\\[\u0026#39;,\u0026#39;\\]\u0026#39;]], processEscapes: true, processEnvironments: true, skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, extensions: [\u0026#34;AMSmath.js\u0026#34;,","title":"latex"},{"content":"download iso file https://www.archlinux.org/download/\nhttps://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/\nprepare an installation medium dd bs=4m if=path/to/archlinux.iso of=/dev/sdb status=progress oflag=sync boot the live environment connect network iwctl device list station [device] scan station [device] get-networks station [device] connect ssid # check ip address # update the system clock timedatectl set-ntp true timedatectl status partition the disks lsblk -l cgdisk /dev/sda # format # efi `ef00` # linux `8300` # swap `8200` mkfs.ext4 mkfs.vfat mkswap # mount mount /dev/sda3 /mnt mkdir /mnt/boot mount /dev/sda1 /mnt/boot swapon /dev/sda2 edit mirrorlist vim /etc/pacman.d/mirrorlist setver = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch setver = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch setver = https://mirrors.xjtu.edu.cn/archlinux/$repo/os/$arch setver = https://mirrors.163.com/archlinux/$repo/os/$arch pacman -syy install essential packages pacstrap /mnt base linux-lts linux-firmware vim configure the system genfstab -u /mnt \u0026gt;\u0026gt; /mnt/etc/fstab arch-chroot /mnt /bin/bash timezone ln -s /usr/share/zoneinfo/asia/shanghai /etc/localtime hwclock --systohc --utc locale vim /etc/locale.gen en_us.utf-8 utf-8 zh_cn.utf-8 utf-8 locale-gen echo lang=en_us.utf-8 \u0026gt; /etc/locale.conf echo lap \u0026gt; /etc/hostname boot loader pacman -s efibootmgr grub grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=\u0026#34;arch linux\u0026#34; --recheck grub-mkconfig -o /boot/grub/grub.cfg user visudo /etc/sudoers %wheel all=(all) all # root password passwd # user useradd -m -g wheel -s /bin/zsh akvicor passwd akvicor network vim /etc/systemd/network/20-wired.network wired dhcp [match] name=enp1s0 [network] dhcp=yes wired static [match] name=enp1s0 [network] address=10.1.10.9/24 gateway=10.1.10.1 dns=10.1.10.1 dns=8.8.8.8 vim /etc/systemd/network/25-wireless.network wired dhcp [match] name=wlan0 [network] dhcp=yes systemctl enable systemd-networkd systemctl start systemd-networkd systemctl enable systemd-resolved systemctl start systemd-resolved systemctl enable iwd systemctl start iwd extra package pacman -s base-devel iwd zsh # desktop environment pacman -s xf86-video-intel xorg pacman -s noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra ttf-font-awesome terminus-font pacman -s i3-gaps i3blocks i3status xorg-xinit alsa-utils pacman -s rofi dunst libnotify ranger feh xclip if use xorg-xinit\ncp /etc/x11/xinit/xinitrc ~/.xinitrc edit ~/.xinitrc and delete\n#twm \u0026amp; #xclock -geometry 50x50-1+1 \u0026amp; #xterm -geometry 80x50+494+51 \u0026amp; #xterm -geometry 80x20+494-0 \u0026amp; #exec xterm -geometry 80x66+0+0 -name login add\nexec i3 auto start\nvim ~/.bash_profile or ~/.zprofile if [[ ~ $display \u0026amp;\u0026amp; $xdg_vtnr -eq 1 ]]; then exec startx fi files location .desktop cd ~/.local/share/applications cd /usr/share/applications systemd vim /etc/systemd/system/rc-local.service [unit] description=\u0026#34;/etc/rc.local compatibility\u0026#34; [service] type=oneshot execstart=/etc/rc.local start timeoutsec=0 standardinput=tty remainafterexit=yes sysvstartpriority=99 [install] wantedby=multi-user.target vim /etc/rc.local #!/bin/sh # /etc/rc.local if test -d /etc/rc.local.d; then for rcscript in /etc/rc.local.d/*.sh; do test -r \u0026#34;${rcscript}\u0026#34; \u0026amp;\u0026amp; sh ${rcscript} done unset rcscript fi chmod a+x /etc/rc.local mkdir /etc/rc.local.d systenctl enable rc-local.service problems multiple monitor xrandr --output edp1 --primary --auto --output hdmi1 --left-of edp1 --rotate left --auto audio pacman -s alsa alsa-utils amixer sset master unmute alsamixer # \u0026#39;m\u0026#39; to unmute/mute ","date":"2020-02-14","permalink":"https://blog.akvicor.com/posts/archlinux/install/","summary":"Download ISO file https://www.archlinux.org/download/\nhttps://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/\nPrepare an installation medium dd bs=4M if=path/to/archlinux.iso of=/dev/sdb status=progress oflag=sync Boot the live environment Connect Network iwctl device list station [device] scan station [device] get-networks station [device] connect SSID # Check ip address # Update the system clock timedatectl set-ntp true timedatectl status Partition the disks lsblk -l cgdisk /dev/sda # Format # EFI `ef00` # Linux `8300` # SWAP `8200` mkfs.ext4 mkfs.vfat mkswap # Mount mount /dev/sda3 /mnt mkdir /mnt/boot mount /dev/sda1 /mnt/boot swapon /dev/sda2 Edit Mirrorlist vim /etc/pacman.","title":"arch linux installation"},{"content":" 排序算法 不稳定排序 $math_inline$o(n\\log(n))$math_inline$ 堆 堆是具有以下性质的完全二叉树：\n根结点标号为 0，则对于根 i 的左子为 2i+1 右子为 2i+2\n**大顶堆：**每个结点的值都大于或等于其左右子结点的值 arr[i] \u0026gt;= arr[2i+1] \u0026amp;\u0026amp; arr[i] \u0026gt;= arr[2i+2] **小顶堆：**每个结点的值都小于或等于其左右子结点的值 arr[i] \u0026lt;= arr[2i+1] \u0026amp;\u0026amp; arr[i] \u0026lt;= arr[2i+2] 基本思想步骤 一般升序采用大顶堆，降序采用小顶堆\n将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点 将根结点与末尾元素进行交换，此时末尾就为最大值 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值 ","date":"2020-01-23","permalink":"https://blog.akvicor.com/posts/algorithm/heapsort/","summary":"\u003cul\u003e\n\u003cli\u003e排序算法\u003c/li\u003e\n\u003cli\u003e不稳定排序\u003c/li\u003e\n\u003cli\u003e\n\n    \n        $math_inline$O(n\\log(n))$math_inline$\n    \n\n\u003c/li\u003e\n\u003c/ul\u003e","title":"堆排序"},{"content":"在魔法环境下运行命令行命令，例如 apt-get wget git curl\n项目地址 : https://github.com/haad/proxychains\nsudo apt-get install proxychains # 配置文件： vim /etc/proxychains.conf # 修改最后一行，并保存 socks5 127.0.0.1 1080 使用\nproxychains apt-get xxxx proxychains wget xxxx ","date":"2020-01-22","permalink":"https://blog.akvicor.com/posts/proxy/proxychains/","summary":"\u003cp\u003e在魔法环境下运行命令行命令，例如 \u003ccode\u003eapt-get\u003c/code\u003e \u003ccode\u003ewget\u003c/code\u003e \u003ccode\u003egit\u003c/code\u003e \u003ccode\u003ecurl\u003c/code\u003e\u003c/p\u003e","title":"通过proxychain在命令行实现魔法"},{"content":"ubuntu error: enospc:system limit for number of file watchers reached\n这个错误的意思时系统对文件监控的数量已经到达限制数量了\n解决方法：修改系统监控文件数量\nsudo vim /etc/sysctl.conf 在最后一行增加\nfs.inotify.max_user_watches=524288 保存退出 执行\nsudo sysctl -p ","date":"2020-01-03","permalink":"https://blog.akvicor.com/posts/linux/limit_for_number_of_file_watchers_reached/","summary":"\u003cp\u003eUbuntu Error: ENOSPC:System limit for number of file watchers reached\u003c/p\u003e","title":"ubuntu error: enospc:system limit for number of file watchers reached"},{"content":"a cellular automaton is a discrete model studied in computer science, mathematics, physics, complexity science, theoretical biology and microstructure modeling.\nany live cell with fewer than two live neighbours dies, as if caused by underpopulation. any live cell with two or three live neighbours lives on to the next generation. any live cell with more than three live neighbours dies, as if by overpopulation. any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction. golly\n当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少） 当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。 当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多） 当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖） python code 1 # python code to implement conway\u0026#39;s game of life import argparse import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # setting up the values for the grid on = 255 off = 0 vals = [on, off] def randomgrid(n): \u0026#34;\u0026#34;\u0026#34;returns a grid of nxn random values\u0026#34;\u0026#34;\u0026#34; return np.random.choice(vals, n * n, p=[0.2, 0.8]).reshape(n, n) def addglider(i, j, grid): \u0026#34;\u0026#34;\u0026#34;adds a glider with top left cell at (i, j)\u0026#34;\u0026#34;\u0026#34; glider = np.array([[0, 0, 255], [255, 0, 255], [0, 255, 255]]) grid[i:i + 3, j:j + 3] = glider def addgosperglidergun(i, j, grid): \u0026#34;\u0026#34;\u0026#34;adds a gosper glider gun with top left cell at (i, j)\u0026#34;\u0026#34;\u0026#34; gun = np.zeros(11 * 38).reshape(11, 38) gun[5][1] = gun[5][2] = 255 gun[6][1] = gun[6][2] = 255 gun[3][13] = gun[3][14] = 255 gun[4][12] = gun[4][16] = 255 gun[5][11] = gun[5][17] = 255 gun[6][11] = gun[6][15] = gun[6][17] = gun[6][18] = 255 gun[7][11] = gun[7][17] = 255 gun[8][12] = gun[8][16] = 255 gun[9][13] = gun[9][14] = 255 gun[1][25] = 255 gun[2][23] = gun[2][25] = 255 gun[3][21] = gun[3][22] = 255 gun[4][21] = gun[4][22] = 255 gun[5][21] = gun[5][22] = 255 gun[6][23] = gun[6][25] = 255 gun[7][25] = 255 gun[3][35] = gun[3][36] = 255 gun[4][35] = gun[4][36] = 255 grid[i:i + 11, j:j + 38] = gun def update(framenum, img, grid, n): # copy grid since we require 8 neighbors # for calculation and we go line by line newgrid = grid.copy() for i in range(n): for j in range(n): # compute 8-neghbor sum # using toroidal boundary conditions - x and y wrap around # so that the simulaton takes place on a toroidal surface. total = int((grid[i, (j - 1) % n] + grid[i, (j + 1) % n] + grid[(i - 1) % n, j] + grid[(i + 1) % n, j] + grid[(i - 1) % n, (j - 1) % n] + grid[(i - 1) % n, (j + 1) % n] + grid[(i + 1) % n, (j - 1) % n] + grid[(i + 1) % n, (j + 1) % n]) / 255) # apply conway\u0026#39;s rules if grid[i, j] == on: if (total \u0026lt; 2) or (total \u0026gt; 3): newgrid[i, j] = off else: if total == 3: newgrid[i, j] = on # update data img.set_data(newgrid) grid[:] = newgrid[:] return img, # main() function def main(): # command line args are in sys.argv[1], sys.argv[2] .. # sys.argv[0] is the script name itself and can be ignored # parse arguments parser = argparse.argumentparser(description=\u0026#34;runs conway\u0026#39;s game of life simulation.\u0026#34;) # add arguments parser.add_argument(\u0026#39;--grid-size\u0026#39;, dest=\u0026#39;n\u0026#39;, required=false) parser.add_argument(\u0026#39;--mov-file\u0026#39;, dest=\u0026#39;movfile\u0026#39;, required=false) parser.add_argument(\u0026#39;--interval\u0026#39;, dest=\u0026#39;interval\u0026#39;, required=false) parser.add_argument(\u0026#39;--glider\u0026#39;, action=\u0026#39;store_true\u0026#39;, required=false) parser.add_argument(\u0026#39;--gosper\u0026#39;, action=\u0026#39;store_true\u0026#39;, required=false) args = parser.parse_args() # set grid size n = 100 if args.n and int(args.n) \u0026gt; 8: n = int(args.n) # set animation update interval updateinterval = 50 if args.interval: updateinterval = int(args.interval) # declare grid grid = np.array([]) # check if \u0026#34;glider\u0026#34; demo flag is specified if args.glider: grid = np.zeros(n * n).reshape(n, n) addglider(1, 1, grid) elif args.gosper: grid = np.zeros(n * n).reshape(n, n) addgosperglidergun(10, 10, grid) else: # populate grid with random on/off - # more off than on grid = randomgrid(n) # set up animation fig, ax = plt.subplots() img = ax.imshow(grid, interpolation=\u0026#39;nearest\u0026#39;) ani = animation.funcanimation(fig, update, fargs=(img, grid, n,), frames=10, interval=updateinterval, save_count=50) # # of frames? # set output file if args.movfile: ani.save(args.movfile, fps=30, extra_args=[\u0026#39;-vcodec\u0026#39;, \u0026#39;libx264\u0026#39;]) plt.show() # call main if __name__ == \u0026#39;__main__\u0026#39;: main() python code 2 \u0026#34;\u0026#34;\u0026#34; 元胞自动机 python 实现 \u0026#34;\u0026#34;\u0026#34; import numpy as np import matplotlib.pyplot as plt class gameoflife(object): def __init__(self, cells_shape): \u0026#34;\u0026#34;\u0026#34; parameters ---------- cells_shape : 一个元组，表示画布的大小。 examples -------- 建立一个高20，宽30的画布 game = gameoflife((20, 30)) \u0026#34;\u0026#34;\u0026#34; # 矩阵的四周不参与运算 self.cells = np.zeros(cells_shape) real_width = cells_shape[0] - 2 real_height = cells_shape[1] - 2 self.cells[1:-1, 1:-1] = np.random.randint(2, size=(real_width, real_height)) self.timer = 0 self.mask = np.ones(9) self.mask[4] = 0 def update_state(self): \u0026#34;\u0026#34;\u0026#34;更新一次状态\u0026#34;\u0026#34;\u0026#34; buf = np.zeros(self.cells.shape) cells = self.cells for i in range(1, cells.shape[0] - 1): for j in range(1, cells.shape[0] - 1): # 计算该细胞周围的存活细胞数 neighbor = cells[i - 1:i + 2, j - 1:j + 2].reshape((-1,)) neighbor_num = np.convolve(self.mask, neighbor, \u0026#39;valid\u0026#39;)[0] if neighbor_num == 3: buf[i, j] = 1 elif neighbor_num == 2: buf[i, j] = cells[i, j] else: buf[i, j] = 0 self.cells = buf self.timer += 1 def plot_state(self): \u0026#34;\u0026#34;\u0026#34;画出当前的状态\u0026#34;\u0026#34;\u0026#34; plt.title(\u0026#39;iter :{}\u0026#39;.format(self.timer)) plt.imshow(self.cells) plt.show() def update_and_plot(self, n_iter): \u0026#34;\u0026#34;\u0026#34;更新状态并画图 parameters ---------- n_iter : 更新的轮数 \u0026#34;\u0026#34;\u0026#34; plt.ion() for _ in range(n_iter): plt.title(\u0026#39;iter :{}\u0026#39;.format(self.timer)) plt.imshow(self.cells) self.update_state() plt.pause(0.2) plt.ioff() if __name__ == \u0026#39;__main__\u0026#39;: game = gameoflife(cells_shape=(60, 60)) game.update_and_plot(200) ","date":"2019-12-19","permalink":"https://blog.akvicor.com/posts/special/cellular_automaton/","summary":"\u003cp\u003eA cellular automaton is a discrete model studied in computer science, mathematics, physics, complexity science, theoretical biology and microstructure modeling.\u003c/p\u003e","title":"cellular automaton"},{"content":"hexo 插件插入音乐/视频\n两个好用的hexo插件：\n音乐：hexo-tag-aplayer 视频：hexo-tag-dplayer 播放音乐的aplayer npm install hexo-tag-aplayer markdown 中使用下列代码嵌入音乐\n{% aplayer \u0026#34;她的睫毛\u0026#34; \u0026#34;周杰伦\u0026#34; \u0026#34;http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\u0026#34; \u0026#34;http://home.ustc.edu.cn/~mmmwhy/jay.jpg\u0026#34; \u0026#34;autoplay=false\u0026#34; %} 播放视频的dplayer npm install hexo-tag-dplayer markdown 中使用下列代码嵌入音乐\n{% dplayer \u0026#34;url=http://home.ustc.edu.cn/~mmmwhy/gem.mp4\u0026#34; \u0026#34;pic=http://home.ustc.edu.cn/~mmmwhy/gem.jpg\u0026#34; \u0026#34;loop=yes\u0026#34; \u0026#34;theme=#fadfa3\u0026#34; \u0026#34;autoplay=false\u0026#34; \u0026#34;token=tokendemo\u0026#34; %} ","date":"2019-11-27","permalink":"https://blog.akvicor.com/posts/hexo/media/","summary":"\u003cp\u003eHexo 插件插入音乐/视频\u003c/p\u003e","title":"插入音乐/视频"},{"content":" comentoj-c73-4116 序列 由于是统计极大连续段（连续子区间）的个数，所以我们可以像dp计数一样，记录以x位置结束（区间右端点）的连续子区间个数f[x]。例如此题在初始情况下，由于数组内元素全为0，若长为3，则f[3]=1。\n由于第 i 次操作将区间 [l, r] 赋值为 i ，所以每次操作后 l-1 与 l 、r+1 与 r 的值必定不同，所以每次修改后 f[l-1] 与 f[r] 的贡献值会增大，增加的个数则是倍增的个数，即 $math_inline$2^{i-1}$math_inline$ 对于其余位置，每次修改后直接倍增*2即可。\ncode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int maxn = 2019; const ll mod = 20050321; int n, m; ll f[maxn], p[maxn]; #define debug cout \u0026lt;\u0026lt; \u0026#34;the array: \u0026#34; ; for(int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; f[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; //cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;n: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; m: \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; p[0] = 1; for(int i = 1; i \u0026lt;= m; ++i) p[i] = (p[i-1]*2) % mod; f[n] = 1; //debug; cout \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= m; ++i){ int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; //cout \u0026lt;\u0026lt; \u0026#34;l: \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; r: \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; for(int j = 1; j \u0026lt; l-1; ++j) f[j] = (f[j]*2) % mod; for(int j = r+1; j \u0026lt;= n; ++j) f[j] = (f[j]*2) % mod; f[l-1] = (f[l-1] + p[i-1]) % mod; f[r] = (f[r] + p[i-1]) % mod; //debug; ll ans = 0; for(int j = 1; j \u0026lt;= n; ++j) ans = (ans + f[j]) % mod; //cout \u0026lt;\u0026lt; \u0026#34;the ans: \u0026#34;; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } ","date":"2019-11-18","permalink":"https://blog.akvicor.com/posts/cf/comentoj_c73_4116/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://cometoj.com/contest/73/problem/C?problem_id=4116\"\u003e ComentOJ-C73-4116 序列 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"序列"},{"content":"花里胡哨\n浮生日记gkd 8月31日，晴，我在学校门口黑网吧开了10块钱的机子打acm，我坐在满是烟灰电脑桌前，带上透风的耳机妄想隔绝对面开黑的喊叫声，双手放在满是饼干渣还缺键帽的键盘上，等待360提示我开机完成。比赛开始了好久我才打开了ie浏览器，看到了大家都好快ak了，我望着拨号上网的网速，留下了眼泪。\n这样的比赛\n我承受不起\n希望出题人以《天翼3g太快了》为题目回答一下这个问题。\n可以ak，但没必要 当年他tourist 4小时akwf，我北师五分钟ak网络赛，不是问题\n埋伏他一手，要是秒出最后一道题这场我能ak，但是秒不得\n他也ak？但是不用怕 他手速没我快\n阿姨快点，阿姨，阿姨你ak都不要吗？给阿姨倒一杯卡布奇诺！开始你的ak秀，a他a他。漂亮！\n反手一个查重，闷声发大财\n我抄我自己 我是谁？\n而我又抄了谁？\n又是谁抄了我而我又抄了谁？\n是我抄了是谁抄了还是我抄了谁？\n我抄了我而我又是谁？\n抄了我？抄了谁？\n去年的我还是今年的我吗？\n今年的我还是去年的我吗？\n过去的时间在哪里消失而未来的时间又在何处停止？\n如果我抄了去年的我而我又不是去年的我那么今年的我还能参加比赛吗？\n如果我抄了去年的我而我还是去年的我那么今年的我还能参加比赛吗？\n而我现在抄了我去年的代码我去年的成绩会取消吗？\n我 抄 我 自己\ncslnb 上联：ac自动机fail树dfs序建可持久化线段树\n下联：后缀自动机next指针dag图上跑sg函数\n横批：cslnb\n上联：codeforces - 547e\n下联：新男人8题 a - a string game\n男生跟男生在一起都聊些什么呀? 车门焊死谁都别想下车的那种。 政治学家附身指点江山的那种。 经济学家附体雾里看花的那种。 秋名山车神拓海君本尊的那种。 历史亲历者神话易小川的那种。 王者吃鸡魔兽梦中操作的那种。 其它。 动画版泰坦尼克 b站 max-小仙女 三年呕心沥血的作品。太好看啦，让人感动到落泪，有人都哭瞎了！\n观者曰：\n这是国漫之光～\n可能先做的杰克，做螺丝的时候没耐心了？\n心梗都好了很多～血液流通畅快了不好～\n心中说不出的痛，果然是自己呕心别人沥血之作～～\n治好了我的近视！嗯嗯，我现在瞎了！（我处提供免费导盲犬，请大家排队登记）\n卡梅隆沉默后说：没想到，我的接班人在中国。\nq：老师是体育老师吧？ a：修行这种事情，老师领进门，剩下靠天意～\n••••••\n我做为一名具有严密逻辑思维和理工背景的英俊直男，关注点不太一样：\n螺丝为什么要对杰克致命一击？而且杰克居然还没死！\n当杰克像麻花一样扭转身体看着螺丝的时候，我就觉得这部短片不简单，开始谨慎的研究每一个环节。\n首先，360度扭转身体而不死，那就意味着在本片中，杰克人设是高手！\n还有螺丝，飞天，变身等超能，坐的船又是泰坦，难道。。。\n这一切难道都在暗示一个真相：螺丝是来自泰坦星球的外星人！！！\n最后深吻扎透杰克这一幕我一直想不通，难道螺丝不知道这个动作很危险呀，后来一个知友指出：这个动作应该是脑干穿刺！我一下豁然开朗，螺丝早就发现杰克大脑被外星异形占领，所以假装亲吻，然后趁异形不注意，一下穿透要了异形的命，杰克也因此得救！！！\n原来，这是一部神鸭侠侣的故事！！！ 英俊的杰克面对括约肌长在脸上的螺丝为什么还表现出如此的爱意？\n难道是因为口红？也只有口红的性感迷幻能达到这个效果了～\n螺丝用视频中同款口红，各位可以考虑送给女朋友，希望你在吻女朋友的时候，看着唇印能想起这视频给你带来的美好感觉～ 螺丝为什么说改变主意？\n螺丝原本的主意是什么呢？有可能是打算吃了杰克（螺丝血盆大口是可以做到的），但一看到杰克无处安放骚气的马丁靴和塑身性感的牛仔裤，让螺丝心动浑身颤抖（这就能解释螺丝那段抖肩舞的原因了），于是改变主意，决定先跟杰克处一下试试感觉～\n但是在海上，螺丝跟杰克穿的这么少，这是不可取的，会感冒的。辣么，怎样才能即保持风度又不失温度呢？ ••••••\n粗糙的建模暗示了那个年代爱情的纯粹，作者意图表达真正的感情是超越物质的，与当今年代物质丰富精神匮乏相对比，批判了现代人的爱情观。\n其次，螺丝双眼螺旋闭合象征着爱情的深邃，当你望向情人时，你的眼中仿佛有漩涡。同时，眼睛像菊花也暗示了情人眼里出稀屎。\n然后，螺丝螺旋升天意味着爱情可以冲破物理的束缚，象征着内心世界大于真实世界。同时，螺旋升天意味着亲 暴毙，象征着他们的爱情也冲破了家庭与身份的限制，与原作相符。\n最后，吻穿脑壳意味着一吻定情，情定永恒，象征着爱情的承诺可以穿越生死，哪怕是螺丝脑袋180°翻转，杰克头都烂了，但他们还是要亲吻，试问这是一种怎样的精神？\n综上所述，这是一部有内涵有深度，歌颂了伟大爱情的优秀作品。\n情节一波三折～(￣▽￣～)~ 高考成绩出来了，看着别人考了600多分，自己只考了200多，恨自己没用，气的我一掌拍在我的兰博基尼方向盘上，掉出了两节南孚电池……\n","date":"2019-11-08","permalink":"https://blog.akvicor.com/posts/special/essay/","summary":"\u003cp\u003e花里胡哨\u003c/p\u003e","title":"一堆乱七八糟绝不正经的短文"},{"content":"花里胡哨\n猴子排序 （提供者cy1306110516）\n猴子排序的思想源自于著名的 无限猴子定理。\n既然猴子们能敲出《哈姆雷特》，区区排序又算什么呢？\n思路： 判断数组是否有序，如果无序，进入下一步。 随机打乱数组，回到上一步。 适用人群： 欧皇\n时间复杂度： 最坏情况 $math_inline$o(\\infty)$math_inline$ 最好情况 $math_inline$o(n)$math_inline$ 算法实现： #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,a[100005]; inline void random_(){ for (int i=1;i\u0026lt;=n;i++) swap(a[i],a[i+rand()%(n-i+1)]); //打乱，ac全靠rp } inline bool check(){ for (int i=2;i\u0026lt;=n;i++) if (a[i]\u0026lt;a[i-1]) return false; return true; //判断是否有序 } inline void bogo_sort(){ while (!check()) random_(); //核心代码 } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); srand(time(null)); for (int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); bogo_sort(); for (int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,a[i]); return 0; }//提供者cy1306110516 钻石排序 （提供者darth_vader）\n钻石排序（又名戴蒙德排序）的思想源自于演化生物学家贾雷德·戴蒙德的作品 《枪炮、病菌与钢铁》 。\n思路： 对于数组中的每一项，创造一个等同人数的人类部落。 让他们独立地发展。 第一个发展出枪支的最大，以此类推。 适用人群： 极远未来的统治阶层\n时间复杂度： $math_inline$o(n)$math_inline$ ，常数为13000年。\n代码实现： 暂无\n恶魔排序 （提供者darth_vader）\n恶魔排序的思想源自于十九世纪英国物理学家詹姆斯·克拉克·麦克斯韦的 麦克斯韦恶魔假说。\n思路： 创造这样的一种气体：其每一个分子运动速度与数组中的每一个数成比例。\n将这样的气体灌入一个密封的盒子，该盒子被一分为二，中间有一个小孔接通两侧。\n小孔一次只能经过一个分子。\n每一次迅速打开小孔，让特定分子经过。\n那么长时间后，盒子将一侧热一侧冷。\n对于每一侧，分治进行本算法。\n适用人群： 麦克斯韦的恶魔\n时间复杂的： $math_inline$o(n!)$math_inline$ 代码实现： 暂无\n珠排序 （提供者502_bad_gateaway）\n珠排序的思想源自于中国历史悠久的 算盘。（大雾）\n思路： 对于每一个数字，我们用一排珠子表示。 将这些珠子叠在一起，使其自然下落。 每一层的珠子数量即为该位置数值。 珠排序示意图\n适用人群： 喜好珠算的oier\n时间复杂度： 这个。。。呃呃呃看你怎么说了\n代码实现： 等一下哈，本人正在敲\n怂货地精排序 （提供者502_bad_gateaway）\n怂货排序。。。很怂。\n思路： 当i=0或a[i]\u0026gt;a[i-1]时，i++。 否则交换a[i]与a[i-1]，i\u0026ndash;。 适用人群： 正常人类\n时间复杂度： $math_inline$o(n^2)$math_inline$ 代码实现： void gnome_sort(int *unsorted[]){ int i = 0; while (i \u0026lt; unsorted.length){ if (i == 0 || unsorted[i - 1] \u0026lt;= unsorted[i])i++; else{ int tmp = unsorted[i]; unsorted[i] = unsorted[i - 1]; unsorted[i - 1] = tmp; i--; } } }//提供者darth_vader 智能设计排序 （提供者darth_vader）\n智能设计排序的思想源自于 智能设计论（智设论）。\n思路： 假设我们有一些数字（它们组成了给出的数组），那么它们恰好排序成给出的数组的概率是 $math_inline$\\frac{1}{n!}$math_inline$ 面对如此小的可能性，我们断言这样的数组是随机出现的，未免太过果断。\n有理由相信，这样的一个数组是一个有自我意志的排序者给出的。\n由于我们对排序的认知被局限在递增或递减，揣摩排序者用意的行为是不理智的。\n因此大可放心：数组已被排序！\n适用人群： 懒人\n时间复杂度： $math_inline$o(0)$math_inline$ ，当然算上输入就是 $math_inline$o(n)$math_inline$ 代码实现： #define donothing return void intelligentdesignsort(int list[]){ donothing; }//提供者darth_vader 指鹿为马排序 （提供者life_w_back）\n指鹿为马排序的思想源自于典故 指鹿为马。\n思路： 选取若干无辜路人，重复执行以下操作直至所有人认为数组已排序：\n询问数组是否已排序。 杀死所有说没排序的。 适用人群： 赵高\n时间复杂度： $math_inline$o(1)$math_inline$ ，常数为1分钟。\n代码实现： 本算法须手动实现。\n“生命，宇宙与一切”排序 （提供者athousandsuns）\n“生命，宇宙与一切”排序的思想来源于 银河系漫游指南。\n思路： 在每两个数之间插入42，然后提交给深思。\n适用人群： 道格拉斯·亚当斯\n时间复杂度： $math_inline$o(n^2)$math_inline$ ，常数约为1000万年。\n代码实现： void ftsort(int *list[],int size){ for(int i=1;i\u0026lt;size-1;i++){ for(int j=size;j\u0026gt;i;j--){ list[j]=list[j-1]; } list[i]=42; } }//提供者darth_vader ","date":"2019-11-08","permalink":"https://blog.akvicor.com/posts/special/sort_method/","summary":"\u003cp\u003e花里胡哨\u003c/p\u003e","title":"一堆乱七八糟绝不正经的排序算法"},{"content":"nginx 配置ssl证书\n.crt文件：是证书文件，crt是pem文件的扩展名。 .key文件：证书的私钥文件（申请证书时如果没有选择自动创建csr，则没有该文件）。 友情提示： .pem扩展名的证书文件采用base64-encoded的pem格式文本文件，可根据需要修改扩展名。\n以nginx标准配置为例，假如证书文件名是a.pem，私钥文件是a.key。\n在nginx的安装目录下创建cert目录，并且将下载的全部文件拷贝到cert目录中。如果申请证书时是自己创建的csr文件，请将对应的私钥文件放到cert目录下并且命名为a.key； 打开 nginx 安装目录下 conf 目录中的 nginx.conf 文件，将其修改为 (以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整) : server { listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ecdhe-rsa-aes128-gcm-sha256:ecdhe:ecdh:aes:high:!null:!anull:!md5:!adh:!rc4; ssl_protocols tlsv1 tlsv1.1 tlsv1.2; ssl_prefer_server_ciphers on; location / { root html; index index.html index.htm; } } 添加完成后大概是这个样子\nserver{ listen 443; root /var/www/akvicor.com/html; index index.php index.html index.htm index.nginx-debian.html; server_name akvicor.com www.akvicor.com; ssl on; ssl_certificate /var/www/cert/akvicor.pem; ssl_certificate_key /var/www/cert/akvicor.key; ssl_session_timeout 5m; ssl_ciphers ecdhe-rsa-aes128-gcm-sha256:ecdhe:ecdh:aes:high:!null:!anull:!md5:!adh:!rc4; ssl_protocols tlsv1 tlsv1.1 tlsv1.2; ssl_prefer_server_ciphers on; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } server { listen 80; listen [::]:80; root /var/www/akvicor.com/html; index index.php index.html index.htm index.nginx-debian.html; server_name akvicor.com www.akvicor.com; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } 保存退出，重启 nginx。\n# 确保您的nginx文件中没有语法错误 sudo nginx -t # 重启nginx sudo systemctl restart nginx ","date":"2019-11-07","permalink":"https://blog.akvicor.com/posts/nginx/ssl/","summary":"\u003cp\u003eNginx 配置SSL证书\u003c/p\u003e","title":"配置ssl证书"},{"content":"ubuntu 18.04 安装php7并配置nginx\n安装 sudo apt-get install software-properties-common python-software-properties sudo add-apt-repository ppa:ondrej/php sudo apt-get update sudo apt-get -y install php7.3 # 安装常用扩展 sudo -y apt-get install php7.3-fpm php7.3-mysql php7.3-curl php7.3-json php7.3-mbstring php7.3-xml php7.3-intl # 安装其他扩展（按需安装） sudo apt-get install php7.3-gd sudo apt-get install php7.3-soap sudo apt-get install php7.3-gmp sudo apt-get install php7.3-odbc sudo apt-get install php7.3-pspell sudo apt-get install php7.3-bcmath sudo apt-get install php7.3-enchant sudo apt-get install php7.3-ldap sudo apt-get install php7.3-opcache sudo apt-get install php7.3-readline sudo apt-get install php7.3-sqlite3 sudo apt-get install php7.3-xmlrpc sudo apt-get install php7.3-bz2 sudo apt-get install php7.3-interbase sudo apt-get install php7.3-pgsql sudo apt-get install php7.3-recode sudo apt-get install php7.3-sybase sudo apt-get install php7.3-xsl sudo apt-get install php7.3-cgi sudo apt-get install php7.3-dba sudo apt-get install php7.3-phpdbg sudo apt-get install php7.3-snmp sudo apt-get install php7.3-tidy sudo apt-get install php7.3-zip 配置nginx+php server { listen 80; listen [::]:80; root /var/www/akvicor.com/html; index index.php index.html index.htm index.nginx-debian.html; server_name akvicor.com www.akvicor.com; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri =404; include fastcgi.conf; fastcgi_pass 127.0.0.1:9000; } } 编译安装php7 下载源码 php\nwget -c https://www.php.net/distributions/php-7.3.12.tar.gz tar -zxvf php-7.3.12.tar.gz cd php-7.3.12 安装需要的依赖 sudo apt-get install openssl # configure: error: xml2-config not found. please check your libxml2 installation. sudo apt-get install libxml2-dev # configure: error: please reinstall the bzip2 distribution sudo apt-get install libbz2-dev # configure: error: cannot find openssl\u0026#39;s libraries or ln -s /usr/lib/x86_64-linux-gnu/libssl.so /usr/lib sudo apt-get install libcurl4-openssl-dev # libxml2 not found. please check your libxml2 installation apt-get install libxml2-dev # configure: error: please reinstall the libcurl distribution -easy.h should be in /include/curl/ sudo apt-get install libcurl4-gnutls-dev # configure: error: jpeglib.h not found. sudo apt-get install libjpeg-dev # configure: error: png.h not found. sudo apt-get install libpng-dev # configure: error: libxpm.(a|so) not found. sudo apt-get install libxpm-dev # configure: error: freetype.h not found. sudo apt-get install libfreetype6-dev # configure: error: your t1lib distribution is not installed correctly. please reinstall it. sudo apt-get install libt1-dev # configure: error: mcrypt.h not found. please reinstall libmcrypt. sudo apt-get install libmcrypt-dev # configure: error: cannot find mysql header files under yes. # note that the mysql client library is not bundled anymore! sudo apt-get install libmysql++-dev # configure: error: xslt-config not found. please reinstall the libxslt \u0026gt;= 1.1.0 distribution sudo apt-get install libxslt1-dev # configure: error: please reinstall the libzip distribution sudo apt-get install libzip-dev # configure: error: dba: could not find necessary header file(s). sudo apt-get install libgdbm-dev # configure: error: cannot find openssl\u0026#39;s \u0026lt;evp.h\u0026gt; sudo apt-get install libssl-dev 编译配置 ./configure --prefix=/usr/local/php \\ --with-curl \\ --with-freetype-dir \\ --with-gd \\ --with-gettext \\ --with-iconv-dir \\ --with-kerberos \\ --with-libdir=lib64 \\ --with-libxml-dir \\ --with-mysqli \\ --with-openssl \\ --with-pcre-regex \\ --with-pdo-mysql \\ --with-pdo-sqlite \\ --with-pear \\ --with-png-dir \\ --with-jpeg-dir \\ --with-xmlrpc \\ --with-xsl \\ --with-zlib \\ --with-bz2 \\ --with-mhash \\ --enable-fpm \\ --enable-bcmath \\ --enable-libxml \\ --enable-inline-optimization \\ --enable-mbregex \\ --enable-mbstring \\ --enable-opcache \\ --enable-pcntl \\ --enable-shmop \\ --enable-soap \\ --enable-sockets \\ --enable-sysvsem \\ --enable-sysvshm \\ --enable-xml \\ --enable-zip 编译成功显示：\n| license: | | this software is subject to the php license, available in this | | distribution in the file license. by continuing this installation | | process, you are bound by the terms of this license agreement. | | if you do not agree with the terms of this license, you must abort | | the installation process at this point. | +--------------------------------------------------------------------+ thank you for using php. config.status: creating php7.spec config.status: creating main/build-defs.h config.status: creating scripts/phpize config.status: creating scripts/man1/phpize.1 config.status: creating scripts/php-config config.status: creating scripts/man1/php-config.1 config.status: creating sapi/cli/php.1 config.status: creating sapi/fpm/php-fpm.conf config.status: creating sapi/fpm/www.conf config.status: creating sapi/fpm/init.d.php-fpm config.status: creating sapi/fpm/php-fpm.service config.status: creating sapi/fpm/php-fpm.8 config.status: creating sapi/fpm/status.html config.status: creating sapi/phpdbg/phpdbg.1 config.status: creating sapi/cgi/php-cgi.1 config.status: creating ext/phar/phar.1 config.status: creating ext/phar/phar.phar.1 config.status: creating main/php_config.h config.status: main/php_config.h is unchanged config.status: executing default commands 编译并安装 make \u0026amp;\u0026amp; make install 配置相应文件 cp php.ini-development /usr/local/php/lib/php.ini cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf cp sapi/fpm/php-fpm /usr/local/bin cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf 然后设置php.ini，使用：vim /usr/local/php/lib/php.ini 打开php配置文件找到 cgi.fix_pathinfo 配置项，这一项默认被注释并且值为1，根据官方文档的说明，这里为了当文件不存在时，阻止nginx将请求发送到后端的php-fpm模块，从而避免恶意脚本注入的攻击，所以此项应该去掉注释并设置为0，设置完毕保存并且退出。\n创建web用户 groupadd www-data useradd-g www-data www-data // 打开www.conf文件，配置用户权限 vim /usr/local/php/etc/php-fpm.d/www.conf 默认user和group的设置为nobody，将其改为www-data 启动php-fpm服务 /usr/local/bin/php-fpm php-fpm服务默认使用9000端口，使用 netstat -tln |grep 9000 可以查看端口使用情况，9000端口正常使用，说明php-fpm服务启动成功。\n配置mginx 打开nginx.conf文件 首先找到user 设置为：user www-data www-data; 然后在service{}层中 添加php location段\nlocation / { root /var/www/test; index index.php index.html; # 添加index.php } location ~ \\.php$ { root /var/www/test; # 项目文件根目录 fastcgi_pass 127.0.0.1:9000; # 对应的php-fpm地址和端口 fastcgi_index index.php; # 默认访问文件 fastcgi_param script_filename $document_root$fastcgi_script_name; # 将 /scripts改为$document_root include fastcgi_params; } 修改完之后保存nginx.conf文件 并且重启nginx\n/usr/local/nginx/sbin/nginx -s reload 然后在项目路径中创建一个index.php文件，内容可以如下：\n\u0026lt;?php echo phpinfo(); ?\u0026gt; 然后打开浏览器输入对应的地址进行访问，看到输出页面，说明nginx和php都配置成功。\n","date":"2019-11-06","permalink":"https://blog.akvicor.com/posts/php/install/","summary":"Ubuntu 18.04 安装PHP7并配置Nginx 安装 sudo apt-get install software-properties-common python-software-properties sudo add-apt-repository ppa:ondrej/php sudo apt-get update sudo apt-get -y install php7.3 # 安装常用扩展 sudo -y apt-get install php7.3-fpm php7.3-mysql php7.3-curl php7.3-json php7.3-mbstring php7.3-xml php7.3-intl # 安装其他扩展（按需安装） sudo apt-get install php7.3-gd sudo apt-get install php7.3-soap sudo apt-get install php7.3-gmp sudo apt-get install","title":"php install"},{"content":"ubuntu 18.04 安装mysql8\nubuntu 下载 apt 包 centos 下载 apt 包 sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb sudo apt update sudo apt install mysql-server # 查看mysql是否安装成功 mysql -u root -p # 查看mysql字符集，mysql8字符集默认为utf-8。 show variables like \u0026#39;%char%\u0026#39;; ","date":"2019-11-06","permalink":"https://blog.akvicor.com/posts/mysql/install/","summary":"Ubuntu 18.04 安装MySQL8 Ubuntu 下载 APT 包 CentOS 下载 APT 包 sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb sudo apt update sudo apt install mysql-server # 查看mysql是否安装成功 mysql -u root -p # 查看mysql字符集，mysql8字符集默认为utf-8。 show","title":"mysql install"},{"content":"ubuntu 18.04 搭建nginx服务\n安装 ubuntu可以从源直接安装nginx\nsudo apt-get update sudo apt-get install nginx 调整防火墙，以免出现各种问题 sudo ufw app list 获得应用程序配置文件的列表：\n可用应用程序： cups nginx full nginx http nginx https openssh 正如你所看到的，nginx有三个配置文件可用：nginx full、nginx http、nginx https\nnginx full ：此配置文件打开端口80（正常，未加密的网络流量）和端口443（tls / ssl加密流量） nginx http ：此配置文件仅打开端口80（正常，未加密的网络流量） nginx https ：此配置文件仅打开端口443（tls / ssl加密流量） sudo ufw allow \u0026#39;nginx http\u0026#39; sudo ufw allow \u0026#39;nginx https\u0026#39; 输入以下命令以启动防火墙，据知有部分用户是没有启动防火墙的，还是建议开启\nsudo ufw enable 输入以下命令以查看防火墙状态：\nsudo ufw status 检查您的web服务器是否在运行 sudo systemctl status nginx 检查是否可以访问默认网页，在浏览器输入： http://本地ip地址 管理nginx进程 sudo systemctl stop nginx sudo systemctl start nginx sudo systemctl restart nginx # 如果您只是简单地进行配置更改，nginx通常可以重新加载而不会丢失连接。 sudo systemctl reload nginx # 默认情况下，nginx配置为在服务器引导时自动启动。 如果这不是您想要的，可以通过输入以下命令来禁用此行为： sudo systemctl disable nginx # 要重新启用服务以在启动时启动，您可以键入：sudo systemctl enable nginx 设置服务器块 ubuntu 18.04上的nginx默认启用了一个服务器模块，该模块被配置为在 /var/www/html 目录下提供文档。 虽然这适用于单个站点，但如果您托管多个站点，它可能会变得很笨重。 我们不必修改/var/www/html ，而是在/var/www为我们的example.com网站创建一个目录结构，并将/var/www/html保留为默认目录，如果客户端请求没有匹配任何其他网站。\n按如下所示为example.com创建目录，使用-p标志创建任何必需的父目录：\nsudo mkdir -p /var/www/example.com/html 接下来，使用$user环境变量分配目录的所有权：\nsudo chown -r $user:$user /var/www/example.com/html/ 如果你没有修改你的umask值，你的web根目录的权限应该是正确的，但是你可以通过输入：\nsudo chmod -r 755 /var/www/example.com/ 接下来，使用vim或您最喜欢的编辑器创建一个index.html页面示例：\nvim /var/www/example.com/html/index.html 在里面，添加下面的示例html：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;welcome to example.com!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;success! the example.com server block is working!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 为了让nginx提供这些内容，有必要创建一个具有正确指令的服务器块。 我们不要直接修改默认配置文件，而是在/etc/nginx/sites-available/example.com上创建一个新文件：\nsudo vim /etc/nginx/sites-available/example.com 粘贴到以下配置块中，该块类似于默认值，但已更新为我们的新目录和域名：\nserver { listen 80; listen [::]:80; root /var/www/example.com/html; index index.html index.htm index.nginx-debian.html; server_name example.com www.example.com; location / { try_files $uri $uri/ =404; } } 请注意，我们已将root配置更新到我们的新目录，并将server_name为我们的域名。 接下来，让我们通过创建一个链接到启动sites-enabled目录来启用该文件，该目录是nginx在启动过程中读取的：\nsudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ 现在启用两个服务器模块并将其配置为基于listen和server_name指令响应请求（您可以阅读关于nginx如何处理这些指令的更多信息）：\nexample.com ：将响应example.com和www.example.com请求。 default ：将响应端口80上与其他两个块不匹配的任何请求。 为了避免添加额外的服务器名称可能导致的哈希桶内存问题，有必要调整/etc/nginx/nginx.conf文件中的单个值。 sudo vim /etc/nginx/nginx.conf 找到server_names_hash_bucket_size指令并删除#符号以取消注释该行：\n... http { ... server_names_hash_bucket_size 64; ... } ... 接下来，测试以确保您的nginx文件中没有语法错误：\nsudo nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 如果没有任何问题，请重新启动nginx以启用您的更改：\nsudo systemctl restart nginx nginx现在应该为您的域名提供服务。 你可以通过导航到http://example.com来测试它\n重要的nginx文件和目录 nginx服务器配置文件：\n/etc/nginx # nginx配置目录。 所有的nginx配置文件都驻留在这里。 /etc/nginx/nginx.conf # 主要的nginx配置文件。 这可以修改，以更改nginx全局配置。 /etc/nginx/sites-available/ # 可存储每个站点服务器块的目录。 除非将nginx链接到sites-enabled了sites-enabled目录，否则nginx不会使用此目录中的配置文件。 通常，所有服务器块配置都在此目录中完成，然后通过链接到其他目录启用。 /etc/nginx/sites-enabled/ # 存储启用的每个站点服务器块的目录。 通常，这些是通过链接到sites-available目录中的配置文件创建的。 /etc/nginx/snippets # 这个目录包含可以包含在nginx配置其他地方的配置片段。 可重复配置的片段可以重构为片段。 # nginx服务器日志文件： /var/log/nginx/access.log # 除非nginx配置为其他方式，否则每个对您的web服务器的请求都会记录在此日志文件中。 /var/log/nginx/error.log # 任何nginx错误都会记录在这个日志中。 ","date":"2019-11-06","permalink":"https://blog.akvicor.com/posts/nginx/install/","summary":"Ubuntu 18.04 搭建Nginx服务 安装 Ubuntu可以从源直接安装nginx sudo apt-get update sudo apt-get install nginx 调整防火墙，以免出现各种问题 sudo ufw app list 获得应用程序配置文件的列表： 可用应用程序： CUPS Nginx","title":"nginx install"},{"content":" comentoj-c72-4033 「火鼠的皮衣 -不焦躁的内心-」 给定 $math_inline$n, a, b, p$math_inline$ （p不一定是质数），求 $math_inline$\\sum\\limits_{i=0}^{\\lfloor\\frac{n}{2}\\rfloor} a^i b^{n-2i} {n\\choose 2i}$math_inline$ 对 $math_inline$p$math_inline$ 取模的结果，t组询问。\n首先对求和公式进行转化；\n$math_inline$ \\begin{equation} \\begin{aligned} ans \u0026= \\sum\\limits_{i=0}^{\\lfloor\\frac{n}{2}\\rfloor} a^i b^{n-2i} {n\\choose 2i} \\\\ \u0026= \\sum\\limits_{i=0}^{n}(\\sqrt{a})^ib^{n-i}{n \\choose i}\\left[i\\%2==0\\right] \\end{aligned} \\end{equation} $math_inline$ 考虑把 $math_inline$\\left[i\\%2==0\\right]$math_inline$ 改写成 $math_inline$\\frac{1^i + {(-1)}^i}{2}$math_inline$ $math_inline$ \\begin{equation} \\begin{aligned} ans \u0026= \\sum\\limits_{i=0}^{n}(\\sqrt{a})^ib^{n-i}{n \\choose i}\\left[i\\%2==0\\right] \\\\ \u0026= \\sum\\limits_{i=0}^{n}(\\sqrt{a})^ib^{n-i}{n \\choose i}\\frac{1^i + {(-1)}^i}{2} \\\\ \u0026= \\frac{1}{2}\\left(\\sum\\limits_{i=0}^{n}(\\sqrt{a})^ib^{n-i}{n \\choose i} + \\sum\\limits_{i=0}^{n}(-\\sqrt{a})^ib^{n-i}{n \\choose i}\\right) \\end{aligned} \\end{equation} $math_inline$ 根据二项式定理 $math_inline${(a+b)}^n=\\sum\\limits^n_{k=0}{n \\choose k}x^{n-k}y^k=\\sum\\limits^n_{k=0}{n \\choose k}x^ky^{n-k}$math_inline$ $math_inline$ \\begin{equation} \\begin{aligned} ans \u0026= \\frac{1}{2}\\left(\\left(b+\\sqrt{a}\\right)^n+\\left(b-\\sqrt{a}\\right)^n\\right) \\end{aligned} \\end{equation} $math_inline$ 因为 a,b 固定，可以设 fx 为当 n=x 时的答案，那么 fx 一定是满足一个二项递推式，即 $math_inline$fx=a\\times f_{x-1}+b\\times f_{x-2}$math_inline$ 。因为 a 不一定有二次剩余，所以不能用快速幂来做，p也不一定是质数，所以不能用 bm 算法求出 a,b（有一个求逆元的步骤）。不过可以通过手算 $math_inline$f_0,f_1,f_2,f_3$math_inline$ 然后解一个二元一次方程组来算出 a,b。\n$math_inline$ \\begin{aligned} f_0 \u0026= 1 \\\\ f_1 \u0026= b \\\\ f_2 \u0026= b^2+a \\\\ f_3 \u0026= b^3+3ab \\end{aligned} $math_inline$ 或者\n考虑特征根方程： $math_inline$x^2=ax+b$math_inline$ ，即 $math_inline$x^2-ax-b=0$math_inline$ ，方程的两个解理应为答案式子中的两个特征根 $math_inline$b+\\sqrt{a},b-\\sqrt{a}$math_inline$ 。根据韦达定理，可知 a 为两根之和 $math_inline$(b+\\sqrt{a})+(b-\\sqrt{a})=2b$math_inline$ ，-b 为两根之积，即 $math_inline$b=-(b+\\sqrt{a})(b-\\sqrt{a})=a-b^2$math_inline$ 。那么求出 $math_inline$f_0=1, f_1=b$math_inline$ 之后用矩阵乘法就可以在 $math_inline$o(log(n))$math_inline$ 的时间内求出。\n矩阵为\n$math_inline$ \\left ( \\begin{matrix} 1 \u0026 b \\end{matrix} \\right ) \\left ( \\begin{matrix} 0 \u0026 a-b^2 \\\\ 1 \u0026 2b \\end{matrix} \\right ) $math_inline$ 或\n$math_inline$ \\left ( \\begin{matrix} b \u0026 1 \\end{matrix} \\right ) \\left ( \\begin{matrix} 2b \u0026 1 \\\\ a-b^2 \u0026 0 \\end{matrix} \\right ) $math_inline$ code 1 /* *********************************************** author : akvicor created time : mon oct 28 14:54:35 2019 file name : d.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); #define endl \u0026#39;\\n\u0026#39; #define asb using namespace std; typedef long long ll; namespace akvicors { #define ase } int main() { return akvicors::sol(); } asb int t; ll n, a, b, p; inline ll mul(ll x, ll y){ return (__int128)x*y%p; } struct mat{ int r, c; ll num[2][2]; mat(int _r=2, int _c=2){r=_r;c=_c;} mat operator * (const mat \u0026amp;obj) const{ mat res(r, obj.c); for(int i = 0; i \u0026lt; res.r; ++i){ for(int j = 0; j \u0026lt; res.c; ++j){ res.num[i][j] = 0; for(int k = 0; k \u0026lt; c; ++k){ res.num[i][j] = (res.num[i][j] + mul(num[i][k], obj.num[k][j]))%p; } } } return res; } }f, g; int sol(){ fast_io; cin \u0026gt;\u0026gt; t; while(t--){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; p; a %= p; b %= p; f.r = 1; f.c = g.r = g.c = 2; f.num[0][0] = 1; f.num[0][1] = b; g.num[0][0] = 0; g.num[0][1] = (a+p-mul(b, b)) % p; g.num[1][0] = 1; g.num[1][1] = 2*b%p; for(; n; n \u0026gt;\u0026gt;= 1, g = g*g) if(n\u0026amp;1) f = f*g; cout \u0026lt;\u0026lt; f.num[0][0] \u0026lt;\u0026lt; endl; } return 0; } ase code 2 /* *********************************************** author : akvicor created time : mon oct 28 14:54:35 2019 file name : d.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); #define endl \u0026#39;\\n\u0026#39; #define asb using namespace std; typedef long long ll; namespace akvicors { #define ase } int main() { return akvicors::sol(); } asb int t; ll n, a, b, p; typedef pair\u0026lt;ll, ll\u0026gt; pll; #define fi first #define se second ll mul(ll x, ll y){ return (__int128)x*y%p; } pll operator * (pll a, pll b){ return make_pair( ( mul(a.fi, b.fi) + mul( mul(a.se, b.se), ::akvicors::a) ) % p, ( mul(a.se, b.fi) + mul(a.fi, b.se) ) % p); } pll qpow(pll x, ll y){ pll ans = make_pair(1, 0); for(; y; y\u0026gt;\u0026gt;=1, x=x*x) if(y\u0026amp;1) ans = ans * x; return ans; } int sol(){ fast_io; cin \u0026gt;\u0026gt; t; while(t--){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; qpow(make_pair(b, 1), n).fi \u0026lt;\u0026lt; endl; } return 0; } ase ","date":"2019-10-28","permalink":"https://blog.akvicor.com/posts/cf/comentoj_c72_4033/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://cometoj.com/contest/72/problem/%EF%BC%A4?problem_id=4033\"\u003e ComentOJ-C72-4033 「火鼠的皮衣 -不焦躁的内心-」 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"「火鼠的皮衣 -不焦躁的内心-」"},{"content":" comentoj-c72-4032 「佛御石之钵 -不碎的意志-」(困难版) 每行开一个并查集，每个格子的祖先表示包括其在内的右边第一个为 0 的格子\n一个总的并查集，表示两个格子是否属于一个集合。\n时间复杂度 $math_inline$o\\left( nm\\alpha(nm) + nq \\right)$math_inline$ code /* *********************************************** author : akvicor created time : mon oct 28 13:06:07 2019 file name : c2.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); #define endl \u0026#39;\\n\u0026#39; #define asb using namespace std; typedef long long ll; namespace akvicors { #define ase } int main() { return akvicors::sol(); } asb int n, m, q, x1, y1, x2, y2, ans, cnt; char s[1010]; const int maxn = 1e3+10; int fa[maxn][maxn]; int f[maxn*maxn]; int id[maxn][maxn]; int fx[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; inline int find(int * f, int x){return f[x] == x ? x : f[x]=find(f, f[x]);} void merge(int x, int y){ ++ans; id[x][y] = ++cnt; // the number of \u0026#39;1\u0026#39; f[cnt] = cnt; // every \u0026#39;1\u0026#39; is the father to itself int u = find(fa[x], y), v = find(fa[x], y+1); // \u0026#39;1\u0026#39; \u0026#39;s root is the next \u0026#39;0\u0026#39; if(u != v) fa[x][u] = v; // check the left, right, up and down for(int i = 0; i \u0026lt; 4; ++i){ int tx = x + fx[i][0]; int ty = y + fx[i][1]; if(tx \u0026amp;\u0026amp; ty \u0026amp;\u0026amp; tx \u0026lt;= n \u0026amp;\u0026amp; ty \u0026lt;= m \u0026amp;\u0026amp; id[tx][ty]){ u = find(f, id[x][y]), v = find(f, id[tx][ty]); if(u != v){ // if u and v is two union before --ans; f[u] = v; } } } } void init(){ for(int i = 0; i \u0026lt;= n; ++i){ for(int j = 0; j \u0026lt;= m+1; ++j){ // must (j \u0026lt;= m+1) else the line 33 while throw segment falt fa[i][j] = j; } } } int sol(){ fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; init(); for(int i = 1; i \u0026lt;= n; ++i){ cin \u0026gt;\u0026gt; (s+1); for(int j = 1; j \u0026lt;= m; ++j){ if(s[j] == \u0026#39;1\u0026#39;){ merge(i, j); } } } cin \u0026gt;\u0026gt; q; while(q--){ cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; for(int x = x1; x \u0026lt;= x2; ++x){ for(int y = find(fa[x], y1); y \u0026lt;= y2; y = find(fa[x], y)){ merge(x, y); // next \u0026#39;0\u0026#39; and merge } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }\treturn 0; } ase ","date":"2019-10-28","permalink":"https://blog.akvicor.com/posts/cf/comentoj_c72_4032/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://cometoj.com/contest/72/problem/%EF%BC%A32?problem_id=4032\"\u003e ComentOJ-C72-4032 「佛御石之钵 -不碎的意志-」(困难版) \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"「佛御石之钵 -不碎的意志-」(困难版)"},{"content":"枚举\n指数型 /* *********************************************** author : akvicor created time : wed sep 18 21:07:30 2019 file name : 1026.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); using namespace std; vector\u0026lt;int\u0026gt; vt; int n; void dfs(int x){ //vt.push_back(x); if(x == n+1){ for(int i = 0; i \u0026lt; vt.size(); ++i){ if(i != 0) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; vt[i]; }cout \u0026lt;\u0026lt; endl; return; } dfs(x+1); vt.push_back(x); dfs(x+1); vt.pop_back(); } int main() { cin \u0026gt;\u0026gt; n; dfs(1); return 0; } 组合 /* *********************************************** author : akvicor created time : thu sep 19 18:31:55 2019 file name : 1027.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); using namespace std; int n, m; vector\u0026lt;int\u0026gt; vt; void dfs(int x, int k){ if(k \u0026gt; m || k + n-x+1 \u0026lt; m) return; if(k == m){ for(int i = 0; i \u0026lt; vt.size(); ++i){ cout \u0026lt;\u0026lt; vt[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }cout \u0026lt;\u0026lt; endl; return; } vt.push_back(x); dfs(x+1, k+1); vt.pop_back(); dfs(x+1, k); } int main() { fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dfs(1, 0); return 0; } 排列 /* *********************************************** author : akvicor created time : thu sep 19 19:10:29 2019 file name : a.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); using namespace std; int n; bool vis[100]; vector\u0026lt;int\u0026gt; v; void dfs(int k){ if(k == n){ for(auto \u0026amp;i : v) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return; } for(int i = 1; i \u0026lt;= n; ++i){ if(!vis[i]) { vis[i] = true; v.push_back(i); dfs(k+1); v.pop_back(); vis[i] = false; } } } void nper(int n){ vector\u0026lt;int\u0026gt; v(n); for(int i = 0; i \u0026lt; n; ++i) v[i] = i+1; do{ for(int i = 0; i \u0026lt; v.size(); ++i){ cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }cout \u0026lt;\u0026lt; endl; }while(next_permutation(v.begin(), v.end())); } int main() { fast_io; cin \u0026gt;\u0026gt; n; dfs(0); return 0; } ","date":"2019-10-08","permalink":"https://blog.akvicor.com/posts/algorithm/dfs_enum/","summary":"\u003cp\u003e枚举\u003c/p\u003e","title":"递归实现枚举"},{"content":" 当使用国外服务器搭建网站的时候, 可能遇到一些网站屏蔽了网站ip, 因此需要检测一下是否被屏蔽 当使用国外服务器搭建网站的时候经常会碰到一些 ip 因为被墙导致网站不能访问，所以可以先检测一下 ip 是否被墙。 时区\nln -sf /usr/share/zoneinfo/etc/gmt-8 /etc/localtime 检测ip\nbash \u0026lt;(curl -sl ip.check.place) -f # 流媒体解锁 bash \u0026lt;(curl -sl media.check.place) -m 4 bash \u0026lt;(curl -l -s check.unlock.media) -m 4 -r 0 # 三网回程 curl https://raw.githubusercontent.com/oneclickvirt/backtrace/main/backtrace_install.sh -ssf | bash # 磁盘io curl -sl yabs.sh | bash bash \u0026lt;(curl -sl yabs.sh) -i -g 检测端口\ntelnet smtp.google.com 25 同步时间\napt-get install systemd-timesyncd 检测ip是否被墙 国内 ping 测试网页 访问 https://www.ipip.net/ping.php 输入ip地址,勾选中国、港澳台，如果如下图所示丢包率 100%，那肯定是被墙了。\n国内外端口扫描测试 http://tool.chinaz.com/port\n国外测试 https://www.yougetsignal.com/tools/open-ports/\n如果上一步 22 端口是关闭状态，在这一步检测是 open 状态，说明 ip 肯定是被墙掉了。\n如果上一步 22 端口是关闭状态，在这一步检测也是 close 状态，那就要查看是不是服务器的防火墙把端口限制了。\n","date":"2019-10-07","permalink":"https://blog.akvicor.com/posts/proxy/check_ip_ban/","summary":"\u003cul\u003e\n\u003cli\u003e当使用国外服务器搭建网站的时候, 可能遇到一些网站屏蔽了网站IP, 因此需要检测一下是否被屏蔽\u003c/li\u003e\n\u003cli\u003e当使用国外服务器搭建网站的时候经常会碰到一些 IP 因为被墙导致网站不能访问，所以可以先检测一下 IP 是否被墙。\u003c/li\u003e\n\u003c/ul\u003e","title":"检测ip地址"},{"content":"将汉诺塔中的3跟柱子改为4根，求盘子数为1到12时将全部盘子从第一根移动到最后一根需要移动的次数。\n考虑正常的汉诺塔规则，若有 n 个圆盘，那么就要将前 n−1 个圆盘移动到 2 号柱，再把最大的圆盘移动到 3 号柱，最后将前 n−1 个圆盘移动到 3 号柱。那么将 n−1 个圆盘移动又要涉及到 n−2 个圆盘，以此类推，所以，3个柱子得到的方程是 $f[i]=f[i-1] \\times 2 + 1$\ncode void hanoi(int n, char a, char b, char c){ if(n == 1) printf(\u0026#34;%c -\u0026gt; %c\\n\u0026#34;, a, c); else{ hanoi(n-1, a, c, b); // 把 a 上面的 n-1 块借助 c 移动到 b printf(\u0026#34;%c -\u0026gt; %c\\n\u0026#34;, a, c); // 第 n 块从 a 移动到 c hanoi(n-1, b, a, c); // 把 b 上面的 n-1 块借助 a 移动到 c } } ","date":"2019-09-30","permalink":"https://blog.akvicor.com/posts/algorithm/strange_tower_of_hanoi/","summary":"\u003cp\u003e将汉诺塔中的3跟柱子改为4根，求盘子数为1到12时将全部盘子从第一根移动到最后一根需要移动的次数。\u003c/p\u003e","title":"strange towers of hanoi"},{"content":"此快捷键说明我是翻译官方的快捷键说明的，方便查看，基于phpstorm的官方help来翻译的，其他系列的jetbrains软件应该都是一样的道理，其中如有错误，欢迎斧正。\nmac mac键盘符号和修饰键说明 ⌘ command ⇧ shift ⌥ option ⌃ control ↩︎ return/enter ⌫ delete ⌦ 向前删除键（fn+delete） ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ page up（fn+↑） ⇟ page down（fn+↓） home fn + ← end fn + → ⇥ 右制表符（tab键） ⇤ 左制表符（shift+tab） ⎋ escape (esc) 一、editing（编辑） control + space 基本的代码补全（补全任何类、方法、变量） control + shift + space 智能代码补全（过滤器方法列表和变量的预期类型） command + shift + enter 自动结束代码，行末自动添加分号 command + p 显示方法的参数信息 control + j 快速查看文档 shift + f1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） command + 鼠标放在代码上 显示代码简要信息 command + f1 在错误或警告处显示具体描述信息 command + n, control + enter, control + n 生成代码（getter、setter、构造函数、hashcode/equals,tostring） control + o 覆盖方法（重写父类方法） control + i 实现方法（实现接口中的方法） command + option + t 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） command + / 注释/取消注释与行注释 command + option + / 注释/取消注释与块注释 option + 方向键上 连续选中代码块 option + 方向键下 减少当前选中的代码块 control + shift + q 显示上下文信息 option + enter 显示意向动作和快速修复代码 command + option + l 格式化代码 control + option + o 优化import control + option + i 自动缩进线 tab / shift + tab 缩进代码 / 反缩进代码 command + x 剪切当前行或选定的块到剪贴板 command + c 复制当前行或选定的块到剪贴板 command + v 从剪贴板粘贴 command + shift + v 从最近的缓冲区粘贴 command + d 复制当前行或选定的块 command + delete 删除当前行或选定的块的行 control + shift + j 智能的将代码拼接成一行 command + enter 智能的拆分拼接的行 shift + enter 开始新的一行 command + shift + u 大小写切换 command + shift + ] / command + shift + [ 选择直到代码块结束/开始 option + fn + delete 删除到单词的末尾 option + delete 删除到单词的开头 command + 加号 / command + 减号 展开 / 折叠代码块 command + shift + 加号 展开所以代码块 command + shift + 减号 折叠所有代码块 command + w 关闭活动的编辑器选项卡 二、search/replace（查询/替换） double shift 查询任何东西 command + f 文件内查找 command + g 查找模式下，向下查找 command + shift + g 查找模式下，向上查找 command + r 文件内替换 command + shift + f 全局查找（根据路径） command + shift + r 全局替换（根据路径） command + shift + s 查询结构（ultimate edition 版专用，需要在keymap中设置） command + shift + m 替换结构（ultimate edition 版专用，需要在keymap中设置） 三、usage search（使用查询） option + f7 / command + f7 在文件中查找用法 / 在类中查找用法 command + shift + f7 在文件中突出显示的用法 command + option + f7 显示用法 四、compile and run（编译和运行） command + f9 编译project command + shift + f9 编译选择的文件、包或模块 control + option + r 弹出 run 的可选择菜单 control + option + d 弹出 debug 的可选择菜单 control + r 运行 control + d 调试 control + shift + r, control + shift + d 从编辑器运行上下文环境配置 五、debugging（调试） f8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 f7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 shift + f7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 shift + f8 跳出 option + f9 运行到光标处，如果光标前有其他断点会进入到该断点 option + f8 计算表达式（可以更改变量值使其生效） command + option + r 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 command + f8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） command + shift + f8 查看断点信息 六、navigation（导航） command + o 查找类文件 command + shift + o 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ command + option + o 前往指定的变量 / 方法 control + 方向键左 / control + 方向键右 左右切换打开的编辑tab页 f12 返回到前一个工具窗口 esc 从工具窗口进入代码文件窗口 shift + esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 command + shift + f4 关闭活动run/messages/find/\u0026hellip; tab command + l 在当前文件跳转到某一行的指定处 command + e 显示最近打开的文件记录列表 option + 方向键左 / option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置 command + option + 方向键左 / command + option + 方向键右 退回 / 前进到上一个操作的地方 command + shift + delete 跳转到最后一个编辑的地方 option + f1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的finder) command + b / command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处 command + option + b 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 option + space, command + y 快速打开光标所在方法、类的定义 control + shift + b 跳转到类型声明处 command + u 前往当前光标所在方法的父类的方法 / 接口定义 control + 方向键下 / control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置 command + ] / command + [ 移动光标到当前所在代码的花括号开始/结束位置 command + f12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） control + h 显示当前类的层次结构 command + shift + h 显示方法层次结构 control + option + h 显示调用层次结构 f2 / shift + f2 跳转到下一个/上一个突出错误或警告的位置 f4 / command + 方向键下 编辑/查看代码源 option + home 显示到当前文件的导航条 f3选中文件/文件夹/代码行，添加/取消书签 option + f3 选中文件/文件夹/代码行，使用助记符添加/取消书签 control + 0...control + 9 定位到对应数值的书签位置 command + f3 显示所有书签 七、refactoring（重构） f5 复制文件到指定目录 f6 移动文件到指定目录 command + delete 在文件上为安全删除文件，弹出确认框 shift + f6 重命名文件 command + f6 更改签名 command + option + n 一致性 command + option + m 将选中的代码提取为方法 command + option + v 提取变量 command + option + f 提取字段 command + option + c 提取常量 command + option + p 提取参数 八、vcs/local history（版本控制/本地历史记录） command + k 提交代码到版本控制器 command + t 从版本控制器更新代码 option + shift + c 查看最近的变更记录 control + c 快速弹出版本控制器操作面板 九、live templates（动态代码模板） command + option + j 弹出模板选择窗口，将选定的代码使用动态模板包住 command + j 插入自定义动态代码模板 十、general（通用） command + 1...command + 9 打开相应编号的工具窗口 command + s 保存所有 command + option + y 同步、刷新 control + command + f 切换全屏模式 command + shift + f12 切换最大化编辑器 option + shift + f 添加到收藏夹 option + shift + i 检查当前文件与当前的配置文件 control + ` 快速切换当前的scheme（切换主题、代码样式等） command + , 打开idea系统设置 command + ; 打开项目结构对话框 shift + command + a 查找动作（可设置相关选项） control + shift + tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口） 十一、other（一些官方文档上没有体现的快捷键） command + shift +8 竖编辑模式 windows 编辑 快捷键组合 说明 ctrl + space 代码自动完成提示（选择） alt + enter 显示意图动作和快速修复 ctrl + p 参数信息（在调用方法参数忘记的时候，提示） ctrl + q 快速查找文件，可以查找当前类定义的文件等 ctrl + 鼠标滑过 基本信息 alt + insert 生成代码\u0026hellip;(细节需要多次操作会发现很有意思) ctrl + o 重写方法（在phpstorm中是重写父类方法，会有选择框） ctrl + i 实现方法（一般是指实现接口类或抽象类方法） ctrl + alt + t 环绕代码块 (if..else, try..catch, for, 等) ctrl + / 单行注释(//) ctrl + shift + / 块注释 (/**/) ctrl + w 选择依次递增的代码块，具体使用目前来看比较少 ctrl + shift + w 去掉当前选择返回上一个选择，类似于撤销选择，与上面的相反 ctrl + alt + l 格式化代码，一般来说，写的代码格式不整齐统一，这个很有用 ctrl + alt + i 自啮合线，这个解释不太好解释，测试结果就是会自动根据代码来进行对齐 ctrl + d 复制当前行或选定的块 ctrl + y 删除插入符号所在行 ctrl + shift + j 智能线连接（html和javascript才有用） ctrl + enter 智能分割线 (html 和 javascript 才有用) shift + enter 开始新行，比如光标在当前行，不需要切换到行尾按enter，直接按这个组合键即可 ctrl + shift + u 切换选中的英文文字的大小写，此处其实用到挺多的 ctrl + shift + ] 或 [ 选择直到代码块的开始或结束，我之前不知道这个，其实很有用 ctrl + delete 删除从当前光标到当前单词结尾 ctrl + backspace 从光标位置删除到当前单词的开始 ctrl + + 或 - 这里是ctrl和加号或者减号产生的组合，可以折叠或展开当前代码块 ctrl + f4 关闭活动中的tab ctrl + shift + v 从历史粘贴 调试 此处我是用得很少\n快捷键组合 说明 f8 跳过 f7 步进 shift + f8 跳出 alt + f8 表达式求值 f9 恢复程序 ctrl + f8 切断断点 ctrl+shift+f8 查看断点 运行 快捷键组合 说明 shift + f10 运行 shift + f9 调试 ctrl + shift + f10 从编辑器运行上下文配置（run context configuration from editor），此处可能翻译不够准确 ctrl + shift + x 在命令行运行 搜索/替换 快捷键组合 说明 ctrl + f/r 查找/替换 f3/shift + f3 查找下一个/上一个 ctrl + shift + f/r 在目录中查找/替换 查找哪些地方使用 快捷键组合 说明 alt + f7 / ctrl + f7 当前文件查找被使用/在文件中查找哪些地方使用 ctrl + shift + f7 文件中搜索并在使用的地方高亮显示 ctrl + alt + f7 显示哪些地方被使用 导航 快捷键组合 说明 ctrl + n 跳转到指定类 ctrl + shift + n 跳转到文件 ctrl + alt + shift + n 跳转到符号 ctrl + g 跳转到第几行 alt + right/left 切换编辑器活动窗 esc go to editor (from tool window) ctrl + e 弹出最近编辑文件，我也是在写这文档才知道，太方便了 ctrl + alt + left/right 导航前进/后退 ctrl + shift + backspace 跳转到最近编辑的代码位置 alt + f1 在任何视图中选择当前文件或符号 ctrl + b 或 ctrl + click 跳到申明（如跳转到当前函数声明的地方，这个很常用，可以实操一下） ctrl + alt + b 与上面相反，跳到执行位置 ctrl + shift + i 打开快速定义查找 ctrl + shift + b 跳转到类型声明 ctrl + u 跳到超级方法(super-method)/超类 (super-class) alt + up/down 跳转到上一个或者下一个方法，在编辑一个类的时候，方便一个一个的方法进行查看 ctrl + ] / [ 跳转到代码块的开始或结束 f2 / shift + f2 跳转到上一个或下一个高亮错误地方，这个检查代码语法错误很有用 f4 / ctrl + enter 编辑源代码/查看源代码 重构 快捷键组合 说明 f5/f6 复制/移动 alt + delete 安全删除 shift + f6 重命名 ctrl + alt + n 内联变量 ctrl + alt + m/v/f/c 提取方法/变量/字段/常数(method/variable/field/constant) ctrl + alt + shift + t 重构这段代码（显示所有可用的重构），比如if else if 这种语句转switch语句 vcs/本地历史 快捷键组合 说明 alt + 反引号 (`) ‘vcs’ 快速弹出，此处需要注意这个反引号在最左上角，和那个~符号在一起的，esc键下面 ctrl + k 提交项目到vcs ctrl + t 从 vcs 更新项目 alt + shift + c 显示最近更改 常用操作 快捷键组合 说明 快速按两次 shift 搜索任何一个地方 ctrl + shift + a 查找方法(action) alt + #[0-9] 打开相应的工具窗口（这个我也没搞明白） ctrl + alt + f11 开启或关闭全屏模式 ctrl + shift + f12 开启或关闭最大化编辑 alt + shift + f 添加到收藏列表（我觉得这个功能很神奇，不知道为啥要这么做） alt + shift + i 检查当前文件以及当前配置文件 ctrl + alt + s 打开设置对话框（表示会与qq默认快捷键冲突） ctrl + tab 在 tabs 和工具窗口间切换 插入模板/片段(针对phpstorm) 快捷键组合 说明 alt + j 插入模板 eco ‘echo’ 语句 fore foreach(iterable_expr as $value) {…} forek foreach(iterable_expr as $key =\u0026gt; $value) {…} inc/inco ‘include’/‘include_once’ 语句 prif private function prof protected function pubf public function rqr/rqro ‘require’/‘require_once’ 语句 更多\u0026hellip; 其他自己尝试 ","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/idea/keymap/","summary":"\u003cp\u003e此快捷键说明我是翻译官方的快捷键说明的，方便查看，基于PHPStorm的官方Help来翻译的，其他系列的JetBrains软件应该都是一样的道理，其中如有错误，欢迎斧正。\u003c/p\u003e","title":"intellij idea keymap"},{"content":"apache禁止某文件夹内运行php脚本、禁止访问文件或目录执行权限的设置方法\n首先我们来看两段对上传目录设置无权限的列子，配置如下：\n\u0026lt;directory \u0026#34;要去掉php执行权限的目录路径，如/upload\u0026#34;\u0026gt; errordocument 404 /404/404.html errordocument 403 /404/403.html \u0026lt;filesmatch \u0026#34;\\.(?i:php|php3|php4)$\u0026#34;\u0026gt; // ?是尽可能多的匹配.php的字符串,i是不区分大小写,然后冒号后面跟上正则表达式，也可以写成：\u0026lt;filesmatch \u0026#34;\\.(php|php3)$\u0026#34;\u0026gt; order allow,deny deny from all \u0026lt;/filesmatch\u0026gt; \u0026lt;/directory\u0026gt; 上面的意思就是说，\u0026lt;directory “要去掉php执行权限的目录路径，例如：/upload”\u0026gt; 内目录路径下所有php文件不区分大小写，通过order,allow,deny 原则判断拒绝执行php文件，对nginx同样也是可应用。\n另外一种方法，是设置在.htaccess里面的，这个方法比较灵活一点，针对那些没有apapche安全操作权限的网站管理员，推荐使用！ apache环境规则内容如下：apache限制uploads目录执行php脚本，把规则添加到.htaccess文件中，代码如下:\nrewriteengine on rewritecond % !^$ rewriterule uploads/(.*).(php)$ – [f] 此方法仅限于apache服务器环境，windows环境无效。\napache禁止访问某些文件/目录 增加files选项来控制，比如要不允许访问 .inc 扩展名的文件，保护php类库：\n\u0026lt;files ~ \u0026#34;\\.inc$\u0026#34;\u0026gt; order allow,deny deny from all \u0026lt;/files\u0026gt; 禁止访问某些指定的目录：（可以用 \u0026lt;directorymatch\u0026gt; 来进行正则匹配）\n\u0026lt;directory ~ \u0026#34;^/var/www/(.+/)*[0-9]{3}\u0026#34;\u0026gt; order allow,deny deny from all \u0026lt;/directory\u0026gt; 通过文件匹配来进行禁止，比如禁止所有针对图片的访问：\n\u0026lt;filesmatch \\.(?i:gif|jpe?g|png)$\u0026gt; order allow,deny deny from all \u0026lt;/filesmatch\u0026gt; 针对url相对路径的禁止访问：\n\u0026lt;location /dir/\u0026gt; order allow,deny deny from all \u0026lt;/location\u0026gt; ","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/apache/deny_access_exec/","summary":"\u003cp\u003eApache禁止某文件夹内运行PHP脚本、禁止访问文件或目录执行权限的设置方法\u003c/p\u003e","title":"禁止某文件夹内运行php脚本、禁止访问文件或目录执行权限的设置方法"},{"content":"i installed a program called gitkraken and it\u0026rsquo;s pretty nice; but one thing it does during installation is to forcefully add a context menu item to open the current folder in it.\nunfortunately, since day 1, this has been broken. i\u0026rsquo;ve tried setting the association manually and it doesn\u0026rsquo;t work. setting an association with the program doesn\u0026rsquo;t yield any different results. is there anything else that can be done? i\u0026rsquo;ve even tried removing it from the registry.\nthis is all happening on windows 10 x64.\nrun regedit.exe go to hkey_classes_root/directory/background/shell/gitkraken/command change \u0026quot;%somedir%\\gitkraken\\update.exe\u0026quot; --processstart=gitkraken.exe --process-start-args=\u0026quot;-p %l\u0026quot; to \u0026quot;%somedir%\\gitkraken\\update.exe\u0026quot; --processstart=gitkraken.exe --process-start-args=\u0026quot;-p %v\u0026quot; ","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/gitkraken/cannot_associate_program_with_context_menu_action/","summary":"\u003cp\u003eI installed a program called GitKraken and it\u0026rsquo;s pretty nice; But one thing it does during installation is to forcefully add a context menu item to open the current folder in it.\u003c/p\u003e\n\u003cp\u003eUnfortunately, since day 1, this has been broken. I\u0026rsquo;ve tried setting the association manually and it doesn\u0026rsquo;t work. Setting an association with the program doesn\u0026rsquo;t yield any different results. Is there anything else that can be done? I\u0026rsquo;ve even tried removing it from the registry.\u003c/p\u003e\n\u003cp\u003eThis is all happening on Windows 10 x64.\u003c/p\u003e","title":"cannot associate program with context menu action"},{"content":"搜索引擎命令\n1、双引号\n把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。bd和google 都支持这个指令。例如搜索： “seo方法图片”\n2、减号减号代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。google 和bd都支持这个指令。\n例如：搜索 -引擎\n返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果\n3、星号星号*是常用的通配符，也可以用在搜索中。百度不支持*号搜索指令。\n比如在google 中搜索：搜索*擎\n其中的*号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。\n4、inurlinurl: 指令用于搜索查询词出现在url 中的页面。bd和google 都支持inurl 指令。inurl 指令支持中文和英文。\n比如搜索：inurl:搜索引擎优化\n返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。\n5、inanchor\ninanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面。百度不支持inanchor。\n比如在google 搜索 ：inanchor:点击这里\n返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。\n可以用来找到某个关键词的竞争对收，而且这些竞争对手往往是做过seo 的。研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。\n6、intitle\nintitle: 指令返回的是页面title 中包含关键词的页面。google 和bd都支持intitle 指令。\n使用intitle 指令找到的文件是更准确的竞争页面。如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。\n7、allintitle\nallintitle:搜索返回的是页面标题中包含多组关键词的文件。\n例如 ：allintitle:seo 搜索引擎优化\n就相当于：intitle:seo intitle:搜索引擎优化\n返回的是标题中中既包含“seo”，也包含“搜索引擎优化”的页面\n8、allinurl\n与allintitle: 类似。\nallinurl:seo 搜索引擎优化\n就相当于 ：inurl:seo inurl:搜索引擎优化\n9、filetype用于搜索特定文件格式。\ngoogle 和bd都支持filetype 指令。\n比如搜索filetype:pdf seo\n返回的就是包含seo 这个关键词的所有pdf 文件。\n10、site\nsite:是seo 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。\n11、linkdomain\nlinkdomain:指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准确，是seo 人员研究竞争对手外部链接情况的重要工具之一。\n比如搜索linkdomain:http://cnseotool.com -site:http://cnseotool.com\n得到的就是点石网站的外部链接，因为-site:http://cnseotool.com 已经排除了点石本身的页面，也就是内部链接，剩下的就都是外部链接了。\n12、related\nrelated:指令只适用于google，返回的结果是与某个网站有关联的页面。比如搜索\nrelated:http://cnseotool.com\n我们就可以得到google 所认为的与点石网站有关联的其他页面。 这种关联到底指的是什么，google 并没有明确说明，一般认为指的是有共同外部链接的网站。\n上面介绍的这几个高级搜索指令，单独使用可以找到不少资源，或者可以更精确地定位竞争对手。把这些指令混合起来使用则更强大。\ninurl:gov 减肥\n返回的就是url 中包含gov，页面中有“减肥”这个词的页面。很多seo 人员认为gvm和学校网站有比较高的权重，找到相关的gvm和学校网站，就找到了最好的链接资源。\n下面这个指令返回的是来自.中国教育和科研计算机网cernet，也就是学校域名上的包含“交换链接”这个词的页面：\ninurl:.中国教育和科研计算机网cernet 交换链接\n从中seo 人员可以找到愿意交换链接的学校网站。\n或者使用一个更精确的搜索：\ninurl:.中国教育和科研计算机网cernet intitle:交换链接\n返回的则是来自中国教育和科研计算机网cernet 域名，标题中包含“交换链接”这四个字的页面，返回的结果大部分应该是愿意交换链接的学校网站。\n再比如下面这个指令：inurl:中国教育和科研计算机网cernet*register\n返回的结果是在.中国教育和科研计算机网cernet 域名上，url 中包含“forum”以及“register”这两个单词的页面，也就是学校论坛的注册页面。找到这些论坛，也就找到了能在高权重域名上留下签名的很多机会。\n下面这个指令返回的是页面与减肥有关，url 中包含links 这个单词的页面：\n减肥 inurl:links\n很多站长把交换链接页面命名为links.html 等，所以这个指令返回的就是与减肥主题相关的交换链接页面。\n下面这个指令返回的是url 中包含http://gov.cn 以及links 的页面，也就是gvm域名上的交换链接页面：\nallinurl:gov.cn+links\n最后一个例子，在雅虎搜索这个指令：\nlinkdomain:http://cnseotool.com -linkdomain:http://cnseotool.com\n返回的是链接到点石网站，却没有链接到我的博客的网站。使用这个指令可以找到很多连向你的竞争对手或其他同行业网站，却没连向你的网站的页面，这些网站是最好的链接资源。\n高级搜索指令组合使用变化多端，功能强大。一个合格的seo必须熟练掌握这几个常用指令的意义及组合方法，才能更有效率地找到更多竞争对手和链接资源。\n找外链的时候你可以用这几种命令组合，例如site:.com inurl:blog “post a comment” -”comments closed” -”you must be logged in” “输入你的关键词“，site:.com 是 指， 只显示.com的网站。\n如果你想要 org的链接，就换成 site:.org，inurl:blog 是指博客。“post a comment” -”comments closed” -”you must be logged in” 是指， “能够写评论的” 减去“ 关闭评论的” 再减去“ 必须要登录才能写评论的”。\n","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/special/google_search_operators/","summary":"\u003cp\u003e搜索引擎命令\u003c/p\u003e","title":"搜索引擎指令"},{"content":"突然发现root登录的xshell的终端提示符显示的是-bash-4.2# 而不是root@主机名 + 路径的显示方式。搞了半天也不知道为什么出现这种情况。今天终于搞定这个问题，\n原因是root在/root下面的几个配置文件丢失，丢失文件如下：\n.bash_profile .bashrc 以上这些文件是每个用户都必备的文件。\n使用以下命令从主默认文件重新拷贝一份配置信息到/root目录下\ncp /etc/skel/.bashrc /root/ cp /etc/skel/.bash_profile /root/ 关掉终端，重新打开就可以了\n","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/linux/xshell_bash/","summary":"\u003cp\u003e突然发现root登录的xshell的终端提示符显示的是-bash-4.2# 而不是root@主机名 + 路径的显示方式。搞了半天也不知道为什么出现这种情况。今天终于搞定这个问题，\u003c/p\u003e","title":"xshell登录服务器提示符显示-bash-4.2#解决方法"},{"content":"javascript 创建动态页面。事件是可以被 javascript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 javascript 函数或程序的事件。\n比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。\n鼠标单击事件( onclick ） onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。\nonclick=\u0026#34;document.getelementbyid(\u0026#39;sign_in_form\u0026#39;).submit();\u0026#34; 鼠标经过事件（onmouseover） 鼠标经过事件，当鼠标移到一个对象上时，该对象就触发onmouseover事件，并执行onmouseover事件调用的程序。\n现实鼠标经过\u0026quot;确定\u0026quot;按钮时，触发onmouseover事件，调用函数info()，弹出消息框，代码如下:\n鼠标移开事件（onmouseout） 鼠标移开事件，当鼠标移开当前对象时，执行onmouseout调用的程序。\n当把鼠标移动到\u0026quot;登录\u0026quot;按钮上，然后再移开时，触发onmouseout事件，调用函数message()，代码如下:\n光标聚焦事件（onfocus） 当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。\n如下代码, 当将光标移到文本框内时，即焦点在文本框内，触发onfocus 事件，并调用函数message()。\n失焦事件（onblur） onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。\n如下代码, 网页中有用户和密码两个文本框。当前光标在用户文本框内时（即焦点在文本框），在光标离开该文本框后（即失焦时），触发onblur事件，并调用函数message()。\n内容选中事件（onselect） 选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。\n如下代码,当选中用户文本框内的文字时，触发onselect 事件，并调用函数message()。\n文本框内容改变事件（onchange） 通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。\n如下代码,当用户将文本框内的文字改变后，弹出对话框“您改变了文本内容！”。\n加载事件（onload） 事件会在页面加载完成后，立即发生，同时执行被调用的程序。 注意：\n加载页面时，触发onload事件，事件写在\u0026lt;body\u0026gt;标签内。 此节的加载页面，可理解为打开一个新页面时。 如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。\n卸载事件（onunload） 当用户退出页面时（页面关闭、页面刷新等），触发onunload事件，同时执行被调用的程序。\n注意：不同浏览器对onunload事件支持不同。\n如下代码,当退出页面时，弹出对话框“您确定离开该网页吗？”。\n","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/js/event/","summary":"\u003cp\u003eJavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。\u003c/p\u003e\n\u003cp\u003e比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://img.akvicor.com/i/2024/09/17/66e99f925f195.jpg\" alt=\"\"\u003e\u003c/p\u003e","title":"事件响应"},{"content":"html form表单提交后不刷新不跳转的实现方法\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34; target=\u0026#34;nm_iframe\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;id_input_text\u0026#34; name=\u0026#34;nm_input_text\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; id=\u0026#34;id_submit\u0026#34; name=\u0026#34;nm_submit\u0026#34; value=\u0026#34;提交\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe id=\u0026#34;id_iframe\u0026#34; name=\u0026#34;nm_iframe\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/html/submit_form_no_redirect/","summary":"\u003cp\u003ehtml form表单提交后不刷新不跳转的实现方法\u003c/p\u003e","title":"form表单提交后不刷新不跳转的实现方法"},{"content":"叙述使用以下代码修改图片大小或创建缩略图。\n参数说明：\n$filename：文件名。 $tmpname：文件路径，如上传中的临时目录。 $xmax：修改后最大宽度。 $ymax：修改后最大高度。\nfunction resize_image($filename, $tmpname, $xmax, $ymax) { $ext = explode(\u0026#34;.\u0026#34;, $filename); $ext = $ext[count($ext)-1]; if($ext == \u0026#34;jpg\u0026#34; || $ext == \u0026#34;jpeg\u0026#34;) $im = imagecreatefromjpeg($tmpname); elseif($ext == \u0026#34;png\u0026#34;) $im = imagecreatefrompng($tmpname); elseif($ext == \u0026#34;gif\u0026#34;) $im = imagecreatefromgif($tmpname); $x = imagesx($im); $y = imagesy($im); if($x \u0026lt;= $xmax \u0026amp;\u0026amp; $y \u0026lt;= $ymax) return $im; if($x \u0026gt;= $y) { $newx = $xmax; $newy = $newx * $y / $x; } else { $newy = $ymax; $newx = $x / $y * $newy; } $im2 = imagecreatetruecolor($newx, $newy); imagecopyresized($im2, $im, 0, 0, 0, 0, floor($newx), floor($newy), $x, $y); return $im2; } ","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/php/modify_picture_size/","summary":"\u003cp\u003e叙述使用以下代码修改图片大小或创建缩略图。\u003c/p\u003e\n\u003cp\u003e参数说明：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$filename\u003c/code\u003e：文件名。\n\u003ccode\u003e$tmpname\u003c/code\u003e：文件路径，如上传中的临时目录。\n\u003ccode\u003e$xmax\u003c/code\u003e：修改后最大宽度。\n\u003ccode\u003e$ymax\u003c/code\u003e：修改后最大高度。\u003c/p\u003e","title":"修改图片大小"},{"content":"不幸的是，无论您是否计划实际使用文件存储功能，adobe的creative cloud安装程序都会在安装任何creative cloud应用程序时将其添加到windows文件资源管理器侧栏中。 更糟糕的是，目前还没有办法通过文件资源管理器或创意云设置删除该边栏条目。 对于那些不喜欢文件资源管理器的人来说，无用的文件不必要地混乱，\n首先，请务必注意，从文件浏览器侧边栏中删除creative cloud文件后，以下步骤实际上并不会删除creative cloud files文件夹本身。 您仍然可以手动访问该文件夹，该文件夹默认位于c：\\ users \\ [user] \\ creative cloud files。\n这些步骤也不会禁用实际的creative cloud files存储或同步功能; 为此，您需要启动创意云桌面应用程序，点击齿轮图标，然后导航到首选项\u0026gt;创意云\u0026gt;文件，您可以在其中将“同步”设置为关闭。 最后，我们在本文中的截图是在windows 10中进行的，但这些步骤同样适用于windows 8.1。\n要从文件资源管理器侧栏中删除creative cloud文件，您需要修改windows注册表中的条目。 按桌面上的windows key + r启动注册表编辑器，然后在“运行”框中键入regedit。 按键盘上的enter键启动该实用程序并授权任何用户帐户控制提示。\n我们现在需要找到正确的注册表项，这将根据您的特定windows配置而有所不同，但将位于hkey_classes_root \\ clsid中的某个位置。 找到正确位置的最快方法是用find命令搜索它。 选中注册表编辑器后，按键盘上的control + f打开“find”窗口。 在“find what”框中键入“creative cloud files ”文件，然后取消选中“keys”和“values”框。 单击查找下一步继续。\n您的第一个结果可能是一个类似于上面截图的条目。 如果您收到不同的结果，请继续按键盘上的f3搜索其他条目，直到您到达一个看起来像示例截图那样的项。\n我们需要修改system.ispinnedtonamespacetree来从dword的file explorer侧栏中删除creative cloud files。 双击它以编辑其值，并将“value data”从默认值1设置为0。 单击确定保存更改。\n现在，退出并重新启动文件资源管理器。您应该看到创意云文件的条目不再存在于侧栏中。如果您仍然看到它，请重新启动计算机，这将确保文件资源管理器完全关闭并重新加载，以使更改生效。\n如上所述，您仍然可以通过手动导航到主用户文件夹中的文件夹来使用创意云文件同步; 这里的步骤只从文件浏览器侧边栏中删除其快捷方式。按照相同的方式，如果您的意图是完全杀死creative cloud文件同步，则还需要在creative cloud首选项中关闭该功能。\n如果您想要在文件资源管理器中恢复creative cloud files侧栏条目，只需重复上述步骤即可在注册表中找到正确的条目，将system.ispinnedtonamespacetree更改 回“1”，然后重新启动文件浏览器或重新启动pc。\n","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/windows/delete_creative_cloud/","summary":"\u003cp\u003e不幸的是，无论您是否计划实际使用文件存储功能，Adobe的Creative Cloud安装程序都会在安装任何Creative Cloud应用程序时将其添加到Windows文件资源管理器侧栏中。 更糟糕的是，目前还没有办法通过文件资源管理器或创意云设置删除该边栏条目。 对于那些不喜欢文件资源管理器的人来说，无用的文件不必要地混乱，\u003c/p\u003e","title":"从文件资源管理器边栏删除creative cloud"},{"content":"exe文件图标变成了白色无图标\n按键 “win+r” 输入即可cmd 然后输入分别输入 ：\ntaskkill /im explorer.exe /f cd /d %userprofile%\\appdata\\local del iconcache.db /a start explorer.exe exit 看了看这段代码，应该就是把图标缓存的数据库给删除了，然后再启动 explorer.exe\n","date":"2019-09-29","permalink":"https://blog.akvicor.com/posts/windows/white_icon/","summary":"\u003cp\u003eexe文件图标变成了白色无图标\u003c/p\u003e","title":"exe文件图标变成了白色无图标"},{"content":"uoj-2 起床困难综合征\n位运算的主要特点之一是在二进制表示下不进位，正因如此，在 $math_inline$x_0$math_inline$ 可以任意选择的情况下，参与位运算的各个位(bit)之间是独立无关的。对于任意的 $math_inline$k(0\\leq k \\leq 30)$math_inline$ ，“ans 的 k 位是几” 只与 “ $math_inline$x_0$math_inline$ 的第 k 位是几” 有关，与其他位无关，所以我们可以从高位到低位，依次考虑 $math_inline$x_0$math_inline$ 的每一位填 0 还是填 1。\n$math_inline$x_0$math_inline$ 的第 k 位填 1，当且仅当同时满足以下两个条件：\n已经填好的更高位构成的数值加上 1 \u0026lt;\u0026lt; k 以后不超过 m。 用每个参数的第 k 位参与位运算。若初值为 1，则 n 次运算后结果为 1，若初值为 0， 则 n 次运算后结果为 0。（若不管初值为 1 或 0，运算后的结果同时为 0 或 1，则填 0 更优，因为可以给后面的位留更大的选择空间）。 code code my #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef enum{ and = 1, or = 2, xor = 3 } bit; vector\u0026lt;pair\u0026lt;bit, int\u0026gt;\u0026gt; ops; bit get(const string\u0026amp; s){ if(s[0] == \u0026#39;a\u0026#39;) return and; else if(s[0] == \u0026#39;o\u0026#39;) return or; else return xor; } bool sol(int k, bool set){ for(auto \u0026amp;i : ops){ switch(i.first){ case and: set \u0026amp;= i.second \u0026gt;\u0026gt; k \u0026amp; 1; break; case or: set |= i.second \u0026gt;\u0026gt; k \u0026amp; 1; break; case xor: set ^= i.second \u0026gt;\u0026gt; k \u0026amp; 1; } } return set; } int main(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string op; int opi; for(int i = 0; i \u0026lt; n; ++i){ cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; opi; ops.emplace_back(get(op), opi); } unsigned int num = 0, res = 0; for(int i = 30; i \u0026gt;= 0; --i){ if(sol(i, 0)) res |= 1\u0026lt;\u0026lt;i; else if((num | (1 \u0026lt;\u0026lt; i)) \u0026lt;= m \u0026amp;\u0026amp; sol(i, 1)) res |= (1 \u0026lt;\u0026lt; i), num |= (1 \u0026lt;\u0026lt; i); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } code 1 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int n, m; pair\u0026lt;string, int\u0026gt; a[100005]; int calc(int bit, int now) { for (int i = 1; i \u0026lt;= n; i++) { int x = a[i].second \u0026gt;\u0026gt; bit \u0026amp; 1; if (a[i].first == \u0026#34;and\u0026#34;) now \u0026amp;= x; else if (a[i].first == \u0026#34;or\u0026#34;) now |= x; else now ^= x; } return now; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { char str[5]; int x; scanf(\u0026#34;%s%d\u0026#34;, str, \u0026amp;x); a[i] = make_pair(str, x); } int val = 0, ans = 0; for (int bit = 29; bit \u0026gt;= 0; bit--) { int res0 = calc(bit, 0); int res1 = calc(bit, 1); if (val + (1 \u0026lt;\u0026lt; bit) \u0026lt;= m \u0026amp;\u0026amp; res0 \u0026lt; res1) val += 1 \u0026lt;\u0026lt; bit, ans += res1 \u0026lt;\u0026lt; bit; else ans += res0 \u0026lt;\u0026lt; bit; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } code 2 #include \u0026lt;cstdio\u0026gt; const int maxn = 100000; const int maxm = 1e9; enum operatortype { and = 0, or = 1, xor = 2 }; struct bitwiseoperator { operatortype type; bool bits[32]; } ops[maxn]; int n; unsigned int m; inline bool check(const int k, const bool value) { bool flag = value; for (int i = 0; i \u0026lt; n; i++) { if (ops[i].type == and) flag \u0026amp;= ops[i].bits[k]; else if (ops[i].type == or) flag |= ops[i].bits[k]; else if (ops[i].type == xor) flag ^= ops[i].bits[k]; } return flag; } inline unsigned int solve() { unsigned int num = 0, ans = 0; for (int i = 32 - 1; i \u0026gt;= 0; i--) { if (check(i, 0)) ans |= (1 \u0026lt;\u0026lt; i); else if ((num | (1 \u0026lt;\u0026lt; i)) \u0026lt;= m \u0026amp;\u0026amp; check(i, 1)) ans |= (1 \u0026lt;\u0026lt; i), num |= (1 \u0026lt;\u0026lt; i); } return ans; } int main() { // freopen(\u0026#34;sleep.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;sleep.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d %u\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; n; i++) { bitwiseoperator \u0026amp;op = ops[i]; char str[sizeof(\u0026#34;and\u0026#34;)]; int x; scanf(\u0026#34;%s %d\u0026#34;, str, \u0026amp;x); if (str[0] == \u0026#39;a\u0026#39;) op.type = and; else if (str[0] == \u0026#39;o\u0026#39;) op.type = or; else if (str[0] == \u0026#39;x\u0026#39;) op.type = xor; for (int i = 0; i \u0026lt; 32; i++) op.bits[i] = ((x \u0026amp; (1 \u0026lt;\u0026lt; i)) == 0) ? false : true; // for (int i = 0; i \u0026lt; 32; i++) putchar(op.bits[i] ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;); // putchar(\u0026#39;\\n\u0026#39;); } printf(\u0026#34;%u\\n\u0026#34;, solve()); return 0; } ","date":"2019-09-14","permalink":"https://blog.akvicor.com/posts/cf/uoj_2/","summary":"\u003cp\u003e\u003ca href=\"https://uoj.ac/problem/2\"\u003eUOJ-2 起床困难综合征\u003c/a\u003e\u003c/p\u003e","title":"起床困难综合征"},{"content":"常用二进制操作\n常用的运算符共 6 种，分别为与（ \u0026amp; ）、或（ | ）、异或（ ^ ）、取反（ ~ ）、左移（ \u0026lt;\u0026lt; ）和右移（ \u0026gt;\u0026gt; ）。\n运算符 解释 \u0026amp; 只有在两个（对应位数中）都为 1 时才为 1 | 只要在两个（对应位数中）有一个 1 时就为 1 ^ 只有两个（对应位数）不同时才为 1 ^ 运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 (a ^ b) ^ b = a 。\n$math_inline$\\begin{aligned} \u00265\u0026=\u0026\u0026(101)_2\\\\ \u00266\u0026=\u0026\u0026(110)_2\\\\ \u00265\\tt\\,\\\u0026\\,6\\rm\u0026=\u0026\u0026(100)_2\u0026=\\ 4\\\\ \u00265\\tt\\,|\\,\\rm6\u0026=\u0026\u0026(111)_2\u0026=\\ 7\\\\ \u00265\\tt\\,\\text{^}\\,\\rm6\u0026=\u0026\u0026(011)_2\u0026=\\ 3\\\\ \\end{aligned}$math_inline$ 取反是对 1 个数 $math_inline$num$math_inline$ 进行的计算。\n~ 把 $math_inline$num$math_inline$ 的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）。\n补码——正数的补码为其（二进制）本身，负数的补码是其（二进制）取反后 $math_inline$+1$math_inline$ 。\n$math_inline$\\begin{aligned} 5=(0000\\ 0101)_2\\\\ 5\\ \\text{的补码} =(0000\\ 0101)_2\\\\ \\tt\\ \\text{~}\\rm5=(1111\\ 1010)_2 \\end{aligned}$math_inline$ 一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。比如集合 {1, 3, 4, 8} ，可以表示成 0b00000000000000000000000100011010 ，十进制就是 $math_inline$2^8+2^4+2^3+2^1=282$math_inline$ 。\n而对应的位运算也就可以看作是对集合进行的操作。\n操作 集合表示 位运算语句 交集 $math_inline$a \\cap b$math_inline$ a \u0026amp; b 并集 $math_inline$a \\cup b$math_inline$ `a 补集 $math_inline$\\bar{a}$math_inline$ ~a 差集 $math_inline$a \\setminus b$math_inline$ a \u0026amp; (~b) 对称差 $math_inline$a\\triangle b$math_inline$ a ^ b 常用操作 乘 2 n \u0026lt;\u0026lt; 1 除 2 负奇数的运算不可用\n我们平常写的除法是向 0 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 0 时两种方法等价，当数小于 0 时会有区别。 如： $math_inline$-1 \\div 2 = 0$math_inline$ , 而 $math_inline$-1 \u003e\u003e 1 = -1$math_inline$ n \u0026gt;\u0026gt; 1 乘以 2 的 m 次方。 n \u0026lt;\u0026lt; m 除以 2 的 m 次方。 n \u0026gt;\u0026gt; m 判断积偶性 // 结果为1 -\u0026gt; 奇数 // 结果为0 -\u0026gt; 偶数 n \u0026amp; 1 取绝对值 （某些机器上，效率比 n \u0026gt; 0 ? n : -n 高）。\n(n ^ (n \u0026gt;\u0026gt; 31)) - (n \u0026gt;\u0026gt; 31) /* n\u0026gt;\u0026gt;31 取得 n 的符号，若 n 为正数，n\u0026gt;\u0026gt;31 等于 0，若 n 为负数，n\u0026gt;\u0026gt;31 等于 - 1 若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1) 需要计算 n 和 - 1 的补码，然后进行异或运算， 结果 n 变号并且为 n 的绝对值减 1，再减去 - 1 就是绝对值 */ 取两个数的最大值 （某些机器上，效率比 a \u0026gt; b ? a : b 高）。\nb \u0026amp; ((a - b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a - b) \u0026gt;\u0026gt; 31) /* 如果 a\u0026gt;=b,(a-b)\u0026gt;\u0026gt;31 为 0，否则为 - 1 */ 取两个数的最小值 取两个数的最小值（某些机器上，效率比 a \u0026gt; b ? b : a 高）。\na \u0026amp; ((a - b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a - b) \u0026gt;\u0026gt; 31) /* 如果 a\u0026gt;=b,(a-b)\u0026gt;\u0026gt;31 为 0，否则为 - 1 */ 判断符号是否相同。 (x ^ y) \u0026gt;= 0 // 有 0 的情况例外 // true 表示 x 和 y 有相同的符号，false 表示 x,y 有相反的符号。 计算 2 的 n 次方。 1 \u0026lt;\u0026lt; n 判断一个数是不是 2 的幂。 n \u0026gt; 0 ? (n \u0026amp; (n - 1)) == 0 : false // 当然你也可以使用下面这种更为简便的写法: // return n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; (n - 1)) == 0; /* 如果是 2 的幂，n 一定是 100... n-1 就是 1111.... 所以做与运算结果为 0 */ 对 2 的 n 次方取余。 m \u0026amp; (n - 1) // n 为 2 的次方 /* 如果是 2 的幂，n 一定是 100... n-1 就是 1111.... 所以做与运算结果保留 m 在 n 范围的非 0 的位 */ 求两个整数的平均值。 (x + y) \u0026gt;\u0026gt; 1 交换两个数的值 效率可能并没有 int c = a; a = b; b = c; 高。\nvoid swap(int \u0026amp;a, int \u0026amp;b) { a = a ^ b; b = a ^ b; a = a ^ b; } 遍历一个集合的子集 int b = 0; do { // process subset b } while (b = (b - x) \u0026amp; x); 取出整数 n 在二进制表示下的第 k 位 (n \u0026gt;\u0026gt; k) \u0026amp; 1 取出整数 n 在二进制表示下的第 0 ~ k-1 位（后 k 位） n \u0026amp; ((1 \u0026lt;\u0026lt; k) - 1) 把整数 n 在二进制表示下的第 k 位取反 n ^ (1 \u0026lt;\u0026lt; k) 对整数 n 在二进制表示下的第 k 位赋值 1 n | (1 \u0026lt;\u0026lt; k) 对整数 n 在二进制表示下的第 k 位赋值 0 n \u0026amp; (~(1 \u0026lt;\u0026lt; k)) 成对变换 当 n 位偶数时，n ^ 1 等于 n + 1 当 n 位奇数时，n ^ 1 等于 n - 1 因此：0 与 1、2 与 3、4 与 5 关于 ^1 运算构成 “成对变换”\n这一性质经常用于图论邻接表中边集的存储。在具有无向边（双向边）的图中把一对正反方向的边分别存储在邻接表数组的第 n 与 n+1 位置（其中 n 为偶数），就可以通过 ^1 的运算获得与当前边 (x, y) 反向的边 (y, x) 的存储位置。\nlowbit 运算 lowbit(n) 定义为非负整数 n 在二进制表示下 “最低位的 1 及其后边所有的 0” 构成的数值。例如 $math_inline$n=10$math_inline$ 的二进制表示为 $math_inline$(1010)_2$math_inline$ 则 lowbit(n) = 2 = (10)_2。\n设 $math_inline$n \u003e 0$math_inline$ , n 的第 k 位是 1，第 0 ~ k-1 位都是 0。\n为了实现 lowbit 运算，先把 n 取反，此时第 k 位变为 0，第 0 ～ k-1 位都是 1 再令 n = n+1，此时因为进位，第 k 位变为 1，第 0 ～ k-1 位都是0.\n在上面的取反加 1 操作后，n 的第 k+1 位到最高位恰好与原来相反，所以 n\u0026amp;(~n+1) 仅有第 k 位为 1，其余位都是 0。而在补码表示下，~n = -1-n，因此；\nlowbit(n) = n\u0026amp;(~n+1) = n\u0026amp;(-n) 找出一个数的那些位为 1 利用上面的 lowbit，我们不断把 n 赋值为 n-lowbit(n)，直至 n = 0. 对 lowbit 值取对数即可得到所在位置，但 math 库自带的函数是以 e 为底的实数运算，且常数较大，所以可以预处理一个数组，利用 hash 的方法代替 log 运算。\nvoid f1(int n){ const int max_n = 1 \u0026lt;\u0026lt; 20; int h[max_n]; for(int i = 0; i \u0026lt; 20; ++i) h[1 \u0026lt;\u0026lt; i] = i; while(n \u0026gt; 0){ cout \u0026lt;\u0026lt; h[n \u0026amp; -n] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; n -= n \u0026amp; -n; } cout \u0026lt;\u0026lt; endl; } 稍微复杂但是效率更高的一个方法是建立一个长度为 37 的数组 h，令 $math_inline$h[2^k \\text{mod} 37] = k$math_inline$ 。这里利用了一个小小的数学技巧： $math_inline$\\forall(k)\\in [0, 35], 2^k \\text{mod} 37$math_inline$ 互不相等，且恰好取遍整数 1 ~ 36。\nvoid f2(int n){ int h[37]; for(int i = 0; i \u0026lt; 36; ++i) h[(1ll \u0026lt;\u0026lt; i) % 37] = i; while(n \u0026gt; 0){ cout \u0026lt;\u0026lt; h[(n \u0026amp; -n) % 37] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; n -= n \u0026amp; -n; } cout \u0026lt;\u0026lt; endl; } gcc 编译器还提供了一些内置函数，可以高效的计算 lowbit 以及二进制数中 1 的个数。不过这些并非 c 语言标准，有的函数更是与及其或编译器版本相关。\nint __buildin_ctz(usigned int x) int __buildin_ctzll(usigned long long x) // 返回 x 的二进制表示下最低位的 1 后边有多少个 0 int __builtin_popcount(usigned int x) int __builtin_popcountll(usigned long long x) // 返回 x 的二进制表示下有多少位为 1 ","date":"2019-09-14","permalink":"https://blog.akvicor.com/posts/algorithm/bit_operation/","summary":"\u003cp\u003e常用二进制操作\u003c/p\u003e","title":"二进制操作"},{"content":"acw-93 最短hamilton路径\n首先，很容易想到一种“朴素（brute-force）”做法，就是枚举n个点的全排列，计算路径长度取最小值，时间复杂度 $math_inline$o(n*n!)$math_inline$ 。\n如果利用二进制状态压缩 dp 可以优化到 $math_inline$o(n^2*2^n)$math_inline$ 在任意时刻，我们可以使用一个 n 位二进制数来表示那些点已经被访问过，那些点没有被访问过。如果第 i 位为 1，则代表第 i 位已经被访问过，反之则未被访问过。在任意时刻，我们还需要知道当前所在的位置，因此我们可以使用 f[i, j] $math_inline$0 \\leq i \u003c 2^n, 0 \\leq j \u003c n$math_inline$ 表示 “点未被经过的状态” 对应的二进制数为 i，且目前处于点 j 时的最短路径。\n在起点时，有 f[1,0] = 0，即只经过了点 0，（i 只有第 0 位为 1），目前处于起点 0，最短路长度为 0。最终目标是 f[(1\u0026lt;\u0026lt;n)-1, n-1]，即经过所有点（i的所有位均为1），处于终点 n-1 的最短路。\n在任意时刻，有公式 f[i, j] = min{f[i, j], f[i^(1\u0026lt;\u0026lt;j), k] + weight(k, j)} 其中 $math_inline$0 \\leq k \u003c n$math_inline$ 并且 ((i \u0026gt;\u0026gt; j) \u0026amp; 1) = 1，即当前时刻 “未被经过的点的状态” 对应的二进制数为 i，处于点 j。因为 j 只能被恰好经过一次，所以一定是刚刚经过的。故在上一时刻 “被经过的点的状态” 对应的二进制数的第 j 位应该赋值为 0，也就是 i ^ (1 \u0026lt;\u0026lt; j)。\n另外，上一时刻所处的位置可能是 i ^ (1 \u0026lt;\u0026lt; j) 中任意一个是 1 的位数 k，从 k 走到 j 需要经过 weight(k, j) 的路程，可以考虑所有这样的 k 取最小值。\ncode code 1 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int f[1 \u0026lt;\u0026lt; 20][20], weight[20][20], n; int hamilton(int n, int weight[20][20]) { memset(f, 0x3f, sizeof(f)); f[1][0] = 0; for (int i = 1; i \u0026lt; 1 \u0026lt;\u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) if (i \u0026gt;\u0026gt; j \u0026amp; 1) for (int k = 0; k \u0026lt; n; k++) if ((i^1\u0026lt;\u0026lt;j) \u0026gt;\u0026gt; k \u0026amp; 1) f[i][j] = min(f[i][j], f[i^1\u0026lt;\u0026lt;j][k]+weight[k][j]); return f[(1 \u0026lt;\u0026lt; n) - 1][n - 1]; } int main() { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;weight[i][j]); cout \u0026lt;\u0026lt; hamilton(n, weight) \u0026lt;\u0026lt; endl; } ","date":"2019-09-14","permalink":"https://blog.akvicor.com/posts/cf/acw_93/","summary":"\u003cp\u003e\u003ca href=\"https://www.acwing.com/problem/content/93/\"\u003eACW-93 最短Hamilton路径\u003c/a\u003e\u003c/p\u003e","title":"最短hamilton路径"},{"content":"快速乘\no(log) 快速幂思想 类似于快速幂的思想，把整数 b 用二进制表示，即\n$math_inline$b=c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_{0}2^{0}$math_inline$ 那么\n$math_inline$a * b=c_{k-1} * a * 2^{k-1}+c_{k-2} * a * 2^{k-2}+...+c_{0} * a * 2^{0}$math_inline$ 因为 $math_inline$a * 2^i=(a * 2^{i-1}) * 2$math_inline$ ，若已求出 $math_inline$a * 2^{i-1}\\text{mod}p$math_inline$ ，则计算 $math_inline$a * 2^{i-1}\\text{mod}p$math_inline$ 时，运算过程中的每一步结果都不超过 $math_inline$2 * 10^{18}$math_inline$ o(1) 特殊情况下易精度丢失导致答案错误 利用 $math_inline$a * b\\text{mod}p = a * b-\\lfloor a * b/p \\rfloor * p$math_inline$ 首先，当 $math_inline$a,b \u003c p$math_inline$ 时， $math_inline$a * b/p$math_inline$ 下取整以后也一定小于 $math_inline$p$math_inline$ 。我们可以用浮点数执行 $math_inline$a * b/p$math_inline$ 的运算，而不用关心小数点之后的部分。long double 在十进制下有效位为 18~19 位。当浮点数的精度不足以保存精确数值时，它会像科学计数法一样舍弃低位，正好符合我们的要求。\n虽然 $math_inline$a * b$math_inline$ 和 $math_inline$\\lfloor a * b/p \\rfloor * p$math_inline$ 可能很大，但是两者的差一定在 0~p-1之间。所以我们用 long long 来保存 $math_inline$a * b$math_inline$ 和 $math_inline$\\lfloor a * b/p \\rfloor * p$math_inline$ 各自的记过。整数运算溢出相当于舍弃高位，也正好符合我们的要求。\ncode code 1 // o(1) ll mul(ll a, ll b, ll p) { return ((__int128)a*b)%p; } // o(1) ll mul(ll a, ll b, ll p) { a %= p; b %= p; ll c = (long double)a * b / p; ll ans = a * b - c * p; return (ans % p + p) % p; } // o(log) ll mul(ll a, ll b, ll p) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % p; a = a * 2 % p; b \u0026gt;\u0026gt;= 1; } return ans; } problem 64 bit integer multiplication\n","date":"2019-09-13","permalink":"https://blog.akvicor.com/posts/algorithm/64bit_multiplication/","summary":"\u003cp\u003e快速乘\u003c/p\u003e","title":"64位整数乘法"},{"content":"快速幂\n根据数学常识，每一个正整数可以唯一表示为若干指数不重复的 2 的次幂的和。\n$math_inline$3^{13} = 3^{(1101)_2} = 3^8 \\cdot 3^4 \\cdot 3^1$math_inline$ 也就是说，如果 b 在二进制表示下有 k 位，其中第 $math_inline$i(0 \\leq i \u003c k)$math_inline$ 位的数字是 $math_inline$c_i$math_inline$ ，那么\n$math_inline$b=c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_{0}2^{0}$math_inline$ 于是\n$math_inline$a^b=a^{c_{k-1}*2^{k-1}}*a^{c_{k-2}*2^{k-2}}*...*a^{c_0}*2^0$math_inline$ 因为 $math_inline$k=\\lceil\\log_2{(b+1)}\\rceil$math_inline$ ，所以上式乘积的数量不多于 $math_inline$\\lceil\\log_2{(b+1)}\\rceil$math_inline$ 个\n又因为 $math_inline$a^{2^i}=\\left(a^{2^{i-1}}\\right)^2$math_inline$ ，所以很容易通过 k 次递推求出每个乘积项，当 $math_inline$c_i=1$math_inline$ 时，把该乘积项累积到答案中\n因此为了计算 $math_inline$3^{13}$math_inline$ ，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了\n$math_inline$13 = (1101)_2$math_inline$ $math_inline$3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$math_inline$ $math_inline$\\begin{align} 3^1 \u0026= 3 \\\\ 3^2 \u0026= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 \u0026= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 \u0026= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$math_inline$ code code 1 ll quick_pow(ll a, ll b, ll p) { a %= p; ll res = 1 % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) res = res * a % p; a = a * a % p; } return res; } problem a^b\n","date":"2019-09-13","permalink":"https://blog.akvicor.com/posts/algorithm/quick_pow/","summary":"\u003cp\u003e快速幂\u003c/p\u003e","title":"快速幂 a^b"},{"content":"codeforces template\nvim syntax on set cindent set nu set tabstop=4 set shiftwidth=4 set background=dark map \u0026lt;c-a\u0026gt; ggvg\u0026#34;+y map \u0026lt;f5\u0026gt; :call run()\u0026lt;cr\u0026gt; func! run() exec \u0026#34;w\u0026#34; exec \u0026#34;!g++ -wall % -o %\u0026lt;\u0026#34; exec \u0026#34;!./%\u0026lt;\u0026#34; endfunc #!/bin/bash for name in {a..m}; do cp a.cpp $name.cpp done filetype plugin indent on colorscheme desert syntax on set nu set backspace=2 set hlsearch set syntax=on set tabstop=4 set shiftwidth=4 set smarttab set smartindent set showmatch set matchtime=0 set report=0 :inoremap ( ()\u0026lt;esc\u0026gt;i :inoremap [ []\u0026lt;esc\u0026gt;i :inoremap { {}\u0026lt;esc\u0026gt;i :inoremap {\u0026lt;cr\u0026gt; {\u0026lt;cr\u0026gt;}\u0026lt;esc\u0026gt;o :inoremap ) \u0026lt;c-r\u0026gt;=close(\u0026#39;)\u0026#39;)\u0026lt;cr\u0026gt; :inoremap ] \u0026lt;c-r\u0026gt;=close(\u0026#39;]\u0026#39;)\u0026lt;cr\u0026gt; :inoremap } \u0026lt;c-r\u0026gt;=close(\u0026#39;}\u0026#39;)\u0026lt;cr\u0026gt; function close(char) if getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;) - 1] == a:char return \u0026#34;\\\u0026lt;right\u0026gt;\u0026#34; else return a:char endif endfunction map \u0026lt;c-a\u0026gt; ggvg\u0026#34;+y map \u0026lt;f5\u0026gt; :call run()\u0026lt;cr\u0026gt; func! run() exec \u0026#34;w\u0026#34; exec \u0026#34;!g++-7 -o2 -std=c++11 -wall % -o %\u0026lt;\u0026#34; exec \u0026#34;!./%\u0026lt;\u0026#34; endfunc map \u0026lt;f12\u0026gt; :call settitle()\u0026lt;cr\u0026gt; func settitle() let l = 0 let l = l + 1 | call setline(l,\u0026#39;/* ***********************************************\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;author : akvicor\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;created time : \u0026#39;.strftime(\u0026#39;%c\u0026#39;)) let l = l + 1 | call setline(l,\u0026#39;file name : \u0026#39;.expand(\u0026#39;%\u0026#39;)) let l = l + 1 | call setline(l,\u0026#39;************************************************ */\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#include \u0026lt;bits/stdc++.h\u0026gt;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;using namespace std;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;int main(){\u0026#39;) let l = l + 1 | call setline(l,\u0026#39; fast_io;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39; \u0026#39;) let l = l + 1 | call setline(l,\u0026#39; return 0;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;}\u0026#39;) endfunc 快速幂 ll quick_pow(ll a, ll b, ll p) { ll res = 1 % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) res = res * a % p; a = a * a % p; } return res; } 快速乘 // o(1) ll mul(ll a, ll b, ll p) { return ((__int128)a*b)%p; } // o(1) ll mul(ll a, ll b, ll p) { a %= p; b %= p; ll c = (long double)a * b / p; ll ans = a * b - c * p; return (ans % p + p) % p; } // o(log) ll mul(ll a, ll b, ll p) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % p; a = a * 2 % p; b \u0026gt;\u0026gt;= 1; } return ans; } 欧拉φ函数 int geteuler(int n) { //欧拉函数 int res = n; for(int i = 2;i*i \u0026lt;= n; ++i){ if(a%i == 0){ res -= res/i; while(n%i == 0) n /= i; } } if(a \u0026gt; 1) // 因为是遍历到sqrt(n)，所以可能存在未除尽或者n本身就为质数的情况 res -= res/n; return res; } int phi(int x) { //欧拉函数 int i, re = x; for (i = 2; i * i \u0026lt;= x; i++) if (x % i == 0) { re /= i; re *= i - 1; while (x % i == 0) x /= i; } if (x ^ 1) re /= x, re *= x - 1; return re; } 欧拉函数线性筛 const int maxn = 1e6; //欧拉线性筛：在线性时间内筛素数的同时求出所有数的欧拉函数 int tot; int phi[maxn]; //保存各个数字的欧拉函数 int prime[maxn]; //按顺序保存素数 bool mark[maxn]; //判断是否是素数 void get_phi(int n){ phi[1] = 1; for(int i = 2; i \u0026lt;= maxn; i++){ //相当于分解质因数的逆过程 if(!mark[i]){ prime[++tot] = i; phi[i] = i-1; } for(int j = 1; j \u0026lt;= tot; j++){ if(i * prime[j] \u0026gt; n) break; mark[i * prime[j]] = 1; //确定i*prime[j]不是素数 if(i % prime[j] == 0){ //判断prime[j] 是否为 i的约数 phi[i * prime[j]] = phi[i] * prime[j]; break; } else{ //prime[j] - 1 就是 phi[prime[j]],利用了欧拉函数的积性 phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } } } green公式-判断多边形边界曲线顺/逆时针 double d = 0; for (int i = 0; i \u0026lt; n - 1; i++) { d += -0.5 * ( y[i + 1] + y[i]) * (x[i + 1] - x[i]); } if ( d \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;counter clockwise\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;clockwise\u0026#34; \u0026lt;\u0026lt; endl; dijkstra const int inf = 0x3f3f3f3f; #define maxn 1000+100 int path[maxn][maxn], dis[maxn]; // 地图 起点到达i的距离 bool vis[maxn]; // 是否访问过 int n, t; // 地标数 路径数 void init() { for (int i = 0; i \u0026lt; maxn; ++i) { for (int j = 0; j \u0026lt; maxn; ++j) { path[i][j] = inf; } path[i][i] = 0; } } void dijkstra(){ // 将1到i的距离初始化 for (int i = 1; i \u0026lt;= n; i++) { dis[i] = path[1][i]; vis[i] = false; } vis[1] = true; // 标记起点为访问过的 dis[1] = 0; // 起点到起点的距离为0 for (int i = 2; i \u0026lt;= n; i++) { // 从2号节点遍历到n号节点 int now = -1, minl = inf; // 遍历一遍dis数组，寻找到未访问过的到1最短的路径长度 for (int j = 1; j \u0026lt;= n; j++) { // 从1到n if (!vis[j] \u0026amp;\u0026amp; minl \u0026gt; dis[j]) { // 如果没有访问过当前节点，并且当前从1到j的距离小于最大长度 now = j; // 更新最短路径的位置 minl = dis[j]; // 最短距离等于当前 } } if (now == -1) break; // 未找到 vis[now] = true; // 将now标记为访问过 // 从1开始寻找到j最短的路径 for (int j = 1; j \u0026lt;= n; j++) { // 没有访问过 并且当前已走的长度加上走到j节点的长度小于当前dis[j] if (!vis[j] \u0026amp;\u0026amp; (dis[now] + path[now][j]) \u0026lt; dis[j]) { dis[j] = dis[now] + path[now][j]; // 更新从起点到j的最短路径 } } } } int main() { freopen(\u0026#34;in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // 从指定文件输入数据 提交时注释掉 // memset(path, int_max, sizeof(path)); while (scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;t) != eof) { init(); for (int i = 0; i \u0026lt; t; i++) { int from, to, len; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;from, \u0026amp;to, \u0026amp;len); if (path[from][to] \u0026gt; len) path[from][to] = path[to][from] = len; } dijkstra(); for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;1 to %d min= %d\\n\u0026#34;, i, dis[i]); } } return 0; } 素性测试 bool is_prime(int n){ /* 判定一个数是不是素数 ，假设输入的数都是正整数 */ for (int i = 2; i * i \u0026lt;= n; i++) { if (!(n % i)) return false; } return n != 1; /* 1是例外 */ } const int s = 8; ll mult_mod(ll a, ll b, ll c){ a %= c; b %= c; ll ret = 0; ll tmp = a; while(b){ if(b\u0026amp;1){ ret += tmp; if(ret \u0026gt; c) ret -= c; } tmp \u0026lt;\u0026lt;= 1; if(tmp \u0026gt; c) tmp -= c; b \u0026gt;\u0026gt;= 1; } return ret; } ll pow_mod(ll a, ll n, ll mod){ ll ret = 1; ll temp = a % mod; while(n){ if(n \u0026amp; 1) ret = mult_mod(ret, temp, mod); temp = mult_mod(temp, temp, mod); n \u0026gt;\u0026gt;= 1; } return ret; } bool check(ll a, ll n, ll x, ll t){ ll ret = pow_mod(a, x, n); ll last = ret; loop(i, 1, t){ ret = mult_mod(ret, ret, n); if(ret == 1 \u0026amp;\u0026amp; last != 1 \u0026amp;\u0026amp; last != n-1) return true; last = ret; } if(ret != 1) return true; else return false; } bool miller_rabin(ll n){ if(n \u0026lt; 2) return false; if(n == 2) return true; if((n\u0026amp;1)==0) return false; ll x = n-1; ll t = 0; while((x\u0026amp;1)==0){x \u0026gt;\u0026gt;= 1; ++t;} srand(time(null)); rep(i, s){ ll a = rand()%(n-1)+1; if(check(a, n, x, t)) return false; } return true; } 埃氏筛法 bool is_prime[100]; int prime[100]; int sieve(int n) { /* 枚举n以内的素数 */ /* 返回n以内素数的个数，素数存在prime数组里 */ int p = 0; for (int i = 0; i \u0026lt;= n; i++) is_prime[i] = true; is_prime[0] = is_prime[1] = false; for (int i = 2; i \u0026lt;= n; i++) { if (is_prime[i]) { prime[p++] = i; for (int j = i * 2; j \u0026lt;= n; j += i) is_prime[j] = false; } } return p; } 区间筛法 #define m 100000000 typedef long long ll; bool is_prime_small[m]; bool is_prime[m]; ll ans = 0; void prime(ll a, ll b) { for (ll i = 2; i * i \u0026lt; b; i++) is_prime_small[i] = true; //初始化2~b^(1/2) for (ll i = 0; i \u0026lt; b - a; i++) is_prime[i] = true; //因为a,b很大，所以用0~b-a 代表a~b for (ll i = 2; i * i \u0026lt; b; i++) { if (is_prime_small[i]) { for (ll j = 2 * i; j * j \u0026lt; b; j += i) is_prime_small[j] = false; for (ll j = max(2ll, (a + i - 1) / i) * i; j \u0026lt; b; j += i) { //找到从a开始的第一个合数 if (is_prime[j - a]) { ans++; //求出几个合数。 //或者也可以最后遍历b-a这区间，求出质数的个数。 is_prime[j - a] = false; } } } } } int main() { ll a, b; ans = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; prime(a, b); // for(ll i = 0;i \u0026lt; b-a;i++) // if(is_prime[i]) ans++; cout \u0026lt;\u0026lt; \u0026#34;ans = \u0026#34; \u0026lt;\u0026lt; b - a - ans \u0026lt;\u0026lt; endl; return 0; } 线段树 class segmenttree{ private: int * tree; int n; public: int * temp; segmenttree(unsigned int n){ tree = new int [(n\u0026lt;\u0026lt;2u) +10u]; temp = new int [(n\u0026lt;\u0026lt;2u) +10u]; this-\u0026gt;n = n; } ~segmenttree(){ delete[] tree; delete[] temp; } /** * 建树 */ void init(){ build(1, 1, this-\u0026gt;n); } /** * 建树 * @param p p树 * @param l 区间左端点 * @param r 区间右端点 */ void build(int p, int l, int r){ if(l == r){ tree[p] = temp[l]; return; } int mid = l + (r - l) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); tree[p] = tree[p * 2] + tree[p * 2 + 1]; } /** * 更新 * @param p 当前节点编号 * @param l 区间左界 * @param r 区间右界 * @param x 需要修改的节点编号 * @param num 操作 */ void change(int p, int l, int r, int x, int num){ if(l == r){ tree[p] += num; if(tree[p]\u0026lt;0) tree[p] = 0; return; } int mid = l + (r - l) / 2; if(x \u0026lt;= mid) change(p * 2, l, mid, x, num); else change(p * 2 + 1, mid + 1, r, x, num); tree[p] = tree[p * 2] + tree[p * 2 + 1]; } /** * 查询 * @param p 在p这棵树 * @param l p的左区间端点 * @param r p的右区间端点 * @param x 查询区间左端点 * @param y 查询区间右端点 * @return 区间和 */ int find(int p, int l, int r, int x, int y){ if(x \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= y) return tree[p]; int mid = l + (r - l) / 2; if(y \u0026lt;= mid) return find(p * 2, l, mid, x, y); if(x \u0026gt; mid) return find(p * 2 + 1, mid + 1, r, x, y); return find(p * 2, l, mid, x, mid) + find(p * 2 + 1, mid + 1, r, mid + 1, y); } }; 最大子列和问题 int maxsequence3(int a[], int len) { int maxsum, maxhere; maxsum = maxhere = a[0]; //初始化最大和为a【0】 for (int i=1; i\u0026lt;len; i++) { if (maxhere \u0026lt;= 0) maxhere = a[i]; //如果前面位置最大连续子序列和小于等于0，则以当前位置i结尾的最大连续子序列和为a[i] else maxhere += a[i]; //如果前面位置最大连续子序列和大于0，则以当前位置i结尾的最大连续子序列和为它们两者之和 if (maxhere \u0026gt; maxsum) { maxsum = maxhere; //更新最大连续子序列和 } } return maxsum; } 约数个数定理 int f1(int n) { int r = (int) sqrt(1.0 * n); int sum = 0; if (r * r == n) { sum++; r--; } for (int i = 1; i \u0026lt;= r; i++) if (n % i == 0) { sum += 2; } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } // 稍快于f1 int f2(int n){ int s = 1, r; for (int i = 2; i * i \u0026lt;= n; i++) { r = 0; while (n % i == 0) { r++; n /= i; } if (r \u0026gt; 0) { r++; s *= r; } } if (n \u0026gt; 1) s *= 2; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } ll f3(ll n) { ll res=1; for(ll i=2;i*i\u0026lt;=n;i++){ ll k=0; while(n%i == 0){ n = n/i; k++; } if(k) res *= (k+1); } if(n != 1) res=res*2; if(res==1){ if(n==1) return 1; else return 2; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } 约数和定理 ll qpow(ll x, ll y) { ll res = 1; while (y) { if (y \u0026amp; 1) res *= x; x *= x; y \u0026gt;\u0026gt;= 1; } return res; } ll getsum(ll n) {//返回n的约数和是多少. ll res = 1; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) { n = n / i; k++; } res *= ((1 - qpow(i, k + 1)) / (1 - i)); } //用等比数列公式(快速幂)算. if (n != 1) res *= (1 + n); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } 大整数 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // base and base_digits must be consistent constexpr int base = 1000000000; constexpr int base_digits = 9; struct bigint { // value == 0 is represented by empty z vector\u0026lt;int\u0026gt; z; // digits // sign == 1 \u0026lt;==\u0026gt; value \u0026gt;= 0 // sign == -1 \u0026lt;==\u0026gt; value \u0026lt; 0 int sign; bigint() : sign(1) {} bigint(long long v) { *this = v; } bigint \u0026amp;operator=(long long v) { sign = v \u0026lt; 0 ? -1 : 1; v *= sign; z.clear(); for (; v \u0026gt; 0; v = v / base) z.push_back((int) (v % base)); return *this; } bigint(const string \u0026amp;s) { read(s); } bigint \u0026amp;operator+=(const bigint \u0026amp;other) { if (sign == other.sign) { for (int i = 0, carry = 0; i \u0026lt; other.z.size() || carry; ++i) { if (i == z.size()) z.push_back(0); z[i] += carry + (i \u0026lt; other.z.size() ? other.z[i] : 0); carry = z[i] \u0026gt;= base; if (carry) z[i] -= base; } } else if (other != 0 /* prevent infinite loop */) { *this -= -other; } return *this; } friend bigint operator+(bigint a, const bigint \u0026amp;b) { return a += b; } bigint \u0026amp;operator-=(const bigint \u0026amp;other) { if (sign == other.sign) { if (sign == 1 \u0026amp;\u0026amp; *this \u0026gt;= other || sign == -1 \u0026amp;\u0026amp; *this \u0026lt;= other) { for (int i = 0, carry = 0; i \u0026lt; other.z.size() || carry; ++i) { z[i] -= carry + (i \u0026lt; other.z.size() ? other.z[i] : 0); carry = z[i] \u0026lt; 0; if (carry) z[i] += base; } trim(); } else { *this = other - *this; this-\u0026gt;sign = -this-\u0026gt;sign; } } else { *this += -other; } return *this; } friend bigint operator-(bigint a, const bigint \u0026amp;b) { return a -= b; } bigint \u0026amp;operator*=(int v) { if (v \u0026lt; 0) sign = -sign, v = -v; for (int i = 0, carry = 0; i \u0026lt; z.size() || carry; ++i) { if (i == z.size()) z.push_back(0); long long cur = (long long) z[i] * v + carry; carry = (int) (cur / base); z[i] = (int) (cur % base); } trim(); return *this; } bigint operator*(int v) const { return bigint(*this) *= v; } friend pair\u0026lt;bigint, bigint\u0026gt; divmod(const bigint \u0026amp;a1, const bigint \u0026amp;b1) { int norm = base / (b1.z.back() + 1); bigint a = a1.abs() * norm; bigint b = b1.abs() * norm; bigint q, r; q.z.resize(a.z.size()); for (int i = (int) a.z.size() - 1; i \u0026gt;= 0; i--) { r *= base; r += a.z[i]; int s1 = b.z.size() \u0026lt; r.z.size() ? r.z[b.z.size()] : 0; int s2 = b.z.size() - 1 \u0026lt; r.z.size() ? r.z[b.z.size() - 1] : 0; int d = (int) (((long long) s1 * base + s2) / b.z.back()); r -= b * d; while (r \u0026lt; 0) r += b, --d; q.z[i] = d; } q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); return {q, r / norm}; } friend bigint sqrt(const bigint \u0026amp;a1) { bigint a = a1; while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0); int n = a.z.size(); int firstdigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]); int norm = base / (firstdigit + 1); a *= norm; a *= norm; while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0); bigint r = (long long) a.z[n - 1] * base + a.z[n - 2]; firstdigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]); int q = firstdigit; bigint res; for (int j = n / 2 - 1; j \u0026gt;= 0; j--) { for (;; --q) { bigint r1 = (r - (res * 2 * base + q) * q) * base * base + (j \u0026gt; 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0); if (r1 \u0026gt;= 0) { r = r1; break; } } res *= base; res += q; if (j \u0026gt; 0) { int d1 = res.z.size() + 2 \u0026lt; r.z.size() ? r.z[res.z.size() + 2] : 0; int d2 = res.z.size() + 1 \u0026lt; r.z.size() ? r.z[res.z.size() + 1] : 0; int d3 = res.z.size() \u0026lt; r.z.size() ? r.z[res.z.size()] : 0; q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstdigit * 2)); } } res.trim(); return res / norm; } bigint operator/(const bigint \u0026amp;v) const { return divmod(*this, v).first; } bigint operator%(const bigint \u0026amp;v) const { return divmod(*this, v).second; } bigint \u0026amp;operator/=(int v) { if (v \u0026lt; 0) sign = -sign, v = -v; for (int i = (int) z.size() - 1, rem = 0; i \u0026gt;= 0; --i) { long long cur = z[i] + rem * (long long) base; z[i] = (int) (cur / v); rem = (int) (cur % v); } trim(); return *this; } bigint operator/(int v) const { return bigint(*this) /= v; } int operator%(int v) const { if (v \u0026lt; 0) v = -v; int m = 0; for (int i = (int) z.size() - 1; i \u0026gt;= 0; --i) m = (int) ((z[i] + m * (long long) base) % v); return m * sign; } bigint \u0026amp;operator*=(const bigint \u0026amp;v) { return *this = *this * v; } bigint \u0026amp;operator/=(const bigint \u0026amp;v) { return *this = *this / v; } bool operator\u0026lt;(const bigint \u0026amp;v) const { if (sign != v.sign) return sign \u0026lt; v.sign; if (z.size() != v.z.size()) return z.size() * sign \u0026lt; v.z.size() * v.sign; for (int i = (int) z.size() - 1; i \u0026gt;= 0; i--) if (z[i] != v.z[i]) return z[i] * sign \u0026lt; v.z[i] * sign; return false; } bool operator\u0026gt;(const bigint \u0026amp;v) const { return v \u0026lt; *this; } bool operator\u0026lt;=(const bigint \u0026amp;v) const { return !(v \u0026lt; *this); } bool operator\u0026gt;=(const bigint \u0026amp;v) const { return !(*this \u0026lt; v); } bool operator==(const bigint \u0026amp;v) const { return !(*this \u0026lt; v) \u0026amp;\u0026amp; !(v \u0026lt; *this); } bool operator!=(const bigint \u0026amp;v) const { return *this \u0026lt; v || v \u0026lt; *this; } void trim() { while (!z.empty() \u0026amp;\u0026amp; z.back() == 0) z.pop_back(); if (z.empty()) sign = 1; } bool iszero() const { return z.empty(); } friend bigint operator-(bigint v) { if (!v.z.empty()) v.sign = -v.sign; return v; } bigint abs() const { return sign == 1 ? *this : -*this; } long long longvalue() const { long long res = 0; for (int i = (int) z.size() - 1; i \u0026gt;= 0; i--) res = res * base + z[i]; return res * sign; } friend bigint gcd(const bigint \u0026amp;a, const bigint \u0026amp;b) { return b.iszero() ? a : gcd(b, a % b); } friend bigint lcm(const bigint \u0026amp;a, const bigint \u0026amp;b) { return a / gcd(a, b) * b; } void read(const string \u0026amp;s) { sign = 1; z.clear(); int pos = 0; while (pos \u0026lt; s.size() \u0026amp;\u0026amp; (s[pos] == \u0026#39;-\u0026#39; || s[pos] == \u0026#39;+\u0026#39;)) { if (s[pos] == \u0026#39;-\u0026#39;) sign = -sign; ++pos; } for (int i = (int) s.size() - 1; i \u0026gt;= pos; i -= base_digits) { int x = 0; for (int j = max(pos, i - base_digits + 1); j \u0026lt;= i; j++) x = x * 10 + s[j] - \u0026#39;0\u0026#39;; z.push_back(x); } trim(); } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;stream, bigint \u0026amp;v) { string s; stream \u0026gt;\u0026gt; s; v.read(s); return stream; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;stream, const bigint \u0026amp;v) { if (v.sign == -1) stream \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; stream \u0026lt;\u0026lt; (v.z.empty() ? 0 : v.z.back()); for (int i = (int) v.z.size() - 2; i \u0026gt;= 0; --i) stream \u0026lt;\u0026lt; setw(base_digits) \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; v.z[i]; return stream; } static vector\u0026lt;int\u0026gt; convert_base(const vector\u0026lt;int\u0026gt; \u0026amp;a, int old_digits, int new_digits) { vector\u0026lt;long long\u0026gt; p(max(old_digits, new_digits) + 1); p[0] = 1; for (int i = 1; i \u0026lt; p.size(); i++) p[i] = p[i - 1] * 10; vector\u0026lt;int\u0026gt; res; long long cur = 0; int cur_digits = 0; for (int v : a) { cur += v * p[cur_digits]; cur_digits += old_digits; while (cur_digits \u0026gt;= new_digits) { res.push_back(int(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; } } res.push_back((int) cur); while (!res.empty() \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } typedef vector\u0026lt;long long\u0026gt; vll; static vll karatsubamultiply(const vll \u0026amp;a, const vll \u0026amp;b) { int n = a.size(); vll res(n + n); if (n \u0026lt;= 32) { for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) res[i + j] += a[i] * b[j]; return res; } int k = n \u0026gt;\u0026gt; 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubamultiply(a1, b1); vll a2b2 = karatsubamultiply(a2, b2); for (int i = 0; i \u0026lt; k; i++) a2[i] += a1[i]; for (int i = 0; i \u0026lt; k; i++) b2[i] += b1[i]; vll r = karatsubamultiply(a2, b2); for (int i = 0; i \u0026lt; a1b1.size(); i++) r[i] -= a1b1[i]; for (int i = 0; i \u0026lt; a2b2.size(); i++) r[i] -= a2b2[i]; for (int i = 0; i \u0026lt; r.size(); i++) res[i + k] += r[i]; for (int i = 0; i \u0026lt; a1b1.size(); i++) res[i] += a1b1[i]; for (int i = 0; i \u0026lt; a2b2.size(); i++) res[i + n] += a2b2[i]; return res; } bigint operator*(const bigint \u0026amp;v) const { vector\u0026lt;int\u0026gt; a6 = convert_base(this-\u0026gt;z, base_digits, 6); vector\u0026lt;int\u0026gt; b6 = convert_base(v.z, base_digits, 6); vll a(a6.begin(), a6.end()); vll b(b6.begin(), b6.end()); while (a.size() \u0026lt; b.size()) a.push_back(0); while (b.size() \u0026lt; a.size()) b.push_back(0); while (a.size() \u0026amp; (a.size() - 1)) a.push_back(0), b.push_back(0); vll c = karatsubamultiply(a, b); bigint res; res.sign = sign * v.sign; for (int i = 0, carry = 0; i \u0026lt; c.size(); i++) { long long cur = c[i] + carry; res.z.push_back((int) (cur % 1000000)); carry = (int) (cur / 1000000); } res.z = convert_base(res.z, 6, base_digits); res.trim(); return res; } }; bigint random_bigint(int n) { string s; for (int i = 0; i \u0026lt; n; i++) { s += rand() % 10 + \u0026#39;0\u0026#39;; } return bigint(s); } // random tests void biginttest() { bigint x = bigint(\u0026#34;120\u0026#34;); bigint y = bigint(\u0026#34;5\u0026#34;); cout \u0026lt;\u0026lt; x / y \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 1000; i++) { int n = rand() % 100 + 1; bigint a = random_bigint(n); bigint res = sqrt(a); bigint xx = res * res; bigint yy = (res + 1) * (res + 1); if (xx \u0026gt; a || yy \u0026lt;= a) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; break; } int m = rand() % n + 1; bigint b = random_bigint(m) + 1; res = a / b; xx = res * b; yy = b * (res + 1); if (xx \u0026gt; a || yy \u0026lt;= a) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; break; } } bigint a = random_bigint(10000); bigint b = random_bigint(2000); clock_t start = clock(); bigint c = a / b; printf(\u0026#34;time=%.3lfsec\\n\u0026#34;, (clock() - start) * 1. / clocks_per_sec); } string str(bigint b) { stringstream ss; ss \u0026lt;\u0026lt; b; string s; ss \u0026gt;\u0026gt; s; return s; } 并查集 namespace uf1{ class unionfind{ private: int* parent; // parent[i]表示第i个元素所指向的父节点 int* sz; // sz[i]表示以i为根的集合中元素个数 int count; // 数据个数 public: // 构造函数 unionfind(int count){ parent = new int[count]; sz = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; sz[i] = 1; } } // 析构函数 ~unionfind(){ delete[] parent; delete[] sz; } // 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } // 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( sz[proot] \u0026lt; sz[qroot] ){ parent[proot] = qroot; sz[qroot] += sz[proot]; } else{ parent[qroot] = proot; sz[proot] += sz[qroot]; } } }; } namespace uf2{ class unionfind{ private: int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int* parent; // parent[i]表示第i个元素所指向的父节点 int count; // 数据个数 public: // 构造函数 unionfind(int count){ parent = new int[count]; rank = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; rank[i] = 1; } } // 析构函数 ~unionfind(){ delete[] parent; delete[] rank; } // 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } // 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( rank[proot] \u0026lt; rank[qroot] ){ parent[proot] = qroot; } else if( rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; } else{ // rank[proot] == rank[qroot] parent[proot] = qroot; rank[qroot] += 1; // 此时, 我维护rank的值 } } }; } 直线划分平面 while(cin\u0026gt;\u0026gt;n) cout\u0026lt;\u0026lt;n*(n+1)/2+1\u0026lt;\u0026lt;endl; 判断两个线段相交 # 点 class point(object): def __init__(self, x, y): self.x, self.y = x, y # 向量 class vector(object): def __init__(self, start_point, end_point): self.start, self.end = start_point, end_point self.x = end_point.x - start_point.x self.y = end_point.y - start_point.y zero = 1e-9 def negative(vector): \u0026#34;\u0026#34;\u0026#34;取反\u0026#34;\u0026#34;\u0026#34; return vector(vector.end_point, vector.start_point) def vector_product(vectora, vectorb): \u0026#39;\u0026#39;\u0026#39;计算 x_1 * y_2 - x_2 * y_1\u0026#39;\u0026#39;\u0026#39; return vectora.x * vectorb.y - vectorb.x * vectora.y def is_intersected(a, b, c, d): \u0026#39;\u0026#39;\u0026#39;a, b, c, d 为 point 类型\u0026#39;\u0026#39;\u0026#39; ac = vector(a, c) ad = vector(a, d) bc = vector(b, c) bd = vector(b, d) ca = negative(ac) cb = negative(bc) da = negative(ad) db = negative(bd) return (vector_product(ac, ad) * vector_product(bc, bd) \u0026lt;= zero) \\ and (vector_product(ca, cb) * vector_product(da, db) \u0026lt;= zero) 网络流 struct flow_dinic { flow_dinic(int n) { head = vector\u0026lt;int\u0026gt;(n + 10, -1); level = vector\u0026lt;int\u0026gt;(n + 10); } struct edge { int to, cap, next; }; vector\u0026lt;int\u0026gt; head; vector\u0026lt;int\u0026gt; level; int s = 0, t = 0; // max_flow from s to t vector\u0026lt;struct edge\u0026gt; edge; void add_edge(int u, int v, int c) { edge.push_back((struct edge) {v, c, head[u]}); head[u] = edge.size() - 1; edge.push_back((struct edge) {u, 0, head[v]}); head[v] = edge.size() - 1; } bool bfs() { fill(level.begin(), level.end(), 0); level[s] = 1; queue\u0026lt;int\u0026gt; que; que.push(s); while (!que.empty()) { for (int i = head[que.front()]; ~i; i = edge[i].next) { if (edge[i].cap \u0026amp;\u0026amp; !level[edge[i].to]) { level[edge[i].to] = level[que.front()] + 1; que.push(edge[i].to); if (edge[i].to == t) return true; } } que.pop(); } return false; } int dfs(int f, int u) { if (u == t) return f; int d = 0, used = 0; for (int i = head[u]; ~i; i = edge[i].next) { if (edge[i].cap \u0026amp;\u0026amp; level[u] == level[edge[i].to] - 1) { if ((d = dfs(min(f - used, edge[i].cap), edge[i].to))) { edge[i].cap -= d; edge[i ^ 1].cap += d; used += d; } } } if (!used) level[u] = 0; return used; } long long run(int _s, int _t) { s = _s; t = _t; long long max_flow = 0; while (bfs()) { int d = 0; while ((d = dfs(0x3f3f3f3f, s))) max_flow += d; } return max_flow; } }; struct dinic { dinic(int n) { g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 10); d = vector\u0026lt;int\u0026gt; (n+10); vis = vector\u0026lt;bool\u0026gt; (n+10); cur = vector\u0026lt;int\u0026gt; (n+10); } struct edge { int from, to, cap, flow; }; int s, t; //节点数,边数,源点编号,汇点编号 vector\u0026lt;edge\u0026gt; edges; //边表,edges[e]和edges[e^1]互为反向弧 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; //邻接表,g[i][j]表示节点i的第j条边在e中的序号 vector\u0026lt;bool\u0026gt; vis; //bfs用 vector\u0026lt;int\u0026gt; d; //从起点到i的距离 vector\u0026lt;int\u0026gt; cur; //当前弧下标 void add_edge(int from, int to, int cap) { edges.push_back({from, to, cap, 0}); edges.push_back({to, from, 0, 0}); g[from].push_back(edges.size() - 2); g[to].push_back(edges.size() - 1); } bool bfs() { fill(vis.begin(), vis.end(), false); queue\u0026lt;int\u0026gt; q; q.push(s); d[s] = 0; vis[s] = true; while (!q.empty()) { for (int id : g[q.front()]) { edge \u0026amp;e = edges[id]; if (!vis[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; e.flow) { vis[e.to] = true; d[e.to] = d[q.front()] + 1; q.push(e.to); } } q.pop(); } return vis[t]; } long long dfs(int u, int a) { if (u == t || a == 0) return a; int flow = 0, f; for (int \u0026amp;i = cur[u]; i \u0026lt; (int) g[u].size(); ++i) { edge \u0026amp;e = edges[g[u][i]]; if (d[u] + 1 == d[e.to] \u0026amp;\u0026amp; (f = dfs(e.to, min(a, e.cap - e.flow))) \u0026gt; 0) { e.flow += f; edges[g[u][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow; } long long run(int _s, int _t) { s = _s; t = _t; long long flow = 0; while (bfs()) { fill(cur.begin(), cur.end(), 0); flow += dfs(s, 0x3f3f3f3f); } return flow; } }; 最大子矩阵 mod(1e9+7); maxn(1010); int mp[maxn][maxn], l[maxn], r[maxn]; priority_queue \u0026lt;int\u0026gt; ans; void solve(){ fast_io; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; loop(i, 1, n) loop(j, 1, m){ char c; cin \u0026gt;\u0026gt; c; mp[i][j] = (c == \u0026#39;1\u0026#39;); } loop(i, 2, n) loop(j, 1, m) if(mp[i-1][j] \u0026amp;\u0026amp; mp[i][j]) mp[i][j] += mp[i-1][j]; loop(i, 1, n){ set\u0026lt;pair\u0026lt;int, pii\u0026gt; \u0026gt; s; stack\u0026lt;int\u0026gt; a, b; loop(j, 1, m){ while(!a.empty() \u0026amp;\u0026amp; mp[i][a.top()] \u0026gt;= mp[i][j]) a.pop(); l[j] = a.size() ? a.top()+1 : 1; a.push(j); } for(int j = m; j \u0026gt;= 1; --j){ while(!b.empty() \u0026amp;\u0026amp; mp[i][b.top()] \u0026gt;= mp[i][j]) b.pop(); r[j] = b.size() ? b.top() - 1 : m; b.push(j); } loop(j, 1, m){ if(mp[i][j]){ pair\u0026lt;int, pii\u0026gt; temp = mp(r[j], mp(l[j], mp[i][j])); pair\u0026lt;int ,pii\u0026gt; temp2; if(!s.count(temp)){ ans.push((r[j] - l[j]+1)*mp[i][j]); s.insert(temp); } if(r[j] - l[j]){ temp = mp(r[j], mp(l[j]+1, mp[i][j])); temp2 = mp(r[j]-1, mp(l[j], mp[i][j])); if(!s.count(temp)){ ans.push((r[j] - l[j]) * mp[i][j]); s.insert(temp); }else if(s.count(temp2)){ ans.push((r[j]-l[j])*mp[i][j]); s.insert(temp2); } } } } } if(ans.size()\u0026lt;2) ans.push(0); ans.pop(); cout \u0026lt;\u0026lt; ans.top() \u0026lt;\u0026lt; endl; } // 速度更快，但只能求前几大 mod(1e9+7); maxn(1e3); int n, m; string s; int high[maxn]; int mxx, mxx2; int stkhg[maxn], stkpos[maxn]; int cnt; void solve(){ fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; high[m+1] = 0; loop(i, 1, n){ cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;-- line #\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; s; loop(j, 1, m) high[j] = s[j-1]==\u0026#39;0\u0026#39; ? 0 : high[j]+1; #ifdef debug cout \u0026lt;\u0026lt; \u0026#34;str: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;high: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; high[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; #endif stkhg[0] = stkpos[0] = cnt = 0; loop(j, 1, m+1){ if(high[j] \u0026gt; stkhg[cnt]){ // 如果比上一格高，说明可以构成矩形，就push进栈 stkhg[++cnt] = high[j]; stkpos[cnt] = j; }else if(high[j] \u0026lt; stkhg[cnt]){ // 如果比上一格矮， // 那么高度等于上一格高度的矩形已经完全找出来了， // 当前格比上一格矮，不能参与构成上个矩形 while(high[j] \u0026lt; stkhg[cnt]){ // 将栈中高于当前位置的高度全部出栈 int area = (j-stkpos[cnt]) * stkhg[cnt]; // 当前位置坐标-比当前格高的格的坐标就是宽度 // 更新前两大矩形 if(area \u0026gt;= mxx){ mxx2 = mxx; mxx = area; mxx2 = max(mxx2, max(area-stkhg[cnt], area-(j-stkpos[j]))); }else if(area \u0026gt; mxx2){ mxx2 = area; } --cnt; } if(stkhg[cnt] != high[j]){ stkhg[++cnt] = high[j]; } } #ifdef debug cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkhg: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkhg[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkpos: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkpos[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mxx: \u0026#34; \u0026lt;\u0026lt; mxx \u0026lt;\u0026lt; \u0026#34; mxx2: \u0026#34; \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; #endif } } cout \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; } 拓展欧几里得 $math_inline$ax+by=\\gcd(a, b)$math_inline$ void exgcd(ll a, ll b, ll \u0026amp;x, ll \u0026amp;y) { if (b == 0) { x = 1;y = 0; } else { exgcd(b, a%b, y, x); y -= (a/b) * x; } } void extgcd(ll a, ll b, ll \u0026amp;d, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { d = a; x = 1; y = 0; } else { extgcd(b, a % b, d, y, x); y -= x * (a / b); } } ll inverse(ll a, ll n) { ll d, x, y; extgcd(a, n, d, x, y); return d == 1 ? (x + n) % n : -1; } 递推求1~n的逆元 const int n = 1e5 + 5; int inv[n]; void inverse(int n, int p) { inv[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { inv[i] = (ll) (p - p / i) * inv[p % i] % p; } } 递推求n!的逆元 // 快速幂求逆元 int quick_inverse(int n, int p) { int ret = 1; int exponent = p - 2; for (int i = exponent; i; i \u0026gt;\u0026gt;= 1, n = n * n % p) { if (i \u0026amp; 1) { ret = ret * n % p; } } return ret; } int invf[n], factor[n]; void get_factorial_inverse(int n, int p) { factor[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { factor[i] = i * factor[i - 1] % p; } invf[n] = quick_inverse(factor[n], p); for (int i = n-1; i \u0026gt;= 0; --i) { invf[i] = invf[i + 1] * (i + 1) % p; } } lowbit lowbit(n) = n\u0026amp;(~n+1) = n\u0026amp;(-n) 数的那些位为1 void f2(int n){ int h[37]; for(int i = 0; i \u0026lt; 36; ++i) h[(1ll \u0026lt;\u0026lt; i) % 37] = i; while(n \u0026gt; 0){ cout \u0026lt;\u0026lt; h[(n \u0026amp; -n) % 37] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; n -= n \u0026amp; -n; } cout \u0026lt;\u0026lt; endl; } 最短hamilton路径 int f[1 \u0026lt;\u0026lt; 20][20], weight[20][20], n; int hamilton(int n, int weight[20][20]) { memset(f, 0x3f, sizeof(f)); f[1][0] = 0; for (int i = 1; i \u0026lt; 1 \u0026lt;\u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) if (i \u0026gt;\u0026gt; j \u0026amp; 1) for (int k = 0; k \u0026lt; n; k++) if ((i^1\u0026lt;\u0026lt;j) \u0026gt;\u0026gt; k \u0026amp; 1) f[i][j] = min(f[i][j], f[i^1\u0026lt;\u0026lt;j][k]+weight[k][j]); return f[(1 \u0026lt;\u0026lt; n) - 1][n - 1]; } int main() { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;weight[i][j]); cout \u0026lt;\u0026lt; hamilton(n, weight) \u0026lt;\u0026lt; endl; } 卡特兰数 前三十项卡特兰数表 [1,1,2,5,14,42,132,429,1430,4862,16796,58786, 208012,742900,2674440,9694845,35357670,129644790, 477638700,1767263190,6564120420,24466267020, 91482563640,343059613650,1289904147324, 4861946401452,18367353072152,69533550916004, 263747951750360,1002242216651368,3814986502092304] 卡特兰数求模模板 const int c_maxn = 1e4 + 10; ll catalannum[c_maxn]; ll inv[c_maxn]; inline void catalan_mod(int n, ll mod) { inv[1] = 1; for(int i=2; i\u0026lt;=n+1; i++)///线性预处理 1 ~ n 关于 mod 的逆元 inv[i] = (mod - mod / i) * inv[mod % i] % mod; catalannum[0] = catalannum[1] = 1; for(int i=2; i\u0026lt;=n; i++) catalannum[i] = catalannum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod; } 卡特兰大数模板 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int c_maxn = 100 + 10;///项数 int catalan_num[c_maxn][1000];///保存卡特兰大数、第二维为具体每个数位的值 int numlen[c_maxn];///每个大数的数长度、输出的时候需倒序输出 void catalan() //求卡特兰数 { int i, j, len, carry, temp; catalan_num[1][0] = numlen[1] = 1; len = 1; for(i = 2; i \u0026lt; 100; i++) { for(j = 0; j \u0026lt; len; j++) //乘法 catalan_num[i][j] = catalan_num[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j \u0026lt; len; j++) //处理相乘结果 { temp = catalan_num[i][j] + carry; catalan_num[i][j] = temp % 10; carry = temp / 10; } while(carry) //进位处理 { catalan_num[i][len++] = carry % 10; carry /= 10; } carry = 0; for(j = len-1; j \u0026gt;= 0; j--) //除法 { temp = carry*10 + catalan_num[i][j]; catalan_num[i][j] = temp/(i+1); carry = temp%(i+1); } while(!catalan_num[i][len-1]) //高位零处理 len --; numlen[i] = len; } } int main(void) { catalan(); for(int i=1; i\u0026lt;=30; i++){ for(int j=numlen[i]-1; j\u0026gt;=0; j--){ printf(\u0026#34;%d\u0026#34;, catalan_num[i][j]); }puts(\u0026#34;\u0026#34;); } return 0; } ","date":"2019-09-11","permalink":"https://blog.akvicor.com/posts/cf/template/","summary":"\u003cp\u003e\u003cstrong\u003eCodeforces Template\u003c/strong\u003e\u003c/p\u003e","title":"template"},{"content":"上传镜像 docker images docker login docker tag hello-world etanqil/test docker push etanqil/test 停止、删除所有的docker容器和镜像 # 列出所有的容器 id docker ps -aq # 停止所有的容器 docker stop $(docker ps -aq) # 删除所有的容器 docker rm $(docker ps -aq) # 删除所有的镜像 docker rmi $(docker images -q) 现在的docker有了专门清理资源(container、image、网络)的命令。 docker 1.13 中增加了 docker system prune的命令，针对container、image可以使用 docker container prune、docker image prune 命令。\ndocker image prune --force --all 或者 docker image prune -f -a : #删除所有不使用的镜像\ndocker container prune -f : #删除所有停止的容器\n","date":"2019-09-08","permalink":"https://blog.akvicor.com/posts/docker/manual/","summary":"上传镜像 docker images docker login docker tag hello-world etanqil/test docker push etanqil/test 停止、删除所有的docker容器和镜像 # 列出所有的容器 ID docker ps -aq # 停止所有的容器 docker stop $(docker ps -aq) # 删除所有的容器 docker rm $(docker ps -aq) # 删除所有的镜像","title":"manual"},{"content":" bzoj-2154 crash 的数字表格\n易知原式等价于\n$math_inline$ \\sum_{i=1}^n\\sum_{j=1}^m\\frac{i\\cdot j}{\\gcd(i,j)} $math_inline$ 枚举最大公因数 $math_inline$d$math_inline$ ，显然两个数除以 $math_inline$d$math_inline$ 得到的数互质\n$math_inline$ \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d\\mid i,d\\mid j,\\gcd(\\frac{i}{d},\\frac{j}{d})=1}\\frac{i\\cdot j}{d} $math_inline$ 非常经典的 $math_inline$\\gcd$math_inline$ 式子的化法\n$math_inline$ \\sum_{d=1}^n d\\cdot\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}[\\gcd(i,j)=1]\\ i\\cdot j $math_inline$ 后半段式子中，出现了互质数对之积的和，为了让式子更简洁就把它拿出来单独计算。于是我们记\n$math_inline$ \\text{sum}(n,m)=\\sum_{i=1}^n\\sum_{j=1}^m [\\gcd(i,j)=1]\\ i\\cdot j $math_inline$ 接下来对 $math_inline$\\text{sum}(n,m)$math_inline$ 进行化简。首先枚举约数，并将 $math_inline$[\\gcd(i,j)=1]$math_inline$ 表示为 $math_inline$\\varepsilon(\\gcd(i,j))$math_inline$ $math_inline$ \\sum_{d=1}^n\\sum_{d\\mid i}^n\\sum_{d\\mid j}^m\\mu(d)\\cdot i\\cdot j $math_inline$ 设 $math_inline$i=i'\\cdot d$math_inline$ ， $math_inline$j=j'\\cdot d$math_inline$ ，显然式子可以变为\n$math_inline$ \\sum_{d=1}^n\\mu(d)\\cdot d^2\\cdot\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}i\\cdot j $math_inline$ 观察上式，前半段可以预处理前缀和；后半段又是一个范围内数对之和，记\n$math_inline$ g(n,m)=\\sum_{i=1}^n\\sum_{j=1}^m i\\cdot j=\\frac{n\\cdot(n+1)}{2}\\times\\frac{m\\cdot(m+1)}{2} $math_inline$ 可以 $math_inline$\\theta(1)$math_inline$ 求解\n至此\n$math_inline$ \\text{sum}(n,m)=\\sum_{d=1}^n\\mu(d)\\cdot d^2\\cdot g(\\lfloor\\frac{n}{d}\\rfloor,\\lfloor\\frac{m}{d}\\rfloor) $math_inline$ 我们可以 $math_inline$\\lfloor\\frac{n}{\\lfloor\\frac{n}{d}\\rfloor}\\rfloor$math_inline$ 数论分块求解 $math_inline$\\text{sum}(n,m)$math_inline$ 函数。\n在求出 $math_inline$\\text{sum}(n,m)$math_inline$ 后，回到定义 $math_inline$\\text{sum}$math_inline$ 的地方，可得原式为\n$math_inline$ \\sum_{d=1}^n d\\cdot\\text{sum}(\\lfloor\\frac{n}{d}\\rfloor,\\lfloor\\frac{m}{d}\\rfloor) $math_inline$ 可见这又是一个可以数论分块求解的式子！\n本题除了推式子比较复杂、代码细节较多之外，是一道很好的莫比乌斯反演练习题！（上述过程中，默认 $math_inline$n\\leqslant m$math_inline$ ）\n时间复杂度： $math_inline$\\theta(n+m)$math_inline$ （两次数论分块）\ncode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int n = 1e7; const int mod = 20101009; int n, m, mu[n + 5], p[n / 10 + 5], sum[n + 5]; bool flg[n + 5]; void init() { mu[1] = 1; int tot = 0, k = min(n, m); for (int i = 2; i \u0026lt;= k; ++i) { if (!flg[i]) p[++tot] = i, mu[i] = -1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt;= k; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } for (int i = 1; i \u0026lt;= k; ++i) sum[i] = (sum[i - 1] + 1ll * i * i % mod * (mu[i] + mod)) % mod; } int sum(int x, int y) { return (1ll * x * (x + 1) / 2 % mod) * (1ll * y * (y + 1) / 2 % mod) % mod; } int func(int x, int y) { int res = 0; for (int i = 1, j; i \u0026lt;= min(x, y); i = j + 1) { j = min(x / (x / i), y / (y / i)); res = (res + 1ll * (sum[j] - sum[i - 1] + mod) * sum(x / i, y / i) % mod) % mod; } return res; } int solve(int x, int y) { int res = 0; for (int i = 1, j; i \u0026lt;= min(x, y); i = j + 1) { j = min(x / (x / i), y / (y / i)); res = (res + 1ll * (j - i + 1) * (i + j) / 2 % mod * func(x / i, y / i) % mod) % mod; } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; init(); cout \u0026lt;\u0026lt; solve(n, m) \u0026lt;\u0026lt; endl; } ","date":"2019-08-19","permalink":"https://blog.akvicor.com/posts/cf/bzoj_2154/","summary":"\u003cp\u003e\u003ca href=\"https://bzoj.net/p/2154\"\u003e BZOJ-2154 Crash 的数字表格\u003c/a\u003e\u003c/p\u003e","title":"crash 的数字表格"},{"content":" bzoj-2301「haoi 2011」problem b\n求值（多组数据）\n$math_inline$ \\sum_{i=x}^{n}\\sum_{j=y}^{m}[\\gcd(i,j)=k]\\qquad (1\\leqslant t,x,y,n,m,k\\leqslant 5\\times 10^4) $math_inline$ 根据容斥原理，原式可以分成 $math_inline$4$math_inline$ 块来处理，每一块的式子都为\n$math_inline$ \\sum_{i=1}^{n}\\sum_{j=1}^{m}[\\gcd(i,j)=k] $math_inline$ 考虑化简该式子\n$math_inline$ \\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}[\\gcd(i,j)=1] $math_inline$ 因为 $math_inline$\\gcd(i,j)=1$math_inline$ 时对答案才用贡献，于是我们可以将其替换为 $math_inline$\\varepsilon(\\gcd(i,j))$math_inline$ （ $math_inline$\\varepsilon(n)$math_inline$ 当且仅当 $math_inline$n=1$math_inline$ 时值为 $math_inline$1$math_inline$ 否则为 $math_inline$0$math_inline$ ），故原式化为\n$math_inline$ \\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}\\varepsilon(\\gcd(i,j)) $math_inline$ 将 $math_inline$\\varepsilon$math_inline$ 函数展开得到\n$math_inline$ \\displaystyle\\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}\\sum_{d\\mid \\gcd(i,j)}\\mu(d) $math_inline$ 变换求和顺序，先枚举 $math_inline$d\\mid gcd(i,j)$math_inline$ 可得\n$math_inline$ \\displaystyle\\sum_{d=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\mu(d)\\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}d\\mid i\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}d\\mid j $math_inline$ （其中 $math_inline$d\\mid i$math_inline$ 表示 $math_inline$i$math_inline$ 是 $math_inline$d$math_inline$ 的倍数时对答案有 $math_inline$1$math_inline$ 的贡献） 易知 $math_inline$1\\sim\\lfloor\\dfrac{n}{k}\\rfloor$math_inline$ 中 $math_inline$d$math_inline$ 的倍数有 $math_inline$\\lfloor\\dfrac{n}{kd}\\rfloor$math_inline$ 个，故原式化为\n$math_inline$ \\displaystyle\\sum_{d=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\mu(d) \\lfloor\\frac{n}{kd}\\rfloor\\lfloor\\frac{m}{kd}\\rfloor $math_inline$ 很显然，式子可以数论分块求解（注意：过程中默认 $math_inline$n\\leqslant m$math_inline$ ）。\n时间复杂度 ： $math_inline$\\theta(n+t\\sqrt{n})$math_inline$ code #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int n = 50000; int mu[n + 5], p[n + 5]; bool flg[n + 5]; void init() { int tot = 0; mu[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!flg[i]) { p[++tot] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } for (int i = 1; i \u0026lt;= n; ++i) mu[i] += mu[i - 1]; } int solve(int n, int m) { int res = 0; for (int i = 1, j; i \u0026lt;= std::min(n, m); i = j + 1) { j = std::min(n / (n / i), m / (m / i)); res += (mu[j] - mu[i - 1]) * (n / i) * (m / i); } return res; } int main() { int t, a, b, c, d, k; init(); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; solve(b / k, d / k) - solve(b / k, (c - 1) / k) - solve((a - 1) / k, d / k) + solve((a - 1) / k, (c - 1) / k) \u0026lt;\u0026lt; endl; } return 0; } code 2 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; namespace sol { const int maxn = 50011; const int maxl = 50000; ll a, b, c, d, k, ans; int prime[maxn], cnt; bool ok[maxn]; int mobius[maxn], sum[maxn]; //莫比乌斯函数及其前缀和 inline void init() { //递推得到莫比乌斯函数 //1的莫比乌斯函数是1；质数的莫比乌斯函数为1；含有相同质因子的数莫比乌斯函数为0； //不含有相同质因子的数的莫比乌斯函数函数为（-1）^k，k为质因子个数 mobius[1] = 1; for (int i = 2; i \u0026lt;= maxl; i++) { if (!ok[i]) { mobius[i] = -1; prime[++cnt] = i; } for (int j = 1; j \u0026lt;= cnt \u0026amp;\u0026amp; i * prime[j] \u0026lt;= maxl; j++) { ok[i * prime[j]] = 1;//标记合数 if (i % prime[j]) mobius[i * prime[j]] = -mobius[i];//互质的两个数乘起来得到一个不含有相同质因子的数，质因子个数奇偶性改变，莫比乌斯函数变号 else { mobius[i * prime[j]] = 0; break; }//留到后面再筛，此处已经可以break } } for (int i = 1; i \u0026lt;= maxl; i++) sum[i] = sum[i - 1] + mobius[i];//求莫比乌斯函数的前缀和 } inline ll solve(ll n, ll m) {//计算a在[1,n]且b在[1,m]中的gcd(a,b)==1的数目 n /= k; m /= k; if (n \u0026gt; m) swap(n, m); if (n == 0) return 0; ll i, next1, next2, next;//把相等的部分直接分块一起计算 ll tot = 0; for (i = 1; i \u0026lt;= n; i = next) { next1 = n / (n / i); next2 = m / (m / i); next = min(next1, next2); tot += (n / i) * (m / i) * (sum[next] - sum[i - 1]); next++; } return tot; } inline void work() { int t; cin \u0026gt;\u0026gt; t; init(); while (t--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; k; ans = solve(b, d) - solve(a - 1, d) - solve(b, c - 1) + solve(a - 1, c - 1);//容斥原理 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } } int main() { sol::work(); return 0; } ","date":"2019-08-19","permalink":"https://blog.akvicor.com/posts/cf/bzoj_2301/","summary":"\u003cp\u003e\u003ca href=\"https://bzoj.net/p/2301\"\u003e BZOJ-2301「HAOI 2011」Problem b\u003c/a\u003e\u003c/p\u003e","title":"「haoi 2011」problem b"},{"content":" bzoj-1042 [haoi2008]硬币购物\n背包 dp + 容斥原理\n如果用背包做的话复杂度是 $math_inline$o(4ns)$math_inline$ ，无法承受。这道题最明显的特点就是硬币一共只有四种。抽象模型，其实就是让我们求方程 $math_inline$\\sum_{i=1}^4c_ix_i=s,x_i\\leq d_i$math_inline$ 的非负整数解的个数。\n采用同样的容斥方式， $math_inline$x_i$math_inline$ 的属性为 $math_inline$x_i\\leq d_i$math_inline$ . 套用容斥原理的公式，最后我们要求解\n$math_inline$ \\sum_{i=1}^4c_ix_i=s-\\sum_{i=1}^kc_{a_i}(d_{a_i}+1) $math_inline$ 也就是无限背包问题。这个问题可以预处理，算上询问，总复杂度 $math_inline$o(4s+2^4n)$math_inline$ .\n首先，求出不限制使用次数，购买价值为 $math_inline$c$math_inline$ 时的方案数，设它为 $math_inline$f(c)$math_inline$ 。\n对于每次询问，我们可以不限制使用次数，购买价值 $math_inline$s_i$math_inline$ 的方案数，减去任意一种硬币超过限制的方案数。\n任意一种硬币超过限制的方案数可以用容斥原理求出，即：每一种硬币超过限制的方案数之和-每两种硬币超过限制的方案数之和+每三种硬币超过限制的方案数之和-四种硬币全部超过限制的方案数。\n考虑如何求出第 $math_inline$i$math_inline$ 种硬币超过限制的方案数：我们至少要使用 $math_inline$d_i+1$math_inline$ 个第 $math_inline$i$math_inline$ 种硬币，剩余的 $math_inline$s-(d_i+1)\\times c_i$math_inline$ 元可以任意选择，即 $math_inline$f(s-(d_i+1)\\times c_i)$math_inline$ code 1 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int s = 1e5 + 5; int c[5], d[5], n, s; long long f[s]; int main() { cin \u0026gt;\u0026gt; c[1] \u0026gt;\u0026gt; c[2] \u0026gt;\u0026gt; c[3] \u0026gt;\u0026gt; c[4] \u0026gt;\u0026gt; n; f[0] = 1; for (int j = 1; j \u0026lt;= 4; j++) for (int i = 1; i \u0026lt; s; i++) if (i \u0026gt;= c[j]) f[i] += f[i - c[j]]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; d[1] \u0026gt;\u0026gt; d[2] \u0026gt;\u0026gt; d[3] \u0026gt;\u0026gt; d[4] \u0026gt;\u0026gt; s; long long ans = 0; for (int j = 1; j \u0026lt; 16; j++) { int m = s, bit = 0; for (int k = 1; k \u0026lt;= 4; k++) if ((j \u0026gt;\u0026gt; (k - 1)) \u0026amp; 1) m -= (d[k] + 1) * c[k], bit++; if (m \u0026gt;= 0) ans += (bit % 2 * 2 - 1) * f[m]; } cout \u0026lt;\u0026lt; f[s] - ans \u0026lt;\u0026lt; endl; } return 0; } code 2 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxm = 1e5; int main() { int c[5], n; // ofstream cout; cout.open(\u0026#34;out\u0026#34;); cin \u0026gt;\u0026gt; c[1] \u0026gt;\u0026gt; c[2] \u0026gt;\u0026gt; c[3] \u0026gt;\u0026gt; c[4] \u0026gt;\u0026gt; n; static long long f[5][maxm + 1]; f[0][0] = 1; for (int i = 1; i \u0026lt;= 4; ++i) { // total number of programs for (int j = 0; j \u0026lt;= maxm; ++j) { if (j \u0026lt; c[i]) f[i][j] = f[i - 1][j]; else f[i][j] = f[i - 1][j] + f[i][j - c[i]]; } } /* cout \u0026lt;\u0026lt; \u0026#34;coin #\u0026#34; \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; c[0] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for(int j = 0; j \u0026lt;= 50; ++j) cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; left \u0026lt;\u0026lt; j; cout \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt;= 4; ++i){ cout \u0026lt;\u0026lt; \u0026#34;coin #\u0026#34; \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for(int j = 0; j \u0026lt;= 50; ++j){ cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; left \u0026lt;\u0026lt; f[i][j]; }cout \u0026lt;\u0026lt; endl; } */ while (n--) { int d[5], m; cin \u0026gt;\u0026gt; d[1] \u0026gt;\u0026gt; d[2] \u0026gt;\u0026gt; d[3] \u0026gt;\u0026gt; d[4] \u0026gt;\u0026gt; m; long long ans = f[4][m]; // total number of programs in m // 每一枚硬币超过限制 -a-b-c-d for (int i = 1; i \u0026lt;= 4; ++i) { if (m - (d[i] + 1) * c[i] \u0026gt;= 0) ans -= f[4][m - (d[i] + 1) * c[i]]; } // 每二枚硬币超过限制 +ab+ac+ad+bc+bd+cd for (int i = 1; i \u0026lt;= 4; ++i) { for (int j = i + 1; j \u0026lt;= 4; ++j) { if (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] \u0026gt;= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]]; } } // 每三枚硬币全部超过限制 -abc-abd-acd-bcd for (int i = 1; i \u0026lt;= 4; ++i) { for (int j = i + 1; j \u0026lt;= 4; ++j) { for (int k = j + 1; k \u0026lt;= 4; ++k) { if (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] \u0026gt;= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]]; } } } // 每四枚硬币全部超过限制 +abcd if (m - ((d[1] + 1) * c[1]) - ((d[2] + 1) * c[2]) - ((d[3] + 1) * c[3]) - ((d[4] + 1) * c[4]) \u0026gt;= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } ","date":"2019-08-19","permalink":"https://blog.akvicor.com/posts/cf/bzoj_1042/","summary":"\u003cp\u003e\u003ca href=\"https://bzoj.net/p/1042\"\u003e BZOJ-1042 [HAOI2008]硬币购物\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e背包 DP + 容斥原理\u003c/p\u003e","title":"「haoi2008」硬币购物"},{"content":"假设班里有 $math_inline$10$math_inline$ 个学生喜欢数学， $math_inline$15$math_inline$ 个学生喜欢语文， $math_inline$21$math_inline$ 个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？\n是 $math_inline$10+15+21=46$math_inline$ 个吗？不是的，因为有些学生可能同时喜欢数学和语文，或者语文和编程，甚至还有可能三者都喜欢。\n为了叙述方便，我们把喜欢语文、数学、编程的学生集合分别用 $math_inline$a,b,c$math_inline$ 表示，则学生总数等于 $math_inline$|a\\cup b\\cup c|$math_inline$ 。\n刚才已经讲过，如果把这三个集合的元素个数 $math_inline$|a|,|b|,|c|$math_inline$ 直接加起来，会有一些元素重复统计了，因此需要扣掉 $math_inline$|a\\cap b|,|b\\cap c|,|c\\cap a|$math_inline$ ，但这样一来，又有一小部分多扣了，需要加回来，即 $math_inline$|a\\cap b\\cap c|$math_inline$ 。\n即： $math_inline$|a\\cup b\\cup c|=|a|+|b|+|c|-|a\\cap b|-|b\\cap c|-|c\\cap a|+|a\\cap b\\cap c|$math_inline$ 把上述问题推广到一般情况，就是我们熟知的容斥原理。\n容斥原理 设 u 中元素有 n 种不同的属性，而第 i 种属性称为 $math_inline$p_i$math_inline$ ，拥有属性 $math_inline$p_i$math_inline$ 的元素构成集合 $math_inline$s_i$math_inline$ ，那么\n$math_inline$ \\begin{split} \\left|\\bigcup_{i=1}^{n}s_i\\right|=\u0026\\sum_{i}|s_i|-\\sum_{i","date":"2019-08-15","permalink":"https://blog.akvicor.com/posts/algorithm/inclusion_exclusion_principle/","summary":"\u003cp\u003e假设班里有\n\n    \n        $math_inline$10$math_inline$\n    \n\n个学生喜欢数学，\n\n    \n        $math_inline$15$math_inline$\n    \n\n个学生喜欢语文，\n\n    \n        $math_inline$21$math_inline$\n    \n\n个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？\u003c/p\u003e","title":"容斥原理"},{"content":"给定任意正整数 $math_inline$n$math_inline$ ，那么在小于等于 $math_inline$n$math_inline$ 的所有正整数之中，有多少个与 $math_inline$n$math_inline$ 构成互质关系？\n计算这个值的方法就叫做欧拉函数 $math_inline$\\phi(n)$math_inline$ 表示：在 $math_inline$1$math_inline$ 到 $math_inline$n$math_inline$ 之中，与n构成互质关系的数的数量。\n分析 情况一 如果 $math_inline$n=1$math_inline$ ，则 $math_inline$\\phi(1)=1$math_inline$ 。因为1与任何数（包括自身）都构成互质关系\n情况二 如果 $math_inline$n$math_inline$ 是质数，则 $math_inline$\\phi(n)=n-1$math_inline$ 。因为质数与小于它的每一个数，都构成互质关系。比如 $math_inline$5$math_inline$ 与 $math_inline$1、2、3、4$math_inline$ 都构成互质关系。\n情况三 如果 $math_inline$n$math_inline$ 是质数的某一个次方，即 $math_inline$n=p^k$math_inline$ （ $math_inline$p$math_inline$ 为质数， $math_inline$k$math_inline$ 为大于等于 $math_inline$1$math_inline$ 的整数），则 $math_inline$\\phi(p^k)=p^k-p^{k-1}$math_inline$ 比如 $math_inline$\\phi(8)=\\phi(2^3)=2^3-2^2=8-4=4$math_inline$ 这是因为只有当一个数不包含质数 $math_inline$p$math_inline$ ，才有可能与 $math_inline$n$math_inline$ 互质。而包含质数 $math_inline$p$math_inline$ 的数一共有 $math_inline$p^{k-1}$math_inline$ 个。\n即 $math_inline$1\\times p、2\\times p、3\\times p、... 、p^{k-1}\\times p$math_inline$ ，把他们去除，剩下的就是与 $math_inline$n$math_inline$ 互质的数。\n上面的式子还可以写成下面的形式：\n$math_inline$\\phi(p^k)=p^k-p^{k-1}=p^k(1-\\frac{1}{p})$math_inline$ 可以看出，上面的第二种情况是 $math_inline$k=1$math_inline$ 时的特例\n情况四 如果n可以分解成两个互质的整数之积： $math_inline$n=p_1\\times p_2$math_inline$ 则： $math_inline$\\phi(n)=\\phi(p_1p_2)=\\phi(p_1)\\phi(p_2)$math_inline$ 即积的欧拉函数等于各个因子的欧拉函数之积。比如 $math_inline$\\phi(56)=\\phi(8\\times 7)=\\phi(8)\\phi(7)=4\\times 6=24$math_inline$ 对于素数 $math_inline$p$math_inline$ ， $math_inline$\\phi(p)=p-1$math_inline$ ，对于两个素数 $math_inline$p,q$math_inline$ ， $math_inline$\\phi(pq)=pq-1$math_inline$ 欧拉函数是积性函数，但不是完全积性函数\n欧拉函数的积性 若 $math_inline$m,n$math_inline$ 互质，则 $math_inline$\\phi(mn)=\\phi(m)\\phi(n)$math_inline$ 。\n由“ $math_inline$m,n$math_inline$ 互质”可知 $math_inline$m,n$math_inline$ 无公因数，所以：\n$math_inline$\\phi(m)\\phi(n)=m(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})...(1-\\frac{1}{p_n})\\cdot n(1-\\frac{1}{p_1'})(1-\\frac{1}{p_2'})(1-\\frac{1}{p_3'})...(1-\\frac{1}{p_n'})$math_inline$ 其中 $math_inline$p_1、p_2、p_3...p_n$math_inline$ 为 $math_inline$m$math_inline$ 的质因数， $math_inline$p_1'、p_2'、p_3'...p_n'$math_inline$ 为 $math_inline$n$math_inline$ 的质因数，而 $math_inline$m,n$math_inline$ 无公因数。\n所以 $math_inline$p_1、p_2、p_3...p_n、p_1'、p_2'、p_3'...p_n$math_inline$ 互不相同，所以 $math_inline$p_1、p_2、p_3...p_n、p_1'、p_2'、p_3'...p_n$math_inline$ 均为 $math_inline$mn$math_inline$ 的质因数且为 $math_inline$mn$math_inline$ 的质因数的全集。\n所以 $math_inline$\\phi(mn)=mn(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})...(1-\\frac{1}{p_n})\\cdot (1-\\frac{1}{p_1'})(1-\\frac{1}{p_2'})(1-\\frac{1}{p_3'})...(1-\\frac{1}{p_n'})$math_inline$ 所以 $math_inline$\\phi(mn)=\\phi(m)\\phi(n)$math_inline$ 。\n以上部分涉及到“中国剩余定理”\n情况五 因为任意一个大于1的正整数，都可以写成一系列质数的积。（分解质因数）\n$math_inline$n=p_1^{k_1}p_2^{k_2}...p_r^{k_r}$math_inline$ 根据结论四，得到\n$math_inline$\\phi(n)=\\phi(p_1^{k_1})\\phi(p_2^{k_2})...\\phi(p_r^{k_r})$math_inline$ 再根据结论三，得到\n$math_inline$\\phi(n)=p_1^{k_1}p_2^{k_2}...p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_r})$math_inline$ 也就等于\n$math_inline$\\phi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_r})$math_inline$ 结论 比如 $math_inline$\\phi(1323)=(3^3\\times 7^2)=1323(1-\\frac{1}{3})(1-\\frac{1}{7})=756$math_inline$ 即 $math_inline$\\phi(mn)=\\phi(n)\\phi(m)$math_inline$ 只在 $math_inline$(m,n)=1$math_inline$ 时成立。\n对于一个正整数 $math_inline$n$math_inline$ 的素数幂分解 $math_inline$n=p_1^{q_1}p_2^{q_2}...p_n^{q_n}$math_inline$ $math_inline$\\phi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_n})$math_inline$ 除了 $math_inline$n=2, \\phi(n)$math_inline$ 都是偶数\n设 $math_inline$n$math_inline$ 为正整数， $math_inline$\\sum{\\phi(d)}=n(d|n)$math_inline$ 欧拉函数 根据性质二，我们可以在 $math_inline$o(\\sqrt{n})$math_inline$ 的时间复杂度内求出一个数的欧拉函数值。\ncode //直接求解欧拉函数 int euler(int n) { //返回euler(n) int res = n, a = n; for (int i = 2; i * i \u0026lt;= a; i++) { if (a % i == 0) { res = res / i * (i - 1);//先进行除法是为了防止中间数据的溢出 while (a % i == 0) a /= i; } } if (a \u0026gt; 1) res = res / a * (a - 1); return res; } 欧拉函数线性筛 如果要求 $math_inline$n$math_inline$ 以内的所有数的欧拉函数 $math_inline$o(n)$math_inline$ code const int maxn = 1e6; //欧拉线性筛：在线性时间内筛素数的同时求出所有数的欧拉函数 int tot; int phi[maxn]; //保存各个数字的欧拉函数 int prime[maxn]; //按顺序保存素数 bool mark[maxn]; //判断是否是素数 void get_phi(int n){ phi[1] = 1; for(int i = 2; i \u0026lt;= maxn; i++){ //相当于分解质因数的逆过程 if(!mark[i]){ prime[++tot] = i; phi[i] = i-1; } for(int j = 1; j \u0026lt;= tot; j++){ if(i * prime[j] \u0026gt; n) break; mark[i * prime[j]] = 1; //确定i*prime[j]不是素数 if(i % prime[j] == 0){ //判断prime[j] 是否为 i的约数 phi[i * prime[j]] = phi[i] * prime[j]; break; } else{ //prime[j] - 1 就是 phi[prime[j]],利用了欧拉函数的积性 phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } } } ","date":"2019-08-13","permalink":"https://blog.akvicor.com/posts/algorithm/euler/","summary":"\u003cp\u003e给定任意正整数\n\n    \n        $math_inline$n$math_inline$\n    \n\n，那么在小于等于\n\n    \n        $math_inline$n$math_inline$\n    \n\n的所有正整数之中，有多少个与\n\n    \n        $math_inline$n$math_inline$\n    \n\n构成互质关系？\u003c/p\u003e\n\u003cp\u003e计算这个值的方法就叫做欧拉函数\n\n    \n        $math_inline$\\phi(n)$math_inline$\n    \n\n表示：在\n\n    \n        $math_inline$1$math_inline$\n    \n\n到\n\n    \n        $math_inline$n$math_inline$\n    \n\n之中，与n构成互质关系的数的数量。\u003c/p\u003e","title":"欧拉函数证明"},{"content":"whereis iptables #查看系统是否安装防火墙可以看到: iptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz #表示已经安装iptables apt-get install iptables #如果默认没有安装，请运行此命令安装防火墙 iptables -l #查看防火墙配置信息，显示如下: chain input (policy accept) target prot opt source destination chain forward (policy accept) target prot opt source destination chain output (policy accept) target prot opt source destination vi /etc/iptables/rules.v4 添加以下内容(备注:80是指web服务器端口,3306是指mysql数据库链接端口,22是指ssh远程管理端口.)\n*filter :input drop [0:0] :forward accept [0:0] :output accept [0:0] :syn-flood - [0:0] -a input -i lo -j accept -a input -m state --state related,established -j accept -a input -p tcp -m state --state new -m tcp --dport 22 -j accept -a input -p tcp -m state --state new -m tcp --dport 80 -j accept -a input -p tcp -m state --state new -m tcp --dport 443 -j accept -a input -p icmp -m limit --limit 100/sec --limit-burst 100 -j accept -a input -p icmp -m limit --limit 1/s --limit-burst 10 -j accept -a input -p tcp -m tcp --tcp-flags fin,syn,rst,ack syn -j syn-flood -a input -j reject --reject-with icmp-host-prohibited -a syn-flood -p tcp -m limit --limit 3/sec --limit-burst 6 -j return -a syn-flood -j reject --reject-with icmp-port-unreachable commit iptables-restore \u0026lt; /etc/iptables/rules.v4 #使防火墙规则生效 vi /etc/network/if-pre-up.d/iptables #创建文件，添加以下内容，使防火墙开机启动 chmod +x /etc/network/if-pre-up.d/iptables #添加执行权限 iptables -l -n查看规则是否生效. 临时修改 # 列出所有规则 iptables -nl --line-number # 将第三条规则改为accept iptables -r input 3 -j accept ","date":"2019-08-12","permalink":"https://blog.akvicor.com/posts/iptables/config/","summary":"whereis iptables #查看系统是否安装防火墙可以看到: iptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz #表示已经安装iptables apt-get install iptables #如果默认没有安装，请运行此命令安装防火墙 iptables -L #查看防火墙配置信息，显示如下:","title":"配置iptables防火墙"},{"content":"dirichlet卷积\n定义 定义数论函数 $math_inline$f$math_inline$ 和 $math_inline$g$math_inline$ 的狄利克雷卷积为 $math_inline$h$math_inline$ ，则 $math_inline$h(n)=\\sum_{d|n}f(d) g(\\frac{n}{d})$math_inline$ 记做 $math_inline$h=f * g$math_inline$ （ * 代表卷积）\n性质 狄利克雷卷积满足交换律，结合律，对加法满足分配律\n交换律： $math_inline$f * g = g * f$math_inline$ 结合律： $math_inline$(f * g) * h = f * (g * h)$math_inline$ 分配律： $math_inline$f * (g+h)=f * g + f * h$math_inline$ 单位元： $math_inline$f * e = e * f$math_inline$ 逆元：对于每一个 $math_inline$f(1)\\neq 0$math_inline$ 的函数 $math_inline$f$math_inline$ ，都有 $math_inline$f * g=\\epsilon$math_inline$ 两个积性函数的狄利克雷卷积依旧为积性函数。 $math_inline$f,g$math_inline$ 为积性函数，则 $math_inline$f * g$math_inline$ 也为积性函数\n$math_inline$e$math_inline$ 为单位元，它卷上任意的数论函数仍为原数论函数，简单来说，就是 $math_inline$e(n)=[n=1]$math_inline$ 求一个函数的逆\n只需定义： $math_inline$g(n)=\\frac{1}{f(1)}\\left([n==1]-\\sum_{i|n,i\\neq1}f(i)g(\\frac{n}{i})\\right)$math_inline$ 这样的话： $math_inline$\\sum_{i|n}f(i)g(\\frac{n}{i})=f(1)g(n)+\\sum_{i|n,i\\neq1}f(i)g(\\frac{n}{i})=[n==1]$math_inline$ 常用的狄利克雷卷积 $math_inline$(1\\cdot\\mu)=e$math_inline$ ，因为 $math_inline$\\sum_{d|n}\\mu(d)=[n=1]$math_inline$ $math_inline$\\mu\\cdot id=\\phi$math_inline$ ，将欧拉函数的通式展开即可得到次式。\n$math_inline$1\\cdot id = \\sigma$math_inline$ $math_inline$1\\cdot 1 = \\tau$math_inline$ 我们能够通过简单的狄利克雷卷积运算轻易的证出莫比乌斯反演\n若有 $math_inline$f(n)=\\sum_{d|n}f(d)$math_inline$ 则有 $math_inline$f=1\\cdot f$math_inline$ ，两边同时卷上 $math_inline$\\mu$math_inline$ ，可得\n$math_inline$\\mu \\cdot f = \\mu \\cdot 1 \\cdot f$math_inline$ 又因为 $math_inline$1\\cdot \\mu =e$math_inline$ ，所以 $math_inline$f=\\mu\\cdot f$math_inline$ 即 $math_inline$f(n)=\\sum_{d|n}\\mu(d)\\cdot f(\\frac{n}{d})$math_inline$ 我们甚至可以弄出一些很棒的东西，比如说\n$math_inline$id=id\\cdot e=id\\cdot\\mu\\cdot 1=\\phi\\cdot1$math_inline$ $math_inline$n=id(n)=\\sum_{d|n}\\phi(d)$math_inline$ $math_inline$\\sigma=1\\cdot id=1\\cdot(1\\cdot\\phi)=(1\\cdot 1)\\cdot\\phi=\\tau\\cdot\\phi$math_inline$ $math_inline$\\sigma(n)=\\sum_{d|n}\\tau(d)\\cdot\\phi(\\frac{n}{d})$math_inline$","date":"2019-08-07","permalink":"https://blog.akvicor.com/posts/algorithm/dirichlet_convolution/","summary":"\u003cp\u003eDirichlet卷积\u003c/p\u003e","title":"狄利克雷卷积"},{"content":"莫比乌斯反演是数论中的重要内容，对于一些函数 $math_inline$f(n)$math_inline$ ，如果很难直接求出它的值，而容易求出其倍数和或约数和 $math_inline$g(n)$math_inline$ ，那么可以通过莫比乌斯反演简化运算，求得 $math_inline$f(n)$math_inline$ 的值。\n开始学习莫比乌斯反演前我们需要一些前置知识：积性函数、dirichlet卷积、莫比乌斯函数\n数论分块与整除相 引理 1 $math_inline$ \\forall a,b,c\\in\\mathbb{z},\\left\\lfloor\\frac{a}{bc}\\right\\rfloor=\\left\\lfloor\\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor $math_inline$ 略证\n$math_inline$ \\begin{split} \u0026\\frac{a}{b}=\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r(0\\leq r\u003c1)\\\\\\\\ \\rightarrow \u0026\\left\\lfloor\\frac{a}{bc}\\right\\rfloor =\\left\\lfloor\\frac{a}{b}\\cdot\\frac{1}{c}\\right\\rfloor =\\left\\lfloor \\frac{1}{c}\\left(\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r\\right)\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c} +\\frac{r}{c}\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor \\end{split} $math_inline$ 引理 2 $math_inline$ \\forall{n} \\in n, \\left | \\left\\{ \\lfloor \\frac{n}{d} \\rfloor \\mid d \\in n \\right\\}\\right| \\leq \\lfloor 2\\sqrt{n} \\rfloor $math_inline$ $math_inline$|v|$math_inline$ 表示集合 $math_inline$v$math_inline$ 的元素个数\n略证\n对于 $math_inline$d\\leq\\lfloor\\sqrt{n}\\rfloor$math_inline$ ， $math_inline$\\lfloor \\frac{n}{d}\\rfloor$math_inline$ 有 $math_inline$\\lfloor\\sqrt{n}\\rfloor$math_inline$ 种取值\n对于 $math_inline$d\u003e\\lfloor\\sqrt{n}\\rfloor$math_inline$ ，有 $math_inline$\\lfloor \\frac{n}{d}\\rfloor\\leq\\lfloor\\sqrt{n}\\rfloor$math_inline$ ，也只有 $math_inline$\\lfloor\\sqrt{n}\\rfloor$math_inline$ 种取值\n综上得证\n数论分块 数论分块的过程大概如下：考虑含有 $math_inline$\\lfloor\\frac{n}{i}\\rfloor$math_inline$ 的求和式子（ $math_inline$n$math_inline$ 为常数）\n对于任意一个 $math_inline$i(i\\leq n)$math_inline$ ，我们需要找到一个最大的 $math_inline$j(i\\leq j\\leq n)$math_inline$ ，使得 $math_inline$\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{j}\\rfloor$math_inline$ 而 $math_inline$j=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor$math_inline$ 略证\n$math_inline$ \\begin{split} \u0026\\left\\lfloor\\frac{n}{i}\\right\\rfloor \\leq \\frac{n}{i}\\\\ \\rightarrow \u0026\\left\\lfloor\\frac{n}{ \\left\\lfloor\\frac{n}{i}\\right\\rfloor }\\right\\rfloor \\geq \\left\\lfloor\\frac{n}{ \\frac{n}{i} }\\right\\rfloor = \\left\\lfloor i \\right\\rfloor=i \\\\ \\rightarrow \u0026i\\leq \\left\\lfloor\\frac{n}{ \\left\\lfloor\\frac{n}{i}\\right\\rfloor }\\right\\rfloor \\end{split} $math_inline$ 即 $math_inline$j=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor$math_inline$ 利用上述结论，我们每次以 $math_inline$[i,j]$math_inline$ 为一块，分块求和即可\n积性函数 定义 若 $math_inline$\\gcd(x,y)=1$math_inline$ 且 $math_inline$f(xy)=f(x)f(y)$math_inline$ ，则 $math_inline$f(n)$math_inline$ 为积性函数。\n性质 若 $math_inline$f(x)$math_inline$ 和 $math_inline$g(x)$math_inline$ 均为积性函数，则以下函数也为积性函数\n$math_inline$ \\begin{aligned} h(x)\u0026=f(x^p)\\\\ h(x)\u0026=f^p(x)\\\\ h(x)\u0026=f(x)g(x)\\\\ h(x)\u0026=\\sum_{d\\mid x}f(d)g(\\frac{x}{d}) \\end{aligned} $math_inline$ 例子\n单位函数： $math_inline$\\epsilon(n)=[n=1]$math_inline$ 恒等函数： $math_inline$\\operatorname{id}_k(n)=n^k\\operatorname{id}_{1}(n)$math_inline$ 通常记做 $math_inline$\\operatorname{id}(n)$math_inline$ 常数函数： $math_inline$1(n)=1$math_inline$ 除数函数： $math_inline$\\sigma_{k}(n)=\\sum_{d\\mid n}d^{k}\\sigma_{0}(n)$math_inline$ 通常简记做 $math_inline$\\operatorname{d}(n)$math_inline$ 或 $math_inline$\\tau(n)$math_inline$ ， $math_inline$\\sigma_{1}(n)$math_inline$ 通常简记做 $math_inline$\\sigma(n)$math_inline$ 欧拉函数： $math_inline$\\varphi(n)=\\sum_{i=1}^n [\\gcd(i,n)=1]$math_inline$ 莫比乌斯函数： $math_inline$\\mu(n) = \\begin{cases}1 \u0026 n=1 \\\\ 0 \u0026 \\exists d:d^{2} \\mid n \\\\ (-1)^{\\omega(n)} \u0026 otherwise\\end{cases}$math_inline$ 其中 $math_inline$\\omega(n)$math_inline$ 表示 $math_inline$n$math_inline$ 的本质不同质因子个数，是一个加性函数 dirichlet卷积 定义 定义两个数论函数 $math_inline$f,g$math_inline$ 的dirichlet卷积为\n$math_inline$ (f*g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d}) $math_inline$ 性质 dirichlet卷积满足交换律和结合律\n其中 $math_inline$\\varepsilon$math_inline$ 为dirichlet卷积的单位元（任何函数卷 $math_inline$\\epsilon$math_inline$ 都为其本身）\n例子 $math_inline$ \\begin{aligned} \\varepsilon=\\mu*1\u0026\\leftrightarrow\\varepsilon(n)=\\sum_{d\\mid n}\\mu(d)\\\\ d=1*1\u0026\\leftrightarrow d(n)=\\sum_{d\\mid n}1\\\\ \\sigma=d*1\u0026\\leftrightarrow\\varepsilon(n)=\\sum_{d\\mid n}d\\\\ \\varphi=\\mu*\\text{id}\u0026\\leftrightarrow\\varphi(n)=\\sum_{d\\mid n}d\\cdot\\mu(\\frac{n}{d}) \\end{aligned} $math_inline$ 莫比乌斯函数 定义 $math_inline$\\mu$math_inline$ 为莫比乌斯函数\n性质 莫比乌斯函数不但是积性函数，还有如下性质：\n$math_inline$ \\mu(n)= \\begin{cases} 1\u0026n=1\\\\ 0\u0026n\\text{ 含有平方因子}\\\\ (-1)^k\u0026k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\\\ \\end{cases} $math_inline$ 证明 $math_inline$ \\varepsilon(n)= \\begin{cases} 1\u0026n=1\\\\ 0\u0026n\\neq 1\\\\ \\end{cases} $math_inline$ 其中 $math_inline$\\displaystyle\\varepsilon(n)=\\sum_{d\\mid n}\\mu(d)$math_inline$ 即 $math_inline$\\varepsilon=\\mu*1$math_inline$ 设 $math_inline$\\displaystyle n=\\prod_{i=1}^k{p_i}^{c_i},n'=\\prod_{i=1}^k p_i$math_inline$ 那么 $math_inline$\\displaystyle\\sum_{d\\mid n}\\mu(d)=\\sum_{d\\mid n'}\\mu(d)=\\sum_{i=0}^k c_k^i\\cdot(-1)^k$math_inline$ 根据二项式定理，易知该式子的值在 $math_inline$k=0$math_inline$ 即 $math_inline$n=1$math_inline$ 时的值为 $math_inline$1$math_inline$ 否则为 $math_inline$0$math_inline$ ，这也同时证明了 $math_inline$\\sum_{d|n}{\\mu(d)}=[n=1]$math_inline$ 补充结论 反演推论： $math_inline$\\displaystyle [gcd(i,j)=1] \\leftrightarrow\\sum_{d\\mid\\gcd(i,j)}\\mu(d)$math_inline$ **直接推导：**如果看懂了上一个结论，这个结论稍加思考便可以推出：如果 $math_inline$\\gcd(i,j)=1$math_inline$ 的话，那么代表着我们按上个结论中枚举的那个 $math_inline$n$math_inline$ 是 $math_inline$1$math_inline$ ，也就是式子的值是 $math_inline$1$math_inline$ ，反之，有一个与 $math_inline$[\\gcd(i,j)=1]$math_inline$ 相同的值：0 **利用 $math_inline$\\varepsilon$math_inline$ 函数：**根据上一结论， $math_inline$[\\gcd(i,j)=1]\\rightarrow \\varepsilon(\\gcd(i,j))$math_inline$ ，将 $math_inline$\\varepsilon$math_inline$ 展开即可。 线性筛 由于 $math_inline$\\mu$math_inline$ 函数为积性函数，因此可以线性筛莫比乌斯函数（线性筛基本可以求所有的积性函数，尽管方法不尽相同）。\ncode void getmu() { mu[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!flg[i]) p[++tot] = i, mu[i] = -1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } } 拓展 $math_inline$\\varphi*1=\\text{id}\\text{（id 函数即 } f(x)=x\\text{）}$math_inline$ 将 $math_inline$n$math_inline$ 分解质因数： $math_inline$\\displaystyle n=\\prod_{i=1}^k {p_i}^{c_i}$math_inline$ 首先，因为 $math_inline$\\varphi$math_inline$ 是积性函数，故只要证明当 $math_inline$n'=p^c$math_inline$ 时 $math_inline$\\displaystyle\\varphi*1=\\sum_{d\\mid n'}\\varphi(\\frac{n'}{d})=\\text{id}$math_inline$ 成立即可。\n因为 $math_inline$p$math_inline$ 是质数，于是 $math_inline$d=p^0,p^1,p^2,\\cdots,p^c$math_inline$ 易知如下过程\n$math_inline$ \\begin{aligned} \\varphi*1\u0026=\\sum_{d\\mid n}\\varphi(\\frac{n}{d})\\\\ \u0026=\\sum_{i=0}^c\\varphi(p^i)\\\\ \u0026=1+p^0\\cdot(p-1)+p^1\\cdot(p-1)+\\cdots+p^{c-1}\\cdot(p-1)\\\\ \u0026=p^c\\\\ \u0026=\\text{id}\\\\ \\end{aligned} $math_inline$ 该式子两侧同时卷 $math_inline$\\mu$math_inline$ 可得 $math_inline$\\displaystyle\\varphi(n)=\\sum_{d\\mid n}d\\cdot\\mu(\\frac{n}{d})$math_inline$ 莫比乌斯反演 公式 设 $math_inline$f(n),g(n)$math_inline$ 为两个数论函数\n如果有 $math_inline$f(n)=\\sum_{d\\mid n}g(d)$math_inline$ 那么有 $math_inline$g(n)=\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})$math_inline$ 证明 **暴力计算：** $math_inline$\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})=\\sum_{d\\mid n}\\mu(d)\\sum_{k\\mid \\frac{n}{d}}g(k)=\\sum_{k\\mid n}g(k)\\sum_{d\\mid \\frac{n}{k}}\\mu(d)=g(n)$math_inline$ 用 $math_inline$\\displaystyle\\sum_{d\\mid n}g(d)$math_inline$ 来替换 $math_inline$f(\\dfrac{n}{d})$math_inline$ ，再变换求和顺序。最后一步转为的依据： $math_inline$\\displaystyle\\sum_{d\\mid n}\\mu(d)=[n=1]$math_inline$ 因此在 $math_inline$\\dfrac{n}{k}=1$math_inline$ 时第二个和式的值才为 $math_inline$1$math_inline$ 。此时 $math_inline$n=k$math_inline$ ，故原式等价于 $math_inline$\\displaystyle\\sum_{k\\mid n}[n=k]\\cdot g(k)=g(n)$math_inline$ 运用卷积：\n原问题为：已知 $math_inline$f=g*1$math_inline$ ，证明 $math_inline$g=f*\\mu$math_inline$ 易知如下转化： $math_inline$f*\\mu=g*1*\\mu\\rightarrow f*\\mu=g$math_inline$ （其中 $math_inline$1*\\mu=\\varepsilon$math_inline$ ）\n莫比乌斯反演拓展 对于数论函数 $math_inline$f,g$math_inline$ 和完全积性函数 $math_inline$t$math_inline$ 且 $math_inline$t(1)=1$math_inline$ ：\n$math_inline$ f(n)=\\sum_{i=1}^nt(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\ \\leftrightarrow g(n)=\\sum_{i=1}^n\\mu(i)t(i)f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right) $math_inline$ 我们来证明一下：\n$math_inline$ \\begin{eqnarray} \u0026\u0026g(n)=\\sum_{i=1}^n\\mu(i)t(i)f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\ \u0026=\u0026\\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}t(j) g\\left(\\left\\lfloor\\frac{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}{j}\\right\\rfloor\\right)\\\\ \u0026=\u0026\\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}t(j) g\\left(\\left\\lfloor\\frac{n}{ij}\\right\\rfloor\\right)\\\\ \u0026=\u0026\\sum_{t=1}^n \\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}[ij=t] t(j)g\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \u0026\u0026\\text{【先枚举 ij 乘积】}\\\\ \u0026=\u0026\\sum_{t=1}^n \\sum_{i|t}\\mu(i)t(i) t\\left(\\frac{t}{i}\\right)g\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \u0026\u0026\\text{【}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}[ij=t] \\text{对答案的贡献为 1，于是省略】}\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \\sum_{i|t}\\mu(i)t(i)t\\left(\\frac{t}{i}\\right)\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \\sum_{i|t}\\mu(i)t(t) \u0026\u0026\\text{【t 是完全积性函数】}\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right)t(t) \\sum_{i|t}\\mu(i)\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right)t(t) \\varepsilon(t) \u0026\u0026\\text{【}\\mu\\ast 1= \\varepsilon\\text{】}\\\\ \u0026=\u0026g(n)t(1) \u0026\u0026\\text{【当且仅当 t=1,}\\varepsilon(t)=1\\text{时】}\\\\ \u0026=\u0026g(n) \u0026\u0026 \\square \\end{eqnarray} $math_inline$ 解法二：\n转化一下，可以将式子写成\n$math_inline$ \\begin{eqnarray} \u0026\u0026\\sum_{d=1}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ijd\\cdot[gcd(i,j)=1]\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ij\\sum_{t\\mid gcd(i,j)}\\mu(t)\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ij\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(t)[t\\mid gcd(i,j)]\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\sum_{i=1}^{\\lfloor\\frac{n}{td}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{td}\\rfloor}ij[1\\mid gcd(i,j)]\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\sum_{i=1}^{\\lfloor\\frac{n}{td}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{td}\\rfloor}ij \\end{eqnarray} $math_inline$ 容易知道\n$math_inline$ \\sum_{i=1}^{n}\\sum_{j=1}^{m}ij=\\frac{n(n+1)}{2}\\cdot \\frac{m(m+1)}{2} $math_inline$ 设 $math_inline$sum(n,m)=\\sum_{i=1}^{n}\\sum_{j=1}^{m}ij$math_inline$ ，继续接着前面的往下推\n$math_inline$ \\begin{eqnarray} \u0026\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\sum_{i=1}^{\\lfloor\\frac{n}{td}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{td}\\rfloor}ij\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\cdot sum(\\lfloor\\frac{n}{td}\\rfloor,\\lfloor\\frac{m}{td}\\rfloor)\\\\ \u0026=\u0026\\sum_{t=1}^{n}sum(\\lfloor\\frac{n}{t}\\rfloor,\\lfloor\\frac{m}{t}\\rfloor)\\sum_{d\\mid t}d\\cdot (\\frac{t}{d})^2\\mu(\\frac{t}{d})\\\\ \u0026=\u0026\\sum_{t=1}^{n}sum(\\lfloor\\frac{n}{t}\\rfloor,\\lfloor\\frac{m}{t}\\rfloor)(t\\sum_{d\\mid t}d\\cdot\\mu(d)) \\end{eqnarray} $math_inline$ 这时我们只要对每个 $math_inline$t$math_inline$ 预处理出 $math_inline$t\\sum_{d\\mid t}d\\cdot\\mu(d)$math_inline$ 的值就行了，考虑如何快速求解\n设 $math_inline$f(n)=\\sum_{d\\mid n}d\\cdot\\mu(d)$math_inline$ 实际上 $math_inline$f$math_inline$ 可以用线性筛筛出，具体的是\n$math_inline$ f(n)= \\begin{cases} 1-n \u0026,n\\in primes \\\\ f(\\frac{x}{p}) \u0026,p^2\\mid n\\\\ f(\\frac{x}{p})\\cdot f(p) \u0026,p^2\\nmid n \\end{cases} $math_inline$ 其中 $math_inline$p$math_inline$ 表示 $math_inline$n$math_inline$ 的最小质因子\n总时间复杂度 $math_inline$o(n+\\sqrt{n})$math_inline$ 例题 「haoi 2011」problem b 「spoj 5971」lcmsum 「bzoj 2154」crash 的数字表格 「sdoi2015」约数个数和 「luogu 3768」简单的数学题 ","date":"2019-08-06","permalink":"https://blog.akvicor.com/posts/algorithm/mobius/","summary":"\u003cp\u003e莫比乌斯反演是数论中的重要内容，对于一些函数\n\n    \n        $math_inline$f(n)$math_inline$\n    \n\n，如果很难直接求出它的值，而容易求出其倍数和或约数和\n\n    \n        $math_inline$g(n)$math_inline$\n    \n\n，那么可以通过莫比乌斯反演简化运算，求得\n\n    \n        $math_inline$f(n)$math_inline$\n    \n\n的值。\u003c/p\u003e\n\u003cp\u003e开始学习莫比乌斯反演前我们需要一些前置知识：\u003cstrong\u003e积性函数、Dirichlet卷积、莫比乌斯函数\u003c/strong\u003e\u003c/p\u003e","title":"莫比乌斯反演"},{"content":" 威尔逊定理 欧拉定理（数论中的欧拉定理） 中国剩余定理（又称孙子定理） 费马小定理 相关定义 积性函数 积性函数：对于任意互质的整数 $math_inline$a$math_inline$ 和 $math_inline$b$math_inline$ 有性质 $math_inline$f(ab)=f(a)f(b)$math_inline$ 的数论函数\n完全积性函数：对于任意整数 $math_inline$a$math_inline$ 和 $math_inline$b$math_inline$ 有性质 $math_inline$f(ab)=f(a)f(b)$math_inline$ 的数论函数\n$math_inline$\\phi(n) \\quad - \\quad \\text{欧拉函数}$math_inline$ $math_inline$\\mu(n) \\quad - \\quad \\text{莫比乌斯函数，关于非平方数的质因子数目}$math_inline$ $math_inline$\\gcd(n,k) \\quad - \\quad \\text{最大公因子，当k固定的情况}$math_inline$ $math_inline$d(n) \\quad - \\quad \\text{n的正因子数目}$math_inline$ $math_inline$\\sigma(n) \\quad - \\quad \\text{n的所有正因子之和}$math_inline$ $math_inline$\\sigma k(n) \\quad - \\quad \\text{因子函数，n的所有正因子的k次幂之和，当中k可为任何复数。}$math_inline$ $math_inline$1(n) \\quad - \\quad \\text{不变的函数，定义为1(n)=1 （完全积性）}$math_inline$ $math_inline$id(n) \\quad - \\quad \\text{单位函数，定义为id(n)=n （完全积性）}$math_inline$ $math_inline$idk(n) \\quad - \\quad \\text{幂函数，对于任何复数、实数k，定义为}idk(n)=n^k \\text{（完全积性）}$math_inline$ $math_inline$\\epsilon(n) \\quad - \\quad \\text{定义为：若}n=1, \\epsilon(n)=1 \\text{；若}n\u003e1, \\epsilon(n)=0 \\text{分别称为“对于狄利克雷卷积的乘法单位” （完全积性）}$math_inline$ $math_inline$\\lambda(n) \\quad - \\quad \\text{刘维尔函数，关于能整数n的质因子的数目}$math_inline$ $math_inline$\\gamma(n) \\quad - \\quad \\text{定义为：} \\gamma(n)=(-1)^{\\omega(n)} \\text{，在次加性函数}\\omega(n)\\text{是不同能整除n的质数的数目}$math_inline$ $math_inline$\\text{另外，所有狄利克雷特征均是完全积性的}$math_inline$ 积性函数的性质\n性质一\n这和算数基本定理有关\n若将n表示成质因子分解式\n$math_inline$n=p_{1}^{a_1}p_{2}^{a_2}...p_{k}^{a_k}$math_inline$ 则有\n$math_inline$f(n)=f(p_{1}^{a_1})f(p_{2}^{a_2})...f(p_{k}^{a_k})$math_inline$ 性质二\n若f为积性函数且有 $math_inline$f(p^n)=f^n(p)$math_inline$ 则f为完全积性函数\n非积性函数\n冯·曼戈尔特函数：当n是质数p的整数幂， $math_inline$\\lambda(n)=\\ln(p)$math_inline$ ，否则 $math_inline$\\lambda(n)=0$math_inline$ 不大于正整数n的质数的数目 $math_inline$\\pi(n)$math_inline$ 整数拆分的数目 $math_inline$p(n)$math_inline$ ：一个整数能表示成正整数之和的方法的数目\n取余的性质 对于基本的四种运算而言，加减乘都符合“分配率”，唯独除法不满足。\n$math_inline$(a-b)\\%c = (a\\%c-b\\%c)\\%c$math_inline$ $math_inline$(a+b)\\%c = (a\\%c+b\\%c)\\%c$math_inline$ $math_inline$(a\\times b)\\%c = (a\\%c\\times b\\%c)\\%c$math_inline$ 如果要实现除法，那么必须把除法转换为乘法，假设 $math_inline$b^{-1}$math_inline$ 是 $math_inline$b$math_inline$ 关于 $math_inline$c$math_inline$ 的逆元。\n$math_inline$(a\\div b)\\%c 可以转化为 (a\\times b^{-1})\\%c = (a\\%c\\times b^{-1}\\%c)\\%c$math_inline$ 完全剩余系 完全剩余系： 从模n的每个剩余类中各取一个数，得到一个由n个数组成的集合，叫做模n的一个完全剩余系。完全剩余系常用于数论中存在性证明。\n在模n的剩余类中各取一个元素，则这n个数就构成了模n的一个完全剩余系。\n命n为一个自然数，a，b为整数。如果a-b为n的整数倍，则称a，b关于n同余，用同余式 $math_inline$a\\equiv b\\left(\\text{mod}n\\right)$math_inline$ 记之。否则称a，b关于n不同余，记为 $math_inline$a\\not\\equiv b\\left(\\text{mod}n\\right)$math_inline$ 。我们称n为同余式的模。同余式满足：\n反射性（reflection），即 $math_inline$a\\equiv a \\left(\\text{mod}n\\right)$math_inline$ 对称性（symmetry），即由 $math_inline$a\\equiv b\\left(\\text{mod}n\\right)$math_inline$ 可得 $math_inline$b\\equiv a\\left(\\text{mod}n\\right)$math_inline$ 传递性（transitivity），即由 $math_inline$a\\equiv b\\left(\\text{mod}n\\right)$math_inline$ , $math_inline$b\\equiv c\\left(\\text{mod}n\\right)$math_inline$ 可得 $math_inline$a\\equiv c\\left(\\text{mod}n\\right)$math_inline$ 因此，可以利用同余关系将整数分类，凡同余的数属于一个类，于是异类中的数皆不同余。共得到整数的n个类。在每一个类中各取一个数作为代表所成的集合称为模n的一个完全剩余系。\n举例\n取最小非负剩余为代表，则得完全剩余系{0,1,2,\u0026hellip;,n-1}。剩余类的代表相加得一数属于另一类，这个类仅与相加两数所在的类有关，而与代表的选取无关。于是，可以定义剩余类间的加法，以0所在的类o为单位元，则剩余类的全体关于加法构成一个交换群。当然在剩余类之间可以定义乘法。但关于除法就不一定可能，例如： $math_inline$3\\cdot 2\\equiv 1\\cdot 2\\left(\\text{mod}4\\right)$math_inline$ ， $math_inline$2\\equiv 2\\left(\\text{mod}4\\right)$math_inline$ ，但是 $math_inline$3\\not\\equiv 1 \\left(\\text{mod}4\\right)$math_inline$ 一个数除以4的余数只能是0，1，2，3，{0，1，2，3}和{4，5，-2，11}是模4的完全剩余系。可以看出0和4，1和5，2和-2，3和11模4同余，这4组数分别属于四个剩余类。\n性质\n(m,n)=1 -\u0026gt; m、n两个数的最大公约数是1\n对于n个整数，其构成模n的完全系等价于其关于模n两两不同余 若 $math_inline$a_i \\left(1\\leq i \\leq n\\right)$math_inline$ 构成模n的完系， $math_inline$k、m \\in z，\\left(m,n\\right)=1$math_inline$ ，则 $math_inline$k+ma_i\\left(1\\leq i \\leq n\\right)$math_inline$ 也构成模n的完系 若 $math_inline$a_i \\left(1\\leq i \\leq n\\right)$math_inline$ 构成模n的完系，则 $math_inline$\\sum_{i=1}^{n}a_i = \\frac{n\\left(n+1\\right)}{2}=\\lbrace ^{\\frac{n}{2}\\left(\\text{mod}n\\right)}_{0\\left(\\text{mod}n\\right)}$math_inline$ 剩余类 剩余类，亦称同余类，是一种数学的用语，为数论的基本概念之一。\n设模为n，则根据余数可将所有的整数分为n类，把所有与整数a模n同余的整数构成的集合叫做模n的一个剩余类，记做[a]。并把a叫做剩余类[a]的一个代表元。\n定义\n一个整数被正整数n除后，余数有n中情形：0，1，2，3，。。。，n-1，他们彼此对模n不同余。这表明，每个整数恰与这n个整数中的某一个对模n同余。这样一来，按模n是否同余对整数集进行分类，可以将整数集分成n个两两不相交的子集。我们把（所有）对模n同余的整数构成的一个集合叫做模n的一个剩余类。\n模m的剩余类具有以下性质\n每一个整数恰包含在某一个类 $math_inline$c_j$math_inline$ 里( $math_inline$0 \\leq j \\leq m-1$math_inline$ ) 两个整数x，y属于同一类的充分必要条件是 $math_inline$x\\equiv y\\left(\\text{mod} m\\right)$math_inline$ 剩余类与完全剩余类\n由此可引出抽象代数中的重要概念，如群论中的陪集，环论中的剩余类等。任取n，这n个数(o, 1, \u0026hellip;, n-1)称为模n的一个完全剩余类。每个数称为相应类的代表元。最常用的完全剩余系是{0, 1, \u0026hellip;, n-1}。\n若 $math_inline$n \\in z^{+}$math_inline$ ，则n个整数， $math_inline$r_0, r_1, ..., r_{n-1}$math_inline$ 构成一个完全剩余系数的充分必要条件是这n个除n的余数两两不相等。 若 $math_inline$n \\in z^{+}, k \\in z, \\left(k, n\\right)=1$math_inline$ ，当 $math_inline$x_1, x_2,..., x_n$math_inline$ 为完全剩余系时， $math_inline$kx_1+m, kx_2+m,..., kx_n+m$math_inline$ 也为完全剩余系数。 若 $math_inline$m,n \\in z^{+}, \\left(m, n\\right)=1$math_inline$ ，则当 $math_inline$a_0,a_1,...,a_{m-1},b_0,b_1,...,b_{n-1}$math_inline$ 是完全剩余系数时， $math_inline$na_i+mb_j\\left(i=0, 1,...,m-1;j=0,1,...,n-1\\right)$math_inline$ 也构成 $math_inline$m\\times n$math_inline$ 完全剩余系 剩余类与简化剩余类\n在剩余类选取一个与n互素代表元构成简化剩余类\n$math_inline$n \\in z^{+}, k \\in z, \\left(k, n\\right)=1$math_inline$ ，当 $math_inline$x_1, x_2,..., x_n$math_inline$ 为简化剩余系时， $math_inline$kx_1+m, kx_2+m,..., kx_n+m$math_inline$ 也为简化剩余系数。 若 $math_inline$m,n \\in z^{+}, \\left(m, n\\right)=1$math_inline$ ，则当 $math_inline$a_0,a_1,...,a_t,b_0,b_1,...,b_s$math_inline$ 是简化剩余系数时， $math_inline$na_i+mb_j\\left(i=0...t;j=0...s\\right)$math_inline$ 也构成 $math_inline$m\\times n$math_inline$ 完全剩余系 缩系 简化剩余系也称既约剩余系、缩系，是数学术语。\n**缩系的定义：**如果一个模m的剩余类里面的数与m互素（显然，只需有一个与m互素，其余的均与m互素）就把它叫做一个与模m互素的剩余类，在与模m互素的全部剩余类中，各取一数所组成的集叫做模m的一组简化剩余系\n若整数 $math_inline$a_1, a_2,..., a_m$math_inline$ 模n分别对应 $math_inline$0, 1, 2,..., n-1$math_inline$ 中所有m个与n互素的自然数，则称集合{ $math_inline$a_1, a_2,..., a_m$math_inline$ }为模n的一个缩系\n缩系的性质：\n对于任意的与n互质的正整数k，若{ $math_inline$a_1, a_2,..., a_m$math_inline$ }为模n的一个缩系，(k,n)=1，则{ $math_inline$k \\times a_1, k \\times a_2,..., k \\times a_m$math_inline$ }也为模n的一个缩系 $math_inline$\\left(k \\times a_1\\right)...\\left(k \\times a_1\\right) \\equiv a_1 \\times a_2...a_m\\left(\\text{mod}n\\right)$math_inline$ 威尔逊定理 欧拉定理 中国剩余定理 费马小定理 费马小定理(fermat\u0026rsquo;s little theorem)是数论中的一个重要定理，在1636年由 皮埃尔·德·费马 提出。如果p是一个质数，而 $math_inline$\\gcd(a,p)=1$math_inline$ (整数a不是p的倍数)，则有 $math_inline$a^{p-1}\\equiv 1\\text{mod}p$math_inline$ 根据费马小定理 $math_inline$a^{p-1}\\equiv 1\\text{mod}p$math_inline$ ，可以发现 $math_inline$a^{p-2} \\times a\\equiv 1\\text{mod}p$math_inline$ 也成立。可知 $math_inline$a^{p-2}$math_inline$ 是 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的逆元。所以求 $math_inline$a$math_inline$ 的逆元，就直接用快速幂求 $math_inline$a^{p-2}$math_inline$ 就可以\ncode ll power(ll a, int x) { ll ans = 1; while(x) { if(x\u0026amp;1) ans = (ans * a) %mod; a = (a * a) %mod; x \u0026gt;\u0026gt;= 1; } return ans; } ll inv(ll a) { return power(a, mod - 2); } 实际上，它是欧拉定理的一个特殊情况（即 $math_inline$a^{\\phi(p)}=q^{p-1}\\equiv 1(\\text{mod}p)$math_inline$ ）\n有些学家独立制作相关的假说（有时也被错误的称为中国的假说），当成立时，p是素数。这是费马小定理的一个特殊情况。然而，这一假说的前设是错误的：例如，341，而341=11*31是一个伪素数。所有的伪素数都是此假说的反例。\n如上所述，中国猜测仅有一半是正确的。符合中国猜测但不是素数的数被称为伪素数。\n更极端的反例是卡迈克尔数：假设a与561互质，则 $math_inline$a^{560}$math_inline$ 被561除都余1.这样的数被称为卡迈克尔数，561是最小的卡迈克尔数。\n验证推倒 引理1\n若a,b,c为任意三个整数，m为正整数，且(m,c)=1，则当 $math_inline$a\\cdot c\\equiv b\\cdot c(\\text{mod}m)$math_inline$ 时有 $math_inline$a\\equiv b(\\text{mod}m)$math_inline$ 证明： $math_inline$a\\cdot c\\equiv b\\cdot c(\\text{mod}m)$math_inline$ 可得 $math_inline$a\\cdot c - b\\cdot c\\equiv 0(\\text{mod}m)$math_inline$ 可得 $math_inline$(a - b)\\cdot c\\equiv 0(\\text{mod}m)$math_inline$ 。因为(m,c)=1即m,c互质，c可以约去， $math_inline$a - b \\equiv 0(\\text{mod}m)$math_inline$ 可得 $math_inline$a \\equiv b(\\text{mod}m)$math_inline$ 引理2\n设m是一个整数且m\u0026gt;1，b是一个整数且(m,b)=1。如果 $math_inline$a[1],a[2],a[3],a[4],...,a[m]$math_inline$ 是模m的一个完全剩余系，则 $math_inline$b\\cdot a[1],b\\cdot a[2],b\\cdot a[3],b\\cdot a[4],...,b\\cdot a[m]$math_inline$ 也构成模m的一个完全剩余系。\n证明：若存在2个整数 $math_inline$b\\cdot a[i]和b\\cdot [j]$math_inline$ 同余即 $math_inline$b\\cdot a[i] \\equiv b\\cdot a[j](\\text{mod}m)\\quad (i\\geq 1 \\\u0026\\\u0026 j\\geq 1)$math_inline$ ，根据引理1则有 $math_inline$a[i]\\equiv a[j](\\text{mod}m)$math_inline$ 。根据完全剩余系的定义可知这是不可能的，因此不存在两个整数 $math_inline$b\\cdot a[i]和b\\cdot [j]$math_inline$ 同余。\n所以 $math_inline$b\\cdot a[1],b\\cdot a[2],b\\cdot a[3],b\\cdot a[4],...,b\\cdot a[m]$math_inline$ 构成模m的一个完全剩余系。\n构造素数 $math_inline$p$math_inline$ 的完全剩余系 $math_inline$p= \\lbrace 1,2,3,...,p-1 \\rbrace$math_inline$ 因为 $math_inline$(a,p)=1$math_inline$ ，由引理2可得 $math_inline$a = \\lbrace a,2a,3a,...,(p-1)a \\rbrace$math_inline$ 也是 $math_inline$p$math_inline$ 的一个完全剩余系。由完全剩余系的性质， $math_inline$1 \\times 2 \\times 3 \\times ... \\times(p-1) \\equiv a,2a,3a,...,(p-1)a (\\text{mod}p)$math_inline$ 即 $math_inline$(p-1)! \\equiv (p-1)! \\cdot a^{p-1} (\\text{mod}p)$math_inline$ 易知 $math_inline$((p-1)!,p)=1$math_inline$ ，同余式两边可约去 $math_inline$(p-1)!$math_inline$ ，得到 $math_inline$a^{p-1}\\equiv 1(\\text{mod}p)$math_inline$ 应用 计算 $math_inline$2^{100}$math_inline$ 除以13的余数\n$math_inline$2^{100} \\equiv 2^{12\\times 8 + 4}(\\text{mod}13)$math_inline$ $math_inline$\\equiv (2^{12})^8\\cdot 2^4(\\text{mod}13)$math_inline$ $math_inline$\\equiv 1^8\\cdot 16(\\text{mod}13)$math_inline$ $math_inline$\\equiv 16(\\text{mod}13)$math_inline$ $math_inline$\\equiv 3(\\text{mod}13)$math_inline$ 故余数为3\n证明对于任意整数a而言， $math_inline$a^{13}-a$math_inline$ 恒为2730的倍数。13-1为12，12的正因数有1，2，3，4，6，12，分别加1，为2，3，4，5，7，13，其中2，3，5，7，13为质数，根据定理 $math_inline$a^{13}-a$math_inline$ 为2的倍数、为3的倍数、为5的倍数、为7的倍数、为13的倍数，即 $math_inline$2\\times 3\\times 5\\times 7\\times 13=2730$math_inline$ 的倍数。\n\u0026gt;\u0026gt;\u0026gt; n =221 \u0026gt;\u0026gt;\u0026gt; a = 38 \u0026gt;\u0026gt;\u0026gt; pow(a ,n -1,n) 1 \u0026#34;\u0026#34;\u0026#34;221 may be a prime number.\u0026#34;\u0026#34;\u0026#34; import random def isprime(n,k=128): if n\u0026lt;2: return false for _ in range(k): a = random.randrange(1,n) if pow(a,n-1,n)!=1: return false return true ","date":"2019-08-02","permalink":"https://blog.akvicor.com/posts/algorithm/wilson_euler_chinese_remainder_fermat_little/","summary":"\u003cul\u003e\n\u003cli\u003e威尔逊定理\u003c/li\u003e\n\u003cli\u003e欧拉定理（数论中的欧拉定理）\u003c/li\u003e\n\u003cli\u003e中国剩余定理（又称孙子定理）\u003c/li\u003e\n\u003cli\u003e费马小定理\u003c/li\u003e\n\u003c/ul\u003e","title":"初等数论四大定理"},{"content":" poj-1845 sumdiv 题意两个数a和b。让s等于 $math_inline$a^b$math_inline$ 的所有因子的和，输出s%9901\n由分解素因数可知 $math_inline$a=p_1^{a_1}p_2^{a_2}...p_k^{a_k}$math_inline$ 那么 $math_inline$a^b=p_1^{a_1b}p_2^{a_2b}...p_k^{a_kb}$math_inline$ 那么 $math_inline$s=(1+p_1+p_1^2+...+p_1^{a_1b})\\times(1+p_2+p_2^2+...+p_2^{a_2b})\\times...\\times(1+p_k+p_k^2+...+p_k^{a_kb})$math_inline$ 对等比数列求和可得： $math_inline$s=\\frac{p_1^{a_1b+1}-1}{p_1-1}\\times\\frac{p_2^{a_2b+1}-1}{p_2-1}\\times ... \\frac{p_k^{a_kb+1}-1}{p_k-1}$math_inline$ 由于有取余操作，那么我们可以通过逆元快速求得每一个分式取余mod的结果\n求逆元一般公式(条件b|a)： $math_inline$ans=\\frac{a}{b}\\text{mod}m=\\frac{a\\text{mod}(mb)}{b}$math_inline$ code /** * author: akvicor * created: 2019-08-02 10-38-51 **/ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;complex\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= n; --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef vector\u0026lt;ll\u0026gt; vl; typedef vector\u0026lt;pll\u0026gt; vll; const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; namespace sol{ /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(9901); maxn(1e4); ll a, b; bool prime[maxn]; int p[maxn]; int cnt; ll mult_mod(ll a, ll b, ll m){ a %= m; b %= m; ll ret = 0; ll tmp = a; while(b){ if(b\u0026amp;1){ ret += tmp; if(ret \u0026gt; m) ret -= m; } tmp \u0026lt;\u0026lt;= 1; if(tmp \u0026gt; m) tmp -= m; b \u0026gt;\u0026gt;= 1; } return ret; } ll quick_mod(ll a, ll n, ll mod){ ll ret = 1; ll temp = a % mod; while(n){ if(n \u0026amp; 1) ret = mult_mod(ret, temp, mod); temp = mult_mod(temp, temp, mod); n \u0026gt;\u0026gt;= 1; } return ret; } void isprime(){ cnt = 0; ms(prime, true); for(int i = 2; i \u0026lt; maxn; ++i){ if(prime[i]){ p[cnt++] = i; for(int j = i+i; j \u0026lt; maxn; j += i) prime[j] = false; } } } void solve(){ fast_io; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; isprime(); ll ans = 1; for(int i = 0; p[i]*p[i] \u0026lt;= a; ++i){ if(a % p[i] == 0){ ll num = 0; while(a % p[i] == 0){ ++num; a /= p[i]; } ll m = (p[i] - 1) * mod; ans *= (quick_mod(p[i], num*b+1, m) - 1) / (p[i]-1); ans %= mod; } } if(a \u0026gt; 1){ ll m = (a - 1) * mod; ans *= (quick_mod(a, b+1, m) - 1) / (a-1); ans %= mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-08-02","permalink":"https://blog.akvicor.com/posts/cf/poj_1845/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://poj.org/problem?id=1845\"\u003e POJ-1845 Sumdiv \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"sumdiv"},{"content":" 乘法逆元 乘法逆元 对于缩系中的元素，每个数a均有唯一的与之对应的乘法逆元x，使得 $math_inline$ax\\equiv 1\\left(\\text{mod}n\\right)$math_inline$ ，一个数有逆元的充分必要条件是gcd(a,n)=1，此时逆元唯一存在\n在一般数学中，我们所说的逆元就是倒数，但是在数论中，如果一个数字a存在一个对p的逆元x，就可以写成 $math_inline$ax\\equiv 1\\left(\\text{mod}p\\right)$math_inline$ 的形式(此处p与a互质，若不互质，则不存在逆元)\n逆元的含义：模n意义下，1个数a如果有逆元x，那么除以a相当于乘以x。\n满足 $math_inline$a \\times k\\equiv 1(\\text{mod}p)的k值就是a关于p的乘法逆元$math_inline$ 当我们要求 $math_inline$\\frac{a}{b}\\text{mod}p$math_inline$ 的值时，我们就可以用到乘法逆元。我们可以用过求b关于p的乘法逆元k，将a乘上k再模p，即 $math_inline$(a \\times k)\\text{mod}p$math_inline$ 。其结果与 $math_inline$\\frac{a}{b}\\text{mod}p$math_inline$ 等价\n证明 根据 $math_inline$b \\times k\\equiv 1(\\text{mod}p)$math_inline$ 有 $math_inline$b \\times k=p \\times x+1$math_inline$ $math_inline$k=\\frac{p \\times x+1}{b}$math_inline$ 把k带入 $math_inline$(a \\times k)\\text{mod}p$math_inline$ 得\n$math_inline$(\\frac{a \\times (p \\times x+1)}{b})\\text{mod}p$math_inline$ $math_inline$=(\\frac{a \\times p \\times x}{b}+\\frac{a}{b})\\text{mod}p$math_inline$ $math_inline$=[(\\frac{a \\times p \\times x}{b}\\text{mod}p)+\\frac{a}{b}]\\text{mod}p$math_inline$ $math_inline$=[(\\frac{p \\times (a \\times x)}{b}\\text{mod}p)+\\frac{a}{b}]\\text{mod}p$math_inline$ $math_inline$//p \\times [\\frac{a \\times x}{b}]\\text{mod}p=0$math_inline$ 所以原式等于： $math_inline$\\frac{a}{b}\\text{mod}p$math_inline$ 拓展欧几里得 **拓展欧几里得:** $math_inline$ax+by=\\gcd(a,b)$math_inline$ 的解一定存在\n当我们要求 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的逆元时，若逆元存在，则 $math_inline$\\gcd(a,p)=1$math_inline$ 。假设逆元为 $math_inline$x$math_inline$ ，即： $math_inline$ax \\equiv 1(\\text{mod}p)$math_inline$ 我们可以展开一下变成 $math_inline$ax=1+pk$math_inline$ ，由于 $math_inline$k$math_inline$ 可正可负，我们可以得到 $math_inline$ax+pk=1$math_inline$ ，其实就是 $math_inline$ax+by=\\gcd(a,b)$math_inline$ 。\n我们用拓展欧几里得求出一个最小的x就是 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的一个逆元。\n求解：\n现在我们已经有了 $math_inline$ax+by=\\gcd(a,b)$math_inline$ 了。我们想试着求出一个特解 $math_inline$x$math_inline$ 。\n根据欧几里得算法我们可以知道 $math_inline$\\gcd(a,b)=\\gcd(b,a\\%b)$math_inline$ 。\n而且我们可以看出 $math_inline$bx+(a\\%b)y = \\gcd(b,\\%b)$math_inline$ 由此我们可得：(由于两边 $math_inline$x$math_inline$ , $math_inline$y$math_inline$ 值不用，我们用 $math_inline$x'$math_inline$ 和 $math_inline$y'$math_inline$ 进行区分)\n$math_inline$bx'+(a\\%b)y'=ax+by$math_inline$ 我们想要把式子简化一下，可以从 $math_inline$a\\%b$math_inline$ 入手，即 $math_inline$a\\%b=a-\\lfloor \\frac{a}{b} \\rfloor\\times b$math_inline$ 。\n所以我们可以化简得到 $math_inline$ax+by=bx'+(a-\\lfloor \\frac{a}{b} \\rfloor\\times b)y'$math_inline$ 移项： $math_inline$ax+by=ay'+b(x'-\\lfloor \\frac{a}{b} \\rfloor y')$math_inline$ 系数相等，所以我们可以解得\n$math_inline$ \\begin{equation} \\left\\{ \\begin{array}{lr} x=y' \u0026 \\\\ y=(x'-\\lfloor \\frac{a}{b} \\rfloor y') \u0026 \\end{array} \\right. \\end{equation} $math_inline$ 根据欧几里得算法，我们一直递归下去，总会到 $math_inline$a\\%b=0$math_inline$ 所以式子变成了 $math_inline$ax=\\gcd(a,b)$math_inline$ 。此时我们取一个特解 $math_inline$x=1,y=0$math_inline$ 。然后往回推，就可以得到一开始的那个x。\n此时解出来的 $math_inline$x$math_inline$ 就是 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的一个逆元。\nps：算法效率较高，常数较小，时间复杂度 $math_inline$o(\\ln{n})$math_inline$ code void exgcd(ll a, ll b, ll \u0026amp;x, ll \u0026amp;y) { if (b == 0) { x = 1;y = 0; } else { exgcd(b, a%b, y, x); y -= (a/b) * x; } } void extgcd(ll a, ll b, ll \u0026amp;d, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { d = a; x = 1; y = 0; } else { extgcd(b, a % b, d, y, x); y -= x * (a / b); } } ll inverse(ll a, ll n) { ll d, x, y; extgcd(a, n, d, x, y); return d == 1 ? (x + n) % n : -1; } 递推求阶乘逆元 我们经常会用到阶乘的逆元，我们可以考虑用费马小定理先求出最大的那个阶乘的逆元，然后再往回推\n我们可以把 $math_inline$n!$math_inline$ 的逆元表示为 $math_inline$\\left[n!\\right]^{-1}$math_inline$ 。\n我们要求 $math_inline$(n-1)!$math_inline$ 的逆元，我们可以考虑给 $math_inline$(n-1)!$math_inline$ 乘上一个 $math_inline$n$math_inline$ 把他变为 $math_inline$n!$math_inline$ 。\n即 $math_inline$(n-1)!\\times n\\left[n!\\right]^{-1} \\equiv 1\\text{mod}p$math_inline$ 因此 $math_inline$\\left[n!\\right]^{-1}$math_inline$ 是 $math_inline$(n-1)!$math_inline$ 关于 $math_inline$p$math_inline$ 的一个逆元。\ncode void init() { fact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } } 费马小定理 在模为素数p的情况下，有费马小定理 $math_inline$a^{p-1}\\equiv 1(\\text{mod}p)$math_inline$ ，（左右同除a）得 $math_inline$a^{p-2}=a^{-1}(\\text{mod}p)$math_inline$ ，也就是说a的逆元为 $math_inline$a^{p-2}$math_inline$ 符号解释 既约 $math_inline$\\perp$math_inline$ ， $math_inline$a\\perp m$math_inline$ ，a与m既约、不可约、互素：\n既约，或称不可约，或称互质，或称互素，a,m既约，记做 $math_inline$a \\perp m$math_inline$ 或 $math_inline$(a,m)=1$math_inline$ 即a,m二者的最大公约数为1，已经约去公因子到不可再约了。\n而在模数不为素数p得情况下，有欧拉定理 $math_inline$a^{phi(m)}\\equiv q (\\text{mod}m)\\quad(a \\perp m)$math_inline$ 同理 $math_inline$a^{-1}=a^{phi(m)-1}$math_inline$ 因此逆元x便可以套用快速幂求得了 $math_inline$x=a^{phi(m)-1}$math_inline$ 如何判断a是否有逆元？检验逆元的性质，看求出的幂值x与a相乘是否为1即可\nps：这种算法复杂度为 $math_inline$o(\\log_2(n))$math_inline$ 在几次测试中，常数似乎较上种方法大\n当p比较大的时候需要用快速幂求解\ncode ll pow_mod(ll x, ll n, ll mod) { ll res = 1; while (n \u0026gt; 0) { if (n \u0026amp; 1)res = res * x % mod; x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } 当模p不是素数的时候需要用到欧拉定理\n$math_inline$a^{phi(p)}\\equiv 1 \\quad (\\text{mod}p)$math_inline$ $math_inline$a \\times a^{phi(p)-1}\\equiv 1 \\quad (\\text{mod}p)$math_inline$ $math_inline$a^{-1}\\equiv a^{phi(p)-1} \\quad (\\text{mod}p)$math_inline$ 所以时间复杂度即求出单个欧拉函数的值\n(当p为素数的时候 $math_inline$phi(p)=p-1$math_inline$ ，则 $math_inline$phi(p)-1=p-2$math_inline$ 可以看出欧拉定理是费马小定理的推广)\nps：这里就贴出欧拉定理的板子，很少会用欧拉定理求逆元\n特殊情况 一 当n是质数，这点也很好理解。当n是质数， $math_inline$0","date":"2019-08-01","permalink":"https://blog.akvicor.com/posts/algorithm/factorial_inverse/","summary":"\u003cul\u003e\n\u003cli\u003e乘法逆元\u003c/li\u003e\n\u003c/ul\u003e","title":"逆元的求法（欧拉定理、阶乘逆元、费马小定理、模质数p的情况）"},{"content":" hdu-6608 find the answer 题意：q组样例。每组给出n、m，接下来一行n个数a[i]。对于每个 $math_inline$i\\in[1, n]$math_inline$ ，输出需要删除最少的个数，使得 $math_inline$\\sum_{j=1}^{i-1}a[i]\\leq m$math_inline$ 对于每个i，删除最少个数 = i-1-留下的最多的个数。我们建一个权值线段树，因为 $math_inline$q\\leq w[i] \\leq 10^9 且 1 \\leq n \\leq 2 \\times 10^5$math_inline$ ，所以需要离散化。\n我们能留下的数的和最大为m-a[i]。那么题目转化为用最多的权值线段树中的数凑出m-a[i]这个数。\n那么我们凑的时候，如果左子树上的数的和已经够用，那么肯定只用左子树上的数；否则我们肯定要全用左子树上的数+右子树凑出 m-a[i]-左子树上数的和。\n注意当递归到叶节点时，那么表明我们只能用这个数去凑val，取 $math_inline$\\text{min}\\left(\\text{tree[cur].num}, \\frac{\\text{val}}{\\text{b[tree[cur].l]}}\\right)$math_inline$ 即可。查询完再更新个数即可\ncode cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; ","date":"2019-07-31","permalink":"https://blog.akvicor.com/posts/cf/hdu_6609/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6609\"\u003e HDU-6608 Find the answer \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"find the answer"},{"content":" hdu-6608 fansblog 题意给定一个整数 $math_inline$p\\left(10^9 \\leq p \\leq 10^{14}\\right)$math_inline$ 设前一个质数为q，求 $math_inline$q!\\%p$math_inline$ 根据威尔逊定理，如果p为质数，则有 $math_inline$\\left(p-1\\right)!\\equiv p-1\\left(\\mod p\\right)$math_inline$ $math_inline$q!=\\frac{\\left(p-1\\right)!}{\\left(q+1\\right)\\left(q+2\\right)...\\left(p-1\\right)} \\equiv \\left(p-1\\right)*inv\\left(\\mod p\\right)$math_inline$ $math_inline$q!\\text{mod}p = \\frac{1}{\\left(q+1\\right)+\\left(q+2\\right)...\\left(p-2\\right)}\\text{mod}p$math_inline$ 根据素数定理， $math_inline$\\pi \\left(x\\right)\\sim \\frac{x}{\\ln(x)}$math_inline$ 其中 $math_inline$\\pi(x)$math_inline$ 表示不超过x的素数的个数。直观的看，x越大，素数密度越大，接近于线性。在题给的范围，相邻素数通常只间隔几十个数。\n为了快速找到前一个质数，这里使用了miller-rabin素数测试算法\ncode /** * author: akvicor * created: 2019-07-30 08-57-12 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= n; --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define mod(x) ((x) %= mod) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef vector\u0026lt;ll\u0026gt; vl; typedef vector\u0026lt;pll\u0026gt; vll; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1e6); const int s = 8; ll mult_mod(ll a, ll b, ll c){ a %= c; b %= c; ll ret = 0; ll tmp = a; while(b){ if(b\u0026amp;1){ ret += tmp; if(ret \u0026gt; c) ret -= c; } tmp \u0026lt;\u0026lt;= 1; if(tmp \u0026gt; c) tmp -= c; b \u0026gt;\u0026gt;= 1; } return ret; } ll pow_mod(ll a, ll n, ll mod){ ll ret = 1; ll temp = a % mod; while(n){ if(n \u0026amp; 1) ret = mult_mod(ret, temp, mod); temp = mult_mod(temp, temp, mod); n \u0026gt;\u0026gt;= 1; } return ret; } bool check(ll a, ll n, ll x, ll t){ ll ret = pow_mod(a, x, n); ll last = ret; loop(i, 1, t){ ret = mult_mod(ret, ret, n); if(ret == 1 \u0026amp;\u0026amp; last != 1 \u0026amp;\u0026amp; last != n-1) return true; last = ret; } if(ret != 1) return true; else return false; } bool miller_rabin(ll n){ if(n \u0026lt; 2) return false; if(n == 2) return true; if((n\u0026amp;1)==0) return false; ll x = n-1; ll t = 0; while((x\u0026amp;1)==0){x \u0026gt;\u0026gt;= 1; ++t;} srand(time(null)); rep(i, s){ ll a = rand()%(n-1)+1; if(check(a, n, x, t)) return false; } return true; } void solve(){ fast_io; int t; ll p; cin \u0026gt;\u0026gt; t; while(t--){ cin \u0026gt;\u0026gt; p; ll ans = 1; for(ll i = p-1; i \u0026gt;= 0; --i){ if(miller_rabin(i)) break; ans = mult_mod(ans, i, p); } ans = (p-pow_mod(ans, p-2, p)) % p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-31","permalink":"https://blog.akvicor.com/posts/cf/hdu_6608/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=6608\"\u003e HDU-6608 Fansblog \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"fansblog"},{"content":" loj-6000 搭配飞行员 如图，可以看作从源点流向正驾驶员，再流向副驾驶员，最后流向汇点，每条边流量均为1\ncode /** * author: akvicor * created: 2019-07-26 18-37-11 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= n; --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define mod(x) ((x) %= mod) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef vector\u0026lt;ll\u0026gt; vl; typedef vector\u0026lt;pll\u0026gt; vll; namespace sol { const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9 + 7); maxn(5e3); struct dinic { dinic(int n) { g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 10); d = vector\u0026lt;int\u0026gt;(n + 10); vis = vector\u0026lt;bool\u0026gt;(n + 10); cur = vector\u0026lt;int\u0026gt;(n + 10); } struct edge { int from, to, cap, flow; }; int s, t; //节点数,边数,源点编号,汇点编号 vector\u0026lt;edge\u0026gt; edges; //边表,edges[e]和edges[e^1]互为反向弧 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; //邻接表,g[i][j]表示节点i的第j条边在e中的序号 vector\u0026lt;bool\u0026gt; vis; //bfs用 vector\u0026lt;int\u0026gt; d; //从起点到i的距离 vector\u0026lt;int\u0026gt; cur; //当前弧下标 void add_edge(int from, int to, int cap) { edges.push_back({from, to, cap, 0}); edges.push_back({to, from, 0, 0}); g[from].push_back(edges.size() - 2); g[to].push_back(edges.size() - 1); } bool bfs() { fill(vis.begin(), vis.end(), false); queue\u0026lt;int\u0026gt; q; q.push(s); d[s] = 0; vis[s] = true; while (!q.empty()) { for (int id : g[q.front()]) { edge \u0026amp;e = edges[id]; if (!vis[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; e.flow) { vis[e.to] = true; d[e.to] = d[q.front()] + 1; q.push(e.to); } } q.pop(); } return vis[t]; } long long dfs(int u, int a) { if (u == t || a == 0) return a; int flow = 0, f; for (int \u0026amp;i = cur[u]; i \u0026lt; (int) g[u].size(); ++i) { edge \u0026amp;e = edges[g[u][i]]; if (d[u] + 1 == d[e.to] \u0026amp;\u0026amp; (f = dfs(e.to, min(a, e.cap - e.flow))) \u0026gt; 0) { e.flow += f; edges[g[u][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow; } long long run(int _s, int _t) { s = _s; t = _t; long long flow = 0; while (bfs()) { fill(cur.begin(), cur.end(), 0); flow += dfs(s, 0x3f3f3f3f); } return flow; } }; void solve() { fast_io; int n, m, u, v, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; struct dinic di = dinic(n); for(int i = 1; i \u0026lt;= m; ++i){ di.add_edge(0, i, 1); } for(int i = m+1; i \u0026lt;= n; ++i){ di.add_edge(i, n+1, 1); } while(cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v){ di.add_edge(u, v, 1); } cout \u0026lt;\u0026lt; di.run(0, n+1) \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main() { #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-28","permalink":"https://blog.akvicor.com/posts/cf/loj_6000/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://loj.ac/problem/6000\"\u003e LOJ-6000 搭配飞行员 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"搭配飞行员"},{"content":" loj-102 最小费用流 code /** * author: akvicor * created: 2019-07-26 18-37-11 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= n; --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define mod(x) ((x) %= mod) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef vector\u0026lt;ll\u0026gt; vl; typedef vector\u0026lt;pll\u0026gt; vll; namespace sol { const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9 + 7); maxn(5e3); struct mcmf { struct edge { int from, to, cap, flow, cost; edge(int u, int v, int c, int f, int w) : from(u), to(v), cap(c), flow(f), cost(w) {} }; mcmf(int n){ g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; (n+10); inq = vector\u0026lt;int\u0026gt; (n+10); p = vector\u0026lt;int\u0026gt; (n+10); a = vector\u0026lt;int\u0026gt; (n+10); d = vector\u0026lt;int\u0026gt; (n+10); } vector\u0026lt;edge\u0026gt; edges; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; vector\u0026lt;int\u0026gt; inq; vector\u0026lt;int\u0026gt; p; vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; d; void add_edge(int from, int to, int cap, int cost) { edges.push_back(edge(from, to, cap, 0, cost)); edges.push_back(edge(to, from, 0, 0, -cost)); g[from].push_back(edges.size() - 2); g[to].push_back(edges.size() - 1); } bool spfa(int s, int t, int \u0026amp;flow, long long \u0026amp;cost) { fill(inq.begin(), inq.end(), 0); fill(d.begin(), d.end(), 0x3f3f3f3f+10); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = 0x3f3f3f3f; queue\u0026lt;int\u0026gt; q; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i \u0026lt; (int) g[u].size(); i++) { edge \u0026amp;e = edges[g[u][i]]; if (e.cap \u0026gt; e.flow \u0026amp;\u0026amp; d[e.to] \u0026gt; d[u] + e.cost) { d[e.to] = d[u] + e.cost; p[e.to] = g[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if (!inq[e.to]) { q.push(e.to); inq[e.to] = 1; } } } } if (d[t] \u0026gt;= 0x3f3f3f3f) return false; flow += a[t]; cost += (long long) d[t] * (long long) a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true; } pair\u0026lt;int, long long\u0026gt; run(int s, int t) { int flow = 0; long long cost = 0; while (spfa(s, t, flow, cost)); return {flow, cost}; } }; void solve() { fast_io; int n, m, s, t, c, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; mcmf mf = mcmf(n); for(int i = 0; i \u0026lt; m; ++i){ cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; c \u0026gt;\u0026gt; w; mf.add_edge(s, t, c, w); } pair\u0026lt;int, long long\u0026gt; p = mf.run(1, n); cout \u0026lt;\u0026lt; p.fi \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.se; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main() { #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-28","permalink":"https://blog.akvicor.com/posts/cf/loj_102/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://loj.ac/problem/102\"\u003e LOJ-102 最小费用流 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"最小费用流"},{"content":" loj-101 最大流 code /** * author: akvicor * created: 2019-07-26 18-37-11 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= n; --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define mod(x) ((x) %= mod) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; typedef pair\u0026lt;ll, ll\u0026gt; pll; typedef vector\u0026lt;ll\u0026gt; vl; typedef vector\u0026lt;pll\u0026gt; vll; namespace sol { const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9 + 7); maxn(5e3); struct dinic { dinic(int n) { g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 10); d = vector\u0026lt;int\u0026gt;(n + 10); vis = vector\u0026lt;bool\u0026gt;(n + 10); cur = vector\u0026lt;int\u0026gt;(n + 10); } struct edge { int from, to, cap, flow; }; int s, t; //节点数,边数,源点编号,汇点编号 vector\u0026lt;edge\u0026gt; edges; //边表,edges[e]和edges[e^1]互为反向弧 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; //邻接表,g[i][j]表示节点i的第j条边在e中的序号 vector\u0026lt;bool\u0026gt; vis; //bfs用 vector\u0026lt;int\u0026gt; d; //从起点到i的距离 vector\u0026lt;int\u0026gt; cur; //当前弧下标 void add_edge(int from, int to, int cap) { edges.push_back({from, to, cap, 0}); edges.push_back({to, from, 0, 0}); g[from].push_back(edges.size() - 2); g[to].push_back(edges.size() - 1); } bool bfs() { fill(vis.begin(), vis.end(), false); queue\u0026lt;int\u0026gt; q; q.push(s); d[s] = 0; vis[s] = true; while (!q.empty()) { for (int id : g[q.front()]) { edge \u0026amp;e = edges[id]; if (!vis[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; e.flow) { vis[e.to] = true; d[e.to] = d[q.front()] + 1; q.push(e.to); } } q.pop(); } return vis[t]; } long long dfs(int u, int a) { if (u == t || a == 0) return a; int flow = 0, f; for (int \u0026amp;i = cur[u]; i \u0026lt; (int) g[u].size(); ++i) { edge \u0026amp;e = edges[g[u][i]]; if (d[u] + 1 == d[e.to] \u0026amp;\u0026amp; (f = dfs(e.to, min(a, e.cap - e.flow))) \u0026gt; 0) { e.flow += f; edges[g[u][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow; } long long run(int _s, int _t) { s = _s; t = _t; long long flow = 0; while (bfs()) { fill(cur.begin(), cur.end(), 0); flow += dfs(s, 0x3f3f3f3f); } return flow; } }; void solve() { fast_io; int n, m, s, t, u, v, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; struct dinic di = dinic(n); for (int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; di.add_edge(u, v, w); } cout \u0026lt;\u0026lt; di.run(s, t) \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main() { #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-28","permalink":"https://blog.akvicor.com/posts/cf/loj_101/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://loj.ac/problem/101\"\u003e LOJ-101 最大流 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"最大流"},{"content":" 最大流 最小费用最大流 最大流 引入 假设你所在的村庄开通了地下流水管道，自来水厂源源不断的提供水，村民们用水直接或间接用水，而村庄用完的废水统一回收于另一点（设从自来水厂流出的水全部回收）。当然每个管道有一定的容量，求出废水站最多可以汇聚多少水。\n概念 **容量：**每条边都有一个容量（水管的最大水流容量） **源点：**出发点（水厂） **汇点：**结束点（废水站） **流：**一个合法解称作一个流，也就是一条可以从源点到汇点的一条合法路径。 **流量：**每条边各自被经过的次数称作其流量，最终收集的总数为整个流的流量。\n限制 **容量限制：**每条边的流量不超过其容量（水管会爆炸） **流量平衡：**对于除源点和汇点以外的点来说，其流入量一定等于流出量。\n解决 现在我们简化一下这个图，来解决这个问题。\nx/y表示总流量为y，已经流了x\n首先我们会想到找随即路径，然而如果走到如上图所示。\n当走完 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 我们就找不到其他路径了，那么答案为1吗？不，答案为2.\n那么现在我们改进算法，给流过的路径建立反向边\n这样就给了一个反悔的机会。\n定义一跳变得残量为：容量-已流过的流量\n反向边的流量值=正向流过的总流量，也就是说正向流过多少，反向就可以流回多少。\n从而我们又找到 1-\u0026gt;3-\u0026gt;2-\u0026gt;4 的一条路径\n再次建路径上的反向边，我们发现没有路径可以到达4点，所以答案为2.\n小结 在图上找到一条从源点到汇点的路径（称为“增广路”） 去增广路上的残量最小值v（也就是流过的路径中流量最小的那一个） 将答案加上v 将增广路上所有边的残量减去v，反向边的残量加上v 重复上边四个步骤直到找不到增广路为止，这称作 ff 方法\n首先这个算法必定不会死循环，因为每次增广都会导致流量增加（并且增加的是整数），而且流量有一个客观存在的最大值，所以它必定结束。\n由于我们并没有指定它走那一条边，所以优先考虑随便走一条边。\n考虑一种极限的情况：\n现增广 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 会出现一条 3-\u0026gt;2 容量为1的边。\n再增广 1-\u0026gt;3-\u0026gt;2-\u0026gt;4 ，再增广 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 \u0026hellip;\n浪费大量的时间，如果脸黑的话最多2e5次\n然而我们如果先 1-\u0026gt;2-\u0026gt;4 然后 1-\u0026gt;3-\u0026gt;4 走两次就好了。\n上面的做法是我们不期望的。我们可以考虑每次增广最短路 （ek算法）\nek算法 ek算法是以上算法的实现：每次寻找最短路进行增广。\n时间复杂度 $math_inline$o(m^2n)$math_inline$ 结构体储存三个变量 next to dis 【邻接表建边】\nflow[i]：表示流过i点的v值，也就是说目前经过到i点的路径上的最小的残量。\ndis[i]：表示i点距离源点的距离，s，t表示源点以及汇点\n首先我们利用bfs处理图的连通性以及所有点于源点的距离，当然，当这条边上的残量已经为0的时候，我们认为它已经不能经过，我们可以直接不考虑。\n在bfs中国呢pre数组是记录每个点最短路的前驱，last数组记录上条边的编号，从而记录出最短路径，然后从汇点进行更新即可。\ncode bool bfs(int s,int t) { memset(flow,0x7f,sizeof(flow)); memset(dis,0x7f,sizeof(dis)); memset(vis,0,sizeof(vis)); q.push(s);vis[s]=1;dis[s]=0,pre[t]=-1; while(!q.empty()) { int temp=q.front(); q.pop(); vis[temp]=0; for(int i=head[temp];i!=-1;i=edge[i].nxt) { int v=edge[i].to; if(edge[i].flow\u0026gt;0\u0026amp;\u0026amp;dis[v]\u0026gt;dis[temp]+edge[i].dis) { dis[v]=dis[temp]+edge[i].dis; pre[v]=temp; last[v]=i; flow[v]=min(flow[temp],edge[i].flow); if(!vis[v]) { vis[v]=1; q.push(v); } } } } return pre[t]!=-1; } 从汇点向前更新\ncode while(bfs(s,t)) { int now=t; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; while(now!=s) { edge[last[now]].flow-=flow[t]; edge[last[now]^1].flow+=flow[t]; now=pre[now]; } } 最大流最小割定理 什么是割？\n比如：你的仇人是一个工厂老板。你要炸掉一些车，让他每个货物都运不到销售点。炸掉越大的车，你越容易被发现。你希望炸掉的车的容量之和尽量小，最小化这个值\n选出一些边的集合，使得删除他们之后从源点无法到达汇点，那么这个集合就叫做一个割。这些边的容量之和叫做这个割的容量\n**定理1:**任取一个割，其容量大于最大流的流量\n从源点汇点每次都会经过割上的最少一条边。\n割掉这条边以后，把源点能到达的边放在左边，不能到达的放在右边。\n显然源点到汇点的流量不会超过从左边走向右边的次数，而这又不会超过从左边到右边的容量之和\n**直观一点：**假设你是在车装着货物的时候炸掉了它。\n每个货物你至少付出1的代价炸掉（流量小于容量的时候你要付出比货物数更多的代价），所以你炸的代价不会小于货物数\n定理2: 最小割的容量大于最大流的流量，且ff方法能够正确的求出它。\n这意味着一个惊人的事实：你能够仅付出和货物数相同的代价，就把你的仇人的财路炸断\n考虑ff算法结束时，残量网络上没有了增广路\n那么我们假设这个时候，从源点经过残量网络能达到的点组成的集合为x，不能达到的点为y。显然汇点在y例，并且残量网络上没有从x到y的边。\n可以发现以下事实成立：\ny到x的边流量为0，如果流量不为0，那么应该存在一条从x到y的反向边，于是矛盾 x到y的边流量等于其容量。只有这样它才不会在残量网络中出现 根据第一个条件，我们可以得知：没有流量从过年x到y之后又回到x，所以当前流量应该等于x到y的边的流量之和，根据第二个条件它又等于从x到y的边容量之和，而所有从x到y的边又构成一个割，其容量等于这些边的容量之和。\n这意味着我们找到一个流和一个割，使得前者的流量等于后者的容量。\n而根据前面的结论，最大流的流量不会超过这个割的容量，所以这个流一定是最大流。\n荣养的，最小割的容量也不会小于这个流的流量，所以这个割也一定是最小割。\n这就是ff法最后的局面（由于ff会终止，所以它必定求出这样一个局面），由此我们得出：ff是正确的，并且最大流等于最小割\nek优化-dinic ek时间复杂度太高，虽然大多数情况跑不到上界。\n有一个显然的优化：\n如果增广一次后发现最短路没有变化，那么可以继续增广，直到源点到汇点的增广路增大，才需要一遍bfs。\nbfs之后我们除去那些可能在最短路上的边，即dis[终点]=dis[起点]+1的那些边\n显然这些边构成的图中没有环，我们只需要沿这些边尽可能的增广即可\ncode int bfs() { memset(dis,-1,sizeof(dis)); dis[s]=0; q.push(s); while(!q.empty()) { int u=q.front(); q.pop() ; for(int i=head[u];i!=-1;i=edge[i].nxt) { int v=edge[i].to; if(dis[v]==-1\u0026amp;\u0026amp;edge[i].w\u0026gt;0) { dis[v]=dis[u]+1; //更新 q.push(v); } } } return dis[t]!=-1; //判断是否联通。 } 当图连通时进行dfs，当前节点为u，每次经过与u距离最近的点，并且这条边的残量值要大于0，然后往后进行dfs。\n我们在dfs时要加一个变量，作为流量控制（最后的流量不能超过前边流量的最小值）\ndfs中变量flow记录这条管道之后的最大流量\ncode bool dfs(int u,int exp) { if(u==t)return exp; //到达重点，全部接受。 int flow=0,tmp=0; for(int i=head[u];i!=-1;i=edge[i].nxt) { int v=edge[i].to; //下一个点。 if(dis[v]==dis[u]+1\u0026amp;\u0026amp;edge[i].w\u0026gt;0) { tmp=dfs(v,min(exp,edge[i].w)); //往下进行 if(!tmp)continue; exp-=tmp; //流量限制-流量，后边有判断。 flow+=tmp; edge[i].w-=tmp; //路径上的边残量减少 edge[i^1].w+=tmp; //流经的边的反向边残量增加。 if(!exp)break; //判断是否在限制边缘 } } return flow; } 重复上边如果图连通（有最短路径），就一直增广\nwhile(bfs())ans+=dfs(s,inf);\n时间复杂度 $math_inline$o(n^2m)$math_inline$ 在某些特殊情况下（每个点要么只有一条入边且容量为1，要么仅有一条出边且容量为1）其时间复杂度甚至能做到 $math_inline$o(m\\sqrt(n))$math_inline$ template 最大流模版 - 链式前向星存图 struct flow_dinic { flow_dinic(int n) { head = vector\u0026lt;int\u0026gt;(n + 10, -1); level = vector\u0026lt;int\u0026gt;(n + 10); } struct edge { int to, cap, next; }; vector\u0026lt;int\u0026gt; head; vector\u0026lt;int\u0026gt; level; int s = 0, t = 0; // max_flow from s to t vector\u0026lt;struct edge\u0026gt; edge; void add_edge(int u, int v, int c) { edge.push_back((struct edge) {v, c, head[u]}); head[u] = edge.size() - 1; edge.push_back((struct edge) {u, 0, head[v]}); head[v] = edge.size() - 1; } bool bfs() { fill(level.begin(), level.end(), 0); level[s] = 1; queue\u0026lt;int\u0026gt; que; que.push(s); while (!que.empty()) { for (int i = head[que.front()]; ~i; i = edge[i].next) { if (edge[i].cap \u0026amp;\u0026amp; !level[edge[i].to]) { level[edge[i].to] = level[que.front()] + 1; que.push(edge[i].to); if (edge[i].to == t) return true; } } que.pop(); } return false; } int dfs(int f, int u) { if (u == t) return f; int d = 0, used = 0; for (int i = head[u]; ~i; i = edge[i].next) { if (edge[i].cap \u0026amp;\u0026amp; level[u] == level[edge[i].to] - 1) { if ((d = dfs(min(f - used, edge[i].cap), edge[i].to))) { edge[i].cap -= d; edge[i ^ 1].cap += d; used += d; } } } if (!used) level[u] = 0; return used; } long long run(int _s, int _t) { s = _s; t = _t; long long max_flow = 0; while (bfs()) { int d = 0; while ((d = dfs(0x3f3f3f3f, s))) max_flow += d; } return max_flow; } }; 最大流模版 - fast - 邻接表存图 struct dinic { dinic(int n) { g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 10); d = vector\u0026lt;int\u0026gt; (n+10); vis = vector\u0026lt;bool\u0026gt; (n+10); cur = vector\u0026lt;int\u0026gt; (n+10); } struct edge { int from, to, cap, flow; }; int s, t; //节点数,边数,源点编号,汇点编号 vector\u0026lt;edge\u0026gt; edges; //边表,edges[e]和edges[e^1]互为反向弧 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; //邻接表,g[i][j]表示节点i的第j条边在e中的序号 vector\u0026lt;bool\u0026gt; vis; //bfs用 vector\u0026lt;int\u0026gt; d; //从起点到i的距离 vector\u0026lt;int\u0026gt; cur; //当前弧下标 void add_edge(int from, int to, int cap) { edges.push_back({from, to, cap, 0}); edges.push_back({to, from, 0, 0}); g[from].push_back(edges.size() - 2); g[to].push_back(edges.size() - 1); } bool bfs() { fill(vis.begin(), vis.end(), false); queue\u0026lt;int\u0026gt; q; q.push(s); d[s] = 0; vis[s] = true; while (!q.empty()) { for (int id : g[q.front()]) { edge \u0026amp;e = edges[id]; if (!vis[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; e.flow) { vis[e.to] = true; d[e.to] = d[q.front()] + 1; q.push(e.to); } } q.pop(); } return vis[t]; } long long dfs(int u, int a) { if (u == t || a == 0) return a; int flow = 0, f; for (int \u0026amp;i = cur[u]; i \u0026lt; (int) g[u].size(); ++i) { edge \u0026amp;e = edges[g[u][i]]; if (d[u] + 1 == d[e.to] \u0026amp;\u0026amp; (f = dfs(e.to, min(a, e.cap - e.flow))) \u0026gt; 0) { e.flow += f; edges[g[u][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow; } long long run(int _s, int _t) { s = _s; t = _t; long long flow = 0; while (bfs()) { fill(cur.begin(), cur.end(), 0); flow += dfs(s, 0x3f3f3f3f); } return flow; } }; 最小费用最大流","date":"2019-07-28","permalink":"https://blog.akvicor.com/posts/algorithm/flow/","summary":"\u003col\u003e\n\u003cli\u003e最大流\u003c/li\u003e\n\u003cli\u003e最小费用最大流\u003c/li\u003e\n\u003c/ol\u003e","title":"网络流"},{"content":"前向星是一种特殊的边集数组中的每一条边按照起点从小到大排序，如果起点相同就按终点从小到大排序，并记录下某个点为起点的所有边在数组中的起始位置和存储长度，那么前向星就构造好了。\n用len[i]来记录所有以i为起点的边在数组中的存储长度 用head[i]来记录以i为边集在数组中的第一个位置 我们输入的边的顺序为\n1 2 2 3 3 4 1 3 4 1 1 5 4 5 排序后就得到\n编号： 1 2 3 4 5 6 7 起点u： 1 1 1 2 3 4 4 终点v： 2 3 5 3 4 1 5 得到\nhead[1] = 1 len[1] = 3 head[2] = 4 len[2] = 1 head[3] = 5 len[3] = 1 head[4] = 6 len[4] = 2 但是利用前向星会有排序操作，如果用快排时间复杂度至少为 o(nlogn)\n如果用链式前向星，就可以避免排序\n我们建立边结构体为\nstruct edge{ int next; // 与第i条边同起点的下一条边的存储位置 int to; // 表示第i条边的终点 int w; // 边的权值 }; 另外还有一个head[]，它用来表示以i为起点的第一条边存储的位置，实际上你会发现这里的第一条边存储的位置其实在以i为起点的所有边的最后输入的那个编号。\nhead[]一般初始化为-1，对于加边的add函数是这样的\nvoid add(int u, int v, int w){ edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++; } 初始化 cnt = 0 ，来模拟一下\nedge[0].to = 2; edge[0].next = -1; head[1] = 0; edge[1].to = 3; edge[1].next = -1; head[2] = 1; edge[2].to = 4; edge[2].next = -1; head[3] = 2; edge[3].to = 3; edge[3].next = 0; head[1] = 3; edge[4].to = 1; edge[4].next = -1; head[4] = 4; edge[5].to = 5; edge[5].next = 3; head[1] = 5; edge[6].to = 5; edge[6].next = 4; head[4] = 6; 很明显，head[i]保存的是以i为起点的所有边中编号最大的那个，而把这个当作顶点i的第一条起始边的位置。\n这样在遍历时是倒着遍历的，也就是说与输入顺序是相反的，不过这样不影响结果的正确性。\n比如以上图为例，以节点1为起点的边有3条，他们的编号分别是0，3，5 而 head[i] = 5\n我们在遍历以u家电为起始位置的所有边的时候是这样的\nfor(int i = head[u]; ~i; i = edge[i].next) 那么就说先遍历编号为5的边，也就是head[1]，然后就是edge[5].next，也就是编号3的边，然后继续edge[3].next也就是编号0的边，可以看出是逆序的。\n","date":"2019-07-26","permalink":"https://blog.akvicor.com/posts/algorithm/chain_forward_star/","summary":"\u003cp\u003e前向星是一种特殊的边集数组中的每一条边按照起点从小到大排序，如果起点相同就按终点从小到大排序，并记录下某个点为起点的所有边在数组中的起始位置和存储长度，那么前向星就构造好了。\u003c/p\u003e","title":"链式前向星"},{"content":" codeforces-c1196 d2. rgb substring (hard version) 因为字符串中只有 rgb 三个字母，所以字串开头只有三种情况，然后分别对这三种情况跑一遍就可以。\ncode /** * author: akvicor * created: 2019-07-25 00-14-18 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= (n); --i) #define peer(i, a, n) for(int i = a; i \u0026gt; (n); --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1e6); int q, n, k; int ans; void find(string t, string \u0026amp;s){ int l = 0, r = 0, res = 0; while(l \u0026lt;= n){ while(r \u0026lt;= n \u0026amp;\u0026amp; r-l \u0026lt; k){ res += (s[r]==t[r%3]); // 记录有多少位匹配 ++r; } if(r-l \u0026lt; k) break; ans = max(ans, res); res -= (s[l]==t[l%3]); // 开头右移一位 ++l; } } void solve(){ fast_io; cin \u0026gt;\u0026gt; q; while(q-- \u0026gt; 0){ ans = 0; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; find(\u0026#34;rgb\u0026#34;, s); find(\u0026#34;gbr\u0026#34;, s); find(\u0026#34;brg\u0026#34;, s); cout \u0026lt;\u0026lt; (k-ans) \u0026lt;\u0026lt; endl; } } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-25","permalink":"https://blog.akvicor.com/posts/cf/cf_c1196_d2/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://codeforces.com/contest/1196/problem/D2\"\u003e Codeforces-C1196 D2. RGB Substring (hard version) \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"rgb substring (hard version)"},{"content":" 最大矩阵 最大正方形 最大子矩阵和 最大矩阵 code - 存到了队列里，可以求第k大 /** * author: akvicor * created: 2019-07-21 21-00-00 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb(x) push_back(x) #define mp(x, y) make_pair(x, y) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1010); int mp[maxn][maxn], l[maxn], r[maxn]; priority_queue \u0026lt;int\u0026gt; ans; void solve(){ fast_io; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; loop(i, 1, n) loop(j, 1, m){ char c; cin \u0026gt;\u0026gt; c; mp[i][j] = (c == \u0026#39;1\u0026#39;); } loop(i, 2, n) loop(j, 1, m) if(mp[i-1][j] \u0026amp;\u0026amp; mp[i][j]) mp[i][j] += mp[i-1][j]; loop(i, 1, n){ set\u0026lt;pair\u0026lt;int, pii\u0026gt; \u0026gt; s; stack\u0026lt;int\u0026gt; a, b; loop(j, 1, m){ while(!a.empty() \u0026amp;\u0026amp; mp[i][a.top()] \u0026gt;= mp[i][j]) a.pop(); l[j] = a.size() ? a.top()+1 : 1; a.push(j); } for(int j = m; j \u0026gt;= 1; --j){ while(!b.empty() \u0026amp;\u0026amp; mp[i][b.top()] \u0026gt;= mp[i][j]) b.pop(); r[j] = b.size() ? b.top() - 1 : m; b.push(j); } loop(j, 1, m){ if(mp[i][j]){ pair\u0026lt;int, pii\u0026gt; temp = mp(r[j], mp(l[j], mp[i][j])); pair\u0026lt;int ,pii\u0026gt; temp2; if(!s.count(temp)){ ans.push((r[j] - l[j]+1)*mp[i][j]); s.insert(temp); } if(r[j] - l[j]){ temp = mp(r[j], mp(l[j]+1, mp[i][j])); temp2 = mp(r[j]-1, mp(l[j], mp[i][j])); if(!s.count(temp)){ ans.push((r[j] - l[j]) * mp[i][j]); s.insert(temp); }else if(s.count(temp2)){ ans.push((r[j]-l[j])*mp[i][j]); s.insert(temp2); } } } } } if(ans.size()\u0026lt;2) ans.push(0); ans.pop(); cout \u0026lt;\u0026lt; ans.top() \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; while (true) { debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; if (cin.eof()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } code - 速度更快，但只能求前几大 /** * author: akvicor * created: 2019-07-23 08-52-07 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= (n); --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1e3); int n, m; string s; int high[maxn]; int mxx, mxx2; int stkhg[maxn], stkpos[maxn]; int cnt; void solve(){ fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; high[m+1] = 0; loop(i, 1, n){ cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;-- line #\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; s; loop(j, 1, m) high[j] = s[j-1]==\u0026#39;0\u0026#39; ? 0 : high[j]+1; #ifdef debug cout \u0026lt;\u0026lt; \u0026#34;str: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;high: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; high[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; #endif stkhg[0] = stkpos[0] = cnt = 0; loop(j, 1, m+1){ if(high[j] \u0026gt; stkhg[cnt]){ // 如果比上一格高，说明可以构成矩形，就push进栈 stkhg[++cnt] = high[j]; stkpos[cnt] = j; }else if(high[j] \u0026lt; stkhg[cnt]){ // 如果比上一格矮， // 那么高度等于上一格高度的矩形已经完全找出来了， // 当前格比上一格矮，不能参与构成上个矩形 while(high[j] \u0026lt; stkhg[cnt]){ // 将栈中高于当前位置的高度全部出栈 int area = (j-stkpos[cnt]) * stkhg[cnt]; // 当前位置坐标-比当前格高的格的坐标就是宽度 // 更新前两大矩形 if(area \u0026gt;= mxx){ mxx2 = mxx; mxx = area; mxx2 = max(mxx2, max(area-stkhg[cnt], area-(j-stkpos[j]))); }else if(area \u0026gt; mxx2){ mxx2 = area; } --cnt; } if(stkhg[cnt] != high[j]){ stkhg[++cnt] = high[j]; } } #ifdef debug cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkhg: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkhg[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkpos: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkpos[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mxx: \u0026#34; \u0026lt;\u0026lt; mxx \u0026lt;\u0026lt; \u0026#34; mxx2: \u0026#34; \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; #endif } } cout \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-22","permalink":"https://blog.akvicor.com/posts/algorithm/maximum_submatrix/","summary":"\u003col\u003e\n\u003cli\u003e最大矩阵\u003c/li\u003e\n\u003cli\u003e最大正方形\u003c/li\u003e\n\u003cli\u003e最大子矩阵和\u003c/li\u003e\n\u003c/ol\u003e","title":"最大子矩阵"},{"content":" 牛客-c882 h - second large rectangle 每读入一行便处理一行，基础算法就是单调栈求最大矩阵\ncode /** * author: akvicor * created: 2019-07-21 21-00-00 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb(x) push_back(x) #define mp(x, y) make_pair(x, y) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1010); int mp[maxn][maxn], l[maxn], r[maxn]; priority_queue \u0026lt;int\u0026gt; ans; void solve(){ fast_io; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; loop(i, 1, n) loop(j, 1, m){ char c; cin \u0026gt;\u0026gt; c; mp[i][j] = (c == \u0026#39;1\u0026#39;); } loop(i, 2, n) loop(j, 1, m) if(mp[i-1][j] \u0026amp;\u0026amp; mp[i][j]) mp[i][j] += mp[i-1][j]; loop(i, 1, n){ set\u0026lt;pair\u0026lt;int, pii\u0026gt; \u0026gt; s; stack\u0026lt;int\u0026gt; a, b; loop(j, 1, m){ while(!a.empty() \u0026amp;\u0026amp; mp[i][a.top()] \u0026gt;= mp[i][j]) a.pop(); l[j] = a.size() ? a.top()+1 : 1; a.push(j); } for(int j = m; j \u0026gt;= 1; --j){ while(!b.empty() \u0026amp;\u0026amp; mp[i][b.top()] \u0026gt;= mp[i][j]) b.pop(); r[j] = b.size() ? b.top() - 1 : m; b.push(j); } loop(j, 1, m){ if(mp[i][j]){ pair\u0026lt;int, pii\u0026gt; temp = mp(r[j], mp(l[j], mp[i][j])); pair\u0026lt;int ,pii\u0026gt; temp2; if(!s.count(temp)){ ans.push((r[j] - l[j]+1)*mp[i][j]); s.insert(temp); } if(r[j] - l[j]){ temp = mp(r[j], mp(l[j]+1, mp[i][j])); temp2 = mp(r[j]-1, mp(l[j], mp[i][j])); if(!s.count(temp)){ ans.push((r[j] - l[j]) * mp[i][j]); s.insert(temp); }else if(s.count(temp2)){ ans.push((r[j]-l[j])*mp[i][j]); s.insert(temp2); } } } } } if(ans.size()\u0026lt;2) ans.push(0); ans.pop(); cout \u0026lt;\u0026lt; ans.top() \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; while (true) { debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; if (cin.eof()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } code - fast /** * author: akvicor * created: 2019-07-23 08-52-07 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= (n); --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1e3); int n, m; string s; int high[maxn]; int mxx, mxx2; int stkhg[maxn], stkpos[maxn]; int cnt; void solve(){ fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; high[m+1] = 0; loop(i, 1, n){ cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;-- line #\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; s; loop(j, 1, m) high[j] = s[j-1]==\u0026#39;0\u0026#39; ? 0 : high[j]+1; #ifdef debug cout \u0026lt;\u0026lt; \u0026#34;str: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;high: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; high[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; #endif stkhg[0] = stkpos[0] = cnt = 0; loop(j, 1, m+1){ if(high[j] \u0026gt; stkhg[cnt]){ // 如果比上一格高，说明可以构成矩形，就push进栈 stkhg[++cnt] = high[j]; stkpos[cnt] = j; }else if(high[j] \u0026lt; stkhg[cnt]){ // 如果比上一格矮， // 那么高度等于上一格高度的矩形已经完全找出来了， // 当前格比上一格矮，不能参与构成上个矩形 while(high[j] \u0026lt; stkhg[cnt]){ // 将栈中高于当前位置的高度全部出栈 int area = (j-stkpos[cnt]) * stkhg[cnt]; // 当前位置坐标-比当前格高的格的坐标就是宽度 // 更新前两大矩形 if(area \u0026gt;= mxx){ mxx2 = mxx; mxx = area; mxx2 = max(mxx2, max(area-stkhg[cnt], area-(j-stkpos[j]))); }else if(area \u0026gt; mxx2){ mxx2 = area; } --cnt; } if(stkhg[cnt] != high[j]){ stkhg[++cnt] = high[j]; } } #ifdef debug cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkhg: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkhg[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkpos: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkpos[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mxx: \u0026#34; \u0026lt;\u0026lt; mxx \u0026lt;\u0026lt; \u0026#34; mxx2: \u0026#34; \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; #endif } } cout \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-21","permalink":"https://blog.akvicor.com/posts/cf/nc_c882_h/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ac.nowcoder.com/acm/contest/882/H\"\u003e 牛客-C882 H - Second Large Rectangle \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"second large rectangle"},{"content":" 牛客-c881 equivalent prefixes 因为是从1-p，所以可以维护两个递增且比a[i]小的栈，如果过程中两个栈的元素数量不一样多，说明到此位置时，最小值的位置不相同。\ncode /** * author: akvicor * created: 2019-07-18 12-32-25 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int n; int a[maxn], b[maxn]; stack\u0026lt;int\u0026gt; x, y; int main(){ fast_io; int ans; while(cin \u0026gt;\u0026gt; n){ while(!x.empty()) x.pop(); while(!y.empty()) y.pop(); rep(i, n) cin \u0026gt;\u0026gt; a[i]; rep(i, n) cin \u0026gt;\u0026gt; b[i]; for(int i = 0; i \u0026lt; n; ++i){ while(!x.empty() \u0026amp;\u0026amp; x.top() \u0026gt; a[i]) x.pop(); x.push(a[i]); while(!y.empty() \u0026amp;\u0026amp; y.top() \u0026gt; b[i]) y.pop(); y.push(b[i]); if(x.size() == y.size()) ans = i; else break; } cout \u0026lt;\u0026lt; ans+1 \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-07-21","permalink":"https://blog.akvicor.com/posts/cf/nc_c881_a/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ac.nowcoder.com/acm/contest/881/A\"\u003e 牛客-C881 Equivalent Prefixes \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"equivalent prefixes"},{"content":" 牛客-c881 j - fraction comparision 先判断整数部分，再判断小数部分\ncode /** * author: akvicor * created: 2019-07-21 10-47-45 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb push_back #define mp make_pair #define fi first #define se second #define mod(x) const int mod = (int)x + 7 #define maxn(x) const int maxn = (int)x + 7 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9); maxn(1e6); ll x, a, y, b; void solve(){ fast_io; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; a \u0026gt;\u0026gt; y \u0026gt;\u0026gt; b){ if(x/a \u0026gt; y/b) cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; else if(x/a \u0026lt; y/b) cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; else if( (x%a)*b \u0026lt; (y%b)*a ) cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; else if( (x%a)*b \u0026gt; (y%b)*a ) cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; endl; } } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugloop: debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; if(debugduration \u0026gt; 0.07) cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; ++debugcnt; if(debugcnt \u0026lt; 100) goto debugloop; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-21","permalink":"https://blog.akvicor.com/posts/cf/nc_c881_j/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ac.nowcoder.com/acm/contest/881/J\"\u003e 牛客-C881 J - Fraction Comparision \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"fraction comparision"},{"content":" 牛客-c881 e - abba 假如把a看成1，b看成-1。根据它的条件会发现，他们的前缀和满足一个规律：[-m, n]。然后枚举每个位置。\n可以看作是直角坐标系，原点为0。\nx轴正方向看作a的数量，值为左边位置的值+1，当超出范围时置为0。\ny轴正方向看作b的数量，值为下边位置的值-1，当超出范围时置为0.\n其他位置均只能从左侧或下侧走到，即值为左侧加下侧的总和，当超出范围时置为0.\ncode /** * author: akvicor * created: 2019-07-21 09-37-22 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb push_back #define mp make_pair #define fi first #define se second #define mod(x) const int mod = (int)x + 7 #define maxn(x) const int maxn = (int)x + 7 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9); maxn(1e6); void mod(long long \u0026amp; n){ n %= (long long)mod; } void mod(int \u0026amp; n){ n %= mod; } ll dp[3010][3010]; void solve(){ fast_io; int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m){ reep(i, n+m) reep(j, n+m) dp[i][j] = 0; dp[0][0] = 1; reep(i, n+m) reep(j, n+m){ if(i) dp[i][j] += dp[i-1][j]; if(j) dp[i][j] += dp[i][j-1]; //dp[i][j] %= mod; mod(dp[i][j]); if(i-j \u0026gt; n || j-i \u0026gt; m) dp[i][j] = 0; } cout \u0026lt;\u0026lt; dp[n+m][n+m] \u0026lt;\u0026lt; endl; } } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugloop: debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; if(debugduration \u0026gt; 0.07) cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; ++debugcnt; if(debugcnt \u0026lt; 100) goto debugloop; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-21","permalink":"https://blog.akvicor.com/posts/cf/nc_c881_e/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ac.nowcoder.com/acm/contest/881/E\"\u003e 牛客-C881 E - ABBA \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"abba"},{"content":" 牛客-c881 f - random point in triangle code /** * author: akvicor * created: 2019-07-21 09-33-42 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb push_back #define mp make_pair #define fi first #define se second #define mod(x) const int mod = (int)x + 7 #define maxn(x) const int maxn = (int)x + 7 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9); maxn(1e6); ll x1, y1, x2, y2, x3, y3; void solve(){ fast_io; while(cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; x3 \u0026gt;\u0026gt; y3){ cout \u0026lt;\u0026lt; 11ll * labs( (x3-x1) * (y2-y1) - (x2-x1)*(y3-y1) ) \u0026lt;\u0026lt; endl; } } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugloop: debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; ++debugcnt; if(debugcnt \u0026lt; 100) goto debugloop; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-21","permalink":"https://blog.akvicor.com/posts/cf/nc_c881_f/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ac.nowcoder.com/acm/contest/881/F\"\u003e 牛客-C881 F - Random Point in Triangle \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"random point in triangle"},{"content":" 计蒜客-36676 b. 自学图论的码队弟弟 题目描述 在一个 n 个节点（编号为1-n），n 条边的连通图中，每个点的权值都是正整数，每条边的权值为两个端点的权值的和。\n已知各边权值，求各点权值。\n输入格式\n第一行一个整数 n 。\n接下来 n 行，每行 3 个整数 x,y,z(1≤x,y≤n)，表示连接点 x 和 y 的边的权值为 z 。\n数据保证合法，且没有自环或重边。给出的图中有且只有一个包括奇数个节点的环。\n输出格式\n$math_inline$n$math_inline$ 行。每行一个正整数 $math_inline$w_i$math_inline$ ，表示点 $math_inline$i$math_inline$ 的权值。\n样例输入\n3 1 2 3 2 3 5 1 3 4 样例输出\n1 2 3 首先我们设第一个点的权值是ans\n然后我们以第一个点为起点进行dfs\n在dfs的过程中我们可以从中推出一点关于ans的表达式\n由于保证有一个环\n肯定有一个点出现两个表达式\n那么这两个表达式一联立就解得了ans\ncode /** * author: akvicor * created: 2019-07-20 23-14-46 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb push_back #define mp make_pair #define fi first #define se second #define mod(x) const int mod = (int)x + 7 #define maxn(x) const int maxn = (int)x + 7 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9); maxn(1e6); int ans; int vis[maxn]; pii p[maxn]; vii ve[maxn]; void dfs(int x, int fa){ rep(i, sz(ve[x])){ int tmp1 = ve[x][i].fi; int tmp2 = ve[x][i].se; if(vis[tmp1] == 1 \u0026amp;\u0026amp; tmp1!=fa){ if(p[x].se==1){ ans = (tmp2-p[x].fi - p[tmp1].fi)/2; }else{ ans = (p[tmp1].fi - tmp2 + p[x].fi)/2; } } if(vis[tmp1] == 0){ vis[tmp1] = 1; p[tmp1].fi = tmp2 - p[x].fi; p[tmp1].se = p[x].se^1; dfs(tmp1, x); } } } void solve(){ fast_io; ms(vis, 0); int n, u, v, w; cin \u0026gt;\u0026gt; n; loop(i, 1, n){ cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; ve[u].pb(mp(v, w)); ve[v].pb(mp(u, w)); } vis[1] = 1; p[1] = mp(0, 1); dfs(1, 0); loop(i, 1, n){ cout \u0026lt;\u0026lt; (p[i].second==0 ? p[i].fi-ans : p[i].fi+ans) \u0026lt;\u0026lt; endl; } } /** \u0026gt;----------------------------------\u0026lt; **/ int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugloop: debugstart = clock(); #endif solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; ++debugcnt; if(debugcnt \u0026lt; 100) goto debugloop; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-20","permalink":"https://blog.akvicor.com/posts/cf/jsk_36676/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://nanti.jisuanke.com/t/36676\"\u003e 计蒜客-36676 B. 自学图论的码队弟弟 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"自学图论的码队弟弟"},{"content":" 计蒜客-40192 a. 码队女朋友的王者之路 题目描述 码队的女朋友非常喜欢玩某款手游，她想让码队带他上分。但是码队可能不会带青铜段位的女朋友上分，因为码队的段位太高（已经到达王者），恐怕不能和他的女朋友匹配游戏。\n码队的女朋友有些失落，她希望能尽快冲上王者。这个赛季开始了，求胜心切的码队的女朋友想让码队帮她计算一个问题：\n这个赛季码队的女朋友一共打了 n 场排位赛，每一场排位赛中，码队女朋友的成绩用 si 来表示（成绩只可能为“赢”或“输”。 1 代表码队女朋友赢了这场比赛，0 则代表输了这场比赛）。由于这款游戏使用净胜场数这个数据指标来衡量玩家能否晋级更高的段位（玩家净胜场数 = 玩家赢场数 - 玩家输场数），所以码队的女朋友想知道，这个赛季的过程中她的最高净胜场次。\n码队听完他女朋友的问题之后，觉得她有些天真，因为码队知道，这家游戏厂商可能出于不想让玩家早“弃坑”的目的，所以在每个赛季都会给每位玩家发出 k 张 「排位保护卡」。如果一名玩家在一场排位赛中输掉了游戏，但 ta 还有排位保护卡，那么系统将自动为 ta 用掉一张排位保护卡，帮该玩家抵消这场输掉的排位赛（即在系统记录成绩时，不将该局游戏计入玩家的输场数）。但是，如果一名玩家在某个赛季中，没有用完这 k 张排位保护卡，那么这些剩余的排位保护卡将失效，不能在下个赛季继续使用。\n听完码队说的这些事情以后，码队的女朋友变得更有信心了！现在，码队的女朋友想求助你：如果按照这个赛季的这 n 场排位赛成绩来计算，经过 m 个赛季（假设每个赛季都打 n 场排位赛，且每个赛季都获得了完全相同的排位赛成绩），那在这 m 个赛季过程中，她的最高净胜是多少场？\n输入格式\n第一行一个整数 t，表示有几组数据（t≤1000）。\n对于每一组测试数据：第一行有三个整数 n,k,m，分别代表码队的女朋友在一个赛季里总共打了 n 场排位赛，每个赛季有 k 张排位保护卡，总共将进行 m 个赛季，以空格分隔。（1≤k≤n≤100，1≤m≤109）\n接下来一行，输入一个长度为 n 的字符串（只由 0 和 1 组成），代表码队的女朋友在一个赛季里的每场排位赛中的成绩 si (i=1,2,⋯,n)。\n输出格式\n对于每一组测试数据，输出一行。\n每行只包含一个整数，代表在 m 个赛季过程中，码队的女朋友最高能净胜多少场游戏。如果净胜场数为负，请输出 0。\n输出时每行末尾的多余空格，不影响答案正确性\n样例输入1\n1 5 1 2 11110 样例输出1\n8 样例输入2\n1 5 2 2 00101 样例输出2\n2 一个普通的模拟，跑第一遍，遇到失败优先使用保护卡。\n记录过程中出现的最大值和跑完一遍后的结果\n如果结果大于0，那么每过一个赛季，最后的净胜场数都会增加，峰值为最后一个赛季的最大值。\n如果结果小于0，那么每过一个赛季，最后的净胜场数都会减少，峰值为第一个赛季的最大值。\n建立二维坐标系，横坐标为比赛场数，纵坐标为净胜场数。画个曲线便很容易理解。\ncode /** * author: akvicor * created: 2019-07-20 14-06-17 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int t, n, k, m; int main(){ fast_io; ll ans = 0; cin \u0026gt;\u0026gt; t; while(t--){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; m; string s; ans = 0; cin \u0026gt;\u0026gt; s; ll cnt = 0; for(auto \u0026amp;i : s){ if(i==\u0026#39;1\u0026#39;) ++ans; else if(i==\u0026#39;0\u0026#39;){ if(k){ --k; }else{ --ans; } } cnt = max(ans, cnt); } if(ans \u0026gt; 0){ cout \u0026lt;\u0026lt; ans*(m-1) + cnt \u0026lt;\u0026lt; endl; }else{ cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2019-07-20","permalink":"https://blog.akvicor.com/posts/cf/jsk_40192/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://nanti.jisuanke.com/t/40192\"\u003e 计蒜客-40192 A. 码队女朋友的王者之路 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"码队女朋友的王者之路"},{"content":" codeforces-c1157 c2. increasing subsequence (hard version) also applies to easy versions\n如果左边小于右边，把左边push进去，last等于左边，continue 如果右边小于左边，把右边push进去，last等于右边，continue 如果last大于等于左边，就看看右边最多能push进去几个，break 如果last大于等于右边，就看看左边最多能push进去几个，break 如果四个条件都不满足，说明此时左边等于右边并且都大于last。那么此时便出现了抉择，走左边长还是走右边长。\n那么就可以用两个while分别跑左边和右边。如果满足递增顺序就将此种情况的最大长度加 1 。两个while跑完后，选择最长的那种情况。\ncode /** * author: akvicor * created: 2019-07-19 19-30-49 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int a[maxn]; int main(){ fast_io; int n; cin \u0026gt;\u0026gt; n; rep(i, n) cin \u0026gt;\u0026gt; a[i]; int last = -1, l = 0, r = n-1; string ans; while(l \u0026lt;= r){ if(last \u0026gt;= a[l]){ while(l \u0026lt;= r \u0026amp;\u0026amp; last \u0026lt; a[r]){ ans.push_back(\u0026#39;r\u0026#39;); last = a[r]; --r; } break; } if(last \u0026gt;= a[r]){ while(l \u0026lt;= r \u0026amp;\u0026amp; last \u0026lt; a[l]){ ans.push_back(\u0026#39;l\u0026#39;); last = a[l]; ++l; } break; } if(a[l] \u0026lt; a[r]){ ans.push_back(\u0026#39;l\u0026#39;); last = a[l]; ++l; continue; } if(a[r] \u0026lt; a[l]){ ans.push_back(\u0026#39;r\u0026#39;); last = a[r]; --r; continue; } int ll = 1; while(ll \u0026lt; r-l+1 \u0026amp;\u0026amp; a[l+ll] \u0026gt; a[l+ll-1]) ++ll; int rr = 1; while(rr \u0026lt; r-l+1 \u0026amp;\u0026amp; a[r-rr] \u0026gt; a[r-rr+1]) ++rr; if(ll \u0026gt;= rr) { rep(i, ll) ans.push_back(\u0026#39;l\u0026#39;); }else{ rep(i, rr) ans.push_back(\u0026#39;r\u0026#39;); } break; } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2019-07-19","permalink":"https://blog.akvicor.com/posts/cf/cf_c1157_c2/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://codeforces.com/contest/1157/problem/C2\"\u003e Codeforces-C1157 C2. Increasing Subsequence (hard version) \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAlso applies to easy versions\u003c/strong\u003e\u003c/p\u003e","title":"increasing subsequence (hard version)"},{"content":" codeforces-c1157 c1. increasing subsequence (easy version) 初始化上次的数为 0，先判断上次的数是否小于数组最左边的数 并且 （数列左边的数小于右边 或 上次的数大于数列右边的数）就选择左边的数字 若不满足上面的条件，判断上次的数是否小于数组最右边的数 并且 （数列右边的数小于左边 或 上次的数大于数列左边的数）就选择右边的数字 code /** * author: akvicor * created: 2019-07-19 15-57-08 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int a[maxn]; int main(){ fast_io; int n; while(cin \u0026gt;\u0026gt; n){ string s; rep(i, n) cin \u0026gt;\u0026gt; a[i]; int i = 0, j = n-1, la = 0; while(i \u0026lt;= j){ if(la \u0026lt; a[i] \u0026amp;\u0026amp; (a[i]\u0026lt;=a[j] || la\u0026gt;a[j])){ s.push_back(\u0026#39;l\u0026#39;); la = a[i]; ++i; }else if(la \u0026lt; a[j] \u0026amp;\u0026amp; (a[j]\u0026lt;a[i] || la\u0026gt;a[i])){ s.push_back(\u0026#39;r\u0026#39;); la = a[j]; --j; }else break; } cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-07-19","permalink":"https://blog.akvicor.com/posts/cf/cf_c1157_c1/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://codeforces.com/contest/1157/problem/C1\"\u003e Codeforces-C1157 C1. Increasing Subsequence (easy version) \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"increasing subsequence (easy version)"},{"content":" codeforces-c1157 b. long number 题意就是对某一个连续子序列进行替换，使得这个序列字典序最大。\ncode /** * author: akvicor * created: 2019-07-19 15-08-20 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int main(){ fast_io; int n; while(cin \u0026gt;\u0026gt; n){ string s; cin \u0026gt;\u0026gt; s; string conv; conv.push_back(\u0026#39;0\u0026#39;); int a; rep(i, 9){ cin \u0026gt;\u0026gt; a; conv.push_back(a+\u0026#39;0\u0026#39;); } for(int i = 0; i \u0026lt; s.length(); ++i){ if(s[i] \u0026lt; conv[s[i]-\u0026#39;0\u0026#39;]){ while(s[i] \u0026lt; conv[s[i]-\u0026#39;0\u0026#39;]){ s[i] = conv[s[i]-\u0026#39;0\u0026#39;]; ++i; } break; } } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-07-19","permalink":"https://blog.akvicor.com/posts/cf/cf_c1157_b/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://codeforces.com/contest/1157/problem/B\"\u003e Codeforces-C1157 B. Long Number \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"long number"},{"content":" codeforces-c1157 a. reachable numbers 题意为按照 $math_inline$f(x)$math_inline$ 对某个数进行操作，在这个过程中一共会出现多少种不同的数字。\n不管 n 为多少，必定可以出现 1-9 中的任意一个数字 如果 n 大于9，则需要把结果 +1 （n本身也算一次） 只统计 +1 并去掉末尾 0 之后的数字有几个 例如 n 为 121 ：\n那么显然 121 算一次 由于 +1 的缘故 121-129 都会出现，数量为 9 - 121 % 10 = 8 12-19 出现了 9 - 12 % 10 = 7 1-9 都可以出现 1 + 8 + 7 + 9 = 25 code /** * author: akvicor * created: 2019-07-19 14-33-13 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int n; int main(){ fast_io; while(cin \u0026gt;\u0026gt; n){ int cnt = 9 + (n \u0026gt; 9); while(n \u0026gt; 9){ cnt += 9 - (n % 10); n /= 10; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-07-19","permalink":"https://blog.akvicor.com/posts/cf/cf_c1157_a/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://codeforces.com/contest/1157/problem/A\"\u003e Codeforces-C1157 A. Reachable Numbers \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"reachable numbers"},{"content":" mina-4236 joioji 用 j, o, i 来记录到当前位置一共有多少个 j, o, i。\n假设 a[i] b[i] c[i] 表示到第i个位置一共有多少个 j, o, i。\n那么只要找到一对 a[j]-b[j]==a[i]-b[i] \u0026amp;\u0026amp; c[j]-b[j]==c[i]-b[i] 即可\ncode /** * author: akvicor * created: 2019-07-17 10-09-13 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; string s; map\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; m; int ans, j, o, i, n; int main(){ fast_io; ans = j = o = i = n = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; m[make_pair(0, 0)] = -1; rep(i, n){ j += s[i]==\u0026#39;j\u0026#39;; o += s[i]==\u0026#39;o\u0026#39;; i += s[i]==\u0026#39;i\u0026#39;; // 如果出现了两次相同的 (j-o, i-o) // 那么就说明这两次之间的 j、o、i 的数量一定相等，符合题目要求，只需用 当前i-上次的i 即可 if(m.find(make_pair(j-o, i-o))==m.end()) m[make_pair(j-o, i-o)] = i; else ans = max(ans, i-m[make_pair(j-o, i-o)]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2019-07-17","permalink":"https://blog.akvicor.com/posts/cf/mina_4236/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://www.mina.moe/BZPRO/JudgeOnline/4236.html\"\u003e MINA-4236 JOIOJI \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"joioji"},{"content":" upc-1792 博丽灵梦的小游戏 题目描述 萃香是一个极其喜欢喝⑨酒的鬼，有着操控密度的能力。\n某天，在博丽神社举行的夏日大宴会上，萃香被灵梦请去玩一个游戏。\n萃香需要操控一个在n行m列的方格的左上角 $math_inline$(1,1)$math_inline$ 的气团，让这个气团最后行进到右下角 $math_inline$(n,m)$math_inline$ 。萃香可以在每一格控制这个气团的密度。由于一些黑幕神奇的原因，可以认为这个气团的密度只有“高”和“低”两种，并且气团只能向右或向下移动。这个方格也不是一个什么一般的方格。在这里面，荷取受灵梦的请求，安装了一些奇特的装置。具体地说，对于 $math_inline$(i,j)$math_inline$ ，都有一个对应的权值 $math_inline$v_{i,j}$math_inline$ 。\n若 $math_inline$v_i,j=0$math_inline$ ，那么气团进入这个格子的时候对密度没有要求。 若 $math_inline$v_i,j=1$math_inline$ ，那么气团进入这个格子的时候的密度必须是\u0026quot;低\u0026quot;。 若 $math_inline$v_i,j=2$math_inline$ ，那么气团进入这个格子的时候的密度必须是\u0026quot;高\u0026quot;。 注意：如果气团所在的格子 $math_inline$v_i,j=1$math_inline$ ，气团的密度可以变成\u0026quot;高\u0026quot;，反之亦然。记气团以“高”密度和“低”密度分别移动了 $math_inline$a,b$math_inline$ 次，那么萃香最后的得分就是a与b的差值的绝对值，即 $math_inline$|a−b|$math_inline$ 。灵梦和萃香提前做了一个约定，如果萃香获得了 $math_inline$x$math_inline$ 分，那么灵梦就要给她装满了 $math_inline$x$math_inline$ 个葫芦的酒。由于灵梦还没有买好酒，你需要帮灵梦求出萃香最多可以得到多少葫芦的酒。\n输入\n第一行两个整数n,m。\n接下来n行，每行m个整数代表 $math_inline$v_{i,j}$math_inline$ 。\n输出\n一个整数代表萃香最多可以得到多少葫芦的酒。\n样例输入\n3 3 0 0 0 0 1 1 0 1 2 样例输出\n2 提示： 对于100%的数据，n,m≤5000\n根据题意，每一格的气团密度是由上一格决定的，那么就可以使用dp来解决\ncode /** * author: akvicor * created: 2019-07-15 12-55-15 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #else #define fast_io std::ios::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; int v[5010][5010], n, m, dp[2][5010][5010]; int main(){ fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; loop(i, 1, n) loop(j, 1, m) cin \u0026gt;\u0026gt; v[i][j]; loop(i, 1, n) loop(j, 1, m){ if(i==j \u0026amp;\u0026amp; i==1) continue; if(v[i][j] == 0){ dp[0][i][j] = max(dp[0][i-1][j], dp[0][i][j-1]) + 1; dp[1][i][j] = max(dp[1][i-1][j], dp[1][i][j-1]) + 1; }else if(v[i][j] == 1){ dp[0][i][j] = max(dp[0][i-1][j], dp[0][i][j-1]) + 1; dp[1][i][j] = max(dp[1][i-1][j], dp[1][i][j-1]) - 1; }else if(v[i][j] == 2){ dp[0][i][j] = max(dp[0][i-1][j], dp[0][i][j-1]) - 1; dp[1][i][j] = max(dp[1][i-1][j], dp[1][i][j-1]) + 1; } } cout \u0026lt;\u0026lt; max(dp[0][n][m], dp[1][n][m]) \u0026lt;\u0026lt; endl; return 0; } ","date":"2019-07-15","permalink":"https://blog.akvicor.com/posts/cf/upc_1792/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://icpc.upc.edu.cn/problem.php?cid=1792\u0026amp;pid=0\"\u003e UPC-1792 博丽灵梦的小游戏 \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"博丽灵梦的小游戏"},{"content":"lnmp一键安装包是一个用linux shell编写的可以为centos/rhel/fedora/aliyun/amazon、debian/ubuntu/raspbian/deepin/mint linux vps或独立主机安装lnmp(nginx/mysql/php)、lnmpa(nginx/mysql/php/apache)、lamp(apache/mysql/php)生产环境的shell程序。\n系统需求: centos/rhel/fedora/debian/ubuntu/raspbian/deepin/aliyun/amazon/mint linux发行版 需要5gb以上硬盘剩余空间，mysql 5.7,mariadb 10至少9gb剩余空间 需要128mb以上内存(128mb小内存vps,xen需有swap,openvz至少要有128mb以上的vswap或突发内存)，注意小内存请勿使用64位系统！ 安装mysql 5.6或5.7及mariadb 10必须1g以上内存，更高版本至少要2g内存!。 安装php 7及以上版本必须1g以上内存!。 vps或服务器必须已经联网且必须设置的是网络源不能是光盘源，同时vps/服务器dns要正常！ linux下区分大小写，输入命令时请注意！ 如有通过yum或apt-get安装的mysql/mariadb请自行备份数据等相关文件！ centos 5,debian 6及之前版本其官网已经结束支持无法使用！ ubuntu 18+,debian 9+,mint 19+,deepin 15.7+及所有新的linux发行版只能使用1.6进行安装！ 低于php 7.1.*版本不支持ubuntu 19+等非常新的linux发行版！ 安装步骤: 使用putty或类似的ssh工具登陆vps或服务器； 登陆后运行：screen -s lnmp\n如果提示screen: command not found 命令不存在可以执行：yum install screen 或 apt-get install screen安装，详细内容参考screen教程。\n下载并安装lnmp一键安装包： wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -co lnmp1.6.tar.gz \u0026amp;\u0026amp; tar zxf lnmp1.6.tar.gz \u0026amp;\u0026amp; cd lnmp1.6 \u0026amp;\u0026amp; ./install.sh lnmp 如提示wget: command not found ，使用yum install wget 或 apt-get install wget 命令安装。\nphp模块/扩展 安装前 安装前建议先执行 /usr/local/php/bin/php -m (此命令显示目前已经安装好的php模块)看一下，要安装的模块是否已安装。然后下载当前php版本的源码并解压。\n大部分php扩展/模块的安装就是三个步骤，在源码目录下执行：\n/usr/local/php/bin/phpize ./configure --with-php-config=/usr/local/php/bin/php-config make \u0026amp;\u0026amp; make install 有些模块可能会稍微有差异，具体看模块的安装文件就可以。\n本文以imap和exif模块为例，进入php源码目录下ext，里面会有大部分模块的源码，这里都是php自带模块，第三方模块的话需要自己找第三方模块的源码。\n安装imap模块 1、安装imap模块前需要先安装imap所需的库：\ncentos ：yum install libc-client-devel\ndebian：apt-get install libc-client-dev\n2、首先进入php安装目录的ext目录\n比如php的源码目录为：/root/lnmp1.3-full/src/php-5.4.45/\n则执行：cd /root/lnmp1.3-full/src/php-5.4.45/ext/ 一般安装完lnmp php源码都是自动删除了的，需要自己进入src目录下解压。\n我们要安装imap模块，执行cd imap/\n再执行 /usr/local/php/bin/phpize 会返回如下信息：\nconfiguring for: php api version: 20041225 zend module api no: 20060613 zend extension api no: 220060519 再执行以下命令：\n./configure --with-php-config=/usr/local/php/bin/php-config --with-kerberos --with-imap-ssl make \u0026amp;\u0026amp; make install 执行完返回：\nbuild complete. don\u0026#39;t forget to run \u0026#39;make test\u0026#39;. installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/ 表示已经成功，再修改/usr/local/php/etc/php.ini\n查找：extension_dir 再下面一行添加上extension = \u0026quot;imap.so\u0026quot;\n保存，执行/etc/init.d/php-fpm restart 重启。\n安装exif模块 安装exif不需要另外安装库，所以省略掉了安装库的步骤。\n比如php的源码目录为：/root/lnmp1.3-full/src/php-5.4.45/\n则执行：cd /root/lnmp1.3-full/src/php-5.4.45/ext/\n我们要安装exif模块，执行cd exif/\n再执行 /usr/local/php/bin/phpize 会返回如下信息：\nconfiguring for: php api version: 20041225 zend module api no: 20060613 zend extension api no: 220060519 再执行以下命令：\n./configure --with-php-config=/usr/local/php/bin/php-config make \u0026amp;\u0026amp; make install 执行完返回：\nbuild complete. don\u0026#39;t forget to run \u0026#39;make test\u0026#39;. installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/ 表示已经成功，再修改/usr/local/php/etc/php.ini\n查找：extension = 再最后一个extension= 后面添加上extension = \u0026quot;exif.so\u0026quot;\n保存，执行/etc/init.d/php-fpm restart 重启。\n**使用：**在/home/wwwroot/下面创建一个exif.php的文件，内容如下：\n\u0026lt;?php $exif = read_exif_data (\u0026#39;img_0001.jpg\u0026#39;); while(list($k,$v)=each($exif)) { echo \u0026#34;$k: $v\u0026lt;br\u0026gt;\\n\u0026#34;; } ?\u0026gt; 安装位置信息 ##lnmp相关软件安装目录\nnginx 目录: /usr/local/nginx/ mysql 目录 : /usr/local/mysql/ mysql数据库所在目录：/usr/local/mysql/var/ mariadb 目录 : /usr/local/mariadb/ mariadb数据库所在目录：/usr/local/mariadb/var/ php目录 : /usr/local/php/ 多php版本目录 : /usr/local/php5.5/ 其他版本前面5.5的版本号换成其他即可 phpmyadmin目录 : 0.9版本为/home/wwwroot/phpmyadmin/ 1.0及以后版本为 /home/wwwroot/default/phpmyadmin/ 强烈建议将此目录重命名为其不容易猜到的名字。phpmyadmin可自己从官网下载新版替换。 默认网站目录 : 0.9版本为 /home/wwwroot/ 1.0及以后版本为 /home/wwwroot/default/ nginx日志目录：/home/wwwlogs/ /root/vhost.sh添加的虚拟主机配置文件所在目录：/usr/local/nginx/conf/vhost/ pureftpd 目录：/usr/local/pureftpd/ pureftpd web管理目录： 0.9版为/home/wwwroot/default/ftp/ 1.0版为 /home/wwwroot/default/ftp/ proftpd 目录：/usr/local/proftpd/ redis 目录：/usr/local/redis/ lnmp相关配置文件位置 nginx主配置(默认虚拟主机)文件：/usr/local/nginx/conf/nginx.conf 添加的虚拟主机配置文件：/usr/local/nginx/conf/vhost/域名.conf mysql配置文件：/etc/my.cnf php配置文件：/usr/local/php/etc/php.ini php-fpm配置文件：/usr/local/php/etc/php-fpm.conf pureftpd配置文件：/usr/local/pureftpd/pure-ftpd.conf 1.3及更高版本：/usr/local/pureftpd/etc/pure-ftpd.conf pureftpd mysql配置文件：/usr/local/pureftpd/pureftpd-mysql.conf proftpd配置文件：/usr/local/proftpd/etc/proftpd.conf 1.2及之前版本为/usr/local/proftpd/proftpd.conf proftpd 用户配置文件：/usr/local/proftpd/etc/vhost/用户名.conf redis 配置文件：/usr/local/redis/etc/redis.conf lnmpa相关目录文件位置 apache目录：/usr/local/apache/ apache配置文件：/usr/local/apache/conf/httpd.conf apache虚拟主机配置文件目录：/usr/local/apache/conf/vhost/ apache默认虚拟主机配置文件：/usr/local/apache/conf/extra/httpd-vhosts.conf 虚拟主机配置文件名称：/usr/local/apache/conf/vhost/域名.conf 安装php模块/拓展 安装前建议先执行 /usr/local/php/bin/php -m (此命令显示目前已经安装好的php模块)看一下，要安装的模块是否已安装。然后下载当前php版本的源码并解压。\n大部分php扩展/模块的安装就是三个步骤，在源码目录下执行：\n/usr/local/php/bin/phpize ./configure --with-php-config=/usr/local/php/bin/php-config make \u0026amp;\u0026amp; make install 有些模块可能会稍微有差异，具体看模块的安装文件就可以。\n本文以imap和exif模块为例，进入php源码目录下ext，里面会有大部分模块的源码，这里都是php自带模块，第三方模块的话需要自己找第三方模块的源码。\n安装imap模块 1、安装imap模块前需要先安装imap所需的库：\ncentos ：yum install libc-client-devel\ndebian：apt-get install libc-client-dev\n2、首先进入php安装目录的ext目录\n比如php的源码目录为：/root/lnmp1.3-full/src/php-5.4.45/\n则执行：cd /root/lnmp1.3-full/src/php-5.4.45/ext/ 一般安装完lnmp php源码都是自动删除了的，需要自己进入src目录下解压。\n我们要安装imap模块，执行cd imap/\n再执行 /usr/local/php/bin/phpize 会返回如下信息：\nconfiguring for: php api version: 20041225 zend module api no: 20060613 zend extension api no: 220060519 再执行以下命令：\n[root@vpser imap]# ./configure --with-php-config=/usr/local/php/bin/php-config --with-kerberos --with-imap-ssl [root@vpser imap]# make \u0026amp;\u0026amp; make install 执行完返回：\nbuild complete. don\u0026#39;t forget to run \u0026#39;make test\u0026#39;. installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/ 表示已经成功，再修改 /usr/local/php/etc/php.ini\n查找：extension_dir 再下面一行添加上 extension = \u0026quot;imap.so\u0026quot;\n保存，执行 /etc/init.d/php-fpm restart 重启。\n在浏览器里面输入http://ip/p.php，打开探针，安装imap模块前：\n安装imap模块后：\n安装exif模块 安装exif不需要另外安装库，所以省略掉了安装库的步骤。\n比如php的源码目录为：/root/lnmp1.3-full/src/php-5.4.45/\n则执行：cd /root/lnmp1.3-full/src/php-5.4.45/ext/\n我们要安装exif模块，执行 cd exif/\n再执行 /usr/local/php/bin/phpize 会返回如下信息：\nconfiguring for: php api version: 20041225 zend module api no: 20060613 zend extension api no: 220060519 再执行以下命令：\n[root@vpser imap]# ./configure --with-php-config=/usr/local/php/bin/php-config [root@vpser imap]# make \u0026amp;\u0026amp; make install 执行完返回：\nbuild complete. don\u0026#39;t forget to run \u0026#39;make test\u0026#39;. installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/ 表示已经成功，再修改 /usr/local/php/etc/php.ini\n查找：extension = 再最后一个extension= 后面添加上extension = \u0026quot;exif.so\u0026quot;\n保存，执行/etc/init.d/php-fpm restart 重启。\n在/home/wwwroot/下面创建一个exif.php的文件，内容如下：\n\u0026lt;?php $exif = read_exif_data (\u0026#39;img_0001.jpg\u0026#39;); while(list($k,$v)=each($exif)) { echo \u0026#34;$k: $v\u0026lt;br\u0026gt;\\n\u0026#34;; } ?\u0026gt; 其中img_0001.jpg为照片文件。\n未安装exif模块前：\n安装exif模块后：\n可以读出照片的exif信息。\n安装其他模块也基本上都是这两种方式，当 ./configure --with-php-config=/usr/local/php/bin/php-config 执行这个的时候是会检查系统上库是否安装上，如果没有安装上就会报错，按错误提示安装相关的库就行。\n","date":"2019-07-09","permalink":"https://blog.akvicor.com/posts/php/lnmp/","summary":"\u003cp\u003eLNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RHEL/Fedora/Aliyun/Amazon、Debian/Ubuntu/Raspbian/Deepin/Mint Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。\u003c/p\u003e","title":"lnmp安装"},{"content":" poj-2524 ubiquitous religions 使用并查集将m对并起来之后，输出集合数量即可\ncode /** * author: akvicor * created: 2019-06-19 15-56-44 **/ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;complex\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #define cout cout \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; class unionfind{ private: int * parents; int * sz; int count; public: unionfind(int n){ this-\u0026gt;count = n; parents = new int[n]; sz = new int[n]; for(int i = 0; i \u0026lt; n; ++i){ parents[i] = i; sz[i] = 1; } } ~unionfind(){ delete [] parents; delete [] sz; } int find(int p){ while(p != parents[p]) p = parents[p];\treturn p; } void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if(proot == qroot) return; if(sz[proot] \u0026lt; sz[qroot]){ parents[proot] = qroot; sz[qroot] += sz[proot]; }else{ parents[qroot] = proot; sz[proot] += sz[qroot]; } } int ans(){ int cnt = 0; for(int i = 0; i \u0026lt; this-\u0026gt;count; ++i){ if(parents[i] == i) ++cnt; } return cnt; } }; int n, m, i, j, cnt = 0; int main(){ fast_io; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; (n || m)){ ++cnt; //if(n==0 \u0026amp;\u0026amp; m==0) break; unionfind uf = unionfind(n); while(m--){ cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j; uf.unionelements(i-1, j-1); } cout \u0026lt;\u0026lt; \u0026#34;case \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; uf.ans() \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-06-19","permalink":"https://blog.akvicor.com/posts/cf/poj_2524/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://poj.org/problem?id=2524\"\u003e POJ-2524 Ubiquitous Religions \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"ubiquitous religions"},{"content":"poj-1703 find them, catch them\n并查集\n数组建两倍于n的长度，分为两段，两段对应位置属于同一个人\nd 时：\n将第一段的p和第二段的q相互连接，同时第一段的q和第二段的p相互连接，代表 p、q 属于不同帮派。\na 时：\n先判断在第一段内 p、q 是否相互连接，如果连接则一定属于同一帮派，因为 p、q 必定以某个敌对帮派的人物为桥梁才建立的连接。\n如果不相连接则再判断 p、q + n 是否相连接，如果连接则一定属于不同帮派\n如果上述都不满足则 p、q 关系不确定\ncode /** * author: akvicor * created: 2019-06-13 21-00-16 **/ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;complex\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #define cout cout \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; class unionfind{ private: int * parent; int * rank; int count; public: unionfind(int n){ n *= 2; n += 10; parent = new int[n]; rank = new int[n]; this-\u0026gt;count = n; for(int i = 0; i \u0026lt; n; ++i){ parent[i] = i; rank[i] = 1; } } ~unionfind(){ delete[] parent; delete[] rank; } int find(int p){ while(p != parent[p]){ p = parent[p]; } return p; } bool isconnected(int p, int q){ return find(p) == find(q); } void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if(proot == qroot) return; if(rank[proot] \u0026lt; rank[qroot]){ parent[proot] = qroot; }else if(rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; }else{ parent[proot] = qroot; rank[qroot] += 1; } } }; int t, n, m, p, q; char c; int main(){ //fast_io; //cin \u0026gt;\u0026gt; t; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;t); while(t--){ //cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;m); unionfind uf = unionfind(n); while(m--){ //cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; scanf(\u0026#34;%c %d %d\\n\u0026#34;, \u0026amp;c, \u0026amp;p, \u0026amp;q); if(c == \u0026#39;d\u0026#39;){ uf.unionelements(p, n+q); uf.unionelements(q, n+p); }else{ if(uf.isconnected(p, q)) cout \u0026lt;\u0026lt; \u0026#34;in the same gang.\u0026#34; \u0026lt;\u0026lt; endl; else if(uf.isconnected(p, n+q)) cout \u0026lt;\u0026lt; \u0026#34;in different gangs.\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;not sure yet.\u0026#34; \u0026lt;\u0026lt; endl; } } } return 0; } ","date":"2019-06-13","permalink":"https://blog.akvicor.com/posts/cf/poj_1703/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://poj.org/problem?id=1703\"\u003ePOJ-1703 Find them, Catch them\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"find them, catch them"},{"content":"hdu-1213 how many tables\n使用并查集求出一共有几个集合就可以\ncode /** * author: akvicor * created: 2019-06-13 16-05-22 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #define cout cout \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; class unionfind{ private: int * parent; int * rank; int count; public: unionfind(int n){ parent = new int[n]; rank = new int[n]; this-\u0026gt;count = n; for(int i = 0; i \u0026lt; n; ++i){ parent[i] = i; rank[i] = 1; } } ~unionfind(){ delete[] parent; delete[] rank; } int find(int p){ while(p != parent[p]){ p = parent[p]; } return p; } bool isconnected(int p, int q){ return find(p) == find(q); } void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if(proot == qroot) return; if(rank[proot] \u0026lt; rank[qroot]){ parent[proot] = qroot; }else if(rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; }else{ parent[proot] = qroot; rank[qroot] += 1; } } int cnt(){ int cnt = 0; for(int i = 0; i \u0026lt; this-\u0026gt;count; ++i){ if(parent[i] == i) ++cnt; } return cnt; } }; int main(){ fast_io; int t; cin \u0026gt;\u0026gt; t; while(t--){ int n, m, p, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; unionfind uf = unionfind(n); while(m--){ cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; uf.unionelements(p-1, q-1); } cout \u0026lt;\u0026lt; uf.cnt() \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-06-13","permalink":"https://blog.akvicor.com/posts/cf/hdu_1213/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1213\"\u003eHDU-1213 How Many Tables\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"how many tables"},{"content":"hdu-1272 小希的迷宫\n并查集判断，只要每次连接的 p、q 之前并未相互连接即可\n每组数据只能组成一个迷宫\ncode /** * author: akvicor * created: 2019-06-13 17-17-53 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #define cout cout \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; class unionfind{ private: int * parent; int * rank; bool * ral; int count; public: unionfind(int n){ parent = new int[n]; rank = new int[n]; ral = new bool[n]; this-\u0026gt;count = n; for(int i = 0; i \u0026lt; n; ++i){ parent[i] = i; rank[i] = 1; ral[i] = false; } } ~unionfind(){ delete[] parent; delete[] rank; } int find(int p){ while(p != parent[p]){ p = parent[p]; } return p; } bool isconnected(int p, int q){ this-\u0026gt;ral[p] = true; this-\u0026gt;ral[q] = true; return find(p) == find(q); } bool is_one_grap(){ int res = 0; for(int i = 0; i \u0026lt;= this-\u0026gt;count; ++i){ if(this-\u0026gt;parent[i] == i \u0026amp;\u0026amp; this-\u0026gt;ral[i]) ++res; } return res \u0026lt;= 1; } void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if(proot == qroot) return; if(rank[proot] \u0026lt; rank[qroot]){ parent[proot] = qroot; }else if(rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; }else{ parent[proot] = qroot; rank[qroot] += 1; } } int cnt(){ int cnt = 0; for(int i = 0; i \u0026lt; this-\u0026gt;count; ++i){ if(parent[i] == i) ++cnt; } return cnt; } }; int main(){ fast_io; int p, q; while(true){ bool flag = true; unionfind uf = unionfind(100010); while(cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q){ if(p == 0 \u0026amp;\u0026amp; q == 0) break; if(p == -1 \u0026amp;\u0026amp; q == -1) return 0; if(!flag) continue; if(uf.isconnected(p, q)) flag = false; else uf.unionelements(p, q); } if(flag \u0026amp;\u0026amp; uf.is_one_grap()) cout \u0026lt;\u0026lt; \u0026#34;yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-06-13","permalink":"https://blog.akvicor.com/posts/cf/hdu_1272/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1272\"\u003eHDU-1272 小希的迷宫\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"小希的迷宫"},{"content":"poj-1611 the suspects\n并查集板子题\ncode /** * author: akvicor * created: 2019-06-13 15-21-28 **/ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;complex\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #ifdef debug string to_string(string s) { return \u0026#39;\u0026#34;\u0026#39; + s + \u0026#39;\u0026#34;\u0026#39;; } string to_string(const char* s) { return to_string((string) s); } string to_string(bool b) { return (b ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); } template \u0026lt;typename a, typename b\u0026gt; string to_string(pair\u0026lt;a, b\u0026gt; p) { return \u0026#34;(\u0026#34; + to_string(p.first) + \u0026#34;, \u0026#34; + to_string(p.second) + \u0026#34;)\u0026#34;; } template \u0026lt;typename a\u0026gt; string to_string(a v) { bool first = true; string res = \u0026#34;{\u0026#34;; for (const auto \u0026amp;x : v) { if (!first) { res += \u0026#34;, \u0026#34;; } first = false; res += to_string(x); } res += \u0026#34;}\u0026#34;; return res; } void debug_out() { cerr \u0026lt;\u0026lt; endl; } template \u0026lt;typename head, typename... tail\u0026gt; void debug_out(head h, tail... t) { cerr \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; to_string(h); debug_out(t...); } #endif #ifdef debug #define debug(...) cerr \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; #__va_args__ \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;, debug_out(__va_args__) #else #define debug(...) 17 #endif #ifdef debug #define fast_io 17 #define cout cout \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define ll long long #define ull unsigned long long #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define all(v) (v).begin(), (v).end() #define pb push_back #define vi vector\u0026lt;int\u0026gt; #define pii pair\u0026lt;int,int\u0026gt; #define fi first #define se second #define sz(x) ((int)(x).size()) const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; const int maxn = (int)1e6 + 10; const int mod = (int)1e9 + 7; class unionfind{ private: int * parent; int * sz; int count; public: unionfind(int n){ parent = new int[n]; sz = new int[n]; this-\u0026gt;count = n; for(int i = 0; i \u0026lt; n; ++i){ parent[i] = i; sz[i] = 1; } } ~unionfind(){ delete[] parent; delete[] sz; } int find(int p){ while(p != parent[p]) p = parent[p]; return p; } bool isconnected(int p, int q){ return find(p) == find(q); } void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if(proot == qroot) return; if(sz[proot] \u0026lt; sz[qroot]){ parent[proot] = qroot; sz[qroot] += sz[proot]; }else{ parent[qroot] = proot; sz[proot] += sz[qroot]; } } int cnt(int p){ return sz[find(p)]; } }; int n, m; int main(){ fast_io; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m){ if(n == 0 \u0026amp;\u0026amp; m == 0) break; int k, p, q; unionfind uf = unionfind(n); while(m--){ cin \u0026gt;\u0026gt; k; if(k == 0) continue; if(k == 1){cin \u0026gt;\u0026gt; k; continue;} cin \u0026gt;\u0026gt; p; while(--k){ cin \u0026gt;\u0026gt; q; uf.unionelements(p, q);\t} } cout \u0026lt;\u0026lt; uf.cnt(0) \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-06-13","permalink":"https://blog.akvicor.com/posts/cf/poj_1611/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://poj.org/problem?id=1611\"\u003ePOJ-1611 The Suspects\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"the suspects"},{"content":"what i have to do after reinstalling the system\ninstall brew /usr/bin/ruby -e \u0026#34;$(curl -fssl https://raw.githubusercontent.com/homebrew/install/master/install)\u0026#34; 关闭每次运行时的自动更新\n# 临时关闭 在terminal中运行 # 永久关闭 在terminal配置文件中加入下面这一行 .bash_profile export homebrew_no_auto_update=true 安装 g++ # 查询可用版本 brew search gcc # 安装 brew install gcc@7 设置gcc7为默认编译器\n# setting gcc7 as default gcc compiler alias gcc=\u0026#39;gcc-7\u0026#39; alias gcc=\u0026#39;g++-7\u0026#39; alias gcc=\u0026#39;cpp-7\u0026#39; alias gcc=\u0026#39;c++-7\u0026#39; .bash_profile # system command alias ll=\u0026#39;ls -al\u0026#39; alias c=\u0026#39;clear\u0026#39; # setting for my command export path=$path:~/.my_command # setting gcc7 as default gcc compiler alias gcc=\u0026#39;gcc-7\u0026#39; alias gcc=\u0026#39;g++-7\u0026#39; alias gcc=\u0026#39;cpp-7\u0026#39; alias gcc=\u0026#39;c++-7\u0026#39; # for acm-icpc alias acm=\u0026#39;cd /users/akvicor/documents/github/problem-set\u0026#39; # use \u0026#39;safe-rm\u0026#39; as \u0026#39;rm\u0026#39; alias rm=\u0026#39;safe-rm\u0026#39; # close homebrew auto update export homebrew_no_auto_update=true .vimrc filetype plugin indent on colorscheme desert syntax on set nu set backspace=2 set hlsearch set syntax=on set tabstop=2 set shiftwidth=2 set smarttab set smartindent set showmatch set matchtime=0 set report=0 function close(char) if getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;) - 1] == a:char return \u0026#34;\\\u0026lt;right\u0026gt;\u0026#34; else return a:char endif endfunction map \u0026lt;c-a\u0026gt; ggvg\u0026#34;+y map \u0026lt;f5\u0026gt; :call run()\u0026lt;cr\u0026gt; map \u0026lt;f4\u0026gt; :call run2()\u0026lt;cr\u0026gt; func! run() exec \u0026#34;w\u0026#34; exec \u0026#34;!g++-7 -o2 -std=c++11 -wall % -o .%\u0026lt;.sol\u0026#34; exec \u0026#34;!./.%\u0026lt;.sol\u0026#34; endfunc func! run2() exec \u0026#34;w\u0026#34; exec \u0026#34;!g++-7 -o2 -std=c++11 -wall % -o .%\u0026lt;.sol\u0026#34; exec \u0026#34;!./.%\u0026lt;.sol \u0026lt; in\u0026#34; endfunc map \u0026lt;f12\u0026gt; :call settitle()\u0026lt;cr\u0026gt; func settitle() let l = 0 let l = l + 1 | call setline(l,\u0026#39;/* ***********************************************\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;author : akvicor\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;created time : \u0026#39;.strftime(\u0026#39;%c\u0026#39;)) let l = l + 1 | call setline(l,\u0026#39;file name : \u0026#39;.expand(\u0026#39;%\u0026#39;)) let l = l + 1 | call setline(l,\u0026#39;************************************************ */\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#include \u0026lt;bits/stdc++.h\u0026gt;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#define endl \u0026#39;\u0026#39;\\n\u0026#39;\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#define asb using namespace std; typedef long long ll; namespace akvicors {\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;#define ase } int main() { return akvicors::sol(); }\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;asb\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;int sol(){\u0026#39;) let l = l + 1 | call setline(l,\u0026#39; fast_io;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39; \u0026#39;) let l = l + 1 | call setline(l,\u0026#39; \u0026#39;) let l = l + 1 | call setline(l,\u0026#39; \u0026#39;) let l = l + 1 | call setline(l,\u0026#39; return 0;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;}\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;ase\u0026#39;) let l = l + 1 | call setline(l,\u0026#39;\u0026#39;) exec \u0026#34;21\u0026#34; endfunc ","date":"2019-06-06","permalink":"https://blog.akvicor.com/posts/mac/reinstall_system/","summary":"\u003cp\u003eWhat I have to do after reinstalling the system\u003c/p\u003e","title":"reinstall system"},{"content":"如果一个平面中有n条直线，最多能将平面划分成多少区域。\n当1条线时 2个平面\n当2条线时 4个平面（交叉1根线等多出2个平面）\n当3条线时 7个平面 (交叉2根线等多出3个平面)\n当4条线时 11个平面 (交叉3根线等多出4个平面)\n\u0026hellip;..\n其实已经可以递推了，前n项和\n$math_inline$f(n)=\\frac{n*(n+1)}{2}+1$math_inline$ while(cin\u0026gt;\u0026gt;n) cout\u0026lt;\u0026lt;n*(n+1)/2+1\u0026lt;\u0026lt;endl; ","date":"2019-05-31","permalink":"https://blog.akvicor.com/posts/algorithm/lines_dividing_planes/","summary":"\u003cp\u003e如果一个平面中有n条直线，最多能将平面划分成多少区域。\u003c/p\u003e","title":"直线划分平面"},{"content":"在使用自定义内网ip的时候突然发现mac提示我无效的服务器地址。\n思路是这样的：先关闭ipv6，然后设置ipv4，再重新开启ipv6。\n关闭 ipv6 显然 ”高级“ \u0026gt; \u0026ldquo;tcp/ip\u0026rdquo; 下 ipv6 没有提供关闭选项，所以需要用终端命令\nnetworksetup -setv6off ethernet 这时候系统会弹窗要求输入密码，搞定后你会发现 ”高级“ \u0026gt; \u0026ldquo;tcp/ip\u0026rdquo; 下 ipv6 多了个关闭选项\n此时再重新填写信息即可\n","date":"2019-05-31","permalink":"https://blog.akvicor.com/posts/mac/basic_ipv6_validation_error/","summary":"\u003cp\u003e在使用自定义内网ip的时候突然发现Mac提示我无效的服务器地址。\u003c/p\u003e","title":"以太网连接 报无效的服务器地址 basicipv6validationerror"},{"content":"如何判断两条直线是否相交？\n这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。\n但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？\n这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。\n问题分析 对于“判断两条直线是否相交”这个问题，我们之所以能迅速而准确地进行判断，是因为“相交”与“不相交”这两个状态有着明显的不同点，即斜率是否相等。\n那么现在，为了判断两条线段是否相交，我们也要找出“相交”与“不相交”这两个状态的不同点。\n假设现在有两条线段 ab 和 cd，我们画出它们之间的三种关系：\n其中，情况 1 为不相交，情况 2、3 为相交。\n作出向量 ac、ad、bc、bd。\n首先介绍一个概念： 向量有序对的旋转方向。这个概念指：对于共起点有序向量二元组(a, b)，其旋转方向为 使 a 能够旋转一个小于 180 度的角并与 b 重合的方向，简记为 direct(a, b)。若 a 和 b 反向共线，则旋转方向取任意值。\n举个例子：图一中，direct(ac, ad) 为顺时针方向。\n接下来我们要分析四个值：direct(ac, ad)、direct(bc, bd)、direct(ca, cb)、direct(da, db)。\n对于图一，direct(ac, ad) 和 direct(bc, bd) 都为顺时针，direct(ca, cb) 为逆时针，direct(da, db) 为顺时针。\n对于图二，direct(ac, ad) 为顺时针，direct(bc, bd) 为任意方向，direct(ca, cb) 为逆时针，direct(da, db) 为顺时针。\n对于图三，direct(ac, ad)、direct(da, db) 为顺时针，direct(bc, bd)、direct(ca, cb) 为逆时针。\n不难发现，两条线段相交的充要条件是：direct(ac, ad) != direct(bc, bd) 且 direct(ca, cb) != direct(da, db)。这便是“相交”与“不相交”这两个状态的不同点。\n然而你可能会觉得：旋转方向这么一个虚无飘渺的东西，怎么用程序去描述啊？\n再来看一幅图：\n再来定义有向角：\n有向角 \u0026lt;a, b\u0026gt; 为向量 a 逆时针旋转到与向量 b 重合所经过的角度。\n不难看出，对于向量 a、b：\n若 direct(a, b) 为逆时针，则 0 \u0026lt;= \u0026lt;a, b\u0026gt; \u0026lt;= 180，从而 sin\u0026lt;a, b\u0026gt; \u0026gt;= 0。\n若 direct(a, b) 为顺时针，则 180 \u0026lt;= \u0026lt;a, b\u0026gt; \u0026lt;= 360，从而 sin\u0026lt;a, b\u0026gt; \u0026lt;= 0。\n这样一来，我们可以将旋转方向的问题转化为 求有向角正弦值 的问题。而这个问题，是很容易的。\n如上图，记\n$math_inline$oa=(x_1,y_1),ob=(x_2,y_2)$math_inline$ $math_inline$|oa|=r_1, |ob|=r_2$math_inline$ 则： $math_inline$sin()$math_inline$ $math_inline$=\\sin\\theta$math_inline$ $math_inline$=\\sin(\\alpha-\\beta)$math_inline$ $math_inline$=\\sin\\alpha\\cos\\beta-\\sin\\beta\\cos\\alpha$math_inline$ $math_inline$=\\frac{(\\sin\\alpha\\cos\\beta-\\sin\\beta\\cos\\alpha)r_1\\cdot r_2}{r_1\\cdot r_2}$math_inline$ $math_inline$=\\frac{x_1 \\cdot y_2-x_2 \\cdot y_1}{r_1 \\cdot r_2}$math_inline$ 而这里，我们要的只是 sin(\u0026lt;oa, ob\u0026gt;) 的符号，而 r1 和 r2 又都是恒正的，因此只需判断 x1 * y2 - x2 * y1 的符号即可。\n这个方法的数学背景是 叉乘，可以前往 wikipedia 了解更多。\n思路小结 由点 a，b，c，d 计算出向量 ac，ad，bc，bd\n计算 sin(\u0026lt;ac, ad\u0026gt;) * sin(\u0026lt;bc, bd\u0026gt;) 和 sin(\u0026lt;ca, cb\u0026gt;) * sin(\u0026lt;da, db\u0026gt;)，若皆为非正数，则相交；否则，不相交。\n实现 # 点 class point(object): def __init__(self, x, y): self.x, self.y = x, y # 向量 class vector(object): def __init__(self, start_point, end_point): self.start, self.end = start_point, end_point self.x = end_point.x - start_point.x self.y = end_point.y - start_point.y zero = 1e-9 def negative(vector): \u0026#34;\u0026#34;\u0026#34;取反\u0026#34;\u0026#34;\u0026#34; return vector(vector.end_point, vector.start_point) def vector_product(vectora, vectorb): \u0026#39;\u0026#39;\u0026#39;计算 x_1 * y_2 - x_2 * y_1\u0026#39;\u0026#39;\u0026#39; return vectora.x * vectorb.y - vectorb.x * vectora.y def is_intersected(a, b, c, d): \u0026#39;\u0026#39;\u0026#39;a, b, c, d 为 point 类型\u0026#39;\u0026#39;\u0026#39; ac = vector(a, c) ad = vector(a, d) bc = vector(b, c) bd = vector(b, d) ca = negative(ac) cb = negative(bc) da = negative(ad) db = negative(bd) return (vector_product(ac, ad) * vector_product(bc, bd) \u0026lt;= zero) \\ and (vector_product(ca, cb) * vector_product(da, db) \u0026lt;= zero) ","date":"2019-05-29","permalink":"https://blog.akvicor.com/posts/algorithm/line_intersect/","summary":"\u003cp\u003e如何判断两条直线是否相交？\u003c/p\u003e\n\u003cp\u003e这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。\u003c/p\u003e\n\u003cp\u003e但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？\u003c/p\u003e\n\u003cp\u003e这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。\u003c/p\u003e","title":"判断两个线段相交"},{"content":"叙述在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式 输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。\n使用控制符的方法 使用流对象的有关成员函数 使用控制符的方法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int a; cout \u0026lt;\u0026lt; \u0026#34;input a:\u0026#34;; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; \u0026#34;dec:\u0026#34; \u0026lt;\u0026lt; dec \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //以十进制形式输出整数 cout \u0026lt;\u0026lt; \u0026#34;hex:\u0026#34; \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //以十六进制形式输出整数a cout \u0026lt;\u0026lt; \u0026#34;oct:\u0026#34; \u0026lt;\u0026lt; setbase(8) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //以八进制形式输出整数a char *pt = \u0026#34;china\u0026#34;; //pt指向字符串\u0026#34;china\u0026#34; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; pt \u0026lt;\u0026lt; endl; //指定域宽为,输出字符串 cout \u0026lt;\u0026lt; setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; pt \u0026lt;\u0026lt; endl; //指定域宽,输出字符串,空白处以\u0026#39;*\u0026#39;填充 double pi = 22.0 / 7.0; //计算pi值 //按指数形式输出,8位小数 cout \u0026lt;\u0026lt; setiosflags(ios::scientific) \u0026lt;\u0026lt; setprecision(8); cout \u0026lt;\u0026lt; \u0026#34;pi=\u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; //输出pi值 cout \u0026lt;\u0026lt; \u0026#34;pi=\u0026#34; \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; //改为位小数 cout \u0026lt;\u0026lt; \u0026#34;pi=\u0026#34; \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; //改为小数形式输出 return 0; } 人们在输入输出时有一些特殊的要求，如在输出实数时规定字段宽度，只保留两位小数，数据向左或向右对齐等。c++提供了在输入输出流中使用的控制符(有的书中称为操纵符)\n举例， 输出双精度数：\ndouble a = 123.456789012345; // 对a赋初值 cout \u0026lt;\u0026lt; a; // 输出： 123.456 cout \u0026lt;\u0026lt; setprecision(9) \u0026lt;\u0026lt; a; //输出： 123.456789 cout \u0026lt;\u0026lt; setprecision(6); //恢复默认格式(精度为6) cout \u0026lt;\u0026lt; setiosflags(ios::fixed); //输出： 123.456789 cout \u0026lt;\u0026lt; setiosflags(ios::fixed)\u0026lt;\u0026lt;setprecision(8) \u0026lt;\u0026lt; a; //输出： 123.45678901 cout \u0026lt;\u0026lt; setiosflags(ios::scientific)\u0026lt;\u0026lt;a; //输出： 1.234568e+02 cout \u0026lt;\u0026lt; setiosflags(ios::scientific)\u0026lt;\u0026lt;setprecision(4) \u0026lt;\u0026lt; a; //输出： 1.2346e02 下面是整数输出的例子：\nint b = 123456; // 对b赋初值 cout \u0026lt;\u0026lt; b; //输出： 123456 cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; b; //输出： 1e240 cout \u0026lt;\u0026lt; setiosflags(ios::uppercase) \u0026lt;\u0026lt; b; //输出： 1e240 cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; b; //输出： 123456，123456 cout \u0026lt;\u0026lt; setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; b; //输出： **** 123456 cout \u0026lt;\u0026lt; setiosflags(ios::showpos) \u0026lt;\u0026lt; b; //输出： +123456 如果在多个cout语句中使用相同的setw(n)，并使用setiosflags(ios::right)，可以实现各行数据右对齐，如果指定相同的精度，可以实现上下小数点对齐。\n例如：各行小数点对齐。\nint main() { double a = 123.456, b = 3.14159, c = -3214.67; cout \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; setiosflags(ios::right) \u0026lt;\u0026lt; setprecision(2); cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 输出如下：\n123.46 (字段宽度为10，右对齐，取两位小数) 3.14 -3214.67 先统一设置定点形式输出、取两位小数、右对齐。这些设置对其后的输出均有效(除非重新设置)，而setw只对其后一个输出项有效，因此必须在输出a，b，c之前都要写setw(10)。\n用流对象的成员函数控制输出格式 除了可以用控制符来控制输出格式外，还可以通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数如下：\n流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表13.5。\n例：用流控制成员函数输出数据。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int a = 21; cout.setf(ios::showbase);//显示基数符号(0x或) cout \u0026lt;\u0026lt; \u0026#34;dec:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //默认以十进制形式输出a cout.unsetf(ios::dec); //终止十进制的格式设置 cout.setf(ios::hex); //设置以十六进制输出的状态 cout \u0026lt;\u0026lt; \u0026#34;hex:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //以十六进制形式输出a cout.unsetf(ios::hex); //终止十六进制的格式设置 cout.setf(ios::oct); //设置以八进制输出的状态 cout \u0026lt;\u0026lt; \u0026#34;oct:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //以八进制形式输出a cout.unsetf(ios::oct); char *pt = \u0026#34;china\u0026#34;; //pt指向字符串\u0026#34;china\u0026#34; cout.width(10); //指定域宽为 cout \u0026lt;\u0026lt; pt \u0026lt;\u0026lt; endl; //输出字符串 cout.width(10); //指定域宽为 cout.fill(\u0026#39;*\u0026#39;); //指定空白处以\u0026#39;*\u0026#39;填充 cout \u0026lt;\u0026lt; pt \u0026lt;\u0026lt; endl; //输出字符串 double pi = 22.0 / 7.0; //输出pi值 cout.setf(ios::scientific); //指定用科学记数法输出 cout \u0026lt;\u0026lt; \u0026#34;pi=\u0026#34;; //输出\u0026#34;pi=\u0026#34; cout.width(14); //指定域宽为 cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; //输出pi值 cout.unsetf(ios::scientific); //终止科学记数法状态 cout.setf(ios::fixed); //指定用定点形式输出 cout.width(12); //指定域宽为 cout.setf(ios::showpos); //正数输出“+”号 cout.setf(ios::internal); //数符出现在左侧 cout.precision(6); //保留位小数 cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; //输出pi,注意数符“+”的位置 return 0; } 运行情况如下：\ndec:21(十进制形式) hex:0x15 (十六进制形式,以x开头) oct:025 (八进制形式,以开头) china (域宽为) *****china (域宽为,空白处以\u0026#39;*\u0026#39;填充) pi=**3.142857e+00 (指数形式输出,域宽,默认位小数) +***3.142857 (小数形式输出,精度为,最左侧输出数符“+”) 对程序的几点说明：\n成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如：\ncout.width(6); cout \u0026lt;\u0026lt; 20 \u0026lt;\u0026lt; 3.14 \u0026lt;\u0026lt; endl; 输出结果为 203.14\n在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)， 而必须在输出每一项前都调用一次width(n\u0026gt;，上面的程序中就是这样做的。\n在表13.5中的输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和 控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或 resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开 始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先 用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因 此hex和oct的设置均不起作用，系统依然以十进制形式输出。\n同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。\n用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：\ncout.setf(ios::internal | ios::showpos); //包含两个状态标志，用\u0026quot;|\u0026ldquo;组合\n可以看到：对输出格式的控制，既可以用控制符(如例13.2)，也可以用cout流的有关成员函数(如例13.3)，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。\n","date":"2019-05-28","permalink":"https://blog.akvicor.com/posts/cpp/output_control/","summary":"\u003cp\u003e叙述在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式 输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用控制符的方法\u003c/li\u003e\n\u003cli\u003e使用流对象的有关成员函数\u003c/li\u003e\n\u003c/ol\u003e","title":"c++输出格式控制"},{"content":"所谓素数，是指恰好有两个约数的正整数。\n埃氏筛法 区间筛法 miller-rabin素性测试 判定单一的一个数是不是素数，素性测试：\ncode bool is_prime(int n){ /* 判定一个数是不是素数 ，假设输入的数都是正整数 */ for (int i = 2; i * i \u0026lt;= n; i++) { if (!(n % i)) return false; } return n != 1; /* 1是例外 */ } 如果只对一个数进行素数测试，通常 $math_inline$o(\\sqrt{n})$math_inline$ 的算法就足够了。但\u0026hellip;\u0026hellip;..\nmiller-rabin素性测试 引理1(费马定理) 设p是素数，a为整数，且(a,p)=1，则 $math_inline$a^{p-1} \\equiv 1(\\text{mod}p)$math_inline$ 。\n引理2(二次探测定理) 如果p是一个素数，且 $math_inline$0","date":"2019-05-28","permalink":"https://blog.akvicor.com/posts/algorithm/prime/","summary":"\u003cp\u003e所谓素数，是指恰好有两个约数的正整数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e埃氏筛法\u003c/li\u003e\n\u003cli\u003e区间筛法\u003c/li\u003e\n\u003cli\u003eMiller-Rabin素性测试\u003c/li\u003e\n\u003c/ul\u003e","title":"素数判定"},{"content":"线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（range minimum/maximum query problem）或者区间异或值的查询。\n对应于树状数组，线段树进行更新（update）的操作为o(logn)，进行区间查询（range query）的操作也为o(logn)。\n实现原理 从数据结构的角度来说，线段树是用一个完全二叉树来存储对应于其每一个区间（segment）的数据。该二叉树的每一个结点中保存着相对应于这一个区间的信息。同时，线段树所使用的这个二叉树是用一个数组保存的，与堆（heap）的实现方式相同。\n例如，给定一个长度为n的数组arr，其所对应的线段树t各个结点的含义如下：\nt的根结点代表整个数组所在的区间对应的信息，及arr[0:n]（不含n）所对应的信息。 t的每一个叶结点存储对应于输入数组的每一个单个元素构成的区间arr[i]所对应的信息，此处 $math_inline$0≤i","date":"2019-05-28","permalink":"https://blog.akvicor.com/posts/algorithm/segment_tree/","summary":"\u003cp\u003e线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。\u003c/p\u003e\n\u003cp\u003e对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。\u003c/p\u003e","title":"线段树"},{"content":"写程序时，程序的运行效率很重要，其往往是评价程序优劣性的直接标准。程序运行效率的最简单方法就是计算程序的运行时间。为了提高程序效率，使用适当的方法对程序的各个部分进行运行时间的计算是很有必要的。\n在 linux/unix 环境下，计算 c 程序运行时间可以通过以下三个函数来实现：\nclock()、time()、gettimeofday()\ngettimeofday()函数的精度最高，为微秒级别； clock()函数的精度次之，为 10ms 级别； time()函数的精度最低，为 1s 级别。 clock() 函数 clock()函数是 ansi c 的标准库函数，是 c/c++ 十分常用的计时函数，其声明定义在 time.h 头文件中：\nclock_t clock( void ); 此函数返回处理器调用某个进程或函数所花费的时间的近似值，准确来说就是返回从“开启这个程序进程”到“程序中调用clock()函数”时这之间的 cpu 时钟计时单元（clock tick）数，在 msdn 中称之为挂钟时间（wal-clock）。如果无法得到处理器时间，则返回数值 -1（转换为 time_t 类型）。时钟计时单元（clock tick）的时间长短是由cpu控制的。一个 clock tick 不是 cpu 的一个时钟周期，而是 c/c++ 的一个基本计时单位。返回类型为clock_t，是用来保存时间的数据类型，在 time.h 文件中，我们可以找到对它的定义：\n#ifndef _clock_t_defined typedef long clock_t; #define _clock_t_defined #endif 很明显，clock_t本质上是一个长整形数。\n以上可知clock()函数返回的是时钟计时单元数（俗称硬件滴答数），要换算成秒或者毫秒，需要用到clocks_per_sec常量（或者clk_tck常量，两者其实一样），此常量在 time.h 文件中定义，用来表示一秒钟会有多少个时钟计时单元。在不同的系统中clocks_per_sec常量的值通常不一样，比如在本人的 linux 系统下，其定义如下：\n#define clocks_per_sec 1000000l（最后面的是字母l） 而在 windows 系统下的 vc6.0 中，其定义为：\n#define clocks_per_sec ((clock_t)1000) 这表示硬件滴答 1000 下是 1 秒，也即可以看到每过千分之一秒（1毫秒），调用clock()函数返回的值就加 1。\n因此，要计算运行某程序所需的时间只需要利用clock()函数得到运行此程序所消耗的钟计时单元数，然后再除以clocks_per_sec即可。\n比如可以使用公式 clock()/clocks_per_sec 来计算一个进程自身的运行时间：\nvoid elapsed_time(){ printf(\u0026#34;elapsed time:%u secs.\\n\u0026#34;,clock()/clocks_per_sec); } 下面用clock()函数来计算运行一个循环或者处理其它事件到底花了多少时间：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(void) { long i = 10000000l; clock_t start, finish; double duration; /* 测量一个事件持续的时间*/ printf( \u0026#34;time to do %ld empty loops is \u0026#34;, i) ; start = clock(); while( i-- ); finish = clock(); duration = (double)(finish - start) / clocks_per_sec; printf( \u0026#34;%f seconds\\n\u0026#34;, duration ); return 0; } 在本人的机器上（linux系统），运行结果如下：\ntime to do 10000000 empty loops is 0.03000 seconds 对于clock()函数来说，需要注意以下几点：\n它返回的是 cpu 耗费在本程序上的时间。也就是说，途中 sleep 的话，由于 cpu 资源被释放，那段时间将不被计算在内。因此，若函数中存在sleep()函数，则sleep()函数消耗的时间将不包含在内；\n得到的返回值其实就是耗费在本程序上的 cpu 时间片的数量，也就是 clock tick 的值。该值必须除以clocks_per_sec这个宏值，才能最后得到以秒为单位的运行时间。在 posix 兼容系统中，clocks_per_sec的值为 1,000,000 的，也就是 1mhz。\n这个函数的精度不适很高，大约为 10ms，也有说是 1ms，但是在本人机器上达不到那么高。低于精度的程序全部输出 0ms。像计算printf()之类的调用时间是不可能实现的，因为printf()的速度太快了，基本上和clock()的速度一样。所以，此函数适合用于计算一些大型程序，或循环程序。\ntime() 函数 time()函数来获得当前日历时间（calendar time）。所谓的日历时间就是用“从一个标准时间点（一般是1970年1月1日0时0分0秒）到此时的时间经过的秒数”来表示的时间。其原型为：\ntime_t time(time_t * timer); 如果 timer 不是 null，则返回值还存放在 timer 中。如果遇到错误，则返回 -1（转换成 time_t 类型）。time_t 是一个 long 类型。如果你已经声明了参数 timer，你可以从参数 timer 返回现在的日历时间，同时也可以通过返回值返回现在的日历时间，即从一个时间点（例如：1970年 1月1日0时0分0秒）到现在此时的秒数。如果参数为空（null），函数将只通过返回值返回现在的日历时间，比如下面这个例子用来显示当前的日历时间：\n#include \u0026lt;time.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;dos.h\u0026gt; int main() { time_t t; t=time(); printf(\u0026#34;the number of seconds since january 1,1970 is %ld\u0026#34;,t); return 0; } 也可以利用time()函数计算某段程序的运行时间：\n#include\u0026lt;time.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { time_t t1,t2; time(\u0026amp;t1); //此处放置要测试的代码 sleep(10);//延时 1 秒 time(\u0026amp;t2); printf(\u0026#34;%ld %ld %lds\\n\u0026#34;,t1,t2,t2-t1); return 0; } 在本人机器上的运行结果为：\n1361997962 1361997972 10s 需要注意的是，time()得到的时间的精度只有 1s。\ngettimeofday() 函数 gettimeofday()的函数原型为：\n#include\u0026lt;sys/time.h\u0026gt; int gettimeofday(struct timeval*tv, struct timezone *tz ) gettimeofday()会把目前的时间用 tv 结构体返回，当地时区的信息则放到 tz 所指的结构中。其结构体定义为：\nstruct timeval { long tv_sec; /*秒*/ long tv_usec; /*微妙*/ }； struct timezone{ int tz_minuteswest; /*和greenwich 时间差了多少分钟*/ int tz_dsttime; /*type of dst correction*/ }; 在gettimeofday()函数中 tv 或者 tz 都可以为空。如果为空则就不返回其对应的结构体。函数执行成功后返回 0，失败后返回 -1，错误代码存于 errno 中。\n程序实例为：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;sys/time.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; int main() { struct timeval tv; struct timezone tz; gettimeofday(\u0026amp;tv,\u0026amp;tz); printf(“tv_sec:%d\\n”,tv.tv_sec); printf(“tv_usec:%d\\n”,tv.tv_usec); printf(“tz_minuteswest:%d\\n”,tz.tz_minuteswest); printf(“tz_dsttime:%d\\n”,tz.tz_dsttime); return 0; } 在使用gettimeofday()函数时，第二个参数一般都为空，因为我们一般都只是为了获得当前时间，而不用获得 timezone 的数值。\n也可利用此函数计算某段程序的运行时间：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; int main() { struct timeval start; struct timeval end; unsigned long timer; gettimeofday(\u0026amp;start,null); printf(\u0026#34;hello world!\\n\u0026#34;); gettimeofday(\u0026amp;end,null); timer = 1000000 * (end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec; printf(\u0026#34;timer = %ld us\\n\u0026#34;,timer); return 0; } timeval start{}; timeval end{}; unsigned long long timer; gettimeofday(\u0026amp;start, nullptr); /********************************/ for (int n = 0; n \u0026lt; 200; ++n) { trial_divisio_fac(n); } /********************************/ gettimeofday(\u0026amp;end, nullptr); timer = 1000000 * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec; printf(\u0026#34;timer = %llu us\\n\u0026#34;, timer); gettimeofday()函数的计算精度为微秒，精度已经很高了。\n","date":"2019-05-27","permalink":"https://blog.akvicor.com/posts/cpp/calculate_program_running_time_in_linux/","summary":"\u003cp\u003e写程序时，程序的运行效率很重要，其往往是评价程序优劣性的直接标准。程序运行效率的最简单方法就是计算程序的运行时间。为了提高程序效率，使用适当的方法对程序的各个部分进行运行时间的计算是很有必要的。\u003c/p\u003e","title":"linux/unix 环境下实现精确计算程序运行的时间"},{"content":"求取数组中最大连续子序列和，例如给定数组为a={1， 3， -2， 4， -5}， 则最大连续子序列和为 $math_inline$6$math_inline$ ，即 $math_inline$1+3+(-2)+4=6$math_inline$ 。\n方法一共有三种，复杂度分别为 $math_inline$o(n^2)$math_inline$ 、 $math_inline$o(nlgn)$math_inline$ 、 $math_inline$o(n)$math_inline$ 解法1 - 暴力 - $math_inline$o(n^2)$math_inline$ 因为最大连续子序列和只可能从数组0到n-1中的某个位置，我们可以遍历0到n-1个位置，计算由这个位置开始的所有连续子序列和中的最大值。最终求出最大值即可。\n更详细的讲，就是计算从位置0开始的最大连续子序列和，从位置1开始的最大连续子序列和。。。直到从位置n-1开始的最大连续子序列和，最后求出所有这些连续子序列和中的最大值就是答案。\nint maxsequence(int arr[], int len) { int max = arr[0]; for (int i=0; i\u0026lt;len; i++) { int sum = 0; for (int j=i; j\u0026lt;len; j++) { sum += arr[j]; if (sum \u0026gt; max) max = sum; } } return max; } 解法2 - 分治 - $math_inline$o(nlgn)$math_inline$ 运用分治的思想来求解，最大连续子序列和要么出现在数组左半部分，要么出现在数组右半部分，要么横跨左右两个部分。因此求出这三种情况下的最大值就可以得到最大连续子序列和。\n/*求三个数最大值*/ int max3(int i, int j, int k) { if (i\u0026gt;=j \u0026amp;\u0026amp; i\u0026gt;=k) return i; return max3(j, k, i); } int maxsequence2(int a[], int l, int u) { if (l \u0026gt; u) return 0; if (l == u) return a[l]; int m = (l + u) / 2; /*求横跨左右的最大连续子序列左半部分*/ int lmax=a[m], lsum=0; for (int i=m; i\u0026gt;=l; i--) { lsum += a[i]; if (lsum \u0026gt; lmax) lmax = lsum; } /*求横跨左右的最大连续子序列右半部分*/ int rmax=a[m+1], rsum = 0; for (int i=m+1; i\u0026lt;=u; i++) { rsum += a[i]; if (rsum \u0026gt; rmax) rmax = rsum; } return max3(lmax+rmax, maxsequence2(a, l, m), maxsequence2(a, m+1, u)); //返回三者最大值 } 解法3 - $math_inline$o(n)$math_inline$ 因为最大连续子序列和只可能是以位置0～n-1中某个位置结尾。当遍历到第i个元素时，判断在它前面的连续子序列和是否大于0，如果大于0，则以位置i结尾的最大连续子序列和为元素i和前面的连续子序列和想加；否则，则以位置i结尾的最大连续子序列和为元素i。\nint maxsequence3(int a[], int len) { int maxsum, maxhere; maxsum = maxhere = a[0]; //初始化最大和为a【0】 for (int i=1; i\u0026lt;len; i++) { if (maxhere \u0026lt;= 0) maxhere = a[i]; //如果前面位置最大连续子序列和小于等于0，则以当前位置i结尾的最大连续子序列和为a[i] else maxhere += a[i]; //如果前面位置最大连续子序列和大于0，则以当前位置i结尾的最大连续子序列和为它们两者之和 if (maxhere \u0026gt; maxsum) { maxsum = maxhere; //更新最大连续子序列和 } } return maxsum; } ","date":"2019-05-27","permalink":"https://blog.akvicor.com/posts/algorithm/maximum_slice/","summary":"\u003cp\u003e求取数组中最大连续子序列和，例如给定数组为A={1， 3， -2， 4， -5}， 则最大连续子序列和为\n\n    \n        $math_inline$6$math_inline$\n    \n\n，即 \n\n    \n        $math_inline$1+3+(-2)+4=6$math_inline$\n    \n\n 。\u003c/p\u003e\n\u003cp\u003e方法一共有三种，复杂度分别为 \n\n    \n        $math_inline$O(N^2)$math_inline$\n    \n\n、\n\n    \n        $math_inline$O(NlgN)$math_inline$\n    \n\n、\n\n    \n        $math_inline$O(N)$math_inline$\n    \n\n\u003c/p\u003e","title":"最大子列和问题"},{"content":"pycharm和turtle库有冲突，不能自己识别出turtle下的方法\n找到turtle.py， turtle.py是安装在python目录下的lib文件夹里。 你可以对turtle库的源码进行如下修改： 注释掉原来的_ all_,新增如下：\n# __all__ = (_tg_classes + _tg_screen_functions + _tg_turtle_functions + # _tg_utilities + [\u0026#39;terminator\u0026#39;]) # + _math_functions) __all__ = [\u0026#39;scrolledcanvas\u0026#39;, \u0026#39;turtlescreen\u0026#39;, \u0026#39;screen\u0026#39;, \u0026#39;rawturtle\u0026#39;, \u0026#39;turtle\u0026#39;, \u0026#39;rawpen\u0026#39;, \u0026#39;pen\u0026#39;, \u0026#39;shape\u0026#39;, \u0026#39;vec2d\u0026#39;, \u0026#39;back\u0026#39;, \u0026#39;backward\u0026#39;, \u0026#39;begin_fill\u0026#39;, \u0026#39;begin_poly\u0026#39;, \u0026#39;bk\u0026#39;, \u0026#39;addshape\u0026#39;, \u0026#39;bgcolor\u0026#39;, \u0026#39;bgpic\u0026#39;, \u0026#39;bye\u0026#39;, \u0026#39;clearscreen\u0026#39;, \u0026#39;colormode\u0026#39;, \u0026#39;delay\u0026#39;, \u0026#39;exitonclick\u0026#39;, \u0026#39;getcanvas\u0026#39;, \u0026#39;getshapes\u0026#39;, \u0026#39;listen\u0026#39;, \u0026#39;mainloop\u0026#39;, \u0026#39;mode\u0026#39;, \u0026#39;numinput\u0026#39;, \u0026#39;onkey\u0026#39;, \u0026#39;onkeypress\u0026#39;, \u0026#39;onkeyrelease\u0026#39;, \u0026#39;onscreenclick\u0026#39;, \u0026#39;ontimer\u0026#39;, \u0026#39;register_shape\u0026#39;, \u0026#39;resetscreen\u0026#39;, \u0026#39;screensize\u0026#39;, \u0026#39;setup\u0026#39;, \u0026#39;terminator\u0026#39;, \u0026#39;setworldcoordinates\u0026#39;, \u0026#39;textinput\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;tracer\u0026#39;, \u0026#39;turtles\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;window_height\u0026#39;, \u0026#39;window_width\u0026#39;, \u0026#39;write_docstringdict\u0026#39;, \u0026#39;done\u0026#39;, \u0026#39;circle\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;clearstamp\u0026#39;, \u0026#39;clearstamps\u0026#39;, \u0026#39;clone\u0026#39;, \u0026#39;color\u0026#39;, \u0026#39;degrees\u0026#39;, \u0026#39;distance\u0026#39;, \u0026#39;dot\u0026#39;, \u0026#39;down\u0026#39;, \u0026#39;end_fill\u0026#39;, \u0026#39;end_poly\u0026#39;, \u0026#39;fd\u0026#39;, \u0026#39;fillcolor\u0026#39;, \u0026#39;filling\u0026#39;, \u0026#39;forward\u0026#39;, \u0026#39;get_poly\u0026#39;, \u0026#39;getpen\u0026#39;, \u0026#39;getscreen\u0026#39;, \u0026#39;get_shapepoly\u0026#39;, \u0026#39;getturtle\u0026#39;, \u0026#39;goto\u0026#39;, \u0026#39;heading\u0026#39;, \u0026#39;hideturtle\u0026#39;, \u0026#39;home\u0026#39;, \u0026#39;ht\u0026#39;, \u0026#39;isdown\u0026#39;, \u0026#39;isvisible\u0026#39;, \u0026#39;left\u0026#39;, \u0026#39;lt\u0026#39;, \u0026#39;onclick\u0026#39;, \u0026#39;ondrag\u0026#39;, \u0026#39;onrelease\u0026#39;, \u0026#39;pd\u0026#39;, \u0026#39;pen\u0026#39;, \u0026#39;pencolor\u0026#39;, \u0026#39;pendown\u0026#39;, \u0026#39;pensize\u0026#39;, \u0026#39;penup\u0026#39;, \u0026#39;pos\u0026#39;, \u0026#39;position\u0026#39;, \u0026#39;pu\u0026#39;, \u0026#39;radians\u0026#39;, \u0026#39;right\u0026#39;, \u0026#39;reset\u0026#39;, \u0026#39;resizemode\u0026#39;, \u0026#39;rt\u0026#39;, \u0026#39;seth\u0026#39;, \u0026#39;setheading\u0026#39;, \u0026#39;setpos\u0026#39;, \u0026#39;setposition\u0026#39;, \u0026#39;settiltangle\u0026#39;, \u0026#39;setundobuffer\u0026#39;, \u0026#39;setx\u0026#39;, \u0026#39;sety\u0026#39;, \u0026#39;shape\u0026#39;, \u0026#39;shapesize\u0026#39;, \u0026#39;shapetransform\u0026#39;, \u0026#39;shearfactor\u0026#39;, \u0026#39;showturtle\u0026#39;, \u0026#39;speed\u0026#39;, \u0026#39;st\u0026#39;, \u0026#39;stamp\u0026#39;, \u0026#39;tilt\u0026#39;, \u0026#39;tiltangle\u0026#39;, \u0026#39;towards\u0026#39;, \u0026#39;turtlesize\u0026#39;, \u0026#39;undo\u0026#39;, \u0026#39;undobufferentries\u0026#39;, \u0026#39;up\u0026#39;, \u0026#39;width\u0026#39;, \u0026#39;write\u0026#39;, \u0026#39;xcor\u0026#39;, \u0026#39;ycor\u0026#39;] ","date":"2019-05-27","permalink":"https://blog.akvicor.com/posts/idea/pycharm_turtle/","summary":"\u003cp\u003ePyCharm和turtle库有冲突，不能自己识别出turtle下的方法\u003c/p\u003e","title":"pycharm不识别turtle下的方法"},{"content":"每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的质因数。如果一个质数是某个数的因数，那么就说这个质数是这个数的质因数。而这个因数一定是一个质数。\n把一个合数用质因数相乘的形式表示出来，叫做分解质因数。如30=2×3×5 。分解质因数只针对合数。\n质数： 质数（prime number）又称素数，有无限个。\n质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。\n合数： 合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。与之相对的是质数，而1既不属于质数也不属于合数。最小的合数是4。其中，完全数与相亲数是以它为基础的。\n定义 质因数（或质因子）在数论里是指能整除给定正整数的质数。两个没有共同质因子的正整数成为互质。因为1没有质因子，所以1与任何正整数（包括自身）都是质数。正整数的因数分解可将正整数表示为一连串的质因子相乘，质因子如重复可以质数表示。根据算数基本定理，任何正整数皆有独一无二的质因子分解式。只有一个质因子的正整数为质数。\n把一个合数分解成若干个质因数的乘积的形式，即求质因数的过程叫做分解质因数。\n分解质因数只针对合数。（分解质因数也称分解素因数）求一个数分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式叫短除法，和除法的性质差不多，还可以用来求多个个数的公因式。\n例子 1没有质因子 5只有1个质因子，5本身。（5是质数） 6的质因子是2和3（6=2*3） 2、4、8、16等只有一个质因子：2（2是质数， $math_inline$4=2^2$math_inline$ ， $math_inline$8=2^3$math_inline$ ，如此类推） 10有两个质因子：2和5.（10=2*5） 就是一个数的约数，并且是质数，比如 $math_inline$8=2 * 2 * 2$math_inline$ ，2就是8的质因数。 $math_inline$12=2 * 2 * 3$math_inline$ ，2和3就是12的质因数。把一个式子以 $math_inline$12=2 * 2 * 3$math_inline$ 的形式表示，叫做分解质因数。 $math_inline$16=2 * 2 * 2 * 2$math_inline$ ，2就是16的质因数，把一个合数写成几个质数相乘的形式表示，这也是分解质因数。\n分解质因数的方法是先用一个合数的最小质因数去除这个合数，得出的数若是一个质数，就写成这个合数相乘形式；若是一个合数就继续按照原来的方法，直至最后是一个质数。\n分解质因数有两种方法表示，除了大家最长知道的“短除法”之外，还有一种方法就是“塔形分解法”。\n分解质因数对解决一些自然数和乘积的问题有很大的帮助，同时又为最大公约数和最小公倍数做了重要铺垫。\n计算方法 短除法 求一个数的分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式叫短除法，和除法性质差不多，还可以用来求多个个数的公因式：\n求最大公因数的一种方法，也可以用来求最小公倍数。\n求几个数最大公因数的方法，开始时用观察比较的方法，即：先把每个数的因数找出来，然后再找出公因数，最后在公因数中找出最大公因数。\n例如：求12与18的最大公因数。\n12的因数有：1、2、3、4、6、12 18的因数有：1、2、3、6、9、18 12与18的公因数有：1、2、3、6 12与18的最大公因数是6 这两种方法对求两个以上数的最大公因数，特别是数目较大的数，显然是不方便的。于是又采用了给每个数分别分解质因数的方法。\n$math_inline$12=2 * 2 * 3$math_inline$ $math_inline$18=2 * 3 * 3$math_inline$ 12与18都可以分成几种形式不同的乘积，但分解质因数连乘积就只有以上一种，而且不能再分解了。所分出的质因数无疑都能整除原数，因此这些质因数也都是原数的约数。从分解的结果来看，12与18都有公约数2和3，而他们的乘积2*3=6，就是12与18的最大公约数。\n采用分解质因数的方法，也就是采用短除的形式，只不过是分别短除，然后再找公约数和最大公约数。如果吧这两个数合在一起短除，则更容易找出公约数和最大公约数。\n从短除中不难看出，12和18都有公约数2和3，他们的乘积2*3=6就是12与18的最大公约数。与前边分别分解质因数相比较，可以发现：不仅结果相同，而且短除法竖式左边就是这两个数的公共质因数，而两个数的最大公约数，就是这两个数的公共质因数的连乘积。\n实际应用中，是吧需要计算的两个或多个数放置在一起，进行短除。\n在计算多个数的最小公倍数时，对其中任意两个数存在的约数都要算出，其它无此约束的数则原样落下。最后把所有约数和最终剩下无法约分的数连乘即得到最小公倍数。\n只含有一个质因数的数一定是亏数。（在数论中，若一个正整数除了本身之外所有因子之和比此数自身小，则称此数为亏数（又称作缺数）。）\n短除法详解：\n短除富豪就是除号倒过来。短除就是在除法中写余数的地方写两个数共有的质因数，然后落下两个数被共有质因数整除的商，之后再除，以此类推，直到结果互质为止（两个数互质）\n而在用短除法计算多个数时，对其中任意两个数存在的因数都要算出，其它没有这个因数的数则原样落下。直到剩下每两个数都是互质关系。\n求最大公因数遍乘一边，求最小公倍数遍乘一圈。\n在用短除计算多个数时，对其中任意两个数存在的因数都要算出，其它没有这个因数的数则原样落下。直到剩下每两个都是互质关系。**求最大公约数遍乘左边所有数公共的因数，求最小公倍数遍乘一圈。**这种方法对求两个以上数的最大公因数，特别是数目较大的数，显然是不方便的。于是又采用了给每个数分别分解质因数的方法。\npollard rho因数分解 1975年，john m. pollard提出了第二种因数分解的方法，pollard rho快速因数分解。该算法时间复杂度为 $math_inline$o(n^{(1/4)})$math_inline$ 。\n将一个正整数分解质因数。例如：输入90，打印出 $math_inline$90=2 * 3 * 3 * 5$math_inline$ 。 程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：\n如果这个质数恰好等于n，则说明分解质因数的过程已经结束，打印出即可。 如果n\u0026lt;\u0026gt;，但n能被k整除，则应打印出k的值，并用n除以k的商，作为新的正整数n，重复执行第一步。 如果n不能被k整除，则用k+1作为k的值，重复执行第一步。 //将一个数n分解为若干个从小到大排列的质数的积 void f1(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; = \u0026#34;; int n2 = n; if (n \u0026lt; 2) { cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; endl; } //小于2的数不合法，若n为质数则输出它本身 for (int i = 2; i * i \u0026lt;= n2; i++) { //根号n复杂度 while (n2 % i == 0) { n2 = n2 / i; cout \u0026lt;\u0026lt; i; if (n2 != 1) cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; } } if (n2 != 1) cout \u0026lt;\u0026lt; n2; //当n为质数 cout \u0026lt;\u0026lt; endl; } void f2(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; = \u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { while (n != i) { if (n % i == 0) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;*\u0026#39;; n = n / i; } else break; } } cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } void f3(ll n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;=\u0026#39;; int flag = 0; for (ll i = 2; i * i \u0026lt;= n; i++) { while (n % i == 0) { n = n / i; if (!flag) cout \u0026lt;\u0026lt; i; else cout \u0026lt;\u0026lt; \u0026#39;*\u0026#39; \u0026lt;\u0026lt; i; flag |= 1; } } if (n != 1 \u0026amp;\u0026amp; !flag) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; else if (n != 1 \u0026amp;\u0026amp; flag) cout \u0026lt;\u0026lt; \u0026#39;*\u0026#39; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; endl; } 另外代码：\n我们用所有正整数试验一下，从2开始进行拭除，逐步增加除数的值，去寻找一个可以整除n的数。在eratosthenes筛法的讨论中，我们知道如果n是一个复合数，那么它就会有一个素数 $math_inline$p\\leq\\sqrt{n}$math_inline$ 。\n这个算法有两个循环路径，内部的和外部的。外部循环求唯一因数，内部循环求一个因数的多个复本。例如： $math_inline$24=2^3\\times3$math_inline$ ，外部循环求出因数2和3.内部循环求出2是一个多因数。\nvoid trial_divisio_fac(int n) { int a = 2; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;= \u0026#34;; while (a * a \u0026lt;= n) { while (n % a == 0) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;*\u0026#39;; n = n / a; } a++; } if (n \u0026gt; 1) cout \u0026lt;\u0026lt; n;//n没有因数 cout \u0026lt;\u0026lt; endl; } 上面的代码解释比较清楚。为什么这种方法可以得到素数。\n因为我们在内层循环中，已经把当前a的所有倍数都去除了。这跟埃斯托尼算法一样的。\n如果整数较小，这种情况下拭除法通常都是很有效的，但是如果用来分解更大的整数，拭除法就变得非常低效甚至不可用了。这种算法的复杂度是随着n的增加呈指数级别增长的。\n拭除法是整数分解算法中最简单和最容易理解的算法。\n给定一个合数n（这里，n是待分解的整数），拭除法看成是用小于等于 $math_inline$\\sqrt{n}$math_inline$ 的每个素数去拭除待分解的整数。如果找到一个数能够整除除尽，这个数就是待分解整数的因子。\n运用拭除法求1233的因数\n$math_inline$1233=3^2 * 137$math_inline$","date":"2019-05-26","permalink":"https://blog.akvicor.com/posts/algorithm/integer_factorization/","summary":"\u003cp\u003e每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的质因数。如果一个质数是某个数的因数，那么就说这个质数是这个数的质因数。而这个因数一定是一个质数。\u003c/p\u003e\n\u003cp\u003e把一个合数用质因数相乘的形式表示出来，叫做分解质因数。如30=2×3×5 。分解质因数只针对合数。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e质数：\u003c/strong\u003e\n质数（prime number）又称素数，有无限个。\u003c/p\u003e\n\u003cp\u003e质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e合数：\u003c/strong\u003e\n合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。与之相对的是质数，而1既不属于质数也不属于合数。最小的合数是4。其中，完全数与相亲数是以它为基础的。\u003c/p\u003e","title":"分解质因数"},{"content":"约数个数定理可以计算出一个数约数的个数\n约数个数定理 对于一个大于1正整数n可以分解质因数： $math_inline$f(n)=\\prod^k_{i=1}{p_i}^{a_i}={p_1}^{a_1}\\cdot{p_2}^{a_2}\\cdot...\\cdot{p_k}^{a_k}$math_inline$ 则n的正约数的个数就是 $math_inline$f(n)=\\prod^k_{i=1}(a_i+1)=(a_1+1)+(a_2+1)..(a_k+1)$math_inline$ 。\n其中 $math_inline$a_1、a_2、a_3...a_k$math_inline$ 是 $math_inline$p_1、p_2、p_3，p_k$math_inline$ 的指数。\n定理简证 首先同上，n可以分解质因数 $math_inline$n={p_1}^{a_1}\\times{p_2}^{a_2}\\times ... \\times{p_k}^{a_k}$math_inline$ ,\n由约数定义可知 $math_inline${p_1}^{a_1}$math_inline$ 的约数有: $math_inline${p_1}^0, {p_1}^1, {p_1}^2......{p_1}^{a_1}$math_inline$ ，共 $math_inline$(a_1+1)$math_inline$ 个;同理 $math_inline${p_2}^{a_2}$math_inline$ 的约数有 $math_inline$(a_2+1)$math_inline$ 个\u0026hellip;\u0026hellip; $math_inline${p_k}^{a_k}$math_inline$ 的约数有 $math_inline$(a_k+1)$math_inline$ 个。\n故根据乘法原理：n的约数的个数就是 $math_inline$(a_1+1)(a_2+1)(a_3+1)…(a_k+1)$math_inline$ 。\n例 例：正整数378000共有多少个正约数？\n解：将378000分解质因数 $math_inline$378000=2^4×3^3×5^3×7^1$math_inline$ 由约数个数定理可知378000共有正约数 $math_inline$(4+1)×(3+1)×(3+1)×(1+1)=160$math_inline$ 个。\n实现 int f1(int n) { int r = (int) sqrt(1.0 * n); int sum = 0; if (r * r == n) { sum++; r--; } for (int i = 1; i \u0026lt;= r; i++) if (n % i == 0) { sum += 2; } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } // 稍快于f1 int f2(int n){ int s = 1, r; for (int i = 2; i * i \u0026lt;= n; i++) { r = 0; while (n % i == 0) { r++; n /= i; } if (r \u0026gt; 0) { r++; s *= r; } } if (n \u0026gt; 1) s *= 2; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } ll f3(ll n) { ll res=1; for(ll i=2;i*i\u0026lt;=n;i++){ ll k=0; while(n%i == 0){ n = n/i; k++; } if(k) res *= (k+1); } if(n != 1) res=res*2; if(res==1){ if(n==1) return 1; else return 2; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } 约数和定理 对于一个大于1正整数n可以分解质因数： $math_inline$n={p_1}^{a_1}\\cdot{p_2}^{a_2}\\cdot...\\cdot{p_k}^{a_k}$math_inline$ 则由约数个数定理可知n的正约数有 $math_inline$(a_i+1)(a_2+1)(a_3+1)$math_inline$ 个，那么n的 $math_inline$(a_i+1)(a_2+1)(a_3+1)$math_inline$ 个正约数的和为\n$math_inline$f(n)=(p_1^0+p_1^1+p_1^2+...+p_1^{a_1})(p_2^0+p_2^1+p_2^2+...++p_2^{a_2})...(p_k^0+p_k^1+p_k^2+...++p_k^{a_k})$math_inline$ 定理证明 若n可以分解质因数： $math_inline$n=p_1^{a_1}*p_2^{a_2}*p_3^{a_3}*...*p_k^{a_k}$math_inline$ 可知 $math_inline$p_1^{a_1}$math_inline$ 的约数有： $math_inline$p_1^0,p_1^1,p_1^2,...,p_1^{a_1}$math_inline$ \u0026hellip;.\n同理可知， $math_inline$p_k^{a_k}$math_inline$ 的约数有： $math_inline$p_k^0,p_k^1,p_k^2,...,p_k^{a_k}$math_inline$ 实际上n的约数是在 $math_inline$p_1^{a_1}、p_2^{a_2}、p_3^{a_3}、...、p_k^{a_k}$math_inline$ 每一个的约数中分别挑一个相乘得来，可知共有 $math_inline$(a_1+1)(a_2+1)(a_3+1)...(a_k+1)$math_inline$ 种挑法，即约数的个数。\n由乘法原理可知它们的和为\n$math_inline$f(n)=(p_1^0+p_1^1+p_1^2+...+p_1^{a_1})(p_2^0+p_2^1+p_2^2+...+p_2^{a_2})...(p_k^0+p_k^1+p_k^2+...+p_k^{a_k})$math_inline$ 例 例：正整数360的所有正约数的和是多少？\n解：\n将360分解质因数可得 $math_inline$360=2^3 * 3^2 * 5^1$math_inline$ 由约数和定理可知，360所有正约数的和为\n$math_inline$(2^0+2^1+2^2+2^3)×(3^0+3^1+3^2)×(5^0+5^1)=(1+2+4+8)(1+3+9)(1+5)=15×13×6=1170$math_inline$ 可知360的约数有：\n$math_inline$1、2、3、4、5、6、8、9、10、12、15、18、20、24、30、36、40、45、60、72、90、120、180、360$math_inline$ 则它们的和为：\n$math_inline$1+2+3+4+5+6+8+9+10+12+15+18+20+24+30+36+40+45+60+72+90+120+180+360=1170$math_inline$ 实现 ll qpow(ll x, ll y) { ll res = 1; while (y) { if (y \u0026amp; 1) res *= x; x *= x; y \u0026gt;\u0026gt;= 1; } return res; } ll getsum(ll n) {//返回n的约数和是多少. ll res = 1; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) { n = n / i; k++; } res *= ((1 - qpow(i, k + 1)) / (1 - i)); } //用等比数列公式(快速幂)算. if (n != 1) res *= (1 + n); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } 题目 求正约数应用例题hihocoder – 1284\n直接暴力肯定不行, 所以想到求他们的约数, 则n的约数*m的约数/gcd(n,m)的约数就是答案. 求约数用以上定理.\nll getnum(ll n) { //得到a的约数个数. ll res = 1; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) { n = n / i; k++; } if (k) res *= (k + 1); } if (n != 1) res = res * 2; //最后一个素数. if (res == 1) { //本身就是素数或1. if (n == 1) return 1; else return 2; } return res; } void solve(ll n, ll m) { ll k = __gcd(m, n); ll num1 = getnum(n); ll num2 = getnum(m); ll num3 = getnum(k); ll t = __gcd(num3, num1 * num2); printf(\u0026#34;%lld %lld\\n\u0026#34;, 1ll * num1 * num2 / t, 1ll * num3 / t); } ","date":"2019-05-26","permalink":"https://blog.akvicor.com/posts/algorithm/sum_of_the_positive_divisors/","summary":"\u003cp\u003e约数个数定理可以计算出一个数约数的个数\u003c/p\u003e","title":"约数定理（约数个数定理，约束和定理）"},{"content":"在运算过程中如果运算结果很大，普通的数据类型无法储存，就需要用到所谓的高精度算法，即用数组来存储整数，并模拟手算的方式进行四则运算。\nfirst code #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct biginteger { static const int base = 100000000; static const int width = 8; vector\u0026lt;int\u0026gt; s; biginteger(long long num = 0) { *this = num; } biginteger\u0026amp; operator = (long long num) { s.clear(); do { s.push_back(num % base); num /= base; } while (num \u0026gt; 0); return *this; } biginteger\u0026amp; operator = (const string\u0026amp; str) { s.clear(); int x, len = (str.length() - 1) / width + 1; for(int i = 0; i \u0026lt; len; ++i){ int end = str.length() - i * width; int start = max(0, end - width); sscanf(str.substr(start, end-start).c_str(), \u0026#34;%d\u0026#34;, \u0026amp;x); s.push_back(x); } return *this; } friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;out, const biginteger\u0026amp; x){ out \u0026lt;\u0026lt; x.s.back(); for(int i = x.s.size()-2; i \u0026gt;= 0; --i){ char buf[20]; sprintf(buf, \u0026#34;%08d\u0026#34;, x.s[i]); for(int j = 0; j \u0026lt; strlen(buf); ++j) out \u0026lt;\u0026lt; buf[j]; } return out; } friend istream\u0026amp; operator \u0026gt;\u0026gt; (istream \u0026amp;in, biginteger\u0026amp; x){ string st; if(!(in \u0026gt;\u0026gt; st)) return in; x = st; return in; } biginteger operator + (const biginteger\u0026amp; b) const{ biginteger c; c.s.clear(); for(int i = 0, g = 0; ; ++i){ if(g==0 \u0026amp;\u0026amp; i\u0026gt;=s.size() \u0026amp;\u0026amp; i\u0026gt;=b.s.size()) break; int x = g; if(i \u0026lt; s.size()) x += s[i]; if(i \u0026lt; b.s.size()) x += b.s[i]; c.s.push_back(x % base); g = x / base; } return c; } biginteger operator += (const biginteger\u0026amp; b){ *this = *this + b; return *this; } bool operator \u0026lt; (const biginteger\u0026amp; b) const { if(s.size() != b.s.size()) return s.size() \u0026lt; b.s.size(); for(int i = s.size()-1; i \u0026gt;= 0; --i) if(s[i] != b.s[i]) return s[i] \u0026lt; b.s[i]; return false; } bool operator \u0026gt; (const biginteger\u0026amp; b) const { return b \u0026lt; *this; } bool operator \u0026lt;= (const biginteger\u0026amp; b) const { return !(b \u0026lt; *this); } bool operator \u0026gt;= (const biginteger\u0026amp; b) const { return !(*this \u0026lt; b); } bool operator != (const biginteger\u0026amp; b) const { return b \u0026lt; *this || *this \u0026lt; b; } bool operator == (const biginteger\u0026amp; b) const { return !(b \u0026lt; *this) \u0026amp;\u0026amp; !(*this \u0026lt; b); } }; int main() { biginteger a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;a= \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;b= \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a+b= \u0026#34; \u0026lt;\u0026lt; (a+b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026lt;b \u0026#34; \u0026lt;\u0026lt; (a\u0026lt;b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026gt;b \u0026#34; \u0026lt;\u0026lt; (a\u0026gt;b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026lt;=b \u0026#34; \u0026lt;\u0026lt; (a\u0026lt;=b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026gt;=b \u0026#34; \u0026lt;\u0026lt; (a\u0026gt;=b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a!=b \u0026#34; \u0026lt;\u0026lt; (a!=b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a==b \u0026#34; \u0026lt;\u0026lt; (a==b) \u0026lt;\u0026lt; endl; return 0; } second code #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int maxn = 410; struct biginteger { int len, s[maxn]; biginteger() { memset(s, 0, sizeof(s)); len = 1; } biginteger(int num) { *this = num; } biginteger(const char *num) { *this = num; } biginteger operator=(const int num) { char s[maxn]; sprintf(s, \u0026#34;%d\u0026#34;, num); *this = s; return *this; } biginteger operator=(const char *num) { for (int i = 0; num[i] == \u0026#39;0\u0026#39;; num++); //去前导0 len = strlen(num); for (int i = 0; i \u0026lt; len; i++) s[i] = num[len - i - 1] - \u0026#39;0\u0026#39;; return *this; } biginteger operator+(const biginteger \u0026amp;b) const //+ { biginteger c; c.len = 0; for (int i = 0, g = 0; g || i \u0026lt; max(len, b.len); i++) { int x = g; if (i \u0026lt; len) x += s[i]; if (i \u0026lt; b.len) x += b.s[i]; c.s[c.len++] = x % 10; g = x / 10; } return c; } biginteger operator+=(const biginteger \u0026amp;b) { *this = *this + b; return *this; } void clean() { while (len \u0026gt; 1 \u0026amp;\u0026amp; !s[len - 1]) len--; } biginteger operator*(const biginteger \u0026amp;b) //* { biginteger c; c.len = len + b.len; for (int i = 0; i \u0026lt; len; i++) { for (int j = 0; j \u0026lt; b.len; j++) { c.s[i + j] += s[i] * b.s[j]; } } for (int i = 0; i \u0026lt; c.len; i++) { c.s[i + 1] += c.s[i] / 10; c.s[i] %= 10; } c.clean(); return c; } biginteger operator*=(const biginteger \u0026amp;b) { *this = *this * b; return *this; } biginteger operator-(const biginteger \u0026amp;b) { biginteger c; c.len = 0; for (int i = 0, g = 0; i \u0026lt; len; i++) { int x = s[i] - g; if (i \u0026lt; b.len) x -= b.s[i]; if (x \u0026gt;= 0) g = 0; else { g = 1; x += 10; } c.s[c.len++] = x; } c.clean(); return c; } biginteger operator-=(const biginteger \u0026amp;b) { *this = *this - b; return *this; } biginteger operator/(const biginteger \u0026amp;b) { biginteger c, f = 0; for (int i = len - 1; i \u0026gt;= 0; i--) { f = f * 10; f.s[0] = s[i]; while (f \u0026gt;= b) { f -= b; c.s[i]++; } } c.len = len; c.clean(); return c; } biginteger operator/=(const biginteger \u0026amp;b) { *this = *this / b; return *this; } biginteger operator%(const biginteger \u0026amp;b) { biginteger r = *this / b; r = *this - r * b; return r; } biginteger operator%=(const biginteger \u0026amp;b) { *this = *this % b; return *this; } bool operator\u0026lt;(const biginteger \u0026amp;b) { if (len != b.len) return len \u0026lt; b.len; for (int i = len - 1; i \u0026gt;= 0; i--) { if (s[i] != b.s[i]) return s[i] \u0026lt; b.s[i]; } return false; } bool operator\u0026gt;(const biginteger \u0026amp;b) { if (len != b.len) return len \u0026gt; b.len; for (int i = len - 1; i \u0026gt;= 0; i--) { if (s[i] != b.s[i]) return s[i] \u0026gt; b.s[i]; } return false; } bool operator==(const biginteger \u0026amp;b) { return !(*this \u0026gt; b) \u0026amp;\u0026amp; !(*this \u0026lt; b); } bool operator!=(const biginteger \u0026amp;b) { return !(*this == b); } bool operator\u0026lt;=(const biginteger \u0026amp;b) { return *this \u0026lt; b || *this == b; } bool operator\u0026gt;=(const biginteger \u0026amp;b) { return *this \u0026gt; b || *this == b; } string str() const { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; len; i++) res = char(s[i] + \u0026#39;0\u0026#39;) + res; return res; } }; istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;in, biginteger \u0026amp;x) { string s; in \u0026gt;\u0026gt; s; x = s.c_str(); return in; } ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;out, const biginteger \u0026amp;x) { out \u0026lt;\u0026lt; x.str(); return out; } int main() { biginteger a, b, c, d, e, f, g; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { a.clean(), b.clean(); c = a + b; d = a - b; e = a * b; f = a / b; g = a % b; cout \u0026lt;\u0026lt; \u0026#34;a+b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // a += b cout \u0026lt;\u0026lt; \u0026#34;a-b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // a -= b; cout \u0026lt;\u0026lt; \u0026#34;a*b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; // a *= b; cout \u0026lt;\u0026lt; \u0026#34;a/b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; // a /= b; cout \u0026lt;\u0026lt; \u0026#34;a%b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; // a %= b; if (a != b) printf(\u0026#34;yes\\n\u0026#34;); else printf(\u0026#34;no\\n\u0026#34;); } return 0; } third (the most complete) code #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // base and base_digits must be consistent constexpr int base = 1000000000; constexpr int base_digits = 9; struct bigint { // value == 0 is represented by empty z vector\u0026lt;int\u0026gt; z; // digits // sign == 1 \u0026lt;==\u0026gt; value \u0026gt;= 0 // sign == -1 \u0026lt;==\u0026gt; value \u0026lt; 0 int sign; bigint() : sign(1) {} bigint(long long v) { *this = v; } bigint \u0026amp;operator=(long long v) { sign = v \u0026lt; 0 ? -1 : 1; v *= sign; z.clear(); for (; v \u0026gt; 0; v = v / base) z.push_back((int) (v % base)); return *this; } bigint(const string \u0026amp;s) { read(s); } bigint \u0026amp;operator+=(const bigint \u0026amp;other) { if (sign == other.sign) { for (int i = 0, carry = 0; i \u0026lt; other.z.size() || carry; ++i) { if (i == z.size()) z.push_back(0); z[i] += carry + (i \u0026lt; other.z.size() ? other.z[i] : 0); carry = z[i] \u0026gt;= base; if (carry) z[i] -= base; } } else if (other != 0 /* prevent infinite loop */) { *this -= -other; } return *this; } friend bigint operator+(bigint a, const bigint \u0026amp;b) { return a += b; } bigint \u0026amp;operator-=(const bigint \u0026amp;other) { if (sign == other.sign) { if (sign == 1 \u0026amp;\u0026amp; *this \u0026gt;= other || sign == -1 \u0026amp;\u0026amp; *this \u0026lt;= other) { for (int i = 0, carry = 0; i \u0026lt; other.z.size() || carry; ++i) { z[i] -= carry + (i \u0026lt; other.z.size() ? other.z[i] : 0); carry = z[i] \u0026lt; 0; if (carry) z[i] += base; } trim(); } else { *this = other - *this; this-\u0026gt;sign = -this-\u0026gt;sign; } } else { *this += -other; } return *this; } friend bigint operator-(bigint a, const bigint \u0026amp;b) { return a -= b; } bigint \u0026amp;operator*=(int v) { if (v \u0026lt; 0) sign = -sign, v = -v; for (int i = 0, carry = 0; i \u0026lt; z.size() || carry; ++i) { if (i == z.size()) z.push_back(0); long long cur = (long long) z[i] * v + carry; carry = (int) (cur / base); z[i] = (int) (cur % base); } trim(); return *this; } bigint operator*(int v) const { return bigint(*this) *= v; } friend pair\u0026lt;bigint, bigint\u0026gt; divmod(const bigint \u0026amp;a1, const bigint \u0026amp;b1) { int norm = base / (b1.z.back() + 1); bigint a = a1.abs() * norm; bigint b = b1.abs() * norm; bigint q, r; q.z.resize(a.z.size()); for (int i = (int) a.z.size() - 1; i \u0026gt;= 0; i--) { r *= base; r += a.z[i]; int s1 = b.z.size() \u0026lt; r.z.size() ? r.z[b.z.size()] : 0; int s2 = b.z.size() - 1 \u0026lt; r.z.size() ? r.z[b.z.size() - 1] : 0; int d = (int) (((long long) s1 * base + s2) / b.z.back()); r -= b * d; while (r \u0026lt; 0) r += b, --d; q.z[i] = d; } q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); return {q, r / norm}; } friend bigint sqrt(const bigint \u0026amp;a1) { bigint a = a1; while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0); int n = a.z.size(); int firstdigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]); int norm = base / (firstdigit + 1); a *= norm; a *= norm; while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0); bigint r = (long long) a.z[n - 1] * base + a.z[n - 2]; firstdigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]); int q = firstdigit; bigint res; for (int j = n / 2 - 1; j \u0026gt;= 0; j--) { for (;; --q) { bigint r1 = (r - (res * 2 * base + q) * q) * base * base + (j \u0026gt; 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0); if (r1 \u0026gt;= 0) { r = r1; break; } } res *= base; res += q; if (j \u0026gt; 0) { int d1 = res.z.size() + 2 \u0026lt; r.z.size() ? r.z[res.z.size() + 2] : 0; int d2 = res.z.size() + 1 \u0026lt; r.z.size() ? r.z[res.z.size() + 1] : 0; int d3 = res.z.size() \u0026lt; r.z.size() ? r.z[res.z.size()] : 0; q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstdigit * 2)); } } res.trim(); return res / norm; } bigint operator/(const bigint \u0026amp;v) const { return divmod(*this, v).first; } bigint operator%(const bigint \u0026amp;v) const { return divmod(*this, v).second; } bigint \u0026amp;operator/=(int v) { if (v \u0026lt; 0) sign = -sign, v = -v; for (int i = (int) z.size() - 1, rem = 0; i \u0026gt;= 0; --i) { long long cur = z[i] + rem * (long long) base; z[i] = (int) (cur / v); rem = (int) (cur % v); } trim(); return *this; } bigint operator/(int v) const { return bigint(*this) /= v; } int operator%(int v) const { if (v \u0026lt; 0) v = -v; int m = 0; for (int i = (int) z.size() - 1; i \u0026gt;= 0; --i) m = (int) ((z[i] + m * (long long) base) % v); return m * sign; } bigint \u0026amp;operator*=(const bigint \u0026amp;v) { return *this = *this * v; } bigint \u0026amp;operator/=(const bigint \u0026amp;v) { return *this = *this / v; } bool operator\u0026lt;(const bigint \u0026amp;v) const { if (sign != v.sign) return sign \u0026lt; v.sign; if (z.size() != v.z.size()) return z.size() * sign \u0026lt; v.z.size() * v.sign; for (int i = (int) z.size() - 1; i \u0026gt;= 0; i--) if (z[i] != v.z[i]) return z[i] * sign \u0026lt; v.z[i] * sign; return false; } bool operator\u0026gt;(const bigint \u0026amp;v) const { return v \u0026lt; *this; } bool operator\u0026lt;=(const bigint \u0026amp;v) const { return !(v \u0026lt; *this); } bool operator\u0026gt;=(const bigint \u0026amp;v) const { return !(*this \u0026lt; v); } bool operator==(const bigint \u0026amp;v) const { return !(*this \u0026lt; v) \u0026amp;\u0026amp; !(v \u0026lt; *this); } bool operator!=(const bigint \u0026amp;v) const { return *this \u0026lt; v || v \u0026lt; *this; } void trim() { while (!z.empty() \u0026amp;\u0026amp; z.back() == 0) z.pop_back(); if (z.empty()) sign = 1; } bool iszero() const { return z.empty(); } friend bigint operator-(bigint v) { if (!v.z.empty()) v.sign = -v.sign; return v; } bigint abs() const { return sign == 1 ? *this : -*this; } long long longvalue() const { long long res = 0; for (int i = (int) z.size() - 1; i \u0026gt;= 0; i--) res = res * base + z[i]; return res * sign; } friend bigint gcd(const bigint \u0026amp;a, const bigint \u0026amp;b) { return b.iszero() ? a : gcd(b, a % b); } friend bigint lcm(const bigint \u0026amp;a, const bigint \u0026amp;b) { return a / gcd(a, b) * b; } void read(const string \u0026amp;s) { sign = 1; z.clear(); int pos = 0; while (pos \u0026lt; s.size() \u0026amp;\u0026amp; (s[pos] == \u0026#39;-\u0026#39; || s[pos] == \u0026#39;+\u0026#39;)) { if (s[pos] == \u0026#39;-\u0026#39;) sign = -sign; ++pos; } for (int i = (int) s.size() - 1; i \u0026gt;= pos; i -= base_digits) { int x = 0; for (int j = max(pos, i - base_digits + 1); j \u0026lt;= i; j++) x = x * 10 + s[j] - \u0026#39;0\u0026#39;; z.push_back(x); } trim(); } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;stream, bigint \u0026amp;v) { string s; stream \u0026gt;\u0026gt; s; v.read(s); return stream; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;stream, const bigint \u0026amp;v) { if (v.sign == -1) stream \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; stream \u0026lt;\u0026lt; (v.z.empty() ? 0 : v.z.back()); for (int i = (int) v.z.size() - 2; i \u0026gt;= 0; --i) stream \u0026lt;\u0026lt; setw(base_digits) \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; v.z[i]; return stream; } static vector\u0026lt;int\u0026gt; convert_base(const vector\u0026lt;int\u0026gt; \u0026amp;a, int old_digits, int new_digits) { vector\u0026lt;long long\u0026gt; p(max(old_digits, new_digits) + 1); p[0] = 1; for (int i = 1; i \u0026lt; p.size(); i++) p[i] = p[i - 1] * 10; vector\u0026lt;int\u0026gt; res; long long cur = 0; int cur_digits = 0; for (int v : a) { cur += v * p[cur_digits]; cur_digits += old_digits; while (cur_digits \u0026gt;= new_digits) { res.push_back(int(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; } } res.push_back((int) cur); while (!res.empty() \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } typedef vector\u0026lt;long long\u0026gt; vll; static vll karatsubamultiply(const vll \u0026amp;a, const vll \u0026amp;b) { int n = a.size(); vll res(n + n); if (n \u0026lt;= 32) { for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) res[i + j] += a[i] * b[j]; return res; } int k = n \u0026gt;\u0026gt; 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubamultiply(a1, b1); vll a2b2 = karatsubamultiply(a2, b2); for (int i = 0; i \u0026lt; k; i++) a2[i] += a1[i]; for (int i = 0; i \u0026lt; k; i++) b2[i] += b1[i]; vll r = karatsubamultiply(a2, b2); for (int i = 0; i \u0026lt; a1b1.size(); i++) r[i] -= a1b1[i]; for (int i = 0; i \u0026lt; a2b2.size(); i++) r[i] -= a2b2[i]; for (int i = 0; i \u0026lt; r.size(); i++) res[i + k] += r[i]; for (int i = 0; i \u0026lt; a1b1.size(); i++) res[i] += a1b1[i]; for (int i = 0; i \u0026lt; a2b2.size(); i++) res[i + n] += a2b2[i]; return res; } bigint operator*(const bigint \u0026amp;v) const { vector\u0026lt;int\u0026gt; a6 = convert_base(this-\u0026gt;z, base_digits, 6); vector\u0026lt;int\u0026gt; b6 = convert_base(v.z, base_digits, 6); vll a(a6.begin(), a6.end()); vll b(b6.begin(), b6.end()); while (a.size() \u0026lt; b.size()) a.push_back(0); while (b.size() \u0026lt; a.size()) b.push_back(0); while (a.size() \u0026amp; (a.size() - 1)) a.push_back(0), b.push_back(0); vll c = karatsubamultiply(a, b); bigint res; res.sign = sign * v.sign; for (int i = 0, carry = 0; i \u0026lt; c.size(); i++) { long long cur = c[i] + carry; res.z.push_back((int) (cur % 1000000)); carry = (int) (cur / 1000000); } res.z = convert_base(res.z, 6, base_digits); res.trim(); return res; } }; bigint random_bigint(int n) { string s; for (int i = 0; i \u0026lt; n; i++) { s += rand() % 10 + \u0026#39;0\u0026#39;; } return bigint(s); } // random tests void biginttest() { bigint x = bigint(\u0026#34;120\u0026#34;); bigint y = bigint(\u0026#34;5\u0026#34;); cout \u0026lt;\u0026lt; x / y \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 1000; i++) { int n = rand() % 100 + 1; bigint a = random_bigint(n); bigint res = sqrt(a); bigint xx = res * res; bigint yy = (res + 1) * (res + 1); if (xx \u0026gt; a || yy \u0026lt;= a) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; break; } int m = rand() % n + 1; bigint b = random_bigint(m) + 1; res = a / b; xx = res * b; yy = b * (res + 1); if (xx \u0026gt; a || yy \u0026lt;= a) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; break; } } bigint a = random_bigint(10000); bigint b = random_bigint(2000); clock_t start = clock(); bigint c = a / b; printf(\u0026#34;time=%.3lfsec\\n\u0026#34;, (clock() - start) * 1. / clocks_per_sec); } string str(bigint b) { stringstream ss; ss \u0026lt;\u0026lt; b; string s; ss \u0026gt;\u0026gt; s; return s; } ","date":"2019-05-23","permalink":"https://blog.akvicor.com/posts/algorithm/arbitrary_precision/","summary":"\u003cp\u003e在运算过程中如果运算结果很大，普通的数据类型无法储存，就需要用到所谓的高精度算法，即用数组来存储整数，并模拟手算的方式进行四则运算。\u003c/p\u003e","title":"高精度(arbitrary-precision arithmetic)"},{"content":"ssh是secure shell的缩写，.ssh目录在用户根目录下\n权限 因为sshd为了安全，对属主的目录和文件权限有所要求。如果权限不对，则ssh的免密码登陆不生效。 用户目录权限为 755 或者 700，就是不能是77x、777，需要保障other用户不能有w权限 .ssh目录权限一般为755或者700。 rsa_id.pub 及authorized_keys权限一般为644 rsa_id权限必须为600\nssh key 查看密钥是否存在 cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除, 也可以直接删除\n生成新密钥 ssh-keygen -t rsa -c \u0026#34;youremail@example.com\u0026#34; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，因为这个key仅仅用于简单的服务，所以也无需设置密码。\n如果服务器端需要公钥, 直接把.ssh目录下的id_rsa.pub配置即可, id_rsa为私钥一定要保密!!!!\n","date":"2019-05-16","permalink":"https://blog.akvicor.com/posts/ssh/path_permission/","summary":"\u003cp\u003eSSH是Secure Shell的缩写，\u003ccode\u003e.ssh\u003c/code\u003e目录在用户根目录下\u003c/p\u003e","title":".ssh目录说明及密钥"},{"content":"首先声明，本博文部分内容仅仅适用于acm竞赛，并不适用于noip与oi竞赛，违规使用可能会遭竞赛处理，请慎重使用！遭遇任何情况都与本人无关哈=7=\n我也不想搞得那么严肃的，但真的有些函数在noip与oi竞赛中有相关规定不能使用，详细我也不知道各位要了解请自行去找比赛要求咯，当然在acm竞赛中，没有限制函数，所以所有内容都适用于acm竞赛。\n那么什么是卡常数呢，简单来说就是你和某神犇算法思路一样，结果他的ac了，你的tle，复杂来说就是程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在oi/acm等算法竞赛规定的时限内运行结束。\n下面就是介绍各种各样的非（花）常（里）实（胡）用（哨）的优化方法的，若本文某些地方有错误或不明确的地方还请指出。=7=\n常见 ~i // i是-1则返回0，否则返回其他值 i=-1 ~i==0 i=other ~i!=0 i^1 // 常用与成对的索引，比如网络流中的 正边 和 反边 i=0 i^1=1 i=1 i^1=0 i=2 i^1=3 i=3 i^1=2 优化i/o 网上有很多说关于cin和scanf的介绍，以及关闭流输入等等优化方法，但这些都还是有可能成为卡常数的地方，那么这个时候，我们就可以自己写输出输出函数了。\n下面一个简单的对读入数字的优化：\ninline void read(int \u0026amp;sum) { char ch = getchar(); int tf = 0; sum = 0; while((ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; (ch != \u0026#39;-\u0026#39;)) ch = getchar(); tf = ((ch == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; (ch = getchar())); while(ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) sum = sum * 10+ (ch - 48), ch = getchar(); (tf) \u0026amp;\u0026amp; (sum =- sum); } 因为getchar()是比scanf和cin快很多的，所以可以用这种方式优化很多，当然也可以写对其他各种类型输入的优化。\n然后就是进阶版优化，cstdio库里面有一个非常快而且和freopen和fopen完美兼容的函数就是fread，而且是整段读取，函数原型为：\n1 size_t fread(void *buffer,size_t size,size_t count,file *stream); 作用：从stream中读取count个大小为size个字节的数据，放到数组buffer中，返回成功了多少个大小为为size个字节的数据。\n所以我们的代码可以更加优化为：\ninline char nc() { static char buf[1000000], *p1 = buf, *p2 = buf; return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread (buf, 1, 1000000, stdin), p1 == p2) ? eof : *p1++; } //#define nc getchar inline void read(int \u0026amp;sum) { char ch = nc(); int tf = 0; sum = 0; while((ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; (ch != \u0026#39;-\u0026#39;)) ch = nc(); tf = ((ch == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; (ch = nc())); while(ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) sum = sum * 10+ (ch - 48), ch = nc(); (tf) \u0026amp;\u0026amp; (sum =- sum); } 但要注意，由于这种方法是整段读取的，这也造就了它两个巨大的bug：\n不能用键盘输入。数据还没输入，程序怎么整段读取。如果你需要在电脑上用键盘输入调试，请把第5行的注释取消。 不能和scanf，getchar等其他读入方法混合使用。因为fread是整段读取的，也就是说所有数据都被读取了，其他函数根本读取不到任何东西(只能从你的读取大小后面开始读)，因此，所有类型的变量读入都必须自己写，上面的read函数只支持int类型。 # language [0,2) [0,8) [0,2^{15})) [0,2^{31}) [0,2^{63}) fread g++ 5.4.0 (-o2) 13 13 39 70 111 getchar g++ 5.4.0 (-o2) 58 73 137 243 423 cin（关闭同步） g++ 5.4.0 (-o2) 161 147 205 270 394 cin g++ 5.4.0 (-o2) 442 429 706 1039 1683 scanf g++ 5.4.0 (-o2) 182 175 256 368 574 fread以压倒性的优势碾压了其他所有方法，还可以注意到关流同步的cin比scanf快，关于为什么不使用位运算的问题下面会说。\n然后就是输出的优化，同理，putchar()会比printf快，所以，输出数字可以优化成：\n// 优化前输出1-10000000：4.336秒 // 优化后输出1-10000000：1.897秒 void print( int k ){ num = 0; while( k \u0026gt; 0 ) ch[++num] = k % 10, k /= 10; while( num ) putchar( ch[num--]+48 ); putchar( 32 ); } 如果输出负数以及其他，就自己写一个或者百度啦，我这里就不贴了。其实大多数还是对读入进行优化，输出一般用printf就可以了。\n位运算 很多人都肯定很喜欢用位运算吧，因为觉得位运算是基于二进制操作，肯定比普通加减乘除快很多，但是真的是所有的位运算操作都比常规操作快么。\n乘和除的位运算 x \u0026lt;\u0026lt; 1; x *= 2; 例如上面这两句，都是把x乘2，但真的用位运算会快么，其实他们理论上是一样的，在被g++翻译成汇编后，两者的语句都是\naddl %eax, %eax1 它等价于 x = x + x。所以在这里位运算并没有任何优化。那么把乘数扩大呢，比如乘10，x *= 10的汇编语言为\nleal (%eax,%eax,4), %eax addl %eax, %eax 翻译过来就是\nx = x + x*4; x = x + x; 而那些喜欢用(x \u0026laquo; 3 + x \u0026laquo; 1)的人自己斟酌！\n但是位运算在某些地方是非常有用的，比如除法，右移的汇编代码为\nmovl _x, %eax sarl %eax movl %eax, _x movl _x, %eax 而除二的汇编代码为\nmovl _x, %eax movl %eax, %edx //(del) shrl $31, %edx //(del) addl %edx, %eax //(del) sarl %eax movl %eax, _x movl _x, %eax 可以看到，右移会比除快很多。\n%2和\u0026amp;1 这个其实可想而知\u0026amp;1快，还是看下汇编代码吧，%2的汇编代码为\nmovl _x, %eax movl $lc0, (%esp) movl %eax, %edx //(del) shrl $31, %edx //(del) addl %edx, %eax //(del) andl $1, %eax subl %edx, %eax //(del) movl %eax, 4(%esp) movl %eax, _x \u0026amp;1的汇编代码为\nmovl _x, %eax movl $lc0, (%esp) andl $1, %eax movl %eax, 4(%esp) movl %eax, _x ^和swap 最开始学c语言两个变量交换都是先学三变量交换法，再学^这种操作，下面是(a ^= b ^= a ^= b)的汇编代码\nmovl _b, %edx movl _a, %eax xorl %edx, %eax xorl %eax, %edx xorl %edx, %eax movl %eax, _a xorl %eax, %eax movl %edx, _b 再来看看(int t = a;a = b,b = t;)的汇编代码\nmovl _a, %eax movl _b, %edx movl %eax, _b xorl %eax, %eax movl %edx, _a 谁慢谁快一眼就知道了，以后swap再无xor。\n其他位运算技巧 网上有很多奇奇怪怪的位运算技巧，但有一些真的令人很无语，没有优化不说，大大降低了代码可读性，在我看来，都是些花里胡哨的操作，比如取绝对值(n ^ (n \u0026raquo; 31)) - (n \u0026raquo; 31)，取两个数的最大值b \u0026amp; ((a - b) \u0026raquo; 31) | a \u0026amp; ( ~(a - b) \u0026raquo; 31)，取两个数的最小值a \u0026amp; ((a - b) \u0026raquo; 31) | b \u0026amp; ( ~(a-b) \u0026raquo; 31 )。恕我愚钝，这些代码一眼看上去根本不知道在干嘛，还有那个取绝对值的和abs(x)，谁快都不用说了。\n但是位运算还是有很多好（骚）操作的，例如：\nlowbit函数 ： x \u0026amp; (-x) 判断是不是2的幂：x \u0026gt; 0 ? ( x \u0026amp; (x - 1)) == 0 : false\nemmm……还有很多，我就不介绍了（我就知道这两个=7=）\n条件判断优化 acm不可避免会有条件语句，if-else也好，?:也好，switch也好，那么问题来了，最后用哪种呢，让我们一一道来。\nif和?: 网上很多说if比?:慢，但是其实不是这样的，二者的汇编除了文件名不一样其他都一模一样。其实不是?:比if快而是?:比if-else快。\n有什么区别吗？你需要先弄清楚if-else的工作原理。 if就像一个铁路分叉道口，在cpu底层这种通讯及其不好的地方，在火车开近之前，鬼知道火车要往哪边开，那怎么办？猜！ 如果猜对了，它直接通过，继续前行。 如果猜错了，车头将停止，倒回去，你将铁轨扳至反方向，火车重新启动，驶过道口。 如果是第一种情况，那很好办，那第二种呢？时间就这么浪过去了，假如你非常不走运，那你的程序就会卡在停止-回滚-热启动的过程中。 上面猜的过程就是分支预测。 虽然是猜，但编译器也不是随便乱猜，那怎么猜呢？答案是分析之前的运行记录。假设之前很多次都是true，那这次就猜true，如果最近连续很多次都是false，那这次就猜false。 但这一切都要看你的cpu了，因此，一般把容易成立的条件写在前面判断，把不容易成立的条件放在else那里。 但是?:消除了分支预测，因此在布尔表达式的结果近似随机的时候?:更快，否则就是if更快啦。\n分支预测优化 gcc存在内置函数：__builtin_expect(!!(x), tf)，他不会改变x的值，仅仅只是减少跳转次数，当tf为true时表示x非常可能为true，反之同理。\n用法就是if(__builtin_expect(!!(x),0)) 或者把0换为1，这样在if猜的时候就会优先猜x为true或是false，达到优化效果。\nswitch和if-else 这个东西还是有必要提一下，当switch没有default的时候，switch会比if-else快，因为他是直接跳转而不是逐条判断，但加了default之后，switch也就变成了无脑判断模式，至于为什么会这样，各位就自行研究咯=7=\n短路运算符 我们知道\u0026amp;\u0026amp;和||是两个短路运算符，什么叫短路运算符，就是一旦可以确定了表达式的真假值时候，就直接返回真假值了，比如下面代码\nint n = 0; n \u0026amp;\u0026amp; ++n; //这里n的值还是0 !n || ++n; //这里n的值还是0 但是上面的两句代码等同于什么呢？等于\nint n = 0; if(n){ ++n; } if(!(!n)){ ++n; } 利用这个特色（你才特色），我们有些时候就可以不需要在做if的无脑判断了，也就是\nif(a) b; → (a)\u0026amp;\u0026amp;(b)\nif(a) b; else c; → a\u0026amp;\u0026amp;(b,1)||c\n但这些并不是短路运算符的精髓，短路运算符的精髓不仅在于优化时间，更是可以防止程序出错。\ndouble t = rand(); if (t / rand_max \u0026lt; 0.2 \u0026amp;\u0026amp; t != 0) printf (\u0026#34;%d\u0026#34;, t); double t = rand(); if (t != 0 \u0026amp;\u0026amp; t / rand_max \u0026lt; 0.2) printf (\u0026#34;%d\u0026#34;, t); 这两种判断，谁快谁慢。但对于cpu来说很有区别。第一段代码中的t/rand_max\u0026lt;0.2为true的概率约为 20%，但t!=0为true的概率约为1/rand_max，明显小于20%\n因此，如果把计算一个不含逻辑运算符布尔表达式的计算次数设为 1 次，设计算了 x 次，则对于第 1 段代码，x 的数学期望为 6/5 次，但对于第二段代码，x 的数学期望2*(rand_max-1) / rand_max为 ，远远大于第一段代码。\n不仅不同位置会优化时间，更是会防止程序错误，例如kuangbin搜索专题有题是catch the cow，就是搜索，不过判断走没走过得判断vis[n]和n \u0026lt; 1e6，我最最开始写的vis[n] \u0026amp;\u0026amp; n \u0026lt; 1e6，提交上去re了，看了很久才发现是这里的原因，得先判断n \u0026lt; 1e6，再做下一步操作。\n所以， 遇到a\u0026amp;\u0026amp;b时，优先把可能为false的表达式放在前面。遇到a||b时，优先把可能为true的表达式放在前面。但也不一定是绝对这样，还得结合题目。\n布尔表达式和逗号运算符 很多人喜欢用if(x == true)这种形式，但其实if(x)就行了，在可读性等方面都没有变化。而且不要开bool数组，int是最快的（原因暂时不知道）。\n逗号运算符若干条语句可以通过逗号运算符合并成一条语句。 例如t=a;a=b;b=t;可以写成t=a,a=b,b=t;有什么用吗？它的返回值。 int x=(1,2,3,4,5); 猜一猜，上面的语句执行完后x的值是多少？ 答案是 5 没错，逗号运算符的返回值就是最后一个的值。而且逗号表达式比分号快很多很多，真的。\n卡编译 c++内联函数inline： 由编译器在编译时会在主程序中把函数的内容直接展开替换，减少了内存访问，但是这并不是适用于各种复杂以及递归式的函数，复杂函数编译器会自动忽略inline\nint max(int a, int b){return a\u0026gt;b?a:b;}//原函数 inline int max(int a, int b){return a\u0026gt;b?a:b;}//直接加inline就好了。 cpu寄存器变量register： 对于一些频繁使用的变量，可以声明时加上该关键字，运行时可能会把该变量放到cpu寄存器中，只是可能，因为寄存器的空间是有限的，不保证有效。特别是你变量多的时候，一般还是丢到内存里面的。 比较下面两段程序：\nregister int a=0; for(register int i=1;i\u0026lt;=999999999;i++)a++; int a=0; for(int i=1;i\u0026lt;=999999999;i++)a++; 优化：0.2826 second 不优化：1.944 second\n卡算法 取模优化 //设模数为 mod inline int inc(int x,int v,int mod){x+=v;return x\u0026gt;=mod?x-mod:x;}//代替取模+ inline int dec(int x,int v,int mod){x-=v;return x\u0026lt;0?x+mod:x;}//代替取模- 加法优化 用++i代替i++，后置++需要保存临时变量以返回之前的值，在 stl 中非常慢。\n结构优化 如果要经常调用a[x],b[x],c[x]这样的数组，把它们写在同一个结构体里面会变快一些，比如f[x].a, f[x].b, f[x].c 指针比下标快，数组在用方括号时做了一次加法才能取地址！所以在那些计算量超大的数据结构中，你每次都多做了一次加法！！！在 64 位系统下是 long long 相加，效率可想而知。\nstl优化 stl快但是也包含了很多可能你用不到的东西，所以最快的就是你自己手写stl=7=，反正我写不来。\n循环展开 void init(int *d, int n){ for(int i = 0; i \u0026lt; n; i++) d[i] = 0; } void init(int *d, int n){ int il for(int i = 0; i \u0026lt; n; i+= 4){ //每次迭代处理4个元素 d[i] = 0; d[i + 1] = 0; d[i + 2] = 0; d[i + 3] = 0; } for(; i \u0026lt; n; i++)//将剩余未处理的元素再依次初始化 d[i] = 0; } 都是同一个操作，但你们觉得谁快呢，用下面的比第一段代码快了不止一倍，循环展开也许只是表面，在缓存和寄存器允许的情况下一条语句内大量的展开运算会刺激 cpu 并发\n减少了不直接有助于程序结果的操作的数量，例如循环索引计算和分支条件。 提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。 好像没什么要讲的了呢，网上还有一些很邪门的优化方式，我觉得就没必要了，能大致知道一些优化流程就行了，比如读入还有mmap但用这个不是很了解的话可能还会用出事，所以别没必要那么追求极限了。自己觉得讲的还是挺多挺全面的，若是哪里有错误或者没讲到的地方还请指出。\n","date":"2019-05-08","permalink":"https://blog.akvicor.com/posts/special/acm_constant/","summary":"\u003cp\u003e\u003cstrong\u003e首先声明，本博文部分内容仅仅适用于ACM竞赛，并不适用于NOIP与OI竞赛，违规使用可能会遭竞赛处理，请慎重使用！遭遇任何情况都与本人无关哈=7=\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我也不想搞得那么严肃的，但真的有些函数在NOIP与OI竞赛中有相关规定不能使用，详细我也不知道各位要了解请自行去找比赛要求咯，当然在ACM竞赛中，没有限制函数，所以所有内容都适用于ACM竞赛。\u003c/p\u003e\n\u003cp\u003e那么什么是卡常数呢，简单来说就是你和某神犇算法思路一样，结果他的AC了，你的TLE，复杂来说就是程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ACM等算法竞赛规定的时限内运行结束。\u003c/p\u003e\n\u003cp\u003e下面就是介绍各种各样的非（花）常（里）实（胡）用（哨）的优化方法的，若本文某些地方有错误或不明确的地方还请指出。=7=\u003c/p\u003e","title":"acm卡常数(各种玄学优化)"},{"content":"knuth-morris-pratt 字符串查找算法，简称为 “kmp算法”，常用于在一个文本串s内查找一个模式串p 的出现位置，这个算法由donald knuth、vaughan pratt、james h. morris三人于1977年联合发表，故取这3人的姓氏命名此算法。\n算法流程 假设现在文本串s匹配到 i 位置，模式串匹配到 j 位置 如果 j=-1，或者当前字符匹配成功（即s[i]==p[i]），都令i++，j++，继续匹配下一个字符 如果 j!=-1，且当前字符匹配失败（即s[i]!=p[j]），则令 i 不变，j=next[j]。这意味着失配时，模式串p相对于文本串s向右移动了j-next[j]位。 next数组中各值含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如next[j]=k，代表j之前的字符串中有最大长度为k的相同前缀后缀。\n这也意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到那个位置。如果next[j]=0或-1，则跳到模式串的开头字符，若next[j]=k 且 k\u0026gt;0，代表下次匹配跳到j之前的某个字符，而不是跳到开头，且具体跳过了k个字符。\n计算next数组 void kmp_pre(char s[], int len, int next[]){ int i, j; j = next[0] = -1; i = 0; while(i \u0026lt; len){ while(-1 != j \u0026amp;\u0026amp; s[i]!=s[j]) j = next[j]; next[++i] = ++j; } } // a b c a b c a b c d e f a b c d e f g h i // -1 0 0 0 1 2 3 4 5 6 0 0 0 1 2 3 0 0 0 0 0 // a b c d a b d // -1 0 0 0 0 1 2 ","date":"2019-04-30","permalink":"https://blog.akvicor.com/posts/algorithm/kmp/","summary":"\u003cp\u003eKnuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。\u003c/p\u003e","title":"kmp 算法"},{"content":"scrcpy是一个能够实时显示并控制android手机的工具\n安装 brew install scrcpy brew cask install android-platform-tools # brew install android-platform-tools # adb tools 启动和快捷键 scrcpy scrcpy --help 「屏幕熄灭时单击一下鼠标右键」： 唤醒屏幕 「屏幕点亮时单击一下鼠标右键」： 发送一个返回键 「control + h 键」：发送一个主页键 「control + p 键」：发送一个短按电源键 「control + s 键」：发送一个多任务键 「control + m 键」：发送一个菜单键 「control + f 键」：切换到全屏显示 「control + x 键」：将窗口恢复到最适合大小 ","date":"2019-04-28","permalink":"https://blog.akvicor.com/posts/mac/scrcpy_install/","summary":"\u003cp\u003eScrcpy是一个能够实时显示并控制Android手机的工具\u003c/p\u003e","title":"安装scrcpy"},{"content":"homebrew是一款mac os上的软件包管理工具，通过它可以很方便的安装/卸载软件工具等，类似于linux下的apt-get，node的npm等包管理工具。\nhomebrew将工具安装在自己创建的/usr/local/cellar目录下，并在/usr/local/bin建立这些工具的符号链接。\n/usr/bin/ruby -e \u0026#34;$(curl -fssl https://raw.githubusercontent.com/homebrew/install/master/install)\u0026#34; 命令详解：\n1.先用 shell命令curl，将文件下载本地，文件名为 install，文件地址：https://raw.githubusercontent.com/homebrew/install/master/install\n2.执行 ruby -e 文件install。\n但是ruby命令里面的内容，是下载github上的homebrew库，但是这个下载是连接国外的网络的，所以比较慢，经常网络断导致安装错误。如果有vpn或者网络较好的情况鼓励使用这种方式，比较方便。\n关闭每次运行时的自动更新\n# 临时关闭 在terminal中运行 # 永久关闭 在terminal配置文件中加入下面这一行 .bash_profile export homebrew_no_auto_update=true ","date":"2019-04-28","permalink":"https://blog.akvicor.com/posts/mac/brew_install/","summary":"\u003cp\u003e\u003ca href=\"https://link.jianshu.com?t=http%3A%2F%2Fbrew.sh%2Findex_zh-cn.html\"\u003eHomebrew\u003c/a\u003e是一款Mac OS上的软件包管理工具，通过它可以很方便的安装/卸载软件工具等，类似于Linux下的apt-get，node的npm等包管理工具。\u003c/p\u003e\n\u003cp\u003eHomebrew将工具安装在自己创建的/usr/local/Cellar目录下，并在/usr/local/bin建立这些工具的符号链接。\u003c/p\u003e","title":"安装brew"},{"content":"\\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号 ","date":"2019-04-28","permalink":"https://blog.akvicor.com/posts/markdown/special_characters/","summary":"\\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号","title":"需要转义的字符"},{"content":"what is adb android debug bridge (adb) is a command line tool that lets you communicate with an emulator or connected android device. you can find the adb tool in android sdk/platform-tools or download adb kits.\nadb debugging adb devices adb forward adb kill-server adb devices prints a list of all attached emulator/device\nadb devices in response, return serial number and state\ne4b25377 device emulator-5554 device adb forward forward socket connections\nadb forward \u0026lt;local\u0026gt; \u0026lt;remote\u0026gt; adb forward tcp:8000 tcp:9000 set up forwarding of host port 8000 to emulator/device port 9000\nprerequisites: enable usb debugging on the device.\nadb kill-server terminates the adb server process\nadb kill-server notes: kill the server if it is running. (terminal adb.exe process)\nwireless adb connect \u0026lt;host\u0026gt;[:\u0026lt;port\u0026gt;] adb usb adb connect use adb over wi-fi\nadb connect \u0026lt;host\u0026gt;[:\u0026lt;port\u0026gt;] step 1. connect to the device over usb.\nstep 2. adb devices list of devices attached ######## device\nnotes: step 1,2 is required\nstep 3. adb tcpip 5555 restarting in tcp mode port: 5555\nstep 4. find out the ip address of the android device: settings -\u0026gt; about -\u0026gt; status -\u0026gt; ip address. remember the ip address, of the form #.#.#.#.\nstep 5. adb connect #.#.#.# connected to #.#.#.#:5555\nstep 6. remove usb cable from device, and confirm you can still access device:\nadb devices list of devices attached #.#.#.#:5555 device\nnotes: make sure that your host is still connected to the same wi-fi network your android device is.\nadb usb restarting adb in usb mode.\nsee also: adb connect\npackage manager adb install [option] \u0026lt;path\u0026gt; adb uninstall [options] \u0026lt;package\u0026gt; adb shell pm list packages [options] \u0026lt;filter\u0026gt; adb shell pm path \u0026lt;package\u0026gt; adb shell pm clear \u0026lt;package\u0026gt; adb install pushes an android application (specified as a full path to an .apk file) to an emulator/device.\nadb install test.apk adb install -l test.apk # forward lock application adb install -r test.apk # replace existing application adb install -t test.apk # allow test packages adb install -s test.apk # install application on sdcard adb install -d test.apk # allow version code downgrade adb install -p test.apk # partial application install adb uninstall removes a package from the emulator/device.\nadb uninstall com.test.app adb uninstall -k com.test.app # keep the data and cache directories around after package removal. adb shell pm list packages prints all packages, optionally only those whose package name contains the text in \u0026lt;filter\u0026gt;.\nadb shell pm list packages adb shell pm list packages -f # see their associated file. adb shell pm list packages -d # filter to only show disabled packages. adb shell pm list packages -e # filter to only show enabled packages. adb shell pm list packages -s # filter to only show system packages. adb shell pm list packages -3 # filter to only show third party packages. adb shell pm list packages -i # see the installer for the packages. adb shell pm list packages -u # also include uninstalled packages. adb shell pm list packages --user \u0026lt;user_id\u0026gt; # the user space to query. adb shell pm path print the path to the apk of the given \u0026lt;package\u0026gt;.\nadb shell pm path com.android.phone package:/system/priv-app/teleservice/teleservice.apk\nadb shell pm clear deletes all data associated with a package.\nadb shell pm clear com.test.abc notes: clearing app data, cache\nfile manager adb pull \u0026lt;remote\u0026gt; [local] adb push \u0026lt;local\u0026gt; \u0026lt;remote\u0026gt; adb shell ls adb shell cd adb shell rm adb shell mkdir adb shell touch adb shell pwd adb shell cp adb shell mv adb pull download a specified file from an emulator/device to your computer.\nadb pull /sdcard/demo.mp4 download /sdcard/demo.mp4 to \u0026lt;android-sdk-path\u0026gt;/platform-tools directory.\nadb pull /sdcard/demo.mp4 e:\\ download /sdcard/demo.mp4 to drive e.\nadb push upload a specified file from your computer to an emulator/device.\nadb push test.apk /sdcard copies \u0026lt;android-sdk-path\u0026gt;/platform-tools/test.apk to /sdcard directory.\nadb push d:\\test.apk /sdcard copies d:\\test.apk to /sdcard directory.\nadb shell ls list directory contents\nls [options] \u0026lt;directory\u0026gt; step 1. adb shell step 2. ls ls -a # do not hide entries starting with ls -i # print index number of each file ls -s # print size of each file, in blocks ls -n # list numeric uids and gids ls -r # list subdirectories recursively notes: press ctrl-c to stop\nadb shell cd change directory\ncd \u0026lt;directory\u0026gt; step 1. adb shell step 2. cd /system adb shell rm remove files or directories\nrm [options] \u0026lt;files or directory\u0026gt; step 1.\nadb shell step 2.\nrm /sdcard/test.txt\nrm -f /sdcard/test.txt # force remove without prompt rm -r /sdcard/tmp # remove the contents of directories recursively rm -d /sdcard/tmp # remove directory, even if it is a non-empty directory notes: rm -d equal rmdir command\nrm -i /sdcard/test.txt # prompt before any removal adb shell mkdir make directories\nmkdir [options] \u0026lt;directory name\u0026gt; mkdir /sdcard/tmp mkdir -m 777 /sdcard/tmp # set permission mode mkdir -p /sdcard/tmp/sub1/sub2 # create parent directories as needed adb shell touch create empty file or change file timestamps\ntouch [options] \u0026lt;file\u0026gt; step 1.\nadb shell step 2.\ntouch /sdcard/tmp/test.txt ls /sdcard/tmp\nadb shell pwd print current working directory location.\npwd adb shell cp copy files and directories\ncp [options] \u0026lt;source\u0026gt; \u0026lt;dest\u0026gt; step 1.\nadb shell step 2.\ncp /sdcard/test.txt /sdcard/demo.txt\nadb shell mv move or rename files\nmv [options] \u0026lt;source\u0026gt; \u0026lt;dest\u0026gt; step 1.\nadb shell step 2.\nmv /sdcard/tmp /system/tmp # move mv /sdcard/tmp /sdcard/test # rename network adb shell netstat adb shell ping adb shell netcfg adb shell ip adb shell netstat network statistics\nnetstat step 1.\nadb shell step 2.\nnetstat adb shell ping test the connection and latency between two network connection.\nping [-aabbddfhlnoqrruvv] [-c count] [-i interval] [-i interface] [-m mark] [-m pmtudisc_option] [-l preload] [-p pattern] [-q tos] [-s packetsize] [-s sndbuf] [-t ttl] [-t timestamp_option] [-w deadline] [-w timeout] [hop1 \u0026hellip;] destination\nstep 1. adb shell step 2. ping www.google.com notes: press ctrl-c to stop ping\nping www.google.com -c 4 adb shell netcfg configure and manage network connections via profiles\nnetcfg [\u0026lt;interface\u0026gt; {dhcp|up|down}] step 1. adb shell step 2. netcfg adb shell ip show, manipulate routing, devices, policy routing and tunnels\nip [ options ] object object := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp }\noptions := { -v[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]}\nstep 1. adb shell step 2. ip -f inet addr show wlan0 # show wifi ip address logcat adb logcat adb shell dumpsys adb shell dumpstate prints log data to the screen.\nadb logcat [option] [filter-specs] adb logcat notes: press ctrl-c to stop monitor\nadb logcat *:v # lowest priority, filter to only show verbose level adb logcat *:d # filter to only show debug level adb logcat *:i # filter to only show info level adb logcat *:w # filter to only show warning level adb logcat *:e # filter to only show error level adb logcat *:f # filter to only show fatal level adb logcat *:s # silent, highest priority, on which nothing is ever printed adb logcat -b \u0026lt;buffer\u0026gt; adb logcat -b radio # view the buffer that contains radio/telephony related messages. adb logcat -b event # view the buffer containing events-related messages. adb logcat -b main # default adb logcat -c # clears the entire log and exits. adb logcat -d # dumps the log to the screen and exits. adb logcat -f test.logs # writes log message output to test.logs . adb logcat -g # prints the size of the specified log buffer and exits. adb logcat -n \u0026lt;count\u0026gt; # sets the maximum number of rotated logs to \u0026lt;count\u0026gt;. notes: the default value is 4. requires the -r option.\nadb logcat -r \u0026lt;kbytes\u0026gt; # rotates the log file every \u0026lt;kbytes\u0026gt; of output. notes: the default value is 16. requires the -f option.\nadb logcat -s # sets the default filter spec to silent. adb logcat -v \u0026lt;format\u0026gt; adb logcat -v brief # display priority/tag and pid of the process issuing the message (default format). adb logcat -v process # display pid only.) adb logcat -v tag # display the priority/tag only. adb logcat -v raw # display the raw log message, with no other metadata fields. adb logcat -v time # display the date, invocation time, priority/tag, and pid of the process issuing the message. adb logcat -v threadtime # display the date, invocation time, priority, tag, and the pid and tid of the thread issuing the message. adb logcat -v long # display all metadata fields and separate messages with blank lines. adb shell dumpsys dumps system data\nadb shell dumpsys [options] adb shell dumpsys adb shell dumpsys meminfo\nadb shell dumpsys battery notes: a mobile device with developer options enabled running android 5.0 or higher.\nadb shell dumpsys batterystats # collects battery data from your device **notes: battery historian converts that data into an html visualization. ** step 1 adb shell dumpsys batterystats \u0026gt; batterystats.txt step 2 python historian.py batterystats.txt \u0026gt; batterystats.html\nadb shell dumpsys batterystats --reset # erases old collection data adb shell dumpsys activity\nadb shell dumpsys gfxinfo com.android.phone measuring com.android.phone ui performance\nadb shell dumpstate dumps state\nadb shell dumpstate adb shell dumpstate \u0026gt; state.logs # dumps state to a file screenshot adb shell screencap adb shell screenrecord [4.4+] adb shell screencap taking a screenshot of a device display.\nadb shell screencap \u0026lt;filename\u0026gt; adb shell screencap /sdcard/screen.png download the file from the device\nadb pull /sdcard/screen.png adb shell screenrecord recording the display of devices running android 4.4 (api level 19) and higher.\nadb shell screenrecord [options] \u0026lt;filename\u0026gt; adb shell screenrecord /sdcard/demo.mp4 (press ctrl-c to stop recording)\ndownload the file from the device\nadb pull /sdcard/demo.mp4 notes: stop the screen recording by pressing ctrl-c, otherwise the recording stops automatically at three minutes or the time limit set by \u0026ndash;time-limit.\nadb shell screenrecord --size \u0026lt;widthxheight\u0026gt; sets the video size: 1280x720. the default value is the device\u0026rsquo;s native display resolution (if supported), 1280x720 if not. for best results, use a size supported by your device\u0026rsquo;s advanced video coding (avc) encoder.\nadb shell screenrecord --bit-rate \u0026lt;rate\u0026gt; sets the video bit rate for the video, in megabits per second. the default value is 4mbps. you can increase the bit rate to improve video quality, but doing so results in larger movie files. the following example sets the recording bit rate to 5mbps: adb shell screenrecord \u0026ndash;bit-rate 5000000 /sdcard/demo.mp4\nadb shell screenrecord --time-limit \u0026lt;time\u0026gt; sets the maximum recording time, in seconds. the default and maximum value is 180 (3 minutes).\nadb shell screenrecord --rotate rotates the output 90 degrees. this feature is experimental.\nadb shell screenrecord --verbose displays log information on the command-line screen. if you do not set this option, the utility does not display any information while running.\nsystem adb rootadb sideload adb shell ps adb shell top adb shell getprop adb shell setprop adb root restarts the adbd daemon with root permissions\nadb root notes: adbd cannot run as root in production builds (test in emulator)\nadb sideload flashing/restoring android update.zip packages.\nadb sideload \u0026lt;update.zip\u0026gt; notes: adb reboot sideload [android m+]\nadb shell ps print process status\nps [options] step 1. adb shell step 2. ps ps -p\nadb shell top display top cpu processes\ntop [options] step 1. adb shell step 2. top notes: (press ctrl-c to stop monitor)\ntop -t show threads instead of processes.\nadb shell getprop get property via the android property service\ngetprop [options] step 1. adb shell step 2. getprop getprop ro.build.version.sdk getprop ro.chipname getprop | grep adb see also adb shell setprop\nadb shell setprop set property service\nsetprop \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; step 1. adb shell step 2. setprop service.adb.tcp.port 5555\nsee also adb shell getprop\n","date":"2019-04-28","permalink":"https://blog.akvicor.com/posts/android/adb/","summary":"\u003ch2 id=\"what-is-adb\"\u003eWhat Is ADB\u003c/h2\u003e\n\u003cp\u003eAndroid Debug Bridge (adb) is a command line tool that lets you communicate with an emulator or connected Android device. You can find the adb tool in \u003cem\u003eandroid sdk/platform-tools\u003c/em\u003e or Download \u003ca href=\"http://adbshell.com/downloads\"\u003eADB Kits\u003c/a\u003e.\u003c/p\u003e","title":"adb commands"},{"content":"python手册\n基本数据类型 整数 python可以处理\u0026quot;任意\u0026quot;大小的整数，包括负数 支持二进制，八进制，十进制，十六进制 前缀 例子 进制 0b或者0b a = 0b1010 2 0o或者0o a = 0o12 8 无 a = 10 10 0x或者0x a = 0xa 16 浮点数 定义\na = 1.2 b = .4 c = 1.2e-4 计算时可能会丢失精度\n字符串 定义 a = \u0026rsquo;test' a = \u0026ldquo;test\u0026rdquo; a = \u0026lsquo;\u0026lsquo;\u0026rsquo;test\u0026rsquo;\u0026rsquo;\u0026rsquo; 可以直接使用单/双引号 a = \u0026#34;test\u0026#34; len(a) 切割字符串 x = \u0026#39;hello world\u0026#39; # 分割字符串 a = x.split(\u0026#39; \u0026#39;) # [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;] # 合并为字符串 \u0026#39; \u0026#39;.join(a) # \u0026#39;hello world\u0026#39; # 切片 s = \u0026#39;12 34\u0026#39; s[2:4] # \u0026#39; 3\u0026#39; 格式化字符串 name = \u0026#34;akvicor\u0026#34; age = 19 # print i\u0026#39;m akvicor new_str = \u0026#34;i\u0026#39;m \u0026#34; + name + \u0026#34;, \u0026#34; + str(age) + \u0026#34; years old\u0026#34; print(\u0026#34;case0: \u0026#34; + new_str) # in python2 new_str1 = \u0026#34;i\u0026#39;m %s, %d years old\u0026#34; % (name, age) print(\u0026#34;case1: \u0026#34; + new_str1) # in python3 new_str2 = \u0026#34;i\u0026#39;m {}, {} years old\u0026#34;.format(name, age) print(\u0026#34;case2: \u0026#34; + new_str2) new_str3 = \u0026#34;i\u0026#39;m {names}, {ages} years old\u0026#34;.format( names=\u0026#39;akvicor\u0026#39;, ages=age ) print(\u0026#34;case3: \u0026#34; + new_str3) new_str4 = f\u0026#34;i\u0026#39;m {name}, {age} years old\u0026#34; print(\u0026#34;case4: \u0026#34; + new_str4) # case0: i\u0026#39;m akvicor, 19 years old # case1: i\u0026#39;m akvicor, 19 years old # case2: i\u0026#39;m akvicor, 19 years old # case3: i\u0026#39;m akvicor, 19 years old # case4: i\u0026#39;m akvicor, 19 years old 运算符 +：两个字符串拼接\n*****：将字符串重复\n布尔型 true false none空值 空值就是没有值 a = \u0026rsquo;\u0026rsquo; 不叫空 a = 0 也不叫空 a = none 叫空 a = none a is none # true a = \u0026#39;\u0026#39; a is none # false turtle 设置画笔大小 pensize(4) 隐藏海龟 hideturtle() 切换rgb色彩模式 colormode(255) 颜色 color((255, 155, 192), \u0026quot;pink\u0026quot;) 设置画布宽和高 setup(840, 500) 设置画笔速度 speed(10) turtle peppa pig source code \u0026#34;\u0026#34;\u0026#34; 绘制小猪佩奇 \u0026#34;\u0026#34;\u0026#34; from turtle import * def nose(x, y): \u0026#34;\u0026#34;\u0026#34;画鼻子\u0026#34;\u0026#34;\u0026#34; # 将海龟移动到指定的坐标 goto(x, y) pendown() # 设置海龟的方向（0-东、90-北、180-西、270-南） setheading(-30) begin_fill() a = 0.4 for i in range(120): if 0 \u0026lt;= i \u0026lt; 30 or 60 \u0026lt;= i \u0026lt; 90: a = a + 0.08 # 向左转3度 left(3) # 向前走 forward(a) else: a = a - 0.08 left(3) forward(a) end_fill() penup() setheading(90) forward(25) setheading(0) forward(10) pendown() # 设置画笔的颜色(红, 绿, 蓝) pencolor(255, 155, 192) setheading(10) begin_fill() circle(5) color(160, 82, 45) end_fill() penup() setheading(0) forward(20) pendown() pencolor(255, 155, 192) setheading(10) begin_fill() circle(5) color(160, 82, 45) end_fill() def head(x, y): \u0026#34;\u0026#34;\u0026#34;画头\u0026#34;\u0026#34;\u0026#34; color((255, 155, 192), \u0026#34;pink\u0026#34;) penup() goto(x, y) setheading(0) pendown() begin_fill() setheading(180) circle(300, -30) circle(100, -60) circle(80, -100) circle(150, -20) circle(60, -95) setheading(161) circle(-300, 15) penup() goto(-100, 100) pendown() setheading(-30) a = 0.4 for i in range(60): if 0 \u0026lt;= i \u0026lt; 30 or 60 \u0026lt;= i \u0026lt; 90: a = a + 0.08 lt(3) # 向左转3度 fd(a) # 向前走a的步长 else: a = a - 0.08 lt(3) fd(a) end_fill() def ears(x, y): \u0026#34;\u0026#34;\u0026#34;画耳朵\u0026#34;\u0026#34;\u0026#34; color((255, 155, 192), \u0026#34;pink\u0026#34;) penup() goto(x, y) pendown() begin_fill() setheading(100) circle(-50, 50) circle(-10, 120) circle(-50, 54) end_fill() penup() setheading(90) forward(-12) setheading(0) forward(30) pendown() begin_fill() setheading(100) circle(-50, 50) circle(-10, 120) circle(-50, 56) end_fill() def eyes(x, y): \u0026#34;\u0026#34;\u0026#34;画眼睛\u0026#34;\u0026#34;\u0026#34; color((255, 155, 192), \u0026#34;white\u0026#34;) penup() setheading(90) forward(-20) setheading(0) forward(-95) pendown() begin_fill() circle(15) end_fill() color(\u0026#34;black\u0026#34;) penup() setheading(90) forward(12) setheading(0) forward(-3) pendown() begin_fill() circle(3) end_fill() color((255, 155, 192), \u0026#34;white\u0026#34;) penup() seth(90) forward(-25) seth(0) forward(40) pendown() begin_fill() circle(15) end_fill() color(\u0026#34;black\u0026#34;) penup() setheading(90) forward(12) setheading(0) forward(-3) pendown() begin_fill() circle(3) end_fill() def cheek(x, y): \u0026#34;\u0026#34;\u0026#34;画脸颊\u0026#34;\u0026#34;\u0026#34; color((255, 155, 192)) penup() goto(x, y) pendown() setheading(0) begin_fill() circle(30) end_fill() def mouth(x, y): \u0026#34;\u0026#34;\u0026#34;画嘴巴\u0026#34;\u0026#34;\u0026#34; color(239, 69, 19) penup() goto(x, y) pendown() setheading(-80) circle(30, 40) circle(40, 80) def setting(): \u0026#34;\u0026#34;\u0026#34;设置参数\u0026#34;\u0026#34;\u0026#34; pensize(4) # 隐藏海龟 hideturtle() colormode(255) color((255, 155, 192), \u0026#34;pink\u0026#34;) setup(840, 500) speed(10) def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; setting() nose(-100, 100) head(-69, 167) ears(0, 160) eyes(0, 140) cheek(80, 10) mouth(-20, 30) done() if __name__ == \u0026#39;__main__\u0026#39;: main() 列表和元组 元组是不可变的(immutable)python对象，储存在固定的一块内存里 列表是可变的(mutable)python对象，需要两块存储空间，一块固定用来存储实际的列表数据，一块可变的空间用于扩展。 结论就是：元组创建和访问要比列表块，但是不如列表灵活 list basic a = [1, 2, 3] b = [1, \u0026#39;abc\u0026#39;, 2.0, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]] print(a) # [1, 2, 3] print(b) # [1, \u0026#39;abc\u0026#39;, 2.0, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]] print(a[0]) # 1 print(a[0], a[1]) # 1 2 # 默认两个之间加入空格 # 默认分隔符为空格，结尾为换行。但可以修改 print(a[0], a[1], a[2], sep=\u0026#39;*\u0026#39;, end=\u0026#39;-\u0026#39;) 1*2*3- c = b[1:3] print(c) # [\u0026#39;abc\u0026#39;, 2.0] s = \u0026#39;abcdefghijklmn\u0026#39; print(s[3:7], s[-5:-2]) # defg jkl list method # 获取列表的一些基本信息 list1 = [9, 1, -4, 3, 7, 11, 3] print(\u0026#39;list1的长度 = \u0026#39;, len(list1)) print(\u0026#39;list1里的最大值 = \u0026#39;, max(list1)) print(\u0026#39;list1里的最小值 = \u0026#39;, min(list1)) print(\u0026#39;list1里3这个元素一共出现了{}次\u0026#39;.format(list1.count(3))) # 列表复制 list_copy = list1[:] # 不能使用 list_copy = list1 这种方法 # 这只会让list_copy和list1指向同一个列表 # 列表的改变 list2 = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] print(\u0026#39;list2 = \u0026#39;, list2) # 给list2结尾添加一个元素\u0026#39;e\u0026#39; list2.append(\u0026#39;e\u0026#39;) print(\u0026#39;list2 = \u0026#39;, list2) # 在list2的\u0026#39;a\u0026#39;和\u0026#39;b\u0026#39;之间插入一个\u0026#39;b\u0026#39; list2.insert(1, \u0026#39;b\u0026#39;) print(\u0026#39;list2 = \u0026#39;, list2) # 删除list2里的 \u0026#39;b\u0026#39; 根据值删除元素 list2.remove(\u0026#39;b\u0026#39;) print(\u0026#39;list2 = \u0026#39;, list2) # 列表反转 list3 = [1, 2, 3] print(\u0026#39;list3 = \u0026#39;, list3) list3.reverse() print(\u0026#39;list3 = \u0026#39;, list3) # 列表排序 list4 = [9, 1, -4, 3, 7, 11, 3] # 永久排序 list4.sort() print(\u0026#39;list4 = \u0026#39;, list4) list4.sort(reverse=true) print(\u0026#39;list4 = \u0026#39;, list4) # 临时排序 list4temp = sorted(list4) list4temp = sorted(list4, reverse=true) # 删除列表元素 根据位置 list4 = [9, 1, -4, 3, 7, 11, 3] # 是用del删除 del list4[6] # -\u0026gt; [9, 1, -4, 3, 7, 11] # 是用pop()删除 默认是最后一个元素，也可以是指定元素 p = list4.pop() # -\u0026gt; [9, 1, -4, 3, 7, 11] # p = 3 p = list4.pop(0) # -\u0026gt; [1, -4, 3, 7, 11, 3] # p = 9 # etc list5 = [1, 2, 3, 4] print(list5 * 2 + [4, 5, 6]) # [1, 2, 3, 4, 1, 2, 3, 4, 4, 5, 6] list1的长度 = 7 list1里的最大值 = 11 list1里的最小值 = -4 list1里3这个元素一共出现了2次 list2 = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] list2 = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] list2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] list2 = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;] list3 = [1, 2, 3] list3 = [3, 2, 1] list4 = [-4, 1, 3, 3, 7, 9, 11] list4 = [11, 9, 7, 3, 3, 1, -4] [1, 2, 3, 4, 1, 2, 3, 4, 4, 5, 6] tuple basic # 元组的创建 a = (1, 2, 3) b = 1, print(a, type(a)) print(b, type(b)) # 元组的访问 print(a) print(a[1]) print(a[-1]) print(a[1:3]) print(a[1:]) print(a[:2]) tuple methods 元组里面的值与字符串类似，不可以改变\n# 获取元组的一些基本信息 tuple1 = (9, 1, -4, 3, 7, 11, 3) print(\u0026#39;tuple1的长度 = \u0026#39;, len(tuple1)) print(\u0026#39;tuple1里的最大值 = \u0026#39;, max(tuple1)) print(\u0026#39;tuple1里的最小值 = \u0026#39;, min(tuple1)) print(\u0026#39;tuple1里3这个元素一共出现了{}次\u0026#39;.format(tuple1.count(3))) tuple5 = (1, 2, 3, 4) print(tuple5 * 2 + (4, 5, 6)) tuple1的长度 = 7 tuple1里的最大值 = 11 tuple1里的最小值 = -4 tuple1里3这个元素一共出现了2次 (1, 2, 3, 4, 1, 2, 3, 4, 4, 5, 6) dict basic # 字典创建 a = { 1: \u0026#39;a\u0026#39;, 2: \u0026#39;b\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;c\u0026#39; } # 不可改变的数据类型 l1 = [1, 2, 3] # 因为list是可以改变的，所以下面这种是错误的 # b = { # l1: 1 # } t1 = (1, 2, 3) # 这是可以的，因为tuple不可改变 c = { t1: l1 } print(c) d = dict() print(d) e = dict(a=1, b=2, d=\u0026#39;a\u0026#39;) print(e) # 字典的访问 print(e[\u0026#39;d\u0026#39;]) e[\u0026#39;c\u0026#39;] = 123 print(e) e[\u0026#39;c\u0026#39;] = 3 print(e) {(1, 2, 3): [1, 2, 3]} {} {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;d\u0026#39;: \u0026#39;a\u0026#39;} a {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;d\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;: 123} {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;d\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;: 3} dict methods d = { \u0026#39;name\u0026#39;: \u0026#39;jack\u0026#39;, \u0026#39;age\u0026#39;: 9, \u0026#39;grade\u0026#39;: 5 } # 不安全，在没有name时会报错 print(d[\u0026#39;name\u0026#39;]) # 在没有name时输出none print(d.get(\u0026#39;name\u0026#39;)) print(d.keys()) print(d.values()) print(d.items()) c = d.pop(\u0026#39;name\u0026#39;) print(c, d) d.clear() print(d) # 字典的更新 c = { 1: 1, 2: 2 } print(c) c[3] = 3 c[4] = 4 d = { 5: 5, 6: 6 } # 字典删除 按照键删除 del c[3] # c.update(d) # print(c) # 或 e = {**c, **d} print(e) jack jack dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;grade\u0026#39;]) dict_values([\u0026#39;jack\u0026#39;, 9, 5]) dict_items([(\u0026#39;name\u0026#39;, \u0026#39;jack\u0026#39;), (\u0026#39;age\u0026#39;, 9), (\u0026#39;grade\u0026#39;, 5)]) jack {\u0026#39;age\u0026#39;: 9, \u0026#39;grade\u0026#39;: 5} {} {1: 1, 2: 2} {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6} set basic a = {\u0026#39;f\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;} print(a) print(\u0026#39;c\u0026#39; in a) print(\u0026#39;d\u0026#39; in a) li = [1, 2, 3, 2, 4, 5, 2] s1 = set(li) print(s1, type(s1), list(s1)) {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;c\u0026#39;} true false {1, 2, 3, 4, 5} \u0026lt;class \u0026#39;set\u0026#39;\u0026gt; [1, 2, 3, 4, 5] set methods s = {1, 2, 3, 4} s.add(5) print(s) # 如果元素不存在会报错 s.remove(5) # s.remove(5) print(s) a = \u0026#39;123452\u0026#39; s1 = set(a) print(s1) s1 = {1, 2, 3, 4} s2 = {3, 4, 5, 6} print(s1 \u0026amp; s2) print(s1 | s2) print(s1 ^ s2) print(s1 - s2) print(s2 - s1) {1, 2, 3, 4, 5} {1, 2, 3, 4} {\u0026#39;2\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;1\u0026#39;} {3, 4} {1, 2, 3, 4, 5, 6} {1, 2, 5, 6} {1, 2} 条件语句和循环语句 if elif else a = eval(input(\u0026#39;please input a integer: \u0026#39;)) print(\u0026#39;information: \u0026#39;, a, type(a)) if a \u0026gt; 0: print(\u0026#39;this integer is large than 0\u0026#39;) elif a == 0: print(\u0026#39;this integer is equal 0\u0026#39;) else: print(\u0026#39;this integer is smaller than 0\u0026#39;) while a = 10 while a \u0026gt; 0: print(a) a -= 1 for a = \u0026#39;12345\u0026#39; b = [1, 2, 3, 4] c = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;) d = { 1: \u0026#39;a\u0026#39;, 2: \u0026#39;b\u0026#39;, 3: \u0026#39;c\u0026#39; } e = {1, 2, 3, 4, 9} for item in a: print(item) print(\u0026#39;\\ndict\u0026#39;) for item in d: print(item) for a, b in d.items(): print(f\u0026#39;{a}={b}\u0026#39;) print(\u0026#39;\\nrange\u0026#39;) for i in range(1, 20, 3): # 默认步长等于1,也可以指定步长，例如三 # 等价于 c++ 中的 for(int i = 1; i \u0026lt; 20; i+=3) print(i) break continue for i in range(10): print(i) if i == 3: break print(\u0026#39;#2\u0026#39;) for i in range(10): if i % 2 == 0: print(i) print(\u0026#39;#3\u0026#39;) for i in range(10): if i % 2 == 0: continue print(i) 0 1 2 3 #2 0 2 4 6 8 #3 1 3 5 7 9 game: guss number import random a = random.randint(0, 100) while true: num = int(input(\u0026#34;please input your choice: \u0026#34;)) if num == a: print(\u0026#39;\\ncongratulation!\u0026#39;) break elif num \u0026gt; a: print(\u0026#39;to large\u0026#39;) else: print(\u0026#39;to small\u0026#39;) print(f\u0026#39;the number is {a}\u0026#39;) 函数 函数的定义和调用 def demo(): print(\u0026#39;hello world\u0026#39;) print(\u0026#39;demo\u0026#39;) demo() def demo1(a, b): print(a, b) print(\u0026#39;demo1\u0026#39;) demo1(a=[1, 2, 3], b={1: 1, 2: 3}) def my_sum(a: int, b: int): return a + b print(my_sum(2, 3)) def my_max(a): if not a: return none max_value = 0 for i in a: if i \u0026gt; max_value: max_value = i return max_value a = [1, 4, 5, 2, 3, 8, 10] print(my_max(a)) hello world demo [1, 2, 3] {1: 1, 2: 3} demo1 5 10 命名空间和范围 x = 1 x += 1 print(x) def demo(): x = 10 print(x) demo() print(x) def demo1(a): a = a + 10 print(a) demo1(a=x) print(x) print(\u0026#34;next\u0026#34;) y = [1, 2, 3] print(\u0026#39;this is y\u0026#39;, y) def demo2(a): a.append(4) print(\u0026#39;demo2\u0026#39;, a) def demo22(a): a = a + [4] print(\u0026#39;demo22\u0026#39;, a) demo22(a=y) print(\u0026#39;after demo22\u0026#39;, y) demo2(a=y) print(\u0026#39;after demo2\u0026#39;, y) print(\u0026#39;可以发现这两种方法中 .append() 会影响原数组，而 + 不会影响\u0026#39;) z = 1 print(\u0026#39;this is z\u0026#39;, z) def demo3(a): global z z = z + a print(\u0026#39;in function\u0026#39;, z) demo3(a=10) print(\u0026#39;after function\u0026#39;, z) 2 10 2 12 2 next this is y [1, 2, 3] demo22 [1, 2, 3, 4] after demo22 [1, 2, 3] demo2 [1, 2, 3, 4] after demo2 [1, 2, 3, 4] 可以发现这两种方法中 .append() 会影响原数组，而 + 不会影响 this is z 1 in function 11 after function 11 可变参数*arge def add(a, b): return a + b print(add(1, 2)) def add1(a, b, c): return a + b + c print(add1(1, 2, 3)) def add2(*args): print(args) result = 0 for i in args: result += i return result print(add2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) 3 6 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 55 可变参数**wargs def add(**kwargs): print(kwargs) print(add(a=1, b=2)) def test(a, b, c): print(a + b + c) def add(x, **kwargs): if x == 2: test(**kwargs) add(x=2, a=1, b=2, c=2) {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} none 5 参数默认值 def test(a, b=false): if b: return a else: return a * a print(test(3)) print(test(3, true)) 9 3 递归的实现 def demo(n): result = 1 for i in range(1, n+1): result *= i return result def rec(n): if n \u0026lt;= 1: return 1 return n * rec(n-1) print(rec(5)) print(demo(5)) # 120 # 120 面向对象 类和对象的基本概念 class myclass: pass # __init__() method 方法 function(函数) # attribute 属性 # method 方法 class people: def __init__(self, name, age): self.name = name self.age = age def say_hi(self): print(\u0026#34;hi, my name is {}, and i\u0026#39;m {}\u0026#34;.format(self.name, self.age)) someone = people(\u0026#39;jack\u0026#39;, 20) print(someone.name, someone.age) someone.say_hi() 私有属性和受保护属性 保护的属性为变量名前有一个_，私有属性为变量名前有两个__。\n保护属性可以在类外更改，但ide会警告\n私有属性不可以在类外更改\n但是通过某种方法也可以更改私有属性，但并不推荐在类外对这两种属性进行更改\nclass people: def __init__(self, name, age): self.name = name self.age = age self._protect_var = 10 # can be replace self.__private_var = 10 # can not be replace def say_hi(self): print(\u0026#34;hi, my name is {}, and i\u0026#39;m {}\u0026#34;.format(self.name, self.age)) def get_var(self): return self.__private_var def set_var(self, var): self.__private_var = var someone = people(\u0026#39;jack\u0026#39;, 20) someone.say_hi() someone.age = 21 someone.say_hi() someone._protect_var = 30 print(someone._protect_var) print(someone.get_var()) someone.set_var(30) print(someone.get_var()) # python 只是将私有变量改名，并没有阻止我们对他的访问和修改 # 这只是变相的阻止我们对他的访问，但在实际项目中请不要这样做 print(dir(someone)) someone._people_protect_var = 31 print(someone._people_protect_var) someone._people__private_var = 31 print(someone.get_var()) hi, my name is jack, and i\u0026#39;m 20 hi, my name is jack, and i\u0026#39;m 21 30 10 30 [\u0026#39;_people__private_var\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;_protect_var\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;get_var\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;say_hi\u0026#39;, \u0026#39;set_var\u0026#39;] 31 31 类的proterty怎么用 @property使类中的私有变量直接以 类名.变量名的形式访问\n@变量名.setter 使类中的私有变量直接以 类名.变量名的形式修改（需要先设定变量的property）\n此方法可以使私有变量在访问和修改时按照指定的方法进行处理，防止存放进去非法数据\nclass people: def __init__(self, name, age, sex): self.__name = name self.__age = age self.__sex = sex def say_hi(self): print(\u0026#34;hi, my name is {}, and i\u0026#39;m {}\u0026#34;.format(self.__name, self.__age)) # def get_name(self): # return self.__name @property def name(self): return self.__name def set_name(self, name): self.__name = name def get_age(self): return self.__age def set_age(self, age): self.__age = age # def get_sex(self): # return self.__sex # def set_sex(self, sex): # self.__sex = sex @property def sex(self): return self.__sex # 必须设置此变量的property @sex.setter def sex(self, sex): self.__sex = sex someone = people(name=\u0026#39;jack\u0026#39;, age=20, sex=\u0026#39;male\u0026#39;) print(someone.get_age()) someone.set_age(21) print(someone.get_age()) print(someone.name) someone.sex = \u0026#39;female\u0026#39; print(someone.sex) 继承和多态 class animal: def eat(self): print(\u0026#39;animal is eating\u0026#39;) class bird(animal): def sing(self): print(\u0026#39;bird is singing\u0026#39;) def eat(self): print(\u0026#39;bird is eating\u0026#39;) class dog(animal): def eat(self): print(\u0026#39;dog is eating\u0026#39;) class cat(animal): def eat(self): print(\u0026#39;cat is eating\u0026#39;) print(\u0026#39;animal\u0026#39;) a = animal() a.eat() print(\u0026#39;bird\u0026#39;) b = bird() b.eat() b.sing() print(\u0026#39;dog\u0026#39;) d = dog() d.eat() print(\u0026#39;cat\u0026#39;) c = cat() print(\u0026#39;this is end\\n\u0026#39;) def demo_eat(a): a.eat() for i in [a, b, c, d]: demo_eat(i) animal animal is eating bird bird is eating bird is singing dog dog is eating cat this is end animal is eating bird is eating cat is eating dog is eating type和isinstance的使用 class a: pass class b(a): pass a = a() b = b() c = 1 print(\u0026#39;type a\u0026#39;, type(a)) print(\u0026#39;type b\u0026#39;, type(b)) print(\u0026#39;a-\u0026gt;a\u0026#39;, isinstance(a, a)) print(\u0026#39;c-\u0026gt;int\u0026#39;, isinstance(c, int)) print(\u0026#39;c-\u0026gt;str\u0026#39;, isinstance(c, str)) print(\u0026#39;b-\u0026gt;b\u0026#39;, isinstance(b, b)) print(\u0026#39;b-\u0026gt;a\u0026#39;, isinstance(b, a)) # 因为b继承自a 类属性和实例属性 类属性在在创建实例时会保留在实例中，修改实例中的属性不回影响到类的属性\n但修改类中的属性会影响到后续通过此类实例化出来的实例。\nclass student: count = 0 def __init__(self, name): student.count += 1 self.name = name s1 = student(\u0026#39;a\u0026#39;) s2 = student(\u0026#39;b\u0026#39;) s3 = student(\u0026#39;c\u0026#39;) print(student.count) # print(student.count) # # print(student.name) 必须有实例才能访问 # s1 = student(name=\u0026#39;a\u0026#39;) # print(s1.name) # print(s1.count) # # s1.name = \u0026#39;b\u0026#39; # s1.count = 1 # print(s1.name) # print(s1.count) # print(student.count) # # student.count = 2 # s2 = student(name=\u0026#39;c\u0026#39;) # print(\u0026#39;after change\u0026#39;) # print(student.count) # print(s1.count) # print(s2.count) 0 a 1 b 1 1 after change 3 1 3 类方法和实例方法 类中的普通方法只能先实例化之后，通过实例调用\n类中的类方法可以直接调用，不用实例化。类方法因为有cls参数，所以可以调用类中的其他方法（例如静态方法和其他的类方法）\n类中的静态方法可以直接调用，不用实例化。\nclass people: def __init__(self, name, age): self.name = name self.age = age def sayhi(self): print(f\u0026#34;hi, my name is {self.name}, and i\u0026#39;m {self.age}\u0026#34;) @classmethod def test1(cls): print(\u0026#39;this is a class method\u0026#39;) cls.test2() # 因为有cls参数，所以可以调用class方法 @staticmethod def test2(): print(\u0026#39;this is a static method\u0026#39;) p1 = people(name=\u0026#39;jack\u0026#39;, age=20) p1.sayhi() p1.test1() p1.test2() print(\u0026#39;-------------\u0026#39;) people.test1() people.test2() 模块和包 # ch8/demo/math.py def my_sum(*args): result = 0 for i in args: result += i return result def my_max(*args): print(\u0026#34;max value\u0026#34;) def my_min(*args): print(\u0026#34;min value\u0026#34;) class people: def __init__(self, name, age): self.name = name self.age = age max_num = 100 # print(my_sum(1, 2, 3, 4)) # ch8/test.py import sys if \u0026#39;/users/akvicor/documents/github/course/learncode/python\u0026#39; not in sys.path: sys.path.append(\u0026#39;/users/akvicor/documents/github/course/learncode/python\u0026#39;) # print(sys.path) from ch8.demo.math import my_sum # 只能在pycharm里才不会报错 # 默认从系统根目录里寻找或从当前目录寻找，pycharm会自动添加ch8设为系统根目录 print(my_sum(1, 2, 3, 4)) 一般在使用import导入包时，最上面一组为系统自带的，中间一组为第三方的，最下面一组为自己的。\nterminal进入venv环境 进入项目目录然后 source venv/bin/activate\nif __name__ == \u0026ldquo;__main__\u0026rdquo; 直接执行一个文件的时候，这个文件里面的 __name__ 就等于 __main__\n否则 __name__等于文件所在位置\n可以使用此语句可以防止此文件被别的文件引用时输出调试信息\npypi pypi.org\n查看包的一些信息\n输入输出和文件 print和input本身就是条用了sys，所以我们可以直接使用sys来输入输出\nimport sys print(\u0026#39;hello world\u0026#39;, \u0026#39;python\u0026#39;, sep=\u0026#39;%\u0026#39;, end=\u0026#39;.\\n\u0026#39;) sys.stdout.write(\u0026#39;hello world!\\n\u0026#39;) # a = input(\u0026#39;ddd: \u0026#39;) # print(a, type(a)) a = sys.stdin.readlines() # command + d to stop print(a, type(a)) 写入文件，mode默认为r参数\nf = open(\u0026#34;test2.txt\u0026#34;, mode=\u0026#39;w\u0026#39;, encoding=\u0026#39;utf8\u0026#39;) f.write(\u0026#34;line 1\\n\u0026#34;) f.writelines([\u0026#39;this is second line\\n\u0026#39;, \u0026#34;line 3\\n\u0026#34;]) f.write(\u0026#34;测试中文\u0026#34;) f.close() \u0026#34;\u0026#34;\u0026#34; 参数列表： file, mode=\u0026#39;r\u0026#39;, buffering=none, encoding=none, errors=none, newline=none, closefd=true ========= =============================================================== character meaning --------- --------------------------------------------------------------- \u0026#39;r\u0026#39; open for reading (default) \u0026#39;w\u0026#39; open for writing, truncating the file first \u0026#39;x\u0026#39; create a new file and open it for writing \u0026#39;a\u0026#39; open for writing, appending to the end of the file if it exists \u0026#39;b\u0026#39; binary mode \u0026#39;t\u0026#39; text mode (default) \u0026#39;+\u0026#39; open a disk file for updating (reading and writing) \u0026#39;u\u0026#39; universal newline mode (deprecated) ========= =============================================================== \u0026#34;\u0026#34;\u0026#34; f为文件指针，当使用readline或readlines的时候指针会向后移动，再次调用时会从指针处继续读，只有用seek将指针改为文件开始处才可以重新从头读\nf = open(\u0026#34;test2.txt\u0026#34;, encoding=\u0026#39;utf-8\u0026#39;) # a = f.read() # while read all line from file, and is very slowly # print(a, type(a)) # for line in f: # it will be quickly # only one times for read # print(line) a = f.readline() # while read all line from file, and is very slowly b = f.readlines() print(a, type(a)) print(b, type(b)) f.seek(0) # back to first line f.close() os import os os.getcwd() # 返回一个str，获取当前目录的完整路径 os.listdir() # 返回一个list，包含当前目录里的所有文件和文件夹 os.mkdir(\u0026#39;demo\u0026#39;) # 创建文件夹 os.path.isdir(\u0026#39;demo\u0026#39;) # 如果参数是文件夹，返回true os.chdir(\u0026#39;demo\u0026#39;) # 进入一个目录 os.path.exists(\u0026#39;demo.txt\u0026#39;) # 当前目录下有没有这个文件夹或者文件，可以是根目录 os.path.join(\u0026#39;ch\u0026#39;, \u0026#39;demo.txt\u0026#39;) # 拼接目录，自动添加 \u0026#39;/\u0026#39; 使用pathlib进行文件相关操作 import os from pathlib import path # in_file = os.path.join(os.getcwd(), \u0026#39;demo\u0026#39;, \u0026#39;test.txt\u0026#39;) # # print(in_file) # # a = path.cwd() / \u0026#39;demo\u0026#39; / \u0026#39;test.txt\u0026#39; # # print(a) # print(type(a)) # # print(a.is_file()) # print(a.is_dir()) # print(a.lstat()) # print(a.parent) # b = path.cwd() / \u0026#39;demo\u0026#39; # b = b / \u0026#39;test\u0026#39; # b.rmdir() p = path.cwd() for file in p.glob(\u0026#39;*\u0026#39;): print(file) print(\u0026#39;******************************************************************************\u0026#39;) for file in p.rglob(\u0026#39;*\u0026#39;): print(file) 读写二进制文件 a = \u0026#39;hello world\u0026#39; b = b\u0026#39;hello world\u0026#39; type(a) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; type(b) # \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; f = open(\u0026#39;test3.txt\u0026#39;, \u0026#39;wb\u0026#39;) f.write(b\u0026#39;hello world!\u0026#39;) f.close() ff = open(\u0026#39;test3.txt\u0026#39;, \u0026#39;rb\u0026#39;) print(ff.read()) ff.close() 序列化对象 import pickle class people: def __init__(self, name, age): self.name = name self.age = age def sayhi(self): print(\u0026#34;hi, my name is {}, and i\u0026#39;m {}\u0026#34;.format(self.name, self.age)) p1 = people(name=\u0026#39;akvicor\u0026#39;, age=20) f = open(\u0026#39;p1\u0026#39;, \u0026#39;wb\u0026#39;) pickle.dump(p1, f) f.close() # 测试序列化对象的加载 （需要类的原型去映射） fp = open(\u0026#39;p1\u0026#39;, \u0026#39;rb\u0026#39;) p2 = pickle.load(fp) f.close() print(p2) 函数式编程 高阶函数是至少满足下列一个条件的函数 接受一个或多个函数作为输入 输出一个函数 print(sum([1,2,3])) b = sum print(b([1,2,3])) # 因为sum是一个函数，所以b被赋值为sum后，b也是个函数，功能与sum相同 def test(x, f): return f(x) printf(test([1,2,3], sum)) # 因为传入的函数为sum， 所以功能为求和 printf(test([1,2,3], max)) # 因为传入的函数为max， 所以功能为求最大值 # test就是一个高阶函数 lambda 匿名函数 def test(x, y): return x + 2 * y f = lambda x, y: x + 2 * y print(test(1, 2)) print(f(1, 2)) def demo(x, y, f): return f(x, y) print(demo(1, 2, lambda x, y: x + 2 * y)) def add_n(n): return lambda x: n + x f = add_n(40) print(f(1)) print(f(-10)) 列表解析 a = [1, 2, 3, 4, 5, 6, 7, 8, 9] b = [item**2 for item in a if item % 2 == 0] print(b) # 列表解析 # 字典解析 高阶函数map和reduce from functools import reduce a = [1, 2, 3, 4] # def f(x, y): # return x + y m = map(lambda x: x * x, a) for i in m: print(i) r = reduce(lambda x, y: x + y, a) print(\u0026#34;r \u0026#34;, r) filter a = [1, 2, 3, 4, 5, 6, 7, 8, 9] f = filter(lambda x: x % 2 == 1, a) print(f) for i in f: print(i, end=\u0026#39; \u0026#39;) print(\u0026#34;\\nlist\u0026#34;) ff = [i for i in a if i % 2 == 1] print(ff) decorator def test1(x): # print(test1.__name__) return x * 2 def test2(x): # print(test2.__name__) return x**3 test1(1) test2(2) def demo(f): def f_new(x): print(f.__name__) return f(x) return f_new f = demo(test1) print(f(3)) # 装饰器 @demo def test3(x): return x * 2 * x print(\u0026#34;for the test3\u0026#34;) a = test3(4) print(a) @demo def test3(x): print(\u0026#39;hello world\u0026#39;) print(\u0026#39;after @@\u0026#39;) test3(1) 完善装饰器 主要是文档注释等函数属性问题\nimport functools def demo(f): \u0026#34;\u0026#34;\u0026#34; this is f :param f: :return: \u0026#34;\u0026#34;\u0026#34; @functools.wraps(f) # 解决文档注释问题 def f_new(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34; this is f-new :param args: :param kwargs: :return: \u0026#34;\u0026#34;\u0026#34; print(f.__name__) return f(*args, **kwargs) # 解决文档注释问题， 或者使用functiontools解决 # f_new.__name__ = f.__name__ # f_new.__doc__ = f.__doc__ return f_new @demo def test1(x, y): \u0026#34;\u0026#34;\u0026#34; this is test 1 :param x: integer :param y: integer :return: str \u0026#34;\u0026#34;\u0026#34; print(f\u0026#39;x={x}, y{y}\u0026#39;) test1(1, 2) print(test1.__name__) print(test1.__doc__) 异常和处理 a = [10, 4, 3, 7, 11, 6, 0, 9, 22, \u0026#39;c\u0026#39;] try: b = [item for item in a if 100 % item == 0] print(b) except zerodivisionerror: print(\u0026#39;zero error\u0026#39;) except typeerror: print(\u0026#39;type error\u0026#39;) except exception as e: print(\u0026#39;other\u0026#39;, e) print(\u0026#39;finished\u0026#39;) 自定义异常 class myexception(exception): pass # raise myexception(\u0026#34;this is user defined exception\u0026#34;) try: raise myexception(\u0026#34;this is user defined exception\u0026#34;) except myexception as e: print(e) assert def demo(x, y): return x + y print(demo(1, 2)) assert(demo(1, 2) != 3) try-except-else try: # 执行代码 except: # 如果有异常发生，执行此处代码 else: # 如果没有异常发生，执行此处代码 try-except-else-finally try: # 执行代码 except: # 如果有异常发生，执行此处代码 else: # 如果没有异常发生，执行此处代码 finally: # 不管有没有异常都会执行此处代码 调试和测试 print 调试 pdb 调试 import pdb pdb.set_trace() pycharm debug doc test 适合小型的项目\ndef func_demo(a, b): \u0026#34;\u0026#34;\u0026#34; doc test demo \u0026gt;\u0026gt;\u0026gt; func_demo(1, 2) 3 \u0026gt;\u0026gt;\u0026gt; func_demo(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) \u0026#39;ab\u0026#39; \u0026gt;\u0026gt;\u0026gt; func_demo([1, 2], [3, 4]) [1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; func_demo(1, \u0026#39;2\u0026#39;) traceback (most recent call last): typeerror: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;\u0026#34;\u0026#34; return a + b if __name__ == \u0026#34;__main__\u0026#34;: import doctest doctest.testmod() 单元测试 python单元测试规范 测试都是以class形式定义 每一个测试类都必须是 unittest.testcase 的子类 每一个测试类里的测试方法都必须以 test_ 开头 使用 assert 去检查预期结果和实际结果是否相符 在测试方法运行之前需要使用 setup() 方法预先定义一些测试规范和临时变量 在测试方法执行完之后需要使用 teardown() 方法清理和销毁临时变量等测试环境 使用 python -m unittest -v test_module 执行测试 unittest import unittest from demo.math import add class testadd(unittest.testcase): def test_add(self): self.assertequal(add(1, 4), 5) def test_add2(self): self.assertequal(add(10, 20), 30) self.assertnotequal(add(10, 20), 31) def test_add3(self): self.assertraises(valueerror, add, 1, 1.2) if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() pysnooper pip install pysnooper\nimport pysnooper @pysnooper.snoop() def f(a, b): return a + b f(1, 2) logging 模块 \u0026#34;\u0026#34;\u0026#34; low -\u0026gt; high debug(), info(), warning(), error(), critical() \u0026#34;\u0026#34;\u0026#34; import logging logging.basicconfig(level=\u0026#39;info\u0026#39;) logging.debug(\u0026#39;this is debug\u0026#39;) logging.info(\u0026#39;this is info\u0026#39;) logging.warning(\u0026#39;this is warning\u0026#39;) logging.error(\u0026#39;this is error\u0026#39;) logging.critical(\u0026#39;this is critical\u0026#39;) 文件写入 \u0026#34;\u0026#34;\u0026#34; low -\u0026gt; high debug(), info(), warning(), error(), critical() \u0026#34;\u0026#34;\u0026#34; import logging logging.basicconfig(level=\u0026#39;info\u0026#39;, filename=\u0026#39;test.log\u0026#39;, filemode=\u0026#39;w\u0026#39;) # w 重新生成文件，默认在文件结尾添加内容 logging.debug(\u0026#39;this is debug\u0026#39;) logging.info(\u0026#39;this is info\u0026#39;) logging.warning(\u0026#39;this is warning\u0026#39;) logging.error(\u0026#39;this is error\u0026#39;) logging.critical(\u0026#39;this is critical\u0026#39;) logging format \u0026#34;\u0026#34;\u0026#34; https://docs.python.org/3/library/logging.html#logrecord-attributes \u0026#34;\u0026#34;\u0026#34; import logging format = \u0026#39;%(asctime)s-%(funcname)s-%(lineno)d-%(levelname)s %(name)s %(message)s\u0026#39; logging.basicconfig(level=\u0026#39;info\u0026#39;, format=format) # logging.basic_format def main(): logging.debug(\u0026#39;this is debug\u0026#39;) logging.info(\u0026#39;this is info\u0026#39;) logging.warning(\u0026#39;this is warning\u0026#39;) logging.error(\u0026#39;this is erro\u0026#39;) logging.critical(\u0026#39;this is critical\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() 创建新的logging对象 import logging logger = logging.getlogger(name=\u0026#39;demo\u0026#39;) logger.setlevel(logging.debug) # create handlers c_handler = logging.streamhandler() f_handler = logging.filehandler(\u0026#39;file.log\u0026#39;) c_handler.setlevel(logging.debug) f_handler.setlevel(logging.info) # create formatters and add it to handlers c_format = logging.formatter(\u0026#39;%(name)s - %(levelname)s - %(message)s\u0026#39;) f_format = logging.formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#39;) c_handler.setformatter(c_format) f_handler.setformatter(f_format) # add handlers to the logger logger.addhandler(c_handler) logger.addhandler(f_handler) def main(): logger.debug(\u0026#39;this is debug\u0026#39;) logger.info(\u0026#39;this is info\u0026#39;) logger.warning(\u0026#39;this is warning\u0026#39;) logger.error(\u0026#39;this is erro\u0026#39;) logger.critical(\u0026#39;this is critical\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() pypy提高python代码执行效率 链接\nbin目录下为可执行文件\n测试代码\nimport time def test(): for i in range(1, 10): n = pow(10, i) start_time = time.time() sum(x for x in range(1, n+1)) end_time = time.time() print(f\u0026#39;10^{i}:{end_time-start_time}\u0026#39;) test() normal\n10^1:3.0994415283203125e-06 10^2:8.106231689453125e-06 10^3:6.008148193359375e-05 10^4:0.0006120204925537109 10^5:0.006687164306640625 10^6:0.06196117401123047 10^7:0.49938416481018066 10^8:4.975664854049683 10^9:49.28339099884033 pypy\n10^1:1.811981201171875e-05 10^2:6.198883056640625e-05 10^3:0.0033159255981445312 10^4:0.00019216537475585938 10^5:0.001216888427734375 10^6:0.0063250064849853516 10^7:0.05159306526184082 10^8:0.5082838535308838 10^9:5.0509021282196045 ","date":"2019-04-26","permalink":"https://blog.akvicor.com/posts/python/manual/","summary":"\u003cp\u003ePython手册\u003c/p\u003e","title":"manual"},{"content":"vim手册\nshiftwidth（缩进的空格数）； tabstop（制表符的宽度）； expandtab（是否在缩进和遇到 tab 键时使用空格替代；使用 noexpandtab 取消设置）； softtabstop（软制表符宽度，设置为非零数值后使用 tab 键和 backspace 时光标移动的格数等于该数值，但实际插入的字符仍受 tabstop 和 expandtab 控制）； autoindent（自动缩进，即每行的缩进值与上一行相等；使用 noautoindent 取消设置）； cindent（使用 c 语言的缩进方式，根据特殊字符如“{”、“}”、“:”和语句是否结束等信息自动调整缩进；在编辑 c/c++ 等类型文件时会自动设定；使用 nocindent 取消设置）； cinoptions（c 语言缩进的具体方式，请参考“:help cinoptions-values”）； paste（粘贴模式，会取消所有上述选项的影响来保证后面的操作——通常是从剪贴板粘贴代码——保持原有代码的风格；使用 nopaste 取消设置）。 第一级 – 存活 安装 vim 启动 vim 什么也别干！请先阅读 当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：\n启动vim后，vim在 normal 模式下。 让我们进入 insert 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了） 此时，你可以输入文本了，就像你用“记事本”一样。 如果你想返回 normal 模式，请按 esc 键。 现在，你知道如何在 insert 和 normal 模式下切换了。下面是一些命令，可以让你在 normal 模式下幸存下来：\ni → insert 模式，按 esc 回到 normal 模式. x → 删当前光标所在的一个字符。 :wq → 存盘 + 退出 (:w 存盘, :q 退出) （陈皓注：:w 后可以跟文件名） dd → 删除当前行，并把删除的行存到剪贴板里 p → 粘贴剪贴板 推荐:\nhjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。 :help \u0026lt;command\u0026gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q） 你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。\n当是，在你进入第二级时，需要再说一下 normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 ctrl 键，比如：ctrl-c。也就是说，ctrl键就好像功能键一样，当你按下了功能键ctrl后，c就不在是c了，而且就是一个命令或是一个快键键了，在vim的normal模式下，所有的键就是功能键了。这个你需要知道。\n标记:\n下面的文字中，如果是 ctrl-λ我会写成 \u0026lt;c-λ\u0026gt;. 以 : 开始的命令你需要输入 \u0026lt;enter\u0026gt; 回车，例如 — 如果我写成 :q 也就是说你要输入 :q\u0026lt;enter\u0026gt;. 第二级 – 感觉良好 上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次esc键）\n各种插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 o → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴 （陈皓注：p/p都可以，p是表示在当前位置之后，p表示在当前位置之前） p → 粘贴 yy → 拷贝当前行当行于 ddp undo/redo u → undo \u0026lt;c-r\u0026gt; → redo 打开/保存/退出/改变文件(buffer) :e \u0026lt;path/to/file\u0026gt; → 打开一个文件 :w → 存盘 :saveas \u0026lt;path/to/file\u0026gt; → 另存为 \u0026lt;path/to/file\u0026gt; :x， zz 或 :wq → 保存并退出 (:x 表示仅在需要时保存，zz不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件） 花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。\n第三级 – 更好，更强，更快 先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。\n更好 下面，让我们看一下vim是怎么重复自己的：\n. → (小数点) 可以重复上一次的命令 n\u0026lt;command\u0026gt; → 重复某个命令n次 下面是一个示例，找开一个文件你可以试试下面的命令：\n2dd → 删除2行 3p → 粘贴文本3次 100idesu [esc] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “ . → 重复上一个命令—— 100 “desu “. 3. → 重复 3 次 “desu” (注意：不是 300，你看，vim多聪明啊). 更强 你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。\nng → 到第 n 行 （陈皓注：注意命令中的g是大写的，另我一般使用 : n 到第n行，如 :137 到第137行）\ngg → 到第一行。（陈皓注：相当于1g，或 :1）\ng → 到最后一行。\n按单词移动：\nw → 到下一个单词的开头。 e → 到下一个单词的结尾。 \u0026gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）\n\u0026gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的e和w。（陈皓注：程序语句）\n下面，让我来说说最强的光标移动：\n% : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上） * 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 相信我，上面这三个命令对程序员来说是相当强大的。\n更快 你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：\n\u0026lt;start position\u0026gt;\u0026lt;command\u0026gt;\u0026lt;end position\u0026gt;\n例如 0y$ 命令意味着：\n0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。\n你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。\n还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：\nd (删除 ) v (可视化的选择) gu (变大写) gu (变小写) 等等 （陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）\n第四级 – vim 超能力 你只需要掌握前面的命令，你就可以很舒服的使用vim了。但是，现在，我们向你介绍的是vim杀手级的功能。下面这些功能是我只用vim的原因。\n在当前行上移动光标: 0 ^ $ f f t t , ;\n0 → 到行头 ^ → 到本行的第一个非blank字符 $ → 到行尾 g_ → 到本行最后一个不是blank字符的位置。 fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 3fa → 在当前行查找第三个出现的a。 f 和 t → 和 f 和 t 一样，只不过是相反方向。 还有一个很有用的命令是 dt\u0026quot; → 删除所有的内容，直到遇到双引号—— \u0026ldquo;。\n区域选择 \u0026lt;action\u0026gt;a\u0026lt;object\u0026gt; 或 \u0026lt;action\u0026gt;i\u0026lt;object\u0026gt;\n在visual 模式下，这些命令很强大，其命令格式为\n\u0026lt;action\u0026gt;a\u0026lt;object\u0026gt; 和 \u0026lt;action\u0026gt;i\u0026lt;object\u0026gt;\naction可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， w 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：\u0026quot;、 '、 )、 }、 ]。 假设你有一个字符串 (map (+) (\u0026quot;foo\u0026quot;)).而光标键在第一个 o 的位置。\nvi\u0026quot; → 会选择 foo. va\u0026quot; → 会选择 \u0026quot;foo\u0026quot;. vi) → 会选择 \u0026quot;foo\u0026quot;. va) → 会选择 (\u0026quot;foo\u0026quot;). v2i) → 会选择 map (+) (\u0026quot;foo\u0026quot;) v2a) → 会选择 (map (+) (\u0026quot;foo\u0026quot;)) 块操作: \u0026lt;c-v\u0026gt;\n块操作，典型的操作： 0 \u0026lt;c-v\u0026gt; \u0026lt;c-d\u0026gt; i-- [esc]\n^ → 到行头 \u0026lt;c-v\u0026gt; → 开始块操作 \u0026lt;c-d\u0026gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) i-- [esc] → i是插入，插入“\u0026ndash;”，按esc键来为每一行生效。 在windows下的vim，你需要使用 \u0026lt;c-q\u0026gt; 而不是 \u0026lt;c-v\u0026gt; ，\u0026lt;c-v\u0026gt; 是拷贝剪贴板。\n自动提示： \u0026lt;c-n\u0026gt; 和 \u0026lt;c-p\u0026gt;\n在 insert 模式下，你可以输入一个词的开头，然后按 \u0026lt;c-p\u0026gt;或是\u0026lt;c-n\u0026gt;，自动补齐功能就出现了……\n宏录制： qa 操作序列 q, @a, @@\nqa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 示例\n在一个只有一行且这一行只有“1”的文本中，键入如下命令：\nqayp\u0026lt;c-a\u0026gt;q→ qa 开始录制 yp 复制行. \u0026lt;c-a\u0026gt; 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 可视化选择： v,v,\u0026lt;c-v\u0026gt;\n前面，我们看到了 \u0026lt;c-v\u0026gt;的示例 （在windows下应该是\u0026lt;c-q\u0026gt;），我们可以使用 v 和 v。一但被选好了，你可以做下面的事：\nj → 把所有的行连接起来（变成一行） \u0026lt; 或 \u0026gt; → 左右缩进 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了） 在所有被选择的行后加上点东西：\n\u0026lt;c-v\u0026gt; 选中相关的行 (可使用 j 或 \u0026lt;c-d\u0026gt; 或是 /pattern 或是 % 等……) $ 到行最后 a, 输入字符串，按 esc。 分屏: :split 和 vsplit.\n下面是主要的命令，你可以使用vim的帮助 :help split. 你可以参考本站以前的一篇文章vim分屏。\n:split → 创建分屏 (:vsplit创建垂直分屏) \u0026lt;c-w\u0026gt;\u0026lt;dir\u0026gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。 \u0026lt;c-w\u0026gt;_ (或 \u0026lt;c-w\u0026gt;|) : 最大化尺寸 (\u0026lt;c-w\u0026gt;| 垂直分屏) \u0026lt;c-w\u0026gt;+ (或 \u0026lt;c-w\u0026gt;-) : 增加尺寸 打开多个文件 在 a 文件中用 :tabedit b 就打开了 b 文件，然后用 gt 来切换进入 a 或 b 文件中；如果打开多个，就用 1gt, 2gt 来切换至不用的文件；\n返回上一个文件用 gt\n","date":"2019-04-21","permalink":"https://blog.akvicor.com/posts/vim/manual/","summary":"\u003cp\u003eVim手册\u003c/p\u003e","title":"manual"},{"content":"macos 默认已经安装了 vim，可执行程序是 /usr/bin/vim，当前的系统 vim 版本有一个问题是不支持与系统剪贴板的集成，另外由于是系统集成版本，使用一段时间后往往会出现版本低于当前 vim 最新版的情况。\n安装包管理器homebrew /usr/bin/ruby -e \u0026#34;$(curl -fssl https://raw.githubusercontent.com/homebrew/install/master/install)\u0026#34; 使用homebrew安装vim brew install vim 可以看到最新版的vim安装到了 /usr/local/cellar/vim/8.0.0946 路径下了\ncd /usr/local/cellar/vim/8.0.0946 ls cd bin/ ls 那么，最新版vim程序的所在位置路径就是：/usr/local/cellar/vim/8.0.0946/bin/vim了！\n修改bash_profile文件内容 接下来要做到就是把最新版vim的安装路径添加到环境变量path中了\n打开 ~/.bash_profile，添加一句话：\nexport path=/usr/local/cellar/vim/8.0.0946:$path 或者\nalias vim=\u0026#39;/usr/local/cellar/vim/8.0.0946/bin/vim\u0026#39; 两者选一\n再source一下文件\nsource ~/.bash_profile ","date":"2019-04-21","permalink":"https://blog.akvicor.com/posts/mac/update_vim/","summary":"\u003cp\u003emacOS 默认已经安装了 Vim，可执行程序是 \u003ccode\u003e/usr/bin/vim\u003c/code\u003e，当前的系统 Vim 版本有一个问题是不支持与系统剪贴板的集成，另外由于是系统集成版本，使用一段时间后往往会出现版本低于当前 Vim 最新版的情况。\u003c/p\u003e","title":"升级vim至最新版"},{"content":"完全数，又称完美数或完备数，是一些特殊的自然数：它所有的真因子（即除了自身以外的约数）的和，恰好等于它本身，完全数不可能是楔形数。\n例如：第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3＝6，恰好等于本身。第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14＝28，也恰好等于本身。后面的数是496、8128。\n十进制的5位数到7位数、9位数、11位数、13到18位数等位数都没有完全数，它们不是亏数就是过剩数。\n完全数的发现 古希腊数学家欧几里得是通过 $math_inline$2^{n-1}\\times(2^n-1)$math_inline$ 的表达式发现前四个完全数的。\n当 $math_inline$n=2 : 2^1\\times(2^2-1)=6$math_inline$ 当 $math_inline$n=3 : 2^2\\times(2^3-1)=28$math_inline$ 当 $math_inline$n=5 : 2^4\\times(2^5-1)=496$math_inline$ 当 $math_inline$n=7 : 2^6\\times(2^7-1)=8128$math_inline$ 一个偶数是完美数，当且仅当它具有如下形式： $math_inline${\\displaystyle 2^{n-1}(2^{n}-1)}$math_inline$ ，其中 $math_inline${\\displaystyle 2^{n}-1}$math_inline$ 是素数，此事实的充分性由欧几里得证明，而必要性则由欧拉所证明。\n比如，上面的 $math_inline${\\displaystyle 6}$math_inline$ 和 $math_inline${\\displaystyle 28}$math_inline$ 对应着 $math_inline${\\displaystyle n=2}$math_inline$ 和 $math_inline${\\displaystyle 3}$math_inline$ 的情况。我们只要找到了一个形如 $math_inline${\\displaystyle 2^{n}-1}​$math_inline$ 的素数（即梅森素数），也就知道了一个偶完美数。\n尽管没有发现奇完全数，但是当代数学家奥斯丁·欧尔证明，若有奇完全数，则其形式必然是 $math_inline${\\displaystyle 12p+1}$math_inline$ 或 $math_inline${\\displaystyle 36p+9}$math_inline$ 的形式，其中 $math_inline${\\displaystyle p}$math_inline$ 是素数。\n首十个完全数是（ a000396）：\n6（1位） 28（2位） 496（3位） 8128（4位） 33550336（8位） 8589869056（10位） 137438691328（12位） 2305843008139952128（19位） 2658455991569831744654692615953842176（37位） 191561942608236107294793378084303638130997321548169216（54位） 每一个梅森素数给出一个偶完全数；反之，每个偶完全数给出一个梅森素数，这结果称为欧几里得－欧拉定理。到 2018 年 1 月为止，共发现了 50 个完全数，且都是偶数。最大的已知完全数为 $math_inline$2^{77232916}\\times(2^{77232917}-1)$math_inline$ 共有 $math_inline${\\displaystyle 46498850}$math_inline$ 位数[1]。\n性质 以下是目前已发现的完全数共有的性质。\n偶完全数都是以6或28结尾。 在十二进制中，除了6跟28以外的偶完全数都以54结尾，甚至，除了6, 28, 496以外的偶完全数都以054或854结尾。而如果存在奇完全数，她在十二进制中必定以1, 09, 39, 69或99结尾。 除6以外的偶完全数，把它的各位数字相加，直到变成个位数，那么这个个位数一定是1[注 1]： $math_inline$28→2+8=10→1+0=1$math_inline$ 所有的偶完全数都可以表达为2的一些连续正整数次幂之和，从 $math_inline${\\displaystyle 2^{p-1}}$math_inline$ 到 $math_inline${\\displaystyle 2^{2p-2}}$math_inline$ ： $math_inline$6=2^1+2^2$math_inline$ $math_inline$28=2^2+2^3+2^4$math_inline$ $math_inline$496=2^4+2^5+2^6+2^7+2^8$math_inline$ $math_inline$8128=2^6+2^7+...+2^{12}$math_inline$ 每个偶完全数都可以写成连续自然数之和[注 2]： $math_inline$6=1+2+3$math_inline$ $math_inline$28=1+2+3+4+5+6+7$math_inline$ $math_inline$496=1+2+3+4+…+30+31$math_inline$ 除6以外的偶完全数，还可以表示成连续奇立方数之和（被加的项共有 $math_inline${\\displaystyle {\\sqrt {2^{p-1}}}}$math_inline$ )[注 3]： $math_inline$28=1^3+3^3$math_inline$ $math_inline$496=1^3+3^3+5^3+7^3$math_inline$ 每个完全数的所有约数（包括本身）的倒数之和，都等于2：（这可以用通分证得。因此每个完全数都是欧尔调和数。） $math_inline$\\frac{1}{1}+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{6}=\\frac{6+3+2+1}{6}=2​$math_inline$ $math_inline$\\frac{1}{1}+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{7}+\\frac{1}{14}+\\frac{1}{28}=\\frac{28+14+7+4+2+1}{28}=2$math_inline$ 它们的二进制表达式也很有趣：（因为偶完全数形式均如 $math_inline$2^{n-1}(2^n-1)$math_inline$ )\n$math_inline$(6)_{10}=(110)_2​$math_inline$ $math_inline$(28)_{10}=(11100)_2$math_inline$ $math_inline$(496)_{10}=(111110000)_2$math_inline$","date":"2019-04-20","permalink":"https://blog.akvicor.com/posts/algorithm/perfect_number/","summary":"\u003cp\u003e\u003cstrong\u003e完全数\u003c/strong\u003e，又称\u003cstrong\u003e完美数\u003c/strong\u003e或\u003cstrong\u003e完备数\u003c/strong\u003e，是一些特殊的\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0\"\u003e自然数\u003c/a\u003e：它所有的真\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%9B%A0%E5%AD%90\"\u003e因子\u003c/a\u003e（即除了自身以外的约数）的和，恰好等于它本身，完全数不可能是\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%A5%94%E5%BD%A2%E6%95%B8\"\u003e楔形数\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e例如：第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3＝6，恰好等于本身。第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14＝28，也恰好等于本身。后面的数是\u003ca href=\"https://zh.wikipedia.org/wiki/496\"\u003e496\u003c/a\u003e、\u003ca href=\"https://zh.wikipedia.org/wiki/8128\"\u003e8128\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%8D%81%E9%80%B2%E4%BD%8D\"\u003e十进制\u003c/a\u003e的5位数到7位数、9位数、11位数、13到18位数等位数都没有完全数，它们不是\u003ca href=\"https://zh.wikipedia.org/wiki/%E4%BA%8F%E6%95%B0\"\u003e亏数\u003c/a\u003e就是\u003ca href=\"https://zh.wikipedia.org/wiki/%E9%81%8E%E5%89%A9%E6%95%B8\"\u003e过剩数\u003c/a\u003e。\u003c/p\u003e","title":"完全数"},{"content":"使用密钥登陆相对于密码来说安全性要高很多\n我们知道ssh登录是用的rsa非对称加密的，所以我们在ssh登录的时候就可以使用rsa密钥登录，ssh有专门创建ssh密钥的工具ssh-keygen，下面就来一睹风采。\n首先进入linux系统的用户目录下的.ssh目录下，root用户是/root/.ssh，普通用户是/home/您的用户名/.ssh，我们以root用户为例：\ncd /root/.ssh 生成密钥 ssh-keygen -t rsa -b 4096 -c \u0026#34;youremain@gmail.com\u0026#34; 这里加了-b 参数，指定了长度，也可以不加-b参数\n-c 参数是注释\n执行密钥生成命令，基本上是一路回车既可以了，但是需要注意的是：执行命令的过程中是会提示呢输入密钥的密码的（如下图中红色箭头处，输入两次相同的，即是又一次确认密码），不需要密码直接回车就行。\n密钥生成后会在当前目录下多出两个文件，id_rsa和id_rsa.pub，其中id_rsa是私钥（敲黑板：这个很重要，不能外泄），id_rsa.pub这个是公钥，\n进入远程服务器需要ssh登录的用户的目录下，这里仍然用root用户，cd /root/.ssh，执行ls看看目录下是否有authorized_keys文件没有的话则执行以下命令创建：\n执行成功会创建空authorized_keys文件，授予600权限（注意：此处权限必须是600）：\nchmod 600 /root/.ssh/authorized_keys 如果已经有了authorized_keys文件，这直接执行以下的密钥追加工作。\n将上面生成的公钥id_rsa.pub追加到authorized_keys文件中：\ncat /root/.ssh/id_rsa.pub \u0026gt;\u0026gt; /root/.ssh/authorized_keys 密钥准备好了接下来就可以使用密钥登录了，\nssh -i ./id_rsa root@192.168.100.39 # or ssh root@192.168.100.39 -i ./id_rsa 注意：id_rsa是私钥，笔者这里是进入私钥的目录下操作的，如果没在私钥的目录下，请写全目录，比如/mnt/id_rsa，也可以是您自定义的目录。执行命令过程中，如果创建密钥对的时候设置了密码，则会提示您输入密码，没有的话会直接登录。\n禁用服务器密码登录 编辑/etc/ssh/sshd_config 将passwordauthentication参数值修改为no： passwordauthentication no 重启ssh服务：systemctl restart sshd.service 参数 ssh-keygen可用的参数选项有： -a trials 在使用 -t 对 dh-gex 候选素数进行安全筛选时需要执行的基本测试数量。 -b 显示指定的公钥/私钥文件的 bubblebabble 摘要。 -b bits 指定密钥长度。对于rsa密钥，最小要求768位，默认是2048位。dsa密钥必须恰好是1024位(fips 186-2 标准的要求)。 -c comment 提供一个新注释 -c 要求修改私钥和公钥文件中的注释。本选项只支持 rsa1 密钥。 程序将提示输入私钥文件名、密语(如果存在)、新注释。 -d reader 下载存储在智能卡 reader 里的 rsa 公钥。 -e 读取openssh的私钥或公钥文件，并以 rfc 4716 ssh 公钥文件格式在 stdout 上显示出来。 该选项能够为多种商业版本的 ssh 输出密钥。 -f hostname 在 known_hosts 文件中搜索指定的 hostname ，并列出所有的匹配项。 这个选项主要用于查找散列过的主机名/ip地址，还可以和 -h 选项联用打印找到的公钥的散列值。 -f filename 指定密钥文件名。 -g output_file 为 dh-gex 产生候选素数。这些素数必须在使用之前使用 -t 选项进行安全筛选。 -g 在使用 -r 打印指纹资源记录的时候使用通用的 dns 格式。 -h 对 known_hosts 文件进行散列计算。这将把文件中的所有主机名/ip地址替换为相应的散列值。 原来文件的内容将会添加一个\u0026#34;.old\u0026#34;后缀后保存。这些散列值只能被 ssh 和 sshd 使用。 这个选项不会修改已经经过散列的主机名/ip地址，因此可以在部分公钥已经散列过的文件上安全使用。 -i 读取未加密的ssh-2兼容的私钥/公钥文件，然后在 stdout 显示openssh兼容的私钥/公钥。 该选项主要用于从多种商业版本的ssh中导入密钥。 -l 显示公钥文件的指纹数据。它也支持 rsa1 的私钥。 对于rsa和dsa密钥，将会寻找对应的公钥文件，然后显示其指纹数据。 -m memory 指定在生成 dh-gexs 候选素数的时候最大内存用量(mb)。 -n new_passphrase 提供一个新的密语。 -p passphrase 提供(旧)密语。 -p 要求改变某私钥文件的密语而不重建私钥。程序将提示输入私钥文件名、原来的密语、以及两次输入新密语。 -q 安静模式。用于在 /etc/rc 中创建新密钥的时候。 -r hostname 从 known_hosts 文件中删除所有属于 hostname 的密钥。 这个选项主要用于删除经过散列的主机(参见 -h 选项)的密钥。 -r hostname 打印名为 hostname 的公钥文件的 sshfp 指纹资源记录。 -s start 指定在生成 dh-gex 候选模数时的起始点(16进制)。 -t output_file 测试 diffie-hellman group exchange 候选素数(由 -g 选项生成)的安全性。 -t type 指定要创建的密钥类型。可以使用：\u0026#34;rsa1\u0026#34;(ssh-1) \u0026#34;rsa\u0026#34;(ssh-2) \u0026#34;dsa\u0026#34;(ssh-2) -u reader 把现存的rsa私钥上传到智能卡 reader -v 详细模式。ssh-keygen 将会输出处理过程的详细调试信息。常用于调试模数的产生过程。 重复使用多个 -v 选项将会增加信息的详细程度(最大3次)。 -w generator 指定在为 dh-gex 测试候选模数时想要使用的 generator -y 读取openssh专有格式的公钥文件，并将openssh公钥显示在 stdout 上。 ssh-copy-id的参数有： -i #指定密钥文件 -p #指定端口，默认端口号是22 -o \u0026lt;ssh -o options\u0026gt; user@]hostname #用户名@主机名 -f: force mode -- copy keys without trying to check if they are already installed -n: dry run -- no keys are actually copied -h|-?: 显示帮助 ","date":"2019-04-15","permalink":"https://blog.akvicor.com/posts/ssh/disable_password_login/","summary":"\u003cp\u003e使用密钥登陆相对于密码来说安全性要高很多\u003c/p\u003e\n\u003cp\u003e我们知道SSH登录是用的RSA非对称加密的，所以我们在SSH登录的时候就可以使用RSA密钥登录，SSH有专门创建SSH密钥的工具ssh-keygen，下面就来一睹风采。\u003c/p\u003e","title":"使用密钥登陆并禁用密码登录"},{"content":"git 默认不区分文件名大小写\n当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.\n然后你在本地修改文件名为 readme.md 接着你去提交,发现代码没有变化.\ngit status 无任何提示信息.\n其实 git 默认对于文件名大小写是不敏感的,所以上面你修改了首字母大写,但是git 并没有发现代码任何改动.\n那么如何才能让 git 识别文件名大小写变化.\n好的约定其实比技术本身更重要，所以尽可能统一规范大小写，从而避免修改默认的配置。\n配置git使其对文件名大小写敏感 在git库文件夹中执行\ngit config core.ignorecase false git config --global core.ignorecase false // 全局设置 ","date":"2019-04-14","permalink":"https://blog.akvicor.com/posts/git/ignorecase/","summary":"\u003cp\u003egit 默认不区分文件名大小写\u003c/p\u003e\n\u003cp\u003e当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.\u003c/p\u003e\n\u003cp\u003e然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit status\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e无任何提示信息.\u003c/p\u003e\n\u003cp\u003e其实 git 默认对于文件名大小写是不敏感的,所以上面你修改了首字母大写,但是git 并没有发现代码任何改动.\u003c/p\u003e\n\u003cp\u003e那么如何才能让 git 识别文件名大小写变化.\u003c/p\u003e","title":"git 默认对大小写不敏感"},{"content":"修改主机名和计算机名 修改terminal终端、iterm前面的用户名字\n修改主机名（终端前面的名字）为akvicor：\nsudo scutil —set hostname akvicor 重启terminal\n修改计算机名称（设备名）\n打开偏好设置 打开共享 修改名字 ","date":"2019-04-14","permalink":"https://blog.akvicor.com/posts/mac/hostname/","summary":"\u003cp\u003e修改主机名和计算机名  修改terminal终端、iterm前面的用户名字\u003c/p\u003e","title":"修改主机名和计算机名"},{"content":"判断一个多边形的边界曲线是否是顺时针或者逆时针\ndouble d = 0; for (int i = 0; i \u0026lt; n - 1; i++) { d += -0.5 * ( y[i + 1] + y[i]) * (x[i + 1] - x[i]); } if ( d \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;counter clockwise\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;clockwise\u0026#34; \u0026lt;\u0026lt; endl; ","date":"2019-04-14","permalink":"https://blog.akvicor.com/posts/algorithm/green_determine_clockwise/","summary":"\u003cp\u003e判断一个多边形的边界曲线是否是顺时针或者逆时针\u003c/p\u003e","title":"green公式-判断多边形边界曲线顺/逆时针"},{"content":"在clion中使用万能头文件bits/stdc++.h\n大部分oj都支持bits.stdc++.h头文件，也就是说刷题的时候，不需要include那么多头文件，就#include \u0026lt;bits/stdc++.h\u0026gt;就能包括几乎所有刷题要用的头文件了。但是mac上的自带的gcc是不支持这个头文件的，所以就需要自行安装。\n然后找到最下面的三个include文件夹，打开中间的那个\n右键v1打开终端，也可以在finder中打开\n创建bits文件夹\nsudo mkdir bits\n创建stdc++.h头文件\nsudo vim stdc++.h\n按下按键a开启编辑模式，讲以下内容粘贴进去\n// c++ includes used for precompiling -*- c++ -*- // copyright (c) 2003-2014 free software foundation, inc. // // this file is part of the gnu iso c++ library. this library is free // software; you can redistribute it and/or modify it under the // terms of the gnu general public license as published by the // free software foundation; either version 3, or (at your option) // any later version. // this library is distributed in the hope that it will be useful, // but without any warranty; without even the implied warranty of // merchantability or fitness for a particular purpose. see the // gnu general public license for more details. // under section 7 of gpl version 3, you are granted additional // permissions described in the gcc runtime library exception, version // 3.1, as published by the free software foundation. // you should have received a copy of the gnu general public license and // a copy of the gcc runtime library exception along with this program; // see the files copying3 and copying.runtime respectively. if not, see // \u0026lt;http://www.gnu.org/licenses/\u0026gt;. /** @file stdc++.h * this is an implementation file for a precompiled header. */ // 17.4.1.2 headers // c #ifndef _glibcxx_no_assert #include \u0026lt;cassert\u0026gt; #endif #include \u0026lt;cctype\u0026gt; #include \u0026lt;cerrno\u0026gt; #include \u0026lt;cfloat\u0026gt; #include \u0026lt;ciso646\u0026gt; #include \u0026lt;climits\u0026gt; #include \u0026lt;clocale\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;csetjmp\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;ctime\u0026gt; #if __cplusplus \u0026gt;= 201103l #include \u0026lt;ccomplex\u0026gt; #include \u0026lt;cfenv\u0026gt; #include \u0026lt;cinttypes\u0026gt; #include \u0026lt;cstdbool\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;ctgmath\u0026gt; #include \u0026lt;cwchar\u0026gt; #include \u0026lt;cwctype\u0026gt; #endif // c++ #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;complex\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ios\u0026gt; #include \u0026lt;iosfwd\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;istream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;locale\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;new\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;ostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;streambuf\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;typeinfo\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;vector\u0026gt; #if __cplusplus \u0026gt;= 201103l #include \u0026lt;array\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;forward_list\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;initializer_list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;ratio\u0026gt; #include \u0026lt;regex\u0026gt; #include \u0026lt;scoped_allocator\u0026gt; #include \u0026lt;system_error\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;tuple\u0026gt; #include \u0026lt;typeindex\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;unordered_set\u0026gt; #endif 输入:wq保存并退出，此时就可以正常使用万能头文件了。\n","date":"2019-04-13","permalink":"https://blog.akvicor.com/posts/cpp/stdc++/","summary":"\u003cp\u003e在Clion中使用万能头文件bits/stdc++.h\u003c/p\u003e\n\u003cp\u003e大部分OJ都支持bits.stdc++.h头文件，也就是说刷题的时候，不需要include那么多头文件，就\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\u003c/code\u003e就能包括几乎所有刷题要用的头文件了。但是Mac上的自带的gcc是不支持这个头文件的，所以就需要自行安装。\u003c/p\u003e","title":"添加万能头文件stdc++.h"},{"content":"背包的状态转换方程 : $math_inline$f[i,j] = max\\lbrace f[i-1,j-w_i]+pi( j \u003e= w_i ), f[i-1,j] \\rbrace$math_inline$ $math_inline$f[i,j]$math_inline$ 表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。 pi表示第i件物品的价值。 决策：为了背包中物品总价值最大化，第 i件物品应该放入背包中吗 ？\n假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。\n有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？\nname weight value 1 2 3 4 5 6 7 8 9 10 a 2 6 0 6 6 9 9 12 12 15 15 15 b 2 3 0 3 3 6 6 9 9 9 10 11 c 6 5 0 0 0 6 6 6 6 6 10 11 d 5 4 0 0 0 6 6 6 6 6 10 10 e 4 6 0 0 0 6 6 6 6 6 6 6 首先要明确这张表是自底向上，从左到右生成的。\n只要你能通过找规律手工填写出上面这张表就算理解了01背包的动态规划算法。\n为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。\n对于d2单元格，表示只有物品e，d时,承重为2的背包，所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。\n同理，c2=0，b2=3，a2=6。\n对于承重为8的背包，a8=15,是怎么得出的呢？\n根据01背包的状态转换方程，需要考察两个值，\n一个是 $math_inline$f[i-1,j]$math_inline$ ，对于这个例子来说就是b8的值9，另一个是 $math_inline$f[i-1,j-wi]+pi$math_inline$ ；\n在这里，\n$math_inline$f[i-1,j]$math_inline$ 表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值\n$math_inline$f[i-1,j-wi]$math_inline$ 表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值\n$math_inline$f[i-1,j-wi]$math_inline$ 就是指单元格b6,值为9，pi指的是a物品的价值，即6\nvoid findmax(){ memset(v, 0, sizeof(v)); for(int i = 1; i \u0026lt;= number; ++i){ for(int j = 1; j \u0026lt;= capacity; ++j){ if(j\u0026lt;w[i]){ // 装不进去 v[i][j] = v[i-1][j]; }else{ // 能装 if(v[i-1][j] \u0026gt; v[i-1][j-w[i]]+v[i]){ // 不装价值大 v[i][j] = v[i-1][j]; }else{ // 前i-1个物品的最优解与第i个物品的价值之和更大 v[i][j] = v[i-1][j-w[i]]+v[i]; } } } } } ","date":"2019-04-05","permalink":"https://blog.akvicor.com/posts/algorithm/dynamic_programming/","summary":"\u003cp\u003e背包的状态转换方程 : \n\n    \n        $math_inline$f[i,j] = Max\\lbrace f[i-1,j-W_i]+Pi( j \u003e= W_i ),  f[i-1,j] \\rbrace$math_inline$\n    \n\n\u003c/p\u003e\n\u003cp\u003e\n\n    \n        $math_inline$f[i,j]$math_inline$\n    \n\n表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。\nPi表示第i件物品的价值。\n决策：为了背包中物品总价值最大化，第 i件物品应该放入背包中吗 ？\u003c/p\u003e","title":"动态规划"},{"content":"\npath 1 2 3 4 5 6 7 8 1 0 3 2 3 ∞ ∞ ∞ ∞ 2 3 0 ∞ ∞ 5 4 ∞ ∞ 3 2 ∞ 0 ∞ ∞ 4 6 ∞ 4 3 ∞ ∞ 0 4 ∞ 6 ∞ 5 ∞ 5 ∞ 4 0 2 2 ∞ 6 ∞ 4 4 ∞ 2 0 ∞ 3 7 ∞ ∞ 6 6 2 ∞ 0 3 8 ∞ ∞ ∞ ∞ ∞ 3 3 0 dis 1 2 3 4 5 6 7 8 估计值 0 3 2 3 ∞ ∞ ∞ ∞ path代表地图 例如path[i][j]代表从i到j的距离\ndis代表从起点到达i的距离，开始时初始化为最大，代表无穷远即未连同\nvis代表当前节点[i]是否访问过\n既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 3 号顶点。\n当选择了 3 号顶点后，dis[3]的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 3 号顶点的最短路程就是当前 dis[3]值。因为目前离 1 号顶点最近的是 3 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 3 号顶点的路程进一步缩短了。因为 1 号顶点到其它顶点的路程肯定没有 1 号到 3 号顶点短。\n既然选了 3 号顶点，接下来再来看 3 号顶点有哪些出边呢。有 3-\u0026gt;6 和 3-\u0026gt;7 这两条边。先讨论通过 3-\u0026gt;6 这条边是否能够让 1 号顶点到 6 号顶点的路程变短。也就是说比较dis[6]和dis[3]+path[3][6]的大小。其中 dis[3] 表示 1 号顶带你到 3 号顶点的路程。dis[3]+path[3][6]中dis[3]表示 1 号顶点到 3 号顶点的路程，path[3][6]表示 3-\u0026gt;6 这条边。所以 dis[3]+path[3][6]就表示从1号顶带你到3号顶点，再通过3-\u0026gt;6这条边到达3号顶点的路程\n我们发现 dis[6]=∞，dis[3]+path[3][6]=6，dis[6] \u0026gt; dis[3]+path[3][6]，因此dis[6]要更新为10。这个过程有个专业术语叫“松弛”。即 1 号顶点到 3 号顶点的路程即 dis[3] ，通过 3-\u0026gt;6 这条边松弛成功。这便是dijkstra算法的主要思想：通过“边”来松弛 1 号顶点到其余各个顶点的路程。\n算法的基本思想是：每次找到离源点（上面例子的源点就是 1 号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：\n将所有的顶点分为两部分：已知最短路程的顶点集合 p 和未知最短路径的顶点集合 q。最开始，已知最短路径的顶点集合 p 中只有源点一个顶点。我们这里用一个 vis[ i ]数组来记录哪些点在集合 p 中。例如对于某个顶点 i，如果 vis[ i ]为 1 则表示这个顶点在集合 p 中，如果 vis[ i ]为 0 则表示这个顶点在集合 q 中。 设置源点 s 到自己的最短路径为 0 即 dis=0。若存在源点有能直接到达的顶点 i，则把 dis[ i ]设为 path[s][ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为 ∞。 在集合 q 的所有顶点中选择一个离源点 s 最近的顶点 u（即 dis[u]最小）加入到集合 p。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v 的边，那么可以通过将边 u-\u0026gt;v 添加到尾部来拓展一条从 s 到 v 的路径，这条路径的长度是 dis[u]+path[u][v]。如果这个值比目前已知的 dis[v]的值要小，我们可以用新值来替代当前 dis[v]中的值。 重复第 3 步，如果集合 q 为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径。 in\n8 13 1 2 3 1 3 2 1 4 3 2 6 4 2 5 5 3 6 4 3 7 6 4 5 4 4 7 6 6 8 3 6 5 2 5 7 2 7 8 3 out\n1 to 2 min= 3 1 to 3 min= 2 1 to 4 min= 3 1 to 5 min= 7 1 to 6 min= 6 1 to 7 min= 8 1 to 8 min= 9 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;limits.h\u0026gt; using namespace std; const int inf = 0x3f3f3f3f; #define maxn 1000+100 int path[maxn][maxn], dis[maxn]; // 地图 起点到达i的距离 bool vis[maxn]; // 是否访问过 int n, t; // 地标数 路径数 void init() { for (int i = 0; i \u0026lt; maxn; ++i) { for (int j = 0; j \u0026lt; maxn; ++j) { path[i][j] = inf; } path[i][i] = 0; } } void dijkstra(){ // 将1到i的距离初始化 for (int i = 1; i \u0026lt;= n; i++) { dis[i] = path[1][i]; vis[i] = false; } vis[1] = true; // 标记起点为访问过的 dis[1] = 0; // 起点到起点的距离为0 for (int i = 2; i \u0026lt;= n; i++) { // 从2号节点遍历到n号节点 int now = -1, minl = inf; // 遍历一遍dis数组，寻找到未访问过的到1最短的路径长度 for (int j = 1; j \u0026lt;= n; j++) { // 从1到n if (!vis[j] \u0026amp;\u0026amp; minl \u0026gt; dis[j]) { // 如果没有访问过当前节点，并且当前从1到j的距离小于最大长度 now = j; // 更新最短路径的位置 minl = dis[j]; // 最短距离等于当前 } } if (now == -1) break; // 未找到 vis[now] = true; // 将now标记为访问过 // 从1开始寻找到j最短的路径 for (int j = 1; j \u0026lt;= n; j++) { // 没有访问过 并且当前已走的长度加上走到j节点的长度小于当前dis[j] if (!vis[j] \u0026amp;\u0026amp; (dis[now] + path[now][j]) \u0026lt; dis[j]) { dis[j] = dis[now] + path[now][j]; // 更新从起点到j的最短路径 } } } } int main() { freopen(\u0026#34;in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // 从指定文件输入数据 提交时注释掉 // memset(path, int_max, sizeof(path)); while (scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;t) != eof) { init(); for (int i = 0; i \u0026lt; t; i++) { int from, to, len; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;from, \u0026amp;to, \u0026amp;len); if (path[from][to] \u0026gt; len) path[from][to] = path[to][from] = len; } dijkstra(); for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;1 to %d min= %d\\n\u0026#34;, i, dis[i]); } } return 0; } ","date":"2019-04-03","permalink":"https://blog.akvicor.com/posts/algorithm/dijkstra/","summary":"\u003cp\u003e\u003cimg src=\"https://img.akvicor.com/i/2024/09/15/66e67546df179.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003epath\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e1\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e2\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e3\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e4\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e5\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e6\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e7\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e8\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e1\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e7\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e8\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003edis\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003cth\u003e7\u003c/th\u003e\n\u003cth\u003e8\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e估计值\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003epath\u003c/code\u003e代表地图 例如\u003ccode\u003epath[i][j]\u003c/code\u003e代表从\u003ccode\u003ei\u003c/code\u003e到\u003ccode\u003ej\u003c/code\u003e的距离\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edis\u003c/code\u003e代表从起点到达\u003ccode\u003ei\u003c/code\u003e的距离，开始时初始化为最大，代表无穷远即未连同\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evis\u003c/code\u003e代表当前节点\u003ccode\u003e[i]\u003c/code\u003e是否访问过\u003c/p\u003e","title":"dijkstra(迪杰斯特拉)算法 单源最短路径算法"},{"content":"并查集是一种树型的数据结构，用于处理一些**不交集（disjoint sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）**定义了两个用于此数据结构的操作：\nfind：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 union：将两个子集合并成同一个集合。 算法实现 变量 一个数组parent代表第i个元素所指向的父节点\n一个数组sz代表以i为根的集合中的元素个数 （用以优化算法，非必须）\nint* parent; // parent[i]表示第i个元素所指向的父节点 // 使用sz还是rank优化需要根据题目的要求进行选择 int* sz; // sz[i]表示以i为根的集合中元素个数 int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int count; // 数据个数 函数 初始化 循环对每个元素的parent和sz赋值，此时每个元素都以自己为根节点，且集合中元素个数均为1\nparent = new int[count]; sz = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; sz[i] = 1; } find函数 assert需要assert.h头文件，处理异常数据p\n// 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } union函数 寻找两个元素的根节点并将两个元素所在的集合合并\n基于sz的优化 // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( sz[proot] \u0026lt; sz[qroot] ){ parent[proot] = qroot; sz[qroot] += sz[proot]; } else{ parent[qroot] = proot; sz[proot] += sz[qroot]; } } 基于rank的优化 // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( rank[proot] \u0026lt; rank[qroot] ){ parent[proot] = qroot; }else if( rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; }else{ // rank[proot] == rank[qroot] parent[proot] = qroot; rank[qroot] += 1; // 此时, 我维护rank的值 } } isconnected函数 用于检测两个元素是否属于同一集合\n// 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } count函数 如hdu-1232需要检测一共有几个集合\nint count_sets(){ int count = 0; for(int i = 0; i \u0026lt; this-\u0026gt;count; i++){ if(find(i) == i) count++; } return count; } 完整算法 全部使用c++的类写的算法，使用方法如下\nint n; cin \u0026gt;\u0026gt; n; uf1::unionfind uf = uf1::unionfind(n); 也可以将其中的变量及函数放到min函数外面使用\n基于sz优化 #include \u0026lt;cassert\u0026gt; using namespace std; namespace uf1{ class unionfind{ private: int* parent; // parent[i]表示第i个元素所指向的父节点 int* sz; // sz[i]表示以i为根的集合中元素个数 int count; // 数据个数 public: // 构造函数 unionfind(int count){ parent = new int[count]; sz = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; sz[i] = 1; } } // 析构函数 ~unionfind(){ delete[] parent; delete[] sz; } // 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } // 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( sz[proot] \u0026lt; sz[qroot] ){ parent[proot] = qroot; sz[qroot] += sz[proot]; } else{ parent[qroot] = proot; sz[proot] += sz[qroot]; } } }; } 基于rank优化 #include \u0026lt;cassert\u0026gt; using namespace std; namespace uf2{ class unionfind{ private: int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int* parent; // parent[i]表示第i个元素所指向的父节点 int count; // 数据个数 public: // 构造函数 unionfind(int count){ parent = new int[count]; rank = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; rank[i] = 1; } } // 析构函数 ~unionfind(){ delete[] parent; delete[] rank; } // 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } // 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( rank[proot] \u0026lt; rank[qroot] ){ parent[proot] = qroot; } else if( rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; } else{ // rank[proot] == rank[qroot] parent[proot] = qroot; rank[qroot] += 1; // 此时, 我维护rank的值 } } }; } ","date":"2019-03-24","permalink":"https://blog.akvicor.com/posts/algorithm/union_find/","summary":"\u003cp\u003e\u003cstrong\u003e并查集\u003c/strong\u003e是一种树型的数据结构，用于处理一些**不交集（Disjoint Sets）\u003cstrong\u003e的合并及查询问题。有一个\u003c/strong\u003e联合-查找算法（union-find algorithm）**定义了两个用于此数据结构的操作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFind：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。\u003c/li\u003e\n\u003cli\u003eUnion：将两个子集合并成同一个集合。\u003c/li\u003e\n\u003c/ul\u003e","title":"并查集"},{"content":"统计一个字符串在另一个字符串中出现的次数，包含重叠和非重叠两种情况\n子串可重叠情况 int count_substring_in_string_overlapping(const std::string \u0026amp;str, const std::string \u0026amp;sub) { int num = 0; for (size_t i = 0; (i = str.find(sub, i)) != std::string::npos; num++, i++); return num; } 子串不可重叠情况 int count_substring_in_string_non_overlapping(const std::string \u0026amp;str, const std::string \u0026amp;sub) { int num = 0; size_t len = sub.length(); if (len == 0)len = 1; for (size_t i = 0; (i = str.find(sub, i)) != std::string::npos; num++, i += len); return num; } ","date":"2019-03-22","permalink":"https://blog.akvicor.com/posts/algorithm/count_substring/","summary":"\u003cp\u003e统计一个字符串在另一个字符串中出现的次数，包含重叠和非重叠两种情况\u003c/p\u003e","title":"统计字符串中子串数目"},{"content":"php 手册\n变量 global关键字 global关键字用于在函数内部访问一个全局变量\n\u0026lt;?php $x = 5; $y = 10; function mytest() { global $x, $y; $y = $x + $y; } mytest(); echo $y; // outputs 15 ?\u0026gt; php还将所有的全局变量出存在一个名为globals的全局数组中\n\u0026lt;?php $x = 5; $y = 10; function mytest() { $globals[\u0026#39;y\u0026#39;] = $globals[\u0026#39;x\u0026#39;] + $globals[\u0026#39;y\u0026#39;]; } mytest(); echo $y; // outputs 15 ?\u0026gt; static关键字 通常情况下当函数执行后局部变量将被删除。但有时我们需要保留它的值。\n\u0026lt;?php function mytest() { static $x = 0; echo $x; $x++; } mytest(); // 0 mytest(); // 1 mytest(); // 2 ?\u0026gt; 整数 数据范围在 -2,147,483,648 and 2,147,483,647\n整数可以用三种格式来制定：十进制（10型），十六进制（前缀0x），八进制（前缀0）\n# the php var_dump() function returns the data type and value: $n = 99; var_dump($n); echo $n.\u0026#34;\\n\u0026#34;; $n = 077; var_dump($n); echo $n.\u0026#34;\\n\u0026#34;; $n = 0xff; var_dump($n); echo $n.\u0026#34;\\n\u0026#34;; $x = 10.365; var_dump($x); int(99) 99 int(63) 63 int(255) 255 float(10.365) array $cars = array(\u0026#34;volvo\u0026#34;,\u0026#34;bmw\u0026#34;,\u0026#34;toyota\u0026#34;); var_dump($cars); array(3) { [0]=\u0026gt; string(5) \u0026#34;volvo\u0026#34; [1]=\u0026gt; string(3) \u0026#34;bmw\u0026#34; [2]=\u0026gt; string(6) \u0026#34;toyota\u0026#34; } the count() function is used to return the length (the number of elements) of an array:\n$cars = array(\u0026#34;volvo\u0026#34;, \u0026#34;bmw\u0026#34;, \u0026#34;toyota\u0026#34;); echo count($cars); # 3 indexed arrays $cars = array(\u0026#34;volvo\u0026#34;, \u0026#34;bmw\u0026#34;, \u0026#34;toyota\u0026#34;); foreach ($colors as $value) { echo \u0026#34;$value \u0026lt;br\u0026gt;\u0026#34;; } associative arrays $age = array(\u0026#34;peter\u0026#34;=\u0026gt;\u0026#34;35\u0026#34;, \u0026#34;ben\u0026#34;=\u0026gt;\u0026#34;37\u0026#34;, \u0026#34;joe\u0026#34;=\u0026gt;\u0026#34;43\u0026#34;); foreach($age as $x =\u0026gt; $x_value) { echo \u0026#34;key=\u0026#34; . $x . \u0026#34;, value=\u0026#34; . $x_value; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } sorting arrays sort() - sort arrays in ascending order rsort() - sort arrays in descending order asort() - sort associative arrays in ascending order, according to the value ksort() - sort associative arrays in ascending order, according to the key arsort() - sort associative arrays in descending order, according to the value krsort() - sort associative arrays in descending order, according to the key $cars = array(\u0026#34;volvo\u0026#34;, \u0026#34;bmw\u0026#34;, \u0026#34;toyota\u0026#34;); sort($cars); $numbers = array(4, 6, 2, 22, 11); sort($numbers); $cars = array(\u0026#34;volvo\u0026#34;, \u0026#34;bmw\u0026#34;, \u0026#34;toyota\u0026#34;); rsort($cars); $numbers = array(4, 6, 2, 22, 11); rsort($numbers); $age = array(\u0026#34;peter\u0026#34;=\u0026gt;\u0026#34;35\u0026#34;, \u0026#34;ben\u0026#34;=\u0026gt;\u0026#34;37\u0026#34;, \u0026#34;joe\u0026#34;=\u0026gt;\u0026#34;43\u0026#34;); asort($age); $age = array(\u0026#34;peter\u0026#34;=\u0026gt;\u0026#34;35\u0026#34;, \u0026#34;ben\u0026#34;=\u0026gt;\u0026#34;37\u0026#34;, \u0026#34;joe\u0026#34;=\u0026gt;\u0026#34;43\u0026#34;); ksort($age); $age = array(\u0026#34;peter\u0026#34;=\u0026gt;\u0026#34;35\u0026#34;, \u0026#34;ben\u0026#34;=\u0026gt;\u0026#34;37\u0026#34;, \u0026#34;joe\u0026#34;=\u0026gt;\u0026#34;43\u0026#34;); arsort($age); $age = array(\u0026#34;peter\u0026#34;=\u0026gt;\u0026#34;35\u0026#34;, \u0026#34;ben\u0026#34;=\u0026gt;\u0026#34;37\u0026#34;, \u0026#34;joe\u0026#34;=\u0026gt;\u0026#34;43\u0026#34;); krsort($age); object \u0026lt;?php class car { // function car() { // old style function __construct() { // new style $this-\u0026gt;model = \u0026#34;vw\u0026#34;; } } // create an object $herbie = new car(); // show object properties echo $herbie-\u0026gt;model; null value # null is a special data type which can have only one value: null. # tip: if a variable is created without a value, it is automatically assigned a value of null. # variables can also be emptied by setting the value to null: $x = \u0026#34;hello world!\u0026#34;; $x = null; var_dump($x); # null string # the php strlen() function returns the length of a string. echo strlen(\u0026#34;hello world!\u0026#34;); // outputs 12 # the php str_word_count() function counts the number of words in a string: echo str_word_count(\u0026#34;hello world!\u0026#34;); // outputs 2 # the php strrev() function reverses a string: echo strrev(\u0026#34;hello world!\u0026#34;); // outputs !dlrow olleh # the php strpos() function searches for a specific text within a string. echo strpos(\u0026#34;hello world!\u0026#34;, \u0026#34;world\u0026#34;); // outputs 6 # the php str_replace() function replaces some characters with some other characters in a string. echo str_replace(\u0026#34;world\u0026#34;, \u0026#34;dolly\u0026#34;, \u0026#34;hello world!\u0026#34;); // outputs hello dolly! global variables - superglobals several predefined variables in php are \u0026ldquo;superglobals\u0026rdquo;, which means that they are always accessible, regardless of scope - and you can access them from any function, class or file without having to do anything special.\nthe php superglobal variables are:\n$globals $_server $_request $_post $_get $_files $_env $_cookie $_session $globals $globals is a php super global variable which is used to access global variables from anywhere in the php script (also from within functions or methods).\nphp stores all global variables in an array called $globals[index]. the index holds the name of the variable.\n$x = 75; $y = 25; function addition() { $globals[\u0026#39;z\u0026#39;] = $globals[\u0026#39;x\u0026#39;] + $globals[\u0026#39;y\u0026#39;]; } addition(); echo $z; $_server $_server is a php super global variable which holds information about headers, paths, and script locations.\necho $_server[\u0026#39;php_self\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $_server[\u0026#39;server_name\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $_server[\u0026#39;http_host\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $_server[\u0026#39;http_referer\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $_server[\u0026#39;http_user_agent\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $_server[\u0026#39;script_name\u0026#39;]; element/code description $_server[\u0026lsquo;php_self\u0026rsquo;] returns the filename of the currently executing script $_server[\u0026lsquo;gateway_interface\u0026rsquo;] returns the version of the common gateway interface (cgi) the server is using $_server[\u0026lsquo;server_addr\u0026rsquo;] returns the ip address of the host server $_server[\u0026lsquo;server_name\u0026rsquo;] returns the name of the host server (such as www.kvxi.org) $_server[\u0026lsquo;server_software\u0026rsquo;] returns the server identification string (such as apache/2.2.24) $_server[\u0026lsquo;server_protocol\u0026rsquo;] returns the name and revision of the information protocol (such as http/1.1) $_server[\u0026lsquo;request_method\u0026rsquo;] returns the request method used to access the page (such as post) $_server[\u0026lsquo;request_time\u0026rsquo;] returns the timestamp of the start of the request (such as 1377687496) $_server[\u0026lsquo;query_string\u0026rsquo;] returns the query string if the page is accessed via a query string $_server[\u0026lsquo;http_accept\u0026rsquo;] returns the accept header from the current request $_server[\u0026lsquo;http_accept_charset\u0026rsquo;] returns the accept_charset header from the current request (such as utf-8,iso-8859-1) $_server[\u0026lsquo;http_host\u0026rsquo;] returns the host header from the current request $_server[\u0026lsquo;http_referer\u0026rsquo;] returns the complete url of the current page (not reliable because not all user-agents support it) $_server[\u0026lsquo;https\u0026rsquo;] is the script queried through a secure http protocol $_server[\u0026lsquo;remote_addr\u0026rsquo;] returns the ip address from where the user is viewing the current page $_server[\u0026lsquo;remote_host\u0026rsquo;] returns the host name from where the user is viewing the current page $_server[\u0026lsquo;remote_port\u0026rsquo;] returns the port being used on the user\u0026rsquo;s machine to communicate with the web server $_server[\u0026lsquo;script_filename\u0026rsquo;] returns the absolute pathname of the currently executing script $_server[\u0026lsquo;server_admin\u0026rsquo;] returns the value given to the server_admin directive in the web server configuration file (if your script runs on a virtual host, it will be the value defined for that virtual host) (such as someone@kvxi.org) $_server[\u0026lsquo;server_port\u0026rsquo;] returns the port on the server machine being used by the web server for communication (such as 80) $_server[\u0026lsquo;server_signature\u0026rsquo;] returns the server version and virtual host name which are added to server-generated pages $_server[\u0026lsquo;path_translated\u0026rsquo;] returns the file system based path to the current script $_server[\u0026lsquo;script_name\u0026rsquo;] returns the path of the current script $_server[\u0026lsquo;script_uri\u0026rsquo;] returns the uri of the current page $_request php $_request is used to collect data after submitting an html form.\nthe example below shows a form with an input field and a submit button. when a user submits the data by clicking on \u0026ldquo;submit\u0026rdquo;, the form data is sent to the file specified in the action attribute of the \u0026lt;form\u0026amp;gt tag. in this example, we point to this file itself for processing form data. if you wish to use another php file to process form data, replace that with the filename of your choice. then, we can use the super global variable $_request to collect the value of the input field:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;\u0026lt;?php echo $_server[\u0026#39;php_self\u0026#39;];?\u0026gt;\u0026#34;\u0026gt; name: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;fname\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;?php if ($_server[\u0026#34;request_method\u0026#34;] == \u0026#34;post\u0026#34;) { // collect value of input field $name = $_request[\u0026#39;fname\u0026#39;]; if (empty($name)) { echo \u0026#34;name is empty\u0026#34;; } else { echo $name; } } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $_post php $_post is widely used to collect form data after submitting an html form with method=\u0026ldquo;post\u0026rdquo;. $_post is also widely used to pass variables.\nthe example below shows a form with an input field and a submit button. when a user submits the data by clicking on \u0026ldquo;submit\u0026rdquo;, the form data is sent to the file specified in the action attribute of the \u0026lt;form\u0026gt; tag. in this example, we point to the file itself for processing form data. if you wish to use another php file to process form data, replace that with the filename of your choice. then, we can use the super global variable $_post to collect the value of the input field:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;\u0026lt;?php echo $_server[\u0026#39;php_self\u0026#39;];?\u0026gt;\u0026#34;\u0026gt; name: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;fname\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;?php if ($_server[\u0026#34;request_method\u0026#34;] == \u0026#34;post\u0026#34;) { // collect value of input field $name = $_post[\u0026#39;fname\u0026#39;]; if (empty($name)) { echo \u0026#34;name is empty\u0026#34;; } else { echo $name; } } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $_get php $_get can also be used to collect form data after submitting an html form with method=\u0026ldquo;get\u0026rdquo;.\n$_get can also collect data sent in the url.\nassume we have an html page that contains a hyperlink with parameters:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;test_get.php?subject=php\u0026amp;web=w3schools.com\u0026#34;\u0026gt;test $get\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; when a user clicks on the link \u0026ldquo;test $get\u0026rdquo;, the parameters \u0026ldquo;subject\u0026rdquo; and \u0026ldquo;web\u0026rdquo; are sent to \u0026ldquo;test_get.php\u0026rdquo;, and you can then access their values in \u0026ldquo;test_get.php\u0026rdquo; with $_get.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php echo \u0026#34;study \u0026#34; . $_get[\u0026#39;subject\u0026#39;] . \u0026#34; at \u0026#34; . $_get[\u0026#39;web\u0026#39;]; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; constants to create a constant, use the define() function.\ndefine(name, value, case-insensitive) parameters:\nname: specifies the name of the constant value: specifies the value of the constant case-insensitive: specifies whether the constant name should be case-insensitive. default is false # the example below creates a constant with a case-sensitive name: define(\u0026#34;greeting\u0026#34;, \u0026#34;welcome to kvxi.org!\u0026#34;); echo greeting; # welcome to kvxi.org! # the example below creates a constant with a case-insensitive name: define(\u0026#34;greeting\u0026#34;, \u0026#34;welcome to kvxi.org!\u0026#34;, true); echo greeting; # welcome to kvxi.org! constant arrays in php7, you can create a array constant using the define() function.\ndefine(\u0026#34;cars\u0026#34;, [ \u0026#34;alfa romeo\u0026#34;, \u0026#34;bmw\u0026#34;, \u0026#34;toyota\u0026#34; ]); echo cars[0]; constants are global constants are automatically global and can be used across the entire script.\nthe example below uses a constant inside a function, even if it is defined outside the function:\ndefine(\u0026#34;greeting\u0026#34;, \u0026#34;welcome to kvxi.org!\u0026#34;); function mytest() { echo greeting; } mytest(); # welcome to kvxi.org! operators arithmetic operators the php arithmetic operators are used with numeric values to perform common arithmetical operations, such as addition, subtraction, multiplication etc.\noperator name example result + addition $x + $y sum of $x and $y - subtraction $x - $y difference of $x and $y * multiplication $x * $y product of $x and $y / division $x / $y quotient of $x and $y % modulus $x % $y remainder of $x divided by $y ** exponentiation $x ** $y result of raising $x to the $y\u0026rsquo;th power assignment operators the php assignment operators are used with numeric values to write a value to a variable.\nthe basic assignment operator in php is \u0026ldquo;=\u0026rdquo;. it means that the left operand gets set to the value of the assignment expression on the right.\nassignment same as\u0026hellip; description x = y x = y the left operand gets set to the value of the expression on the right x += y x = x + y addition x -= y x = x - y subtraction x *= y x = x * y multiplication x /= y x = x / y division x %= y x = x % y modulus comparison operators the php comparison operators are used to compare two values (number or string):\noperator name example result == equal $x == $y returns true if $x is equal to $y === identical $x === $y returns true if $x is equal to $y, and they are of the same type != not equal $x != $y returns true if $x is not equal to $y \u0026lt;\u0026gt; not equal $x \u0026lt;\u0026gt; $y returns true if $x is not equal to $y !== not identical $x !== $y returns true if $x is not equal to $y, or they are not of the same type \u0026gt; greater than $x \u0026gt; $y returns true if $x is greater than $y \u0026lt; less than $x \u0026lt; $y returns true if $x is less than $y \u0026gt;= greater than or equal to $x \u0026gt;= $y returns true if $x is greater than or equal to $y \u0026lt;= less than or equal to $x \u0026lt;= $y returns true if $x is less than or equal to $y \u0026lt;=\u0026gt; spaceship $x \u0026lt;=\u0026gt; $y returns an integer less than, equal to, or greater than zero, depending on if $x is less than, equal to, or greater than $y. introduced in php 7. increment / decrement operators the php increment operators are used to increment a variable\u0026rsquo;s value.\nthe php decrement operators are used to decrement a variable\u0026rsquo;s value.\noperator name description ++$x pre-increment increments $x by one, then returns $x $x++ post-increment returns $x, then increments $x by one \u0026ndash;$x pre-decrement decrements $x by one, then returns $x $x\u0026ndash; post-decrement returns $x, then decrements $x by one logical operators the php logical operators are used to combine conditional statements.\noperator name example result and and $x and $y true if both $x and $y are true or or $x or $y true if either $x or $y is true xor xor $x xor $y true if either $x or $y is true, but not both \u0026amp;\u0026amp; and $x \u0026amp;\u0026amp; $y true if both $x and $y are true || or $x || $y true if either $x or $y is true ! not !$x true if $x is not true string operators php has two operators that are specially designed for strings.\noperator name example result . concatenation $txt1 . $txt2 concatenation of $txt1 and $txt2 .= concatenation assignment $txt1 .= $txt2 appends $txt2 to $txt1 array operators the php array operators are used to compare arrays.\noperator name example result + union $x + $y union of $x and $y == equality $x == $y returns true if $x and $y have the same key/value pairs === identity $x === $y returns true if $x and $y have the same key/value pairs in the same order and of the same types != inequality $x != $y returns true if $x is not equal to $y \u0026lt;\u0026gt; inequality $x \u0026lt;\u0026gt; $y returns true if $x is not equal to $y !== non-identity $x !== $y returns true if $x is not identical to $y conditional assignment operators the php conditional assignment operators are used to set a value depending on conditions:\noperator name example result ?: ternary $x = expr1 ? expr2 : expr3 returns the value of $x. the value of $x is expr2 if expr1 = true. the value of $x is expr3 if expr1 = false ?? null coalescing $x = expr1 ?? expr2 returns the value of $x. the value of $x is expr1 if expr1 exists, and is not null. if expr1 does not exist, or is null, the value of $x is expr2. introduced in php 7 forms validate name $name = test_input($_post[\u0026#34;name\u0026#34;]); if (!preg_match(\u0026#34;/^[a-za-z ]*$/\u0026#34;,$name)) { $nameerr = \u0026#34;only letters and white space allowed\u0026#34;; } validate e-mail $email = test_input($_post[\u0026#34;email\u0026#34;]); if (!filter_var($email, filter_validate_email)) { $emailerr = \u0026#34;invalid email format\u0026#34;; } validate url $website = test_input($_post[\u0026#34;website\u0026#34;]); if (!preg_match(\u0026#34;/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+\u0026amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+\u0026amp;@#\\/%=~_|]/i\u0026#34;,$website)) { $websiteerr = \u0026#34;invalid url\u0026#34;; } validate name, e-mail, and url \u0026lt;?php // define variables and set to empty values $nameerr = $emailerr = $gendererr = $websiteerr = \u0026#34;\u0026#34;; $name = $email = $gender = $comment = $website = \u0026#34;\u0026#34;; function test_input($data) { $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data; } if ($_server[\u0026#34;request_method\u0026#34;] == \u0026#34;post\u0026#34;) { if (empty($_post[\u0026#34;name\u0026#34;])) { $nameerr = \u0026#34;name is required\u0026#34;; } else { $name = test_input($_post[\u0026#34;name\u0026#34;]); // check if name only contains letters and whitespace if (!preg_match(\u0026#34;/^[a-za-z ]*$/\u0026#34;,$name)) { $nameerr = \u0026#34;only letters and white space allowed\u0026#34;; } } if (empty($_post[\u0026#34;email\u0026#34;])) { $emailerr = \u0026#34;email is required\u0026#34;; } else { $email = test_input($_post[\u0026#34;email\u0026#34;]); // check if e-mail address is well-formed if (!filter_var($email, filter_validate_email)) { $emailerr = \u0026#34;invalid email format\u0026#34;; } } if (empty($_post[\u0026#34;website\u0026#34;])) { $website = \u0026#34;\u0026#34;; } else { $website = test_input($_post[\u0026#34;website\u0026#34;]); // check if url address syntax is valid (this regular expression also allows dashes in the url) if (!preg_match(\u0026#34;/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+\u0026amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+\u0026amp;@#\\/%=~_|]/i\u0026#34;,$website)) { $websiteerr = \u0026#34;invalid url\u0026#34;; } } if (empty($_post[\u0026#34;comment\u0026#34;])) { $comment = \u0026#34;\u0026#34;; } else { $comment = test_input($_post[\u0026#34;comment\u0026#34;]); } if (empty($_post[\u0026#34;gender\u0026#34;])) { $gendererr = \u0026#34;gender is required\u0026#34;; } else { $gender = test_input($_post[\u0026#34;gender\u0026#34;]); } } ?\u0026gt; final name: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; value=\u0026#34;\u0026lt;?php echo $name;?\u0026gt;\u0026#34;\u0026gt; e-mail: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34; value=\u0026#34;\u0026lt;?php echo $email;?\u0026gt;\u0026#34;\u0026gt; website: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;website\u0026#34; value=\u0026#34;\u0026lt;?php echo $website;?\u0026gt;\u0026#34;\u0026gt; comment: \u0026lt;textarea name=\u0026#34;comment\u0026#34; rows=\u0026#34;5\u0026#34; cols=\u0026#34;40\u0026#34;\u0026gt;\u0026lt;?php echo $comment;?\u0026gt;\u0026lt;/textarea\u0026gt; gender: \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; \u0026lt;?php if (isset($gender) \u0026amp;\u0026amp; $gender==\u0026#34;female\u0026#34;) echo \u0026#34;checked\u0026#34;;?\u0026gt; value=\u0026#34;female\u0026#34;\u0026gt;female \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; \u0026lt;?php if (isset($gender) \u0026amp;\u0026amp; $gender==\u0026#34;male\u0026#34;) echo \u0026#34;checked\u0026#34;;?\u0026gt; value=\u0026#34;male\u0026#34;\u0026gt;male \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; \u0026lt;?php if (isset($gender) \u0026amp;\u0026amp; $gender==\u0026#34;other\u0026#34;) echo \u0026#34;checked\u0026#34;;?\u0026gt; value=\u0026#34;other\u0026#34;\u0026gt;other advanced date and time the php date() function formats a timestamp to a more readable date and time.\nsyntax date(format,timestamp) parameter description format required. specifies the format of the timestamp timestamp optional. specifies a timestamp. default is the current date and time 参数 描述 format 必需。规定时间戳的格式。 timestamp 可选。规定时间戳。默认是当前时间和日期。 时间戳 时间戳是一种字符序列，它表示具体事件发生的日期和事件。\na - \u0026#34;am\u0026#34; 或是 \u0026#34;pm\u0026#34; a - \u0026#34;am\u0026#34; 或是 \u0026#34;pm\u0026#34; d - 几日，二位数字，若不足二位则前面补零; 如: \u0026#34;01\u0026#34; 至 \u0026#34;31\u0026#34; d - 星期几，三个英文字母; 如: \u0026#34;fri\u0026#34; f - 月份，英文全名; 如: \u0026#34;january\u0026#34; h - 12 小时制的小时; 如: \u0026#34;01\u0026#34; 至 \u0026#34;12\u0026#34; h - 24 小时制的小时; 如: \u0026#34;00\u0026#34; 至 \u0026#34;23\u0026#34; g - 12 小时制的小时，不足二位不补零; 如: \u0026#34;1\u0026#34; 至 12\u0026#34; g - 24 小时制的小时，不足二位不补零; 如: \u0026#34;0\u0026#34; 至 \u0026#34;23\u0026#34; i - 分钟; 如: \u0026#34;00\u0026#34; 至 \u0026#34;59\u0026#34; j - 几日，二位数字，若不足二位不补零; 如: \u0026#34;1\u0026#34; 至 \u0026#34;31\u0026#34; l - 星期几，英文全名; 如: \u0026#34;friday\u0026#34; m - 月份，二位数字，若不足二位则在前面补零; 如: \u0026#34;01\u0026#34; 至 \u0026#34;12\u0026#34; n - 月份，二位数字，若不足二位则不补零; 如: \u0026#34;1\u0026#34; 至 \u0026#34;12\u0026#34; m - 月份，三个英文字母; 如: \u0026#34;jan\u0026#34; s - 秒; 如: \u0026#34;00\u0026#34; 至 \u0026#34;59\u0026#34; s - 字尾加英文序数，二个英文字母; 如: \u0026#34;th\u0026#34;，\u0026#34;nd\u0026#34; t - 指定月份的天数; 如: \u0026#34;28\u0026#34; 至 \u0026#34;31\u0026#34; u - 总秒数 w - 数字型的星期几，如: \u0026#34;0\u0026#34; (星期日) 至 \u0026#34;6\u0026#34; (星期六) y - 年，四位数字; 如: \u0026#34;1999\u0026#34; y - 年，二位数字; 如: \u0026#34;99\u0026#34; z - 一年中的第几天; 如: \u0026#34;0\u0026#34; 至 \u0026#34;365\u0026#34; time()用法举例： time();输出结果：1332427715（返回的结果即当前的时间戳） strtotime($time)用法举例： echo strtotime(\u0026#39;2012-03-22\u0026#39;);输出结果：1332427715（此处结果为随便写的，仅作说明使用） echo strtotime(date(\u0026#39;y-d-m\u0026#39;));输出结果：（结合date()，结果同上）（时间日期转换为时间戳） strtotime()还有个很强大的用法，参数可加入对于数字的操作、年月日周英文字符，示例如下： echo date(\u0026#39;y-m-d h:i:s\u0026#39;,strtotime(\u0026#39;+1 day\u0026#39;));输出结果：2012-03-23 23:30:33（会发现输出明天此时的时间） echo date(\u0026#39;y-m-d h:i:s\u0026#39;,strtotime(\u0026#39;-1 day\u0026#39;));输出结果：2012-03-21 23:30:33（昨天此时的时间） echo date(\u0026#39;y-m-d h:i:s\u0026#39;,strtotime(\u0026#39;+1 week\u0026#39;));输出结果：2012-03-29 23:30:33（下个星期此时的时间） echo date(\u0026#39;y-m-d h:i:s\u0026#39;,strtotime(\u0026#39;next thursday\u0026#39;));输出结果：2012-03-29 00:00:00（下个星期四此时的时间） echo date(\u0026#39;y-m-d h:i:s\u0026#39;,strtotime(\u0026#39;last thursday\u0026#39;));输出结果：2012-03-15 00:00:00（上个星期四此时的时间） 获得时区 如果从代码返回的不是正确的时间，有可能是因为您的服务器位于其他国家或者被设置为不同时区。\n因此，如果您需要基于具体位置的准确时间，您可以设置要用的时区。\n下面的例子把时区设置为 \u0026ldquo;asia/shanghai\u0026rdquo;，然后以指定格式输出当前时间：\n\u0026lt;?php // date_default_timezone_set(\u0026#34;america/new_york\u0026#34;); date_default_timezone_set(\u0026#34;asia/shanghai\u0026#34;); echo \u0026#34;当前时间是 \u0026#34; . date(\u0026#34;h:i:sa\u0026#34;); ?\u0026gt; 通过 php mktime() 创建日期 date() 函数中可选的时间戳参数规定时间戳。如果您未规定时间戳，将使用当前日期和时间（正如上例中那样）。\nmktime() 函数返回日期的 unix 时间戳。unix 时间戳包含 unix 纪元（1970 年 1 月 1 日 00:00:00 gmt）与指定时间之间的秒数。\nmktime(hour,minute,second,month,day,year) 下面的例子使用 mktime() 函数中的一系列参数来创建日期和时间：\n\u0026lt;?php $d=mktime(9, 12, 31, 6, 10, 2015); echo \u0026#34;创建日期是 \u0026#34; . date(\u0026#34;y-m-d h:i:sa\u0026#34;, $d); ?\u0026gt; 通过 php strtotime() 用字符串来创建日期 php strtotime() 函数用于把人类可读的字符串转换为 unix 时间。\nstrtotime(time,now) \u0026lt;?php $d=strtotime(\u0026#34;10:38pm april 15 2015\u0026#34;); echo \u0026#34;创建日期是 \u0026#34; . date(\u0026#34;y-m-d h:i:sa\u0026#34;, $d); ?\u0026gt; more date examples \u0026lt;?php // the example below outputs the dates for the next six saturdays: $startdate = strtotime(\u0026#34;saturday\u0026#34;); $enddate = strtotime(\u0026#34;+6 weeks\u0026#34;, $startdate); while ($startdate \u0026lt; $enddate) { echo date(\u0026#34;m d\u0026#34;, $startdate) . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; $startdate = strtotime(\u0026#34;+1 week\u0026#34;, $startdate); } // the example below outputs the number of days until 4th of july: $d1=strtotime(\u0026#34;july 04\u0026#34;); $d2=ceil(($d1-time())/60/60/24); echo \u0026#34;there are \u0026#34; . $d2 .\u0026#34; days until 4th of july.\u0026#34;; runtime 配置 date/time 函数的行为受到 php.ini 中设置的影响：\n名称 描述 默认 php 版本 date.timezone 默认时区（所有的 date/time 函数使用该选项） \u0026quot;\u0026quot; php 5.1 date.default_latitude 默认纬度（date_sunrise() 和 date_sunset() 使用该选项） \u0026ldquo;31.7667\u0026rdquo; php 5.0 date.default_longitude 默认经度（date_sunrise() 和 date_sunset() 使用该选项） \u0026ldquo;35.2333\u0026rdquo; php 5.0 date.sunrise_zenith 默认日出天顶（date_sunrise() 和 date_sunset() 使用该选项） \u0026ldquo;90.83\u0026rdquo; php 5.0 date.sunset_zenith 默认日落天顶（date_sunrise() 和 date_sunset() 使用该选项） \u0026ldquo;90.83\u0026rdquo; php 5.0 php 5 date/time 函数 函数 描述 checkdate() 验证格利高里日期。 date_add() 添加日、月、年、时、分和秒到日期。 date_create_from_format() 返回根据指定格式进行格式化的新的 datetime 对象。 date_create() 返回新的 datetime 对象。 date_date_set() 设置新日期。 date_default_timezone_get() 返回由所有的 date/time 函数使用的默认时区。 date_default_timezone_set() 设置由所有的 date/time 函数使用的默认时区。 date_diff() 返回两个日期间的差值。 date_format() 返回根据指定格式进行格式化的日期。 date_get_last_errors() 返回日期字符串中的警告/错误。 date_interval_create_from_date_string() 从字符串的相关部分建立 dateinterval。 date_interval_format() 格式化时间间隔。 date_isodate_set() 设置 iso 日期。 date_modify() 修改时间戳。 date_offset_get() 返回时区偏移。 date_parse_from_format() 根据指定的格式返回带有关于指定日期的详细信息的关联数组。 date_parse() 返回带有关于指定日期的详细信息的关联数组。 date_sub() 从指定日期减去日、月、年、时、分和秒。 date_sun_info() 返回包含有关指定日期与地点的日出/日落和黄昏开始/黄昏结束的信息的数组。 date_sunrise() 返回指定日期与位置的日出时间。 date_sunset() 返回指定日期与位置的日落时间。 date_time_set() 设置时间。 date_timestamp_get() 返回 unix 时间戳。 date_timestamp_set() 设置基于 unix 时间戳的日期和时间。 date_timezone_get() 返回给定 datetime 对象的时区。 date_timezone_set() 设置 datetime 对象的时区。 date() 格式化本地日期和时间。 getdate() 返回某个时间戳或者当前本地的日期/时间的日期/时间信息。 gettimeofday() 返回当前时间。 gmdate() 格式化 gmt/utc 日期和时间。 gmmktime() 返回 gmt 日期的 unix 时间戳。 gmstrftime() 根据区域设置对 gmt/utc 日期和时间进行格式化。 idate() 将本地时间/日期格式化为整数。 localtime() 返回本地时间。 microtime() 返回当前时间的微秒数。 mktime() 返回日期的 unix 时间戳。 strftime() 根据区域设置对本地时间/日期进行格式化。 strptime() 解析由 strftime() 生成的时间/日期。 strtotime() 将任何英文文本的日期或时间描述解析为 unix 时间戳。 time() 返回当前时间的 unix 时间戳。 timezone_abbreviations_list() 返回包含夏令时、偏移量和时区名称的关联数组。 timezone_identifiers_list() 返回带有所有时区标识符的索引数组。 timezone_location_get() 返回指定时区的位置信息。 timezone_name_from_abbr() 根据时区缩略语返回时区名称。 timezone_name_get() 返回时区的名称。 timezone_offset_get() 返回相对于 gmt 的时区偏移。 timezone_open() 创建新的 datetimezone 对象。 timezone_transitions_get() 返回时区的所有转换。 timezone_version_get() 返回时区数据库的版本。 php 5 预定义的 date/time 常量 常量 描述 date_atom atom （例如：2005-08-15t16:13:03+0000） date_cookie http cookies （例如：sun, 14 aug 2005 16:13:03 utc） date_iso8601 iso-8601 （例如：2005-08-14t16:13:03+0000） date_rfc822 rfc 822 （例如：sun, 14 aug 2005 16:13:03 utc） date_rfc850 rfc 850 （例如：sunday, 14-aug-05 16:13:03 utc） date_rfc1036 rfc 1036 （例如：sunday, 14-aug-05 16:13:03 utc） date_rfc1123 rfc 1123 （例如：sun, 14 aug 2005 16:13:03 utc） date_rfc2822 rfc 2822 （sun, 14 aug 2005 16:13:03 +0000） date_rss rss （sun, 14 aug 2005 16:13:03 utc） date_w3c world wide web consortium （例如： 2005-08-14t16:13:03+0000） include the require statement is also used to include a file into the php code.\nhowever, there is one big difference between include and require; when a file is included with the include statement and php cannot find it, the script will continue to execute.\nuse require when the file is required by the application.\nuse include when the file is not required and application should continue when file is not found.\nreadfile() function the readfile() function reads a file and writes it to the output buffer.\nassume we have a text file called \u0026ldquo;webdictionary.txt\u0026rdquo;, stored on the server, that looks like this:\najax = asynchronous javascript and xml css = cascading style sheets html = hyper text markup language php = php hypertext preprocessor sql = structured query language svg = scalable vector graphics xml = extensible markup language the php code to read the file and write it to the output buffer is as follows (the readfile() function returns the number of bytes read on success):\necho readfile(\u0026#34;webdictionary.txt\u0026#34;); the readfile() function is useful if all you want to do is open up a file and read its contents.\nfile open/read/close open file - fopen() a better method to open files is with the fopen() function. this function gives you more options than the readfile() function.\nwe will use the text file, \u0026ldquo;webdictionary.txt\u0026rdquo;, during the lessons:\najax = asynchronous javascript and xml css = cascading style sheets html = hyper text markup language php = php hypertext preprocessor sql = structured query language svg = scalable vector graphics xml = extensible markup language the first parameter of fopen() contains the name of the file to be opened and the second parameter specifies in which mode the file should be opened. the following example also generates a message if the fopen() function is unable to open the specified file:\n$myfile = fopen(\u0026#34;webdictionary.txt\u0026#34;, \u0026#34;r\u0026#34;) or die(\u0026#34;unable to open file!\u0026#34;); echo fread($myfile,filesize(\u0026#34;webdictionary.txt\u0026#34;)); fclose($myfile); the file may be opened in one of the following modes:\nmodes description r open a file for read only. file pointer starts at the beginning of the file w open a file for write only. erases the contents of the file or creates a new file if it doesn\u0026rsquo;t exist. file pointer starts at the beginning of the file a open a file for write only. the existing data in file is preserved. file pointer starts at the end of the file. creates a new file if the file doesn\u0026rsquo;t exist x creates a new file for write only. returns false and an error if file already exists r+ open a file for read/write. file pointer starts at the beginning of the file w+ open a file for read/write. erases the contents of the file or creates a new file if it doesn\u0026rsquo;t exist. file pointer starts at the beginning of the file a+ open a file for read/write. the existing data in file is preserved. file pointer starts at the end of the file. creates a new file if the file doesn\u0026rsquo;t exist x+ creates a new file for read/write. returns false and an error if file already exists read file - fread() the fread() function reads from an open file.\nthe first parameter of fread() contains the name of the file to read from and the second parameter specifies the maximum number of bytes to read.\nthe following php code reads the \u0026ldquo;webdictionary.txt\u0026rdquo; file to the end:\nfread($myfile,filesize(\u0026#34;webdictionary.txt\u0026#34;)); close file - fclose() the fclose() requires the name of the file (or a variable that holds the filename) we want to close:\n\u0026lt;?php $myfile = fopen(\u0026#34;webdictionary.txt\u0026#34;, \u0026#34;r\u0026#34;); // some code to be executed.... fclose($myfile); ?\u0026gt; read single line - fgets() the fgets() function is used to read a single line from a file.\nthe example below outputs the first line of the \u0026ldquo;webdictionary.txt\u0026rdquo; file:\n\u0026lt;?php $myfile = fopen(\u0026#34;webdictionary.txt\u0026#34;, \u0026#34;r\u0026#34;) or die(\u0026#34;unable to open file!\u0026#34;); echo fgets($myfile); fclose($myfile); after a call to the fgets() function, the file pointer has moved to the next line.\ncheck end-of-file - feof() the feof() function checks if the \u0026ldquo;end-of-file\u0026rdquo; (eof) has been reached.\nthe feof() function is useful for looping through data of unknown length.\nthe example below reads the \u0026ldquo;webdictionary.txt\u0026rdquo; file line by line, until end-of-file is reached:\n\u0026lt;?php $myfile = fopen(\u0026#34;webdictionary.txt\u0026#34;, \u0026#34;r\u0026#34;) or die(\u0026#34;unable to open file!\u0026#34;); // output one line until end-of-file while(!feof($myfile)) { echo fgets($myfile) . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } fclose($myfile); read single character - fgetc() the fgetc() function is used to read a single character from a file.\nthe example below reads the \u0026ldquo;webdictionary.txt\u0026rdquo; file character by character, until end-of-file is reached:\n\u0026lt;?php $myfile = fopen(\u0026#34;webdictionary.txt\u0026#34;, \u0026#34;r\u0026#34;) or die(\u0026#34;unable to open file!\u0026#34;); // output one character until end-of-file while(!feof($myfile)) { echo fgetc($myfile); } fclose($myfile); after a call to the fgetc() function, the file pointer moves to the next character.\nfile create/write create file - fopen() the fopen() function is also used to create a file. maybe a little confusing, but in php, a file is created using the same function used to open files.\nif you use fopen() on a file that does not exist, it will create it, given that the file is opened for writing (w) or appending (a).\nthe example below creates a new file called \u0026ldquo;testfile.txt\u0026rdquo;. the file will be created in the same directory where the php code resides:\n$myfile = fopen(\u0026#34;testfile.txt\u0026#34;, \u0026#34;w\u0026#34;) write to file - fwrite() the fwrite() function is used to write to a file.\nthe first parameter of fwrite() contains the name of the file to write to and the second parameter is the string to be written.\nthe example below writes a couple of names into a new file called \u0026ldquo;newfile.txt\u0026rdquo;:\n\u0026lt;?php $myfile = fopen(\u0026#34;newfile.txt\u0026#34;, \u0026#34;w\u0026#34;) or die(\u0026#34;unable to open file!\u0026#34;); $txt = \u0026#34;john doe\\n\u0026#34;; fwrite($myfile, $txt); $txt = \u0026#34;jane doe\\n\u0026#34;; fwrite($myfile, $txt); fclose($myfile); notice that we wrote to the file \u0026ldquo;newfile.txt\u0026rdquo; twice. each time we wrote to the file we sent the string $txt that first contained \u0026ldquo;john doe\u0026rdquo; and second contained \u0026ldquo;jane doe\u0026rdquo;. after we finished writing, we closed the file using the fclose() function.\nif we open the \u0026ldquo;newfile.txt\u0026rdquo; file it would look like this:\njohn doe jane doe overwriting now that \u0026ldquo;newfile.txt\u0026rdquo; contains some data we can show what happens when we open an existing file for writing. all the existing data will be erased and we start with an empty file.\nin the example below we open our existing file \u0026ldquo;newfile.txt\u0026rdquo;, and write some new data into it:\n\u0026lt;?php $myfile = fopen(\u0026#34;newfile.txt\u0026#34;, \u0026#34;w\u0026#34;) or die(\u0026#34;unable to open file!\u0026#34;); $txt = \u0026#34;mickey mouse\\n\u0026#34;; fwrite($myfile, $txt); $txt = \u0026#34;minnie mouse\\n\u0026#34;; fwrite($myfile, $txt); fclose($myfile); if we now open the \u0026ldquo;newfile.txt\u0026rdquo; file, both john and jane have vanished, and only the data we just wrote is present:\nmickey mouse minnie mouse file upload configure the \u0026ldquo;php.ini\u0026rdquo; file\nfirst, ensure that php is configured to allow file uploads.\nin your \u0026ldquo;php.ini\u0026rdquo; file, search for the file_uploads directive, and set it to on:\nfile_uploads = on\nthe html form \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;upload.php\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; select image to upload: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;filetoupload\u0026#34; id=\u0026#34;filetoupload\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload image\u0026#34; name=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; some rules to follow for the html form above:\nmake sure that the form uses method=\u0026ldquo;post\u0026rdquo; the form also needs the following attribute: enctype=\u0026ldquo;multipart/form-data\u0026rdquo;. it specifies which content-type to use when submitting the form the upload file php script \u0026lt;?php $target_dir = \u0026#34;uploads/\u0026#34;; $target_file = $target_dir . basename($_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;name\u0026#34;]); $uploadok = 1; $imagefiletype = strtolower(pathinfo($target_file,pathinfo_extension)); // check if image file is a actual image or fake image if(isset($_post[\u0026#34;submit\u0026#34;])) { $check = getimagesize($_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;tmp_name\u0026#34;]); if($check !== false) { echo \u0026#34;file is an image - \u0026#34; . $check[\u0026#34;mime\u0026#34;] . \u0026#34;.\u0026#34;; $uploadok = 1; } else { echo \u0026#34;file is not an image.\u0026#34;; $uploadok = 0; } } php script explained:\n$target_dir = \u0026ldquo;uploads/\u0026rdquo; - specifies the directory where the file is going to be placed $target_file specifies the path of the file to be uploaded $uploadok=1 is not used yet (will be used later) $imagefiletype holds the file extension of the file (in lower case) next, check if the image file is an actual image or a fake image you will need to create a new directory called \u0026ldquo;uploads\u0026rdquo; in the directory where \u0026ldquo;upload.php\u0026rdquo; file resides. the uploaded files will be saved there.\ncheck if file already exists now we can add some restrictions.\nfirst, we will check if the file already exists in the \u0026ldquo;uploads\u0026rdquo; folder. if it does, an error message is displayed, and $uploadok is set to 0:\n// check if file already exists if (file_exists($target_file)) { echo \u0026#34;sorry, file already exists.\u0026#34;; $uploadok = 0; } limit file type the code below only allows users to upload jpg, jpeg, png, and gif files. all other file types gives an error message before setting $uploadok to 0:\n// allow certain file formats if($imagefiletype != \u0026#34;jpg\u0026#34; \u0026amp;\u0026amp; $imagefiletype != \u0026#34;png\u0026#34; \u0026amp;\u0026amp; $imagefiletype != \u0026#34;jpeg\u0026#34; \u0026amp;\u0026amp; $imagefiletype != \u0026#34;gif\u0026#34; ) { echo \u0026#34;sorry, only jpg, jpeg, png \u0026amp; gif files are allowed.\u0026#34;; $uploadok = 0; } complete upload file php script \u0026lt;?php $target_dir = \u0026#34;uploads/\u0026#34;; $target_file = $target_dir . basename($_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;name\u0026#34;]); $uploadok = 1; $imagefiletype = strtolower(pathinfo($target_file,pathinfo_extension)); // check if image file is a actual image or fake image if(isset($_post[\u0026#34;submit\u0026#34;])) { $check = getimagesize($_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;tmp_name\u0026#34;]); if($check !== false) { echo \u0026#34;file is an image - \u0026#34; . $check[\u0026#34;mime\u0026#34;] . \u0026#34;.\u0026#34;; $uploadok = 1; } else { echo \u0026#34;file is not an image.\u0026#34;; $uploadok = 0; } } // check if file already exists if (file_exists($target_file)) { echo \u0026#34;sorry, file already exists.\u0026#34;; $uploadok = 0; } // check file size if ($_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;size\u0026#34;] \u0026gt; 500000) { echo \u0026#34;sorry, your file is too large.\u0026#34;; $uploadok = 0; } // allow certain file formats if($imagefiletype != \u0026#34;jpg\u0026#34; \u0026amp;\u0026amp; $imagefiletype != \u0026#34;png\u0026#34; \u0026amp;\u0026amp; $imagefiletype != \u0026#34;jpeg\u0026#34; \u0026amp;\u0026amp; $imagefiletype != \u0026#34;gif\u0026#34; ) { echo \u0026#34;sorry, only jpg, jpeg, png \u0026amp; gif files are allowed.\u0026#34;; $uploadok = 0; } // check if $uploadok is set to 0 by an error if ($uploadok == 0) { echo \u0026#34;sorry, your file was not uploaded.\u0026#34;; // if everything is ok, try to upload file } else { if (move_uploaded_file($_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;tmp_name\u0026#34;], $target_file)) { echo \u0026#34;the file \u0026#34;. basename( $_files[\u0026#34;filetoupload\u0026#34;][\u0026#34;name\u0026#34;]). \u0026#34; has been uploaded.\u0026#34;; } else { echo \u0026#34;sorry, there was an error uploading your file.\u0026#34;; } } ?\u0026gt; cookies create cookies a cookie is created with the setcookie() function.\nsyntax\nsetcookie(*name, value, expire, path, domain, secure, httponly*); only the name parameter is required. all other parameters are optional.\nphp create/retrieve a cookie the following example creates a cookie named \u0026ldquo;user\u0026rdquo; with the value \u0026ldquo;john doe\u0026rdquo;. the cookie will expire after 30 days (86400 * 30). the \u0026ldquo;/\u0026rdquo; means that the cookie is available in entire website (otherwise, select the directory you prefer).\nwe then retrieve the value of the cookie \u0026ldquo;user\u0026rdquo; (using the global variable $_cookie). we also use the isset() function to find out if the cookie is set:\n\u0026lt;?php $cookie_name = \u0026#34;user\u0026#34;; $cookie_value = \u0026#34;john doe\u0026#34;; setcookie($cookie_name, $cookie_value, time() + (86400 * 30), \u0026#34;/\u0026#34;); // 86400 = 1 day ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php if(!isset($_cookie[$cookie_name])) { echo \u0026#34;cookie named \u0026#39;\u0026#34; . $cookie_name . \u0026#34;\u0026#39; is not set!\u0026#34;; } else { echo \u0026#34;cookie \u0026#39;\u0026#34; . $cookie_name . \u0026#34;\u0026#39; is set!\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;value is: \u0026#34; . $_cookie[$cookie_name]; } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; the setcookie() function must appear before the \u0026lt;html\u0026gt; tag.\nthe value of the cookie is automatically urlencoded when sending the cookie, and automatically decoded when received (to prevent urlencoding, use setrawcookie() instead).\nmodify a cookie value to modify a cookie, just set (again) the cookie using the setcookie() function:\n\u0026lt;?php $cookie_name = \u0026#34;user\u0026#34;; $cookie_value = \u0026#34;alex porter\u0026#34;; setcookie($cookie_name, $cookie_value, time() + (86400 * 30), \u0026#34;/\u0026#34;); ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php if(!isset($_cookie[$cookie_name])) { echo \u0026#34;cookie named \u0026#39;\u0026#34; . $cookie_name . \u0026#34;\u0026#39; is not set!\u0026#34;; } else { echo \u0026#34;cookie \u0026#39;\u0026#34; . $cookie_name . \u0026#34;\u0026#39; is set!\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;value is: \u0026#34; . $_cookie[$cookie_name]; } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; delete a cookie to delete a cookie, use the setcookie() function with an expiration date in the past:\n\u0026lt;?php // set the expiration date to one hour ago setcookie(\u0026#34;user\u0026#34;, \u0026#34;\u0026#34;, time() - 3600); ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php echo \u0026#34;cookie \u0026#39;user\u0026#39; is deleted.\u0026#34;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; check if cookies are enabled the following example creates a small script that checks whether cookies are enabled. first, try to create a test cookie with the setcookie() function, then count the $_cookie array variable:\n\u0026lt;?php setcookie(\u0026#34;test_cookie\u0026#34;, \u0026#34;test\u0026#34;, time() + 3600, \u0026#39;/\u0026#39;); ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php if(count($_cookie) \u0026gt; 0) { echo \u0026#34;cookies are enabled.\u0026#34;; } else { echo \u0026#34;cookies are disabled.\u0026#34;; } ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; sessions a session is a way to store information (in variables) to be used across multiple pages.\nunlike a cookie, the information is not stored on the users computer.\nstart a php session a session is started with the session_start() function.\nsession variables are set with the php global variable: $_session.\nnow, let\u0026rsquo;s create a new page called \u0026ldquo;demo_session1.php\u0026rdquo;. in this page, we start a new php session and set some session variables:\n\u0026lt;?php // start the session session_start(); ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // set session variables $_session[\u0026#34;favcolor\u0026#34;] = \u0026#34;green\u0026#34;; $_session[\u0026#34;favanimal\u0026#34;] = \u0026#34;cat\u0026#34;; echo \u0026#34;session variables are set.\u0026#34;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; the session_start() function must be the very first thing in your document. before any html tags.\nget php session variable values next, we create another page called \u0026ldquo;demo_session2.php\u0026rdquo;. from this page, we will access the session information we set on the first page (\u0026ldquo;demo_session1.php\u0026rdquo;).\nnotice that session variables are not passed individually to each new page, instead they are retrieved from the session we open at the beginning of each page (session_start()).\nalso notice that all session variable values are stored in the global $_session variable:\n\u0026lt;?php session_start(); ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // echo session variables that were set on previous page echo \u0026#34;favorite color is \u0026#34; . $_session[\u0026#34;favcolor\u0026#34;] . \u0026#34;.\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;favorite animal is \u0026#34; . $_session[\u0026#34;favanimal\u0026#34;] . \u0026#34;.\u0026#34;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; another way to show all the session variable values for a user session is to run the following code:\n\u0026lt;?php session_start(); ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php print_r($_session); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; modify a php session variable \u0026lt;?php session_start(); ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // to change a session variable, just overwrite it $_session[\u0026#34;favcolor\u0026#34;] = \u0026#34;yellow\u0026#34;; print_r($_session); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; destroy a php session to remove all global session variables and destroy the session, use session_unset() and session_destroy():\n\u0026lt;?php session_start(); ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // remove all session variables session_unset(); // destroy the session session_destroy(); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; filters validating data = determine if the data is in proper form.\nsanitizing data = remove any illegal character from the data.\nfilter extension php filters are used to validate and sanitize external input.\nthe php filter extension has many of the functions needed for checking user input, and is designed to make data validation easier and quicker.\nthe filter_list() function can be used to list what the php filter extension offers:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;filter name\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;filter id\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;?php foreach (filter_list() as $id =\u0026gt;$filter) { echo \u0026#39;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026#39; . $filter . \u0026#39;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026#39; . filter_id($filter) . \u0026#39;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#39;; } ?\u0026gt; \u0026lt;/table\u0026gt; filter_var() function the filter_var() function both validate and sanitize data.\nthe filter_var() function filters a single variable with a specified filter. it takes two pieces of data:\nthe variable you want to check the type of check to use sanitize a string the following example uses the filter_var() function to remove all html tags from a string:\n\u0026lt;?php $str = \u0026#34;\u0026lt;h1\u0026gt;hello world!\u0026lt;/h1\u0026gt;\u0026#34;; $newstr = filter_var($str, filter_sanitize_string); echo $newstr; ?\u0026gt; validate an integer the following example uses the filter_var() function to check if the variable $int is an integer. if ​$int is an integer, the output of the code below will be: \u0026ldquo;integer is valid\u0026rdquo;. if $int is not an integer, the output will be: \u0026ldquo;integer is not valid\u0026rdquo;:\n\u0026lt;?php $int = 100; if (!filter_var($int, filter_validate_int) === false) { echo(\u0026#34;integer is valid\u0026#34;); } else { echo(\u0026#34;integer is not valid\u0026#34;); } ?\u0026gt; filter_var() and problem with 0 in the example above, if $int was set to 0, the function above will return \u0026ldquo;integer is not valid\u0026rdquo;. to solve this problem, use the code below:\n\u0026lt;?php $int = 0; if (filter_var($int, filter_validate_int) === 0 || !filter_var($int, filter_validate_int) === false) { echo(\u0026#34;integer is valid\u0026#34;); } else { echo(\u0026#34;integer is not valid\u0026#34;); } ?\u0026gt; validate an ip address the following example uses the filter_var() function to check if the variable $ip is a valid ip address:\n\u0026lt;?php $ip = \u0026#34;127.0.0.1\u0026#34;; if (!filter_var($ip, filter_validate_ip) === false) { echo(\u0026#34;$ip is a valid ip address\u0026#34;); } else { echo(\u0026#34;$ip is not a valid ip address\u0026#34;); } ?\u0026gt; sanitize and validate an email address the following example uses the filter_var() function to first remove all illegal characters from the $email variable, then check if it is a valid email address:\n\u0026lt;?php $email = \u0026#34;john.doe@example.com\u0026#34;; // remove all illegal characters from email $email = filter_var($email, filter_sanitize_email); // validate e-mail if (!filter_var($email, filter_validate_email) === false) { echo(\u0026#34;$email is a valid email address\u0026#34;); } else { echo(\u0026#34;$email is not a valid email address\u0026#34;); } ?\u0026gt; sanitize and validate a url the following example uses the filter_var() function to first remove all illegal characters from a url, then check if $url is a valid url:\n\u0026lt;?php $url = \u0026#34;https://www.w3schools.com\u0026#34;; // remove all illegal characters from a url $url = filter_var($url, filter_sanitize_url); // validate url if (!filter_var($url, filter_validate_url) === false) { echo(\u0026#34;$url is a valid url\u0026#34;); } else { echo(\u0026#34;$url is not a valid url\u0026#34;); } ?\u0026gt; filters advanced validate an integer within a range the following example uses the filter_var() function to check if a variable is both of type int, and between 1 and 200:\n\u0026lt;?php $int = 122; $min = 1; $max = 200; if (filter_var($int, filter_validate_int, array(\u0026#34;options\u0026#34; =\u0026gt; array(\u0026#34;min_range\u0026#34;=\u0026gt;$min, \u0026#34;max_range\u0026#34;=\u0026gt;$max))) === false) { echo(\u0026#34;variable value is not within the legal range\u0026#34;); } else { echo(\u0026#34;variable value is within the legal range\u0026#34;); } ?\u0026gt; validate ipv6 address the following example uses the filter_var() function to check if the variable $ip is a valid ipv6 address:\n\u0026lt;?php $ip = \u0026#34;2001:0db8:85a3:08d3:1319:8a2e:0370:7334\u0026#34;; if (!filter_var($ip, filter_validate_ip, filter_flag_ipv6) === false) { echo(\u0026#34;$ip is a valid ipv6 address\u0026#34;); } else { echo(\u0026#34;$ip is not a valid ipv6 address\u0026#34;); } ?\u0026gt; validate url - must contain querystring the following example uses the filter_var() function to check if the variable $url is a url with a querystring:\n\u0026lt;?php $url = \u0026#34;https://www.w3schools.com\u0026#34;; if (!filter_var($url, filter_validate_url, filter_flag_query_required) === false) { echo(\u0026#34;$url is a valid url with a query string\u0026#34;); } else { echo(\u0026#34;$url is not a valid url with a query string\u0026#34;); } ?\u0026gt; remove characters with ascii value \u0026gt; 127 the following example uses the filter_var() function to sanitize a string. it will both remove all html tags, and all characters with ascii value \u0026gt; 127, from the string:\n\u0026lt;?php $str = \u0026#34;\u0026lt;h1\u0026gt;hello worldæøå!\u0026lt;/h1\u0026gt;\u0026#34;; $newstr = filter_var($str, filter_sanitize_string, filter_flag_strip_high); echo $newstr; ?\u0026gt; function a 函数 说明 abs 绝对值 acos 反余弦 acosh 反双曲余弦 addcslashes 以 c 语言风格使用反斜线转义字符串中的字符 addslashes 使用反斜线引用字符串 apache_child_terminate 在本次请求结束后终止 apache 子进程 apache_getenv 获取 apache subprocess_env 变量 apache_get_modules 获得已加载的apache模块列表 apache_get_version 获得apache版本信息 apache_lookup_uri 对指定的 uri 执行部分请求并返回所有有关信息 apache_note 取得或设置 apache 请求记录 apache_request_headers 获取全部 http 请求头信息 apache_reset_timeout 重置 apache 写入计时器 apache_response_headers 获得全部 http 响应头信息 apache_setenv 设置 apache 子进程环境变量 apcu_add cache a new variable in the data store apcu_cache_info retrieves cached information from apcu’s data store apcu_cas updates an old value with a new value apcu_clear_cache clears the apcu cache apcu_dec decrease a stored number apcu_delete removes a stored variable from the cache apcu_entry atomically fetch or generate a cache entry apcu_exists checks if entry exists apcu_fetch fetch a stored variable from the cache apcu_inc increase a stored number apcu_sma_info retrieves apcu shared memory allocation information apcu_store cache a variable in the data store apc_add 缓存一个变量到数据存储 apc_bin_dump get a binary dump of the given files and user variables apc_bin_dumpfile output a binary dump of cached files and user variables to a file apc_bin_load load a binary dump into the apc file/user cache apc_bin_loadfile load a binary dump from a file into the apc file/user cache apc_cache_info retrieves cached information from apc’s data store apc_cas 用新值更新旧值 apc_clear_cache 清除apc缓存 apc_compile_file stores a file in the bytecode cache, bypassing all filters. apc_dec decrease a stored number apc_define_constants defines a set of constants for retrieval and mass-definition apc_delete 从用户缓存中删除某个变量 apc_delete_file deletes files from the opcode cache apc_exists 检查apc中是否存在某个或者某些key apc_fetch 从缓存中取出存储的变量 apc_inc 递增一个储存的数字 apc_load_constants loads a set of constants from the cache apc_sma_info retrieves apc’s shared memory allocation information apc_store cache a variable in the data store apd_breakpoint stops the interpreter and waits on a cr from the socket apd_callstack returns the current call stack as an array apd_clunk throw a warning and a callstack apd_continue restarts the interpreter apd_croak throw an error, a callstack and then exit apd_dump_function_table outputs the current function table apd_dump_persistent_resources return all persistent resources as an array apd_dump_regular_resources return all current regular resources as an array apd_echo echo to the debugging socket apd_get_active_symbols get an array of the current variables names in the local scope apd_set_pprof_trace starts the session debugging apd_set_session changes or sets the current debugging level apd_set_session_trace starts the session debugging apd_set_session_trace_socket starts the remote session debugging array 新建一个数组 array_change_key_case 返回字符串键名全为小写或大写的数组 array_chunk 将一个数组分割成多个 array_column 返回数组中指定的一列 array_combine 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值 array_count_values 统计数组中所有的值出现的次数 array_diff 计算数组的差集 array_diff_assoc 带索引检查计算数组的差集 array_diff_key 使用键名比较计算数组的差集 array_diff_uassoc 用用户提供的回调函数做索引检查来计算数组的差集 array_diff_ukey 用回调函数对键名比较计算数组的差集 array_fill 用给定的值填充数组 array_fill_keys 使用指定的键和值填充数组 array_filter 用回调函数过滤数组中的单元 array_flip 交换数组中的键和值 array_intersect 计算数组的交集 array_intersect_assoc 带索引检查计算数组的交集 array_intersect_key 使用键名比较计算数组的交集 array_intersect_uassoc 带索引检查计算数组的交集，用回调函数比较索引 array_intersect_ukey 用回调函数比较键名来计算数组的交集 array_keys 返回数组中部分的或所有的键名 array_key_exists 检查给定的键名或索引是否存在于数组中 array_map 将回调函数作用到给定数组的单元上 array_merge 合并一个或多个数组 array_merge_recursive 递归地合并一个或多个数组 array_multisort 对多个数组或多维数组进行排序 array_pad 用值将数组填补到指定长度 array_pop 将数组最后一个单元弹出（出栈） array_product 计算数组中所有值的乘积 array_push 将一个或多个单元压入数组的末尾（入栈） array_rand 从数组中随机取出一个或多个单元 array_reduce 用回调函数迭代地将数组简化为单一的值 array_replace 使用传递的数组替换第一个数组的元素 array_replace_recursive 使用传递的数组递归替换第一个数组的元素 array_reverse 返回一个单元顺序相反的数组 array_search 在数组中搜索给定的值，如果成功则返回相应的键名 array_shift 将数组开头的单元移出数组 array_slice 从数组中取出一段 array_splice 把数组中的一部分去掉并用其它值取代 array_sum 计算数组中所有值的和 array_udiff 用回调函数比较数据来计算数组的差集 array_udiff_assoc 带索引检查计算数组的差集，用回调函数比较数据 array_udiff_uassoc 带索引检查计算数组的差集，用回调函数比较数据和索引 array_uintersect 计算数组的交集，用回调函数比较数据 array_uintersect_assoc 带索引检查计算数组的交集，用回调函数比较数据 array_uintersect_uassoc 带索引检查计算数组的交集，用回调函数比较数据和索引 array_unique 移除数组中重复的值 array_unshift 在数组开头插入一个或多个单元 array_values 返回数组中所有的值 array_walk 使用用户自定义函数对数组中的每个元素做回调处理 array_walk_recursive 对数组中的每个成员递归地应用用户函数 arsort 对数组进行逆向排序并保持索引关系 asin 反正弦 asinh 反双曲正弦 asort 对数组进行排序并保持索引关系 assert 检查一个断言是否为 false assert_options 设置/获取断言的各种标志 atan 反正切 atan2 两个参数的反正切 atanh 反双曲正切 b 函数 说明 base64_decode 对使用 mime base64 编码的数据进行解码 base64_encode 使用 mime base64 对数据进行编码 basename 返回路径中的文件名部分 base_convert 在任意进制之间转换数字 bbcode_add_element adds a bbcode element bbcode_add_smiley adds a smiley to the parser bbcode_create create a bbcode resource bbcode_destroy close bbcode_container resource bbcode_parse parse a string following a given rule set bbcode_set_arg_parser attach another parser in order to use another rule set for argument parsing bbcode_set_flags set or alter parser options bcadd 2个任意精度数字的加法计算 bccomp 比较两个任意精度的数字 bcdiv 2个任意精度的数字除法计算 bcmod 对一个任意精度数字取模 bcmul 2个任意精度数字乘法计算 bcompiler_load 从一个 bz 压缩过的文件中读取并创建类 bcompiler_load_exe 从一个 bcompiler exe 文件中读取并创建类 bcompiler_parse_class 读取一个类的字节码并回调一个用户的函数 bcompiler_read 从一个文件句柄中读取并创建类 bcompiler_write_class 写入定义过的类的字节码 bcompiler_write_constant 写入定义过的常量的字节码 bcompiler_write_exe_footer 写入开始位置以及 exe 类型文件的结尾信号 bcompiler_write_file 写入 php 源码文件的字节码 bcompiler_write_footer 写入单个字符 \\x00 用于标识编译数据的结尾 bcompiler_write_function 以字节码写入定义过的函数 bcompiler_write_functions_from_file 以字节码写入一个文件中定义过的所以函数 bcompiler_write_header 写入 bcompiler 头 bcompiler_write_included_filename 写入一个包含的文件的字节码 bcpow 任意精度数字的成方 bcpowmod raise an arbitrary precision number to another, reduced by a specified modulus bcscale 设置所有bc数学函数的默认小数点保留位数 bcsqrt 任意精度数字的二次方根 bcsub 2个任意精度数字的减法 bin2hex 函数把ascii字符的字符串转换为十六进制值 bindec 二进制转换为十进制 bindtextdomain sets the path for a domain bind_textdomain_codeset specify the character encoding in which the messages from the domain message catalog will be returned blenc_encrypt encrypt a php script with blenc. boolval get the boolean value of a variable bson_decode 反序列化一个 bson 对象为 php 数组 bson_encode 序列化一个 php 变量为 bson 字符串 bzclose 关闭一个 bzip2 文件 bzcompress 把一个字符串压缩成 bzip2 编码数据 bzdecompress 解压经 bzip2 编码过的数据 bzerrno 返回一个 bzip2 错误码 bzerror 返回包含 bzip2 错误号和错误字符串的一个 array bzerrstr 返回一个 bzip2 的错误字符串 bzflush 强制写入所有写缓冲区的数据 bzopen 打开一个经 bzip2 压缩过的文件 bzread bzip2 文件二进制安全地读取 bzwrite 二进制安全地写入 bzip2 文件 c 函数 说明 cairo_create returns a new cairocontext object on the requested surface. cairo_font_face_get_type description cairo_font_options_create description cairo_font_options_equal description cairo_font_options_get_antialias description cairo_font_options_get_hint_metrics description cairo_font_options_get_hint_style description cairo_font_options_get_subpixel_order description cairo_font_options_hash description cairo_font_options_merge description cairo_font_options_set_antialias description cairo_font_options_set_hint_metrics description cairo_font_options_set_hint_style description cairo_font_options_set_subpixel_order description cairo_font_options_status description cairo_format_stride_for_width description cairo_image_surface_create description cairo_image_surface_create_for_data description cairo_image_surface_create_from_png description cairo_image_surface_get_data description cairo_image_surface_get_format description cairo_image_surface_get_height description cairo_image_surface_get_stride description cairo_image_surface_get_width description cairo_matrix_invert description cairo_matrix_multiply description cairo_matrix_rotate description cairo_matrix_transform_distance description cairo_matrix_transform_point description cairo_matrix_translate description cairo_pattern_add_color_stop_rgb description cairo_pattern_add_color_stop_rgba description cairo_pattern_create_for_surface description cairo_pattern_create_linear description cairo_pattern_create_radial description cairo_pattern_create_rgb description cairo_pattern_create_rgba description cairo_pattern_get_color_stop_count description cairo_pattern_get_color_stop_rgba description cairo_pattern_get_extend description cairo_pattern_get_filter description cairo_pattern_get_linear_points description cairo_pattern_get_matrix description cairo_pattern_get_radial_circles description cairo_pattern_get_rgba description cairo_pattern_get_surface description cairo_pattern_get_type description cairo_pattern_set_extend description cairo_pattern_set_filter description cairo_pattern_set_matrix description cairo_pattern_status description cairo_pdf_surface_create description cairo_pdf_surface_set_size description cairo_ps_get_levels description cairo_ps_level_to_string description cairo_ps_surface_create description cairo_ps_surface_dsc_begin_page_setup description cairo_ps_surface_dsc_begin_setup description cairo_ps_surface_dsc_comment description cairo_ps_surface_get_eps description cairo_ps_surface_restrict_to_level description cairo_ps_surface_set_eps description cairo_ps_surface_set_size description cairo_scaled_font_create description cairo_scaled_font_extents description cairo_scaled_font_get_ctm description cairo_scaled_font_get_font_face description cairo_scaled_font_get_font_matrix description cairo_scaled_font_get_font_options description cairo_scaled_font_get_scale_matrix description cairo_scaled_font_get_type description cairo_scaled_font_glyph_extents description cairo_scaled_font_status description cairo_scaled_font_text_extents description cairo_surface_copy_page description cairo_surface_create_similar description cairo_surface_finish description cairo_surface_flush description cairo_surface_get_content description cairo_surface_get_device_offset description cairo_surface_get_font_options description cairo_surface_get_type description cairo_surface_mark_dirty description cairo_surface_mark_dirty_rectangle description cairo_surface_set_device_offset description cairo_surface_set_fallback_resolution description cairo_surface_show_page description cairo_surface_status description cairo_surface_write_to_png description cairo_svg_surface_create description cairo_svg_surface_restrict_to_version description cairo_svg_version_to_string description calculhmac obtain a hmac key (needs 2 arguments) calcul_hmac obtain a hmac key (needs 8 arguments) call_user_func 把第一个参数作为回调函数调用 call_user_func_array 调用回调函数，并把一个数组参数作为回调函数的参数 call_user_method 对特定对象调用用户方法（已废弃） call_user_method_array 调用一个用户方法，同时传递参数数组（已废弃） cal_days_in_month 返回某个历法中某年中某月的天数 cal_from_jd 转换julian day计数到一个支持的历法。 cal_info 返回选定历法的信息 cal_to_jd 从一个支持的历法转变为julian day计数。 ceil 进一法取整 chdb_create creates a chdb file chdir 改变目录 checkdate 验证一个格里高里日期 checkdnsrr 给指定的主机（域名）或者ip地址做dns通信检查 chgrp 改变文件所属的组 chmod 改变文件模式 chop rtrim 的别名 chown 改变文件的所有者 chr 返回指定的字符 chroot 改变根目录 chunk_split 将字符串分割成小块 classkit_import import new class method definitions from a file classkit_method_add dynamically adds a new method to a given class classkit_method_copy copies a method from class to another classkit_method_redefine dynamically changes the code of the given method classkit_method_remove dynamically removes the given method classkit_method_rename dynamically changes the name of the given method class_alias 为一个类创建别名 class_exists 检查类是否已定义 class_implements 返回指定的类实现的所有接口。 class_parents 返回指定类的父类。 class_uses return the traits used by the given class clearstatcache 清除文件状态缓存 cli_get_process_title returns the current process title cli_set_process_title sets the process title closedir 关闭目录句柄 closelog 关闭系统日志链接 compact 建立一个数组，包括变量名和它们的值 com_create_guid generate a globally unique identifier (guid) com_event_sink connect events from a com object to a php object com_get_active_object returns a handle to an already running instance of a com object com_load_typelib 装载一个 typelib com_message_pump process com messages, sleeping for up to timeoutms milliseconds com_print_typeinfo print out a php class definition for a dispatchable interface connection_aborted 检查客户端是否已经断开 connection_status 返回连接的状态位 constant 返回一个常量的值 constants for pdo_4d constants for pdo_4d context 参数 context 参数列表 convert_cyr_string 将字符由一种 cyrillic 字符转换成另一种 convert_uudecode 解码一个 uuencode 编码的字符串 convert_uuencode 使用 uuencode 编码一个字符串 copy 拷贝文件 cos 余弦 cosh 双曲余弦 count 计算数组中的单元数目或对象中的属性个数 counter_bump 修改简单计数器的当前值。 counter_bump_value 更新计数器资源的当前值。 counter_create 创建一个包含单个数值的计数器。 counter_get 获取简单计数器的当前值。 counter_get_meta 返回计数器资源的部分元信息。 counter_get_named 按名称查询一个已存在的计数器，并作为资源返回。 counter_get_value 获取计数器资源的当前值。 counter_reset 重置简单计数器的当前值。 counter_reset_value 重置计数器资源的当前值。 count_chars 返回字符串所用字符的信息 crack_check performs an obscure check with the given password crack_closedict closes an open cracklib dictionary crack_getlastmessage returns the message from the last obscure check crack_opendict opens a new cracklib dictionary crc32 计算一个字符串的 crc32 多项式 create_function create an anonymous (lambda-style) function crypt 单向字符串散列 ctype_alnum 做字母和数字字符检测 ctype_alpha 做纯字符检测 ctype_cntrl 做控制字符检测 ctype_digit 做纯数字检测 ctype_graph 做可打印字符串检测，空格除外 ctype_lower 做小写字符检测 ctype_print 做可打印字符检测 ctype_punct 检测可打印的字符是不是不包含空白、数字和字母 ctype_space 做空白字符检测 ctype_upper 做大写字母检测 ctype_xdigit 检测字符串是否只包含十六进制字符 cubrid_affected_rows return the number of rows affected by the last sql statement cubrid_bind bind variables to a prepared statement as parameters cubrid_client_encoding return the current cubrid connection charset cubrid_close close cubrid connection cubrid_close_prepare close the request handle cubrid_close_request close the request handle cubrid_column_names get the column names in result cubrid_column_types get column types in result cubrid_col_get get contents of collection type column using oid cubrid_col_size get the number of elements in collection type column using oid cubrid_commit commit a transaction cubrid_connect open a connection to a cubrid server cubrid_connect_with_url establish the environment for connecting to cubrid server cubrid_current_oid get oid of the current cursor location cubrid_data_seek move the internal row pointer of the cubrid result cubrid_db_name get db name from results of cubrid_list_dbs cubrid_disconnect close a database connection cubrid_drop delete an instance using oid cubrid_errno return the numerical value of the error message from previous cubrid operation cubrid_error get the error message cubrid_error_code get error code for the most recent function call cubrid_error_code_facility get the facility code of error cubrid_error_msg get last error message for the most recent function call cubrid_execute execute a prepared sql statement cubrid_fetch fetch the next row from a result set cubrid_fetch_array fetch a result row as an associative array, a numeric array, or both cubrid_fetch_assoc return the associative array that corresponds to the fetched row cubrid_fetch_field get column information from a result and return as an object cubrid_fetch_lengths return an array with the lengths of the values of each field from the current row cubrid_fetch_object fetche the next row and returns it as an object cubrid_fetch_row return a numerical array with the values of the current row cubrid_field_flags return a string with the flags of the given field offset cubrid_field_len get the maximum length of the specified field cubrid_field_name return the name of the specified field index cubrid_field_seek move the result set cursor to the specified field offset cubrid_field_table return the name of the table of the specified field cubrid_field_type return the type of the column corresponding to the given field offset cubrid_free_result free the memory occupied by the result data cubrid_get get a column using oid cubrid_get_autocommit get auto-commit mode of the connection cubrid_get_charset return the current cubrid connection charset cubrid_get_class_name get the class name using oid cubrid_get_client_info return the client library version cubrid_get_db_parameter returns the cubrid database parameters cubrid_get_query_timeout get the query timeout value of the request cubrid_get_server_info return the cubrid server version cubrid_insert_id return the id generated for the last updated auto_increment column cubrid_is_instance check whether the instance pointed by oid exists cubrid_list_dbs return an array with the list of all existing cubrid databases cubrid_load_from_glo read data from a glo instance and save it in a file cubrid_lob2_bind bind a lob object or a string as a lob object to a prepared statement as parameters. cubrid_lob2_close close lob object. cubrid_lob2_export export the lob object to a file. cubrid_lob2_import import blob/clob data from a file. cubrid_lob2_new create a lob object. cubrid_lob2_read read from blob/clob data. cubrid_lob2_seek move the cursor of a lob object. cubrid_lob2_seek64 move the cursor of a lob object. cubrid_lob2_size get a lob object’s size. cubrid_lob2_size64 get a lob object’s size. cubrid_lob2_tell tell the cursor position of the lob object. cubrid_lob2_tell64 tell the cursor position of the lob object. cubrid_lob2_write write to a lob object. cubrid_lob_close close blob/clob data cubrid_lob_export export blob/clob data to file cubrid_lob_get get blob/clob data cubrid_lob_send read blob/clob data and send straight to browser cubrid_lob_size get blob/clob data size cubrid_lock_read set a read lock on the given oid cubrid_lock_write set a write lock on the given oid cubrid_move_cursor move the cursor in the result cubrid_new_glo create a glo instance cubrid_next_result get result of next query when executing multiple sql statements cubrid_num_cols return the number of columns in the result set cubrid_num_fields return the number of columns in the result set cubrid_num_rows get the number of rows in the result set cubrid_pconnect open a persistent connection to a cubrid server cubrid_pconnect_with_url open a persistent connection to cubrid server cubrid_ping ping a server connection or reconnect if there is no connection cubrid_prepare prepare a sql statement for execution cubrid_put update a column using oid cubrid_query send a cubrid query cubrid_real_escape_string escape special characters in a string for use in an sql statement cubrid_result return the value of a specific field in a specific row cubrid_rollback roll back a transaction cubrid_save_to_glo save requested file in a glo instance cubrid_schema get the requested schema information cubrid_send_glo read data from glo and send it to std output cubrid_seq_drop delete an element from sequence type column using oid cubrid_seq_insert insert an element to a sequence type column using oid cubrid_seq_put update the element value of sequence type column using oid cubrid_set_add insert a single element to set type column using oid cubrid_set_autocommit set autocommit mode of the connection cubrid_set_db_parameter sets the cubrid database parameters cubrid_set_drop delete an element from set type column using oid cubrid_set_query_timeout set the timeout time of query execution cubrid_unbuffered_query perform a query without fetching the results into memory cubrid_version get the cubrid php module’s version curl context options curl 上下文选项列表 curl_close 关闭一个curl会话 curl_copy_handle 复制一个curl句柄和它的所有选项 curl_errno 返回最后一次的错误号 curl_error 返回一个保护当前会话最近一次错误的字符串 curl_escape 使用 url 编码给定的字符串 curl_exec 执行一个curl会话 curl_file_create 创建一个 curlfile 对象 curl_getinfo 获取一个curl连接资源句柄的信息 curl_init 初始化一个curl会话 curl_multi_add_handle 向curl批处理会话中添加单独的curl句柄 curl_multi_close 关闭一组curl句柄 curl_multi_exec 运行当前 curl 句柄的子连接 curl_multi_getcontent 如果设置了curlopt_returntransfer，则返回获取的输出的文本流 curl_multi_info_read 获取当前解析的curl的相关传输信息 curl_multi_init 返回一个新curl批处理句柄 curl_multi_remove_handle 移除curl批处理句柄资源中的某个句柄资源 curl_multi_select 等待所有curl批处理中的活动连接 curl_multi_setopt 为 curl 并行处理设置一个选项 curl_multi_strerror return string describing error code curl_pause pause and unpause a connection curl_reset reset all options of a libcurl session handle curl_setopt 设置一个curl传输选项 curl_setopt_array 为curl传输会话批量设置选项 curl_share_close close a curl share handle curl_share_init initialize a curl share handle curl_share_setopt set an option for a curl share handle. curl_strerror return string describing the given error code curl_unescape 解码给定的 url 编码的字符串 curl_version 获取curl版本信息 current 返回数组中的当前单元 cyrus_authenticate authenticate against a cyrus imap server cyrus_bind bind callbacks to a cyrus imap connection cyrus_close close connection to a cyrus imap server cyrus_connect connect to a cyrus imap server cyrus_query send a query to a cyrus imap server cyrus_unbind unbind … d 函数 说明 date 格式化一个本地时间／日期 date_default_timezone_get 取得一个脚本中所有日期时间函数所使用的默认时区 date_default_timezone_set 设定用于一个脚本中所有日期时间函数的默认时区 date_parse returns associative array with detailed info about given date date_parse_from_format get info about given date formatted according to the specified format date_sunrise 返回给定的日期与地点的日出时间 date_sunset 返回给定的日期与地点的日落时间 date_sun_info returns an array with information about sunset/sunrise and twilight begin/end db2_autocommit returns or sets the autocommit state for a database connection db2_bind_param binds a php variable to an sql statement parameter db2_client_info returns an object with properties that describe the db2 database client db2_close closes a database connection db2_columns returns a result set listing the columns and associated metadata for a table db2_column_privileges returns a result set listing the columns and associated privileges for a table db2_commit commits a transaction db2_connect returns a connection to a database db2_conn_error returns a string containing the sqlstate returned by the last connection attempt db2_conn_errormsg returns the last connection error message and sqlcode value db2_cursor_type returns the cursor type used by a statement resource db2_escape_string used to escape certain characters db2_exec executes an sql statement directly db2_execute executes a prepared sql statement db2_fetch_array returns an array, indexed by column position, representing a row in a result set db2_fetch_assoc returns an array, indexed by column name, representing a row in a result set db2_fetch_both returns an array, indexed by both column name and position, representing a row in a result set db2_fetch_object returns an object with properties representing columns in the fetched row db2_fetch_row sets the result set pointer to the next row or requested row db2_field_display_size returns the maximum number of bytes required to display a column db2_field_name returns the name of the column in the result set db2_field_num returns the position of the named column in a result set db2_field_precision returns the precision of the indicated column in a result set db2_field_scale returns the scale of the indicated column in a result set db2_field_type returns the data type of the indicated column in a result set db2_field_width returns the width of the current value of the indicated column in a result set db2_foreign_keys returns a result set listing the foreign keys for a table db2_free_result frees resources associated with a result set db2_free_stmt frees resources associated with the indicated statement resource db2_get_option retrieves an option value for a statement resource or a connection resource db2_last_insert_id returns the auto generated id of the last insert query that successfully executed on this connection db2_lob_read gets a user defined size of lob files with each invocation db2_next_result requests the next result set from a stored procedure db2_num_fields returns the number of fields contained in a result set db2_num_rows returns the number of rows affected by an sql statement db2_pclose closes a persistent database connection db2_pconnect returns a persistent connection to a database db2_prepare prepares an sql statement to be executed db2_primary_keys returns a result set listing primary keys for a table db2_procedures returns a result set listing the stored procedures registered in a database db2_procedure_columns returns a result set listing stored procedure parameters db2_result returns a single column from a row in the result set db2_rollback rolls back a transaction db2_server_info returns an object with properties that describe the db2 database server db2_set_option set options for connection or statement resources db2_special_columns returns a result set listing the unique row identifier columns for a table db2_statistics returns a result set listing the index and statistics for a table db2_stmt_error returns a string containing the sqlstate returned by an sql statement db2_stmt_errormsg returns a string containing the last sql statement error message db2_tables returns a result set listing the tables and associated metadata in a database db2_table_privileges returns a result set listing the tables and associated privileges in a database dbase_add_record adds a record to a database dbase_close closes a database dbase_create creates a database dbase_delete_record deletes a record from a database dbase_get_header_info gets the header info of a database dbase_get_record gets a record from a database as an indexed array dbase_get_record_with_names gets a record from a database as an associative array dbase_numfields gets the number of fields of a database dbase_numrecords gets the number of records in a database dbase_open opens a database dbase_pack packs a database dbase_replace_record replaces a record in a database dba_close close a dba database dba_delete delete dba entry specified by key dba_exists check whether key exists dba_fetch fetch data specified by key dba_firstkey fetch first key dba_handlers list all the handlers available dba_insert insert entry dba_key_split splits a key in string representation into array representation dba_list list all open database files dba_nextkey fetch next key dba_open open database dba_optimize optimize database dba_popen open database persistently dba_replace replace or insert entry dba_sync synchronize database dbplus_add add a tuple to a relation dbplus_aql perform aql query dbplus_chdir get/set database virtual current directory dbplus_close close a relation dbplus_curr get current tuple from relation dbplus_errcode get error string for given errorcode or last error dbplus_errno get error code for last operation dbplus_find set a constraint on a relation dbplus_first get first tuple from relation dbplus_flush flush all changes made on a relation dbplus_freealllocks free all locks held by this client dbplus_freelock release write lock on tuple dbplus_freerlocks free all tuple locks on given relation dbplus_getlock get a write lock on a tuple dbplus_getunique get an id number unique to a relation dbplus_info get information about a relation dbplus_last get last tuple from relation dbplus_lockrel request write lock on relation dbplus_next get next tuple from relation dbplus_open open relation file dbplus_prev get previous tuple from relation dbplus_rchperm change relation permissions dbplus_rcreate creates a new db++ relation dbplus_rcrtexact creates an exact but empty copy of a relation including indices dbplus_rcrtlike creates an empty copy of a relation with default indices dbplus_resolve resolve host information for relation dbplus_restorepos restore position dbplus_rkeys specify new primary key for a relation dbplus_ropen open relation file local dbplus_rquery perform local (raw) aql query dbplus_rrename rename a relation dbplus_rsecindex create a new secondary index for a relation dbplus_runlink remove relation from filesystem dbplus_rzap remove all tuples from relation dbplus_savepos save position dbplus_setindex set index dbplus_setindexbynumber set index by number dbplus_sql perform sql query dbplus_tcl execute tcl code on server side dbplus_tremove remove tuple and return new current tuple dbplus_undo undo dbplus_undoprepare prepare undo dbplus_unlockrel give up write lock on relation dbplus_unselect remove a constraint from relation dbplus_update update specified tuple in relation dbplus_xlockrel request exclusive lock on relation dbplus_xunlockrel free exclusive lock on relation dbx_close close an open connection/database dbx_compare compare two rows for sorting purposes dbx_connect open a connection/database dbx_error report the error message of the latest function call in the module dbx_escape_string escape a string so it can safely be used in an sql-statement dbx_fetch_row fetches rows from a query-result that had the dbx_result_unbuffered flag set dbx_query send a query and fetch all results (if any) dbx_sort sort a result from a dbx_query by a custom sort function dcgettext overrides the domain for a single lookup dcngettext plural version of dcgettext debug_backtrace 产生一条回溯跟踪(backtrace) debug_print_backtrace 打印一条回溯。 debug_zval_dump dumps a string representation of an internal zend value to output decbin 十进制转换为二进制 dechex 十进制转换为十六进制 decoct 十进制转换为八进制 define 定义一个常量 defined 检查某个名称的常量是否存在 define_syslog_variables initializes all syslog related variables deg2rad 将角度转换为弧度 delete 参见 unlink 或 unset dgettext override the current domain die 等同于 exit dio_close closes the file descriptor given by fd dio_fcntl performs a c library fcntl on fd dio_open opens a file (creating it if necessary) at a lower level than the c library input/ouput stream functions allow. dio_read reads bytes from a file descriptor dio_seek seeks to pos on fd from whence dio_stat gets stat information about the file descriptor fd dio_tcsetattr sets terminal attributes and baud rate for a serial port dio_truncate truncates file descriptor fd to offset bytes dio_write writes data to fd with optional truncation at length dir 返回一个 directory 类实例 dirname 返回路径中的目录部分 diskfreespace disk_free_space 的别名 disk_free_space 返回目录中的可用空间 disk_total_space 返回一个目录的磁盘总大小 dl 运行时载入一个 php 扩展 dngettext plural version of dgettext dns_check_record 别名 checkdnsrr dns_get_mx 别名 getmxrr dns_get_record 获取指定主机的dns记录 dom_import_simplexml gets a domelement object from a simplexmlelement object doubleval floatval 的别名 e 函数 说明 each 返回数组中当前的键／值对并将数组指针向前移动一步 easter_date 得到指定年份的复活节午夜时的unix时间戳。 easter_days 得到指定年份的3月21日到复活节之间的天数 echo 输出一个或多个字符串 eio_busy artificially increase load. could be useful in tests, benchmarking. eio_cancel cancels a request eio_chmod change file/direcrory permissions. eio_chown change file/direcrory permissions. eio_close close file eio_custom execute custom request like any other eio_* call. eio_dup2 duplicate a file descriptor eio_event_loop polls libeio until all requests proceeded eio_fallocate allows the caller to directly manipulate the allocated disk space for a file eio_fchmod change file permissions. eio_fchown change file ownership eio_fdatasync synchronize a file’s in-core state with storage device. eio_fstat get file status eio_fstatvfs get file system statistics eio_fsync synchronize a file’s in-core state with storage device eio_ftruncate truncate a file eio_futime change file last access and modification times eio_get_event_stream get stream representing a variable used in internal communications with libeio. eio_get_last_error returns string describing the last error associated with a request resource eio_grp createsa request group. eio_grp_add adds a request to the request group. eio_grp_cancel cancels a request group eio_grp_limit set group limit eio_init (re-)initialize eio eio_link create a hardlink for file eio_lstat get file status eio_mkdir create directory eio_mknod create a special or ordinary file. eio_nop does nothing, except go through the whole request cycle. eio_npending returns number of finished, but unhandled requests eio_nready returns number of not-yet handled requests eio_nreqs returns number of requests to be processed eio_nthreads returns number of threads currently in use eio_open opens a file eio_poll can be to be called whenever there are pending requests that need finishing. eio_read read from a file descriptor at given offset. eio_readahead perform file readahead into page cache eio_readdir reads through a whole directory eio_readlink read value of a symbolic link. eio_realpath get the canonicalized absolute pathname. eio_rename change the name or location of a file. eio_rmdir remove a directory eio_seek repositions the offset of the open file associated with the fd argument to the argument offset according to the directive whence eio_sendfile transfer data between file descriptors eio_set_max_idle set maximum number of idle threads. eio_set_max_parallel set maximum parallel threads eio_set_max_poll_reqs set maximum number of requests processed in a poll. eio_set_max_poll_time set maximum poll time eio_set_min_parallel set minimum parallel thread number eio_stat get file status eio_statvfs get file system statistics eio_symlink create a symbolic link eio_sync commit buffer cache to disk eio_syncfs calls linux’ syncfs syscall, if available eio_sync_file_range sync a file segment with disk eio_truncate truncate a file eio_unlink delete a name and possibly the file it refers to eio_utime change file last access and modification times. eio_write write to file empty 检查一个变量是否为空 enchant_broker_describe enumerates the enchant providers enchant_broker_dict_exists whether a dictionary exists or not. using non-empty tag enchant_broker_free free the broker resource and its dictionnaries enchant_broker_free_dict free a dictionary resource enchant_broker_get_dict_path get the directory path for a given backend enchant_broker_get_error returns the last error of the broker enchant_broker_init create a new broker object capable of requesting enchant_broker_list_dicts returns a list of available dictionaries enchant_broker_request_dict create a new dictionary using a tag enchant_broker_request_pwl_dict creates a dictionary using a pwl file enchant_broker_set_dict_path set the directory path for a given backend enchant_broker_set_ordering declares a preference of dictionaries to use for the language enchant_dict_add_to_personal add a word to personal word list enchant_dict_add_to_session add ‘word’ to this spell-checking session enchant_dict_check check whether a word is correctly spelled or not enchant_dict_describe describes an individual dictionary enchant_dict_get_error returns the last error of the current spelling-session enchant_dict_is_in_session whether or not ‘word’ exists in this spelling-session enchant_dict_quick_check check the word is correctly spelled and provide suggestions enchant_dict_store_replacement add a correction for a word enchant_dict_suggest will return a list of values if any of those pre-conditions are not met end 将数组的内部指针指向最后一个单元 ereg 正则表达式匹配 eregi 不区分大小写的正则表达式匹配 eregi_replace 不区分大小写的正则表达式替换 ereg_replace 正则表达式替换 error_clear_last clear the most recent error error_get_last 获取最后发生的错误 error_log 发送错误信息到某个地方 error_reporting 设置应该报告何种 php 错误 escapeshellarg 把字符串转码为可以在 shell 命令里使用的参数 escapeshellcmd shell 元字符转义 eval 把字符串作为php代码执行 event_base_free destroy event base event_base_loop handle events event_base_loopbreak abort event loop event_base_loopexit exit loop after a time event_base_new create and initialize new event base event_base_priority_init set the number of event priority levels event_base_reinit reinitialize the event base after a fork event_base_set associate event base with an event event_buffer_base_set associate buffered event with an event base event_buffer_disable disable a buffered event event_buffer_enable enable a buffered event event_buffer_fd_set change a buffered event file descriptor event_buffer_free destroy buffered event event_buffer_new create new buffered event event_buffer_priority_set assign a priority to a buffered event event_buffer_read read data from a buffered event event_buffer_set_callback set or reset callbacks for a buffered event event_buffer_timeout_set set read and write timeouts for a buffered event event_buffer_watermark_set set the watermarks for read and write events event_buffer_write write data to a buffered event event_new create new event event_priority_set assign a priority to an event. event_timer_add 别名 event_add event_timer_del 别名 event_del event_timer_new 别名 event_new event_timer_set prepare a timer event examples with pdo_4d examples pdo_4d exec 执行一个外部程序 exif_imagetype 判断一个图像的类型 exif_read_data 从 jpeg 或 tiff 文件中读取 exif 头信息 exif_tagname 获取指定索引的头名称 exif_thumbnail 取得嵌入在 tiff 或 jpeg 图像中的缩略图 exit 输出一个消息并且退出当前脚本 exp 计算 e 的指数 expect_expectl waits until the output from a process matches one of the patterns, a specified time period has passed, or an eof is seen expect_popen execute command via bourne shell, and open the pty stream to the process explode 使用一个字符串分割另一个字符串 expm1 返回 exp(number) extension_loaded 检查一个扩展是否已经加载 extract 从数组中将变量导入到当前的符号表 ezmlm_hash 计算 ezmlm 所需的散列值 f 函数 说明 fam_cancel_monitor terminate monitoring fam_close close fam connection fam_monitor_collection monitor a collection of files in a directory for changes fam_monitor_directory monitor a directory for changes fam_monitor_file monitor a regular file for changes fam_next_event get next pending fam event fam_open open connection to fam daemon fam_pending check for pending fam events fam_resume_monitor resume suspended monitoring fam_suspend_monitor temporarily suspend monitoring fann_cascadetrain_on_data trains on an entire dataset, for a period of time using the cascade2 training algorithm fann_cascadetrain_on_file trains on an entire dataset read from file, for a period of time using the cascade2 training algorithm. fann_clear_scaling_params clears scaling parameters fann_copy creates a copy of a fann structure fann_create_from_file constructs a backpropagation neural network from a configuration file fann_create_shortcut creates a standard backpropagation neural network which is not fully connectected and has shortcut connections fann_create_shortcut_array creates a standard backpropagation neural network which is not fully connectected and has shortcut connections fann_create_sparse creates a standard backpropagation neural network, which is not fully connected fann_create_sparse_array creates a standard backpropagation neural network, which is not fully connected using an array of layer sizes fann_create_standard creates a standard fully connected backpropagation neural network fann_create_standard_array creates a standard fully connected backpropagation neural network using an array of layer sizes fann_create_train creates an empty training data struct fann_create_train_from_callback creates the training data struct from a user supplied function fann_descale_input scale data in input vector after get it from ann based on previously calculated parameters fann_descale_output scale data in output vector after get it from ann based on previously calculated parameters fann_descale_train descale input and output data based on previously calculated parameters fann_destroy destroys the entire network and properly freeing all the associated memory fann_destroy_train destructs the training data fann_duplicate_train_data returns an exact copy of a fann train data fann_get_activation_function returns the activation function fann_get_activation_steepness returns the activation steepness for supplied neuron and layer number fann_get_bias_array get the number of bias in each layer in the network fann_get_bit_fail the number of fail bits fann_get_bit_fail_limit returns the bit fail limit used during training fann_get_cascade_activation_functions returns the cascade activation functions fann_get_cascade_activation_functions_count returns the number of cascade activation functions fann_get_cascade_activation_steepnesses returns the cascade activation steepnesses fann_get_cascade_activation_steepnesses_count the number of activation steepnesses fann_get_cascade_candidate_change_fraction returns the cascade candidate change fraction fann_get_cascade_candidate_limit return the candidate limit fann_get_cascade_candidate_stagnation_epochs returns the number of cascade candidate stagnation epochs fann_get_cascade_max_cand_epochs returns the maximum candidate epochs fann_get_cascade_max_out_epochs returns the maximum out epochs fann_get_cascade_min_cand_epochs returns the minimum candidate epochs fann_get_cascade_min_out_epochs returns the minimum out epochs fann_get_cascade_num_candidates returns the number of candidates used during training fann_get_cascade_num_candidate_groups returns the number of candidate groups fann_get_cascade_output_change_fraction returns the cascade output change fraction fann_get_cascade_output_stagnation_epochs returns the number of cascade output stagnation epochs fann_get_cascade_weight_multiplier returns the weight multiplier fann_get_connection_array get connections in the network fann_get_connection_rate get the connection rate used when the network was created fann_get_errno returns the last error number fann_get_errstr returns the last errstr fann_get_layer_array get the number of neurons in each layer in the network fann_get_learning_momentum returns the learning momentum fann_get_learning_rate returns the learning rate fann_get_mse reads the mean square error from the network fann_get_network_type get the type of neural network it was created as fann_get_num_input get the number of input neurons fann_get_num_layers get the number of layers in the neural network fann_get_num_output get the number of output neurons fann_get_quickprop_decay returns the decay which is a factor that weights should decrease in each iteration during quickprop training fann_get_quickprop_mu returns the mu factor fann_get_rprop_decrease_factor returns the increase factor used during rprop training fann_get_rprop_delta_max returns the maximum step-size fann_get_rprop_delta_min returns the minimum step-size fann_get_rprop_delta_zero returns the initial step-size fann_get_rprop_increase_factor returns the increase factor used during rprop training fann_get_sarprop_step_error_shift returns the sarprop step error shift fann_get_sarprop_step_error_threshold_factor returns the sarprop step error threshold factor fann_get_sarprop_temperature returns the sarprop temperature fann_get_sarprop_weight_decay_shift returns the sarprop weight decay shift fann_get_total_connections get the total number of connections in the entire network fann_get_total_neurons get the total number of neurons in the entire network fann_get_training_algorithm returns the training algorithm fann_get_train_error_function returns the error function used during training fann_get_train_stop_function returns the stop function used during training fann_init_weights initialize the weights using widrow + nguyen’s algorithm fann_length_train_data returns the number of training patterns in the train data fann_merge_train_data merges the train data fann_num_input_train_data returns the number of inputs in each of the training patterns in the train data fann_num_output_train_data returns the number of outputs in each of the training patterns in the train data fann_print_error prints the error string fann_randomize_weights give each connection a random weight between min_weight and max_weight fann_read_train_from_file reads a file that stores training data fann_reset_errno resets the last error number fann_reset_errstr resets the last error string fann_reset_mse resets the mean square error from the network fann_run will run input through the neural network fann_save saves the entire network to a configuration file fann_save_train save the training structure to a file fann_scale_input scale data in input vector before feed it to ann based on previously calculated parameters fann_scale_input_train_data scales the inputs in the training data to the specified range fann_scale_output scale data in output vector before feed it to ann based on previously calculated parameters fann_scale_output_train_data scales the outputs in the training data to the specified range fann_scale_train scale input and output data based on previously calculated parameters fann_scale_train_data scales the inputs and outputs in the training data to the specified range fann_set_activation_function sets the activation function for supplied neuron and layer fann_set_activation_function_hidden sets the activation function for all of the hidden layers fann_set_activation_function_layer sets the activation function for all the neurons in the supplied layer. fann_set_activation_function_output sets the activation function for the output layer fann_set_activation_steepness sets the activation steepness for supplied neuron and layer number fann_set_activation_steepness_hidden sets the steepness of the activation steepness for all neurons in the all hidden layers fann_set_activation_steepness_layer sets the activation steepness for all of the neurons in the supplied layer number fann_set_activation_steepness_output sets the steepness of the activation steepness in the output layer fann_set_bit_fail_limit set the bit fail limit used during training fann_set_callback sets the callback function for use during training fann_set_cascade_activation_functions sets the array of cascade candidate activation functions fann_set_cascade_activation_steepnesses sets the array of cascade candidate activation steepnesses fann_set_cascade_candidate_change_fraction sets the cascade candidate change fraction fann_set_cascade_candidate_limit sets the candidate limit fann_set_cascade_candidate_stagnation_epochs sets the number of cascade candidate stagnation epochs fann_set_cascade_max_cand_epochs sets the max candidate epochs fann_set_cascade_max_out_epochs sets the maximum out epochs fann_set_cascade_min_cand_epochs sets the min candidate epochs fann_set_cascade_min_out_epochs sets the minimum out epochs fann_set_cascade_num_candidate_groups sets the number of candidate groups fann_set_cascade_output_change_fraction sets the cascade output change fraction fann_set_cascade_output_stagnation_epochs sets the number of cascade output stagnation epochs fann_set_cascade_weight_multiplier sets the weight multiplier fann_set_error_log sets where the errors are logged to fann_set_input_scaling_params calculate input scaling parameters for future use based on training data fann_set_learning_momentum sets the learning momentum fann_set_learning_rate sets the learning rate fann_set_output_scaling_params calculate output scaling parameters for future use based on training data fann_set_quickprop_decay sets the quickprop decay factor fann_set_quickprop_mu sets the quickprop mu factor fann_set_rprop_decrease_factor sets the decrease factor used during rprop training fann_set_rprop_delta_max sets the maximum step-size fann_set_rprop_delta_min sets the minimum step-size fann_set_rprop_delta_zero sets the initial step-size fann_set_rprop_increase_factor sets the increase factor used during rprop training fann_set_sarprop_step_error_shift sets the sarprop step error shift fann_set_sarprop_step_error_threshold_factor sets the sarprop step error threshold factor fann_set_sarprop_temperature sets the sarprop temperature fann_set_sarprop_weight_decay_shift sets the sarprop weight decay shift fann_set_scaling_params calculate input and output scaling parameters for future use based on training data fann_set_training_algorithm sets the training algorithm fann_set_train_error_function sets the error function used during training fann_set_train_stop_function sets the stop function used during training fann_set_weight set a connection in the network fann_set_weight_array set connections in the network fann_shuffle_train_data shuffles training data, randomizing the order fann_subset_train_data returns an copy of a subset of the train data fann_test test with a set of inputs, and a set of desired outputs fann_test_data test a set of training data and calculates the mse for the training data fann_train train one iteration with a set of inputs, and a set of desired outputs fann_train_epoch train one epoch with a set of training data fann_train_on_data trains on an entire dataset for a period of time fann_train_on_file trains on an entire dataset, which is read from file, for a period of time fastcgi_finish_request 冲刷(flush)所有响应的数据给客户端 fbsql_affected_rows get number of affected rows in previous frontbase operation fbsql_autocommit enable or disable autocommit fbsql_blob_size get the size of a blob fbsql_change_user change logged in user of the active connection fbsql_clob_size get the size of a clob fbsql_close close frontbase connection fbsql_commit commits a transaction to the database fbsql_connect open a connection to a frontbase server fbsql_create_blob create a blob fbsql_create_clob create a clob fbsql_create_db create a frontbase database fbsql_database get or set the database name used with a connection fbsql_database_password sets or retrieves the password for a frontbase database fbsql_data_seek move internal result pointer fbsql_db_query send a frontbase query fbsql_db_status get the status for a given database fbsql_drop_db drop (delete) a frontbase database fbsql_errno returns the error number from previous operation fbsql_error returns the error message from previous operation fbsql_fetch_array fetch a result row as an associative array, a numeric array, or both fbsql_fetch_assoc fetch a result row as an associative array fbsql_fetch_field get column information from a result and return as an object fbsql_fetch_lengths get the length of each output in a result fbsql_fetch_object fetch a result row as an object fbsql_fetch_row get a result row as an enumerated array fbsql_field_flags get the flags associated with the specified field in a result fbsql_field_len returns the length of the specified field fbsql_field_name get the name of the specified field in a result fbsql_field_seek set result pointer to a specified field offset fbsql_field_table get name of the table the specified field is in fbsql_field_type get the type of the specified field in a result fbsql_free_result free result memory fbsql_get_autostart_info 说明 fbsql_hostname get or set the host name used with a connection fbsql_insert_id get the id generated from the previous insert operation fbsql_list_dbs list databases available on a frontbase server fbsql_list_fields list frontbase result fields fbsql_list_tables list tables in a frontbase database fbsql_next_result move the internal result pointer to the next result fbsql_num_fields get number of fields in result fbsql_num_rows get number of rows in result fbsql_password get or set the user password used with a connection fbsql_pconnect open a persistent connection to a frontbase server fbsql_query send a frontbase query fbsql_read_blob read a blob from the database fbsql_read_clob read a clob from the database fbsql_result get result data fbsql_rollback rollback a transaction to the database fbsql_rows_fetched get the number of rows affected by the last statement fbsql_select_db select a frontbase database fbsql_set_characterset change input/output character set fbsql_set_lob_mode set the lob retrieve mode for a frontbase result set fbsql_set_password change the password for a given user fbsql_set_transaction set the transaction locking and isolation fbsql_start_db start a database on local or remote server fbsql_stop_db stop a database on local or remote server fbsql_tablename 别名 fbsql_table_name fbsql_table_name get table name of field fbsql_username get or set the username for the connection fbsql_warnings enable or disable frontbase warnings fclose 关闭一个已打开的文件指针 fdf_add_doc_javascript adds javascript code to the fdf document fdf_add_template adds a template into the fdf document fdf_close close an fdf document fdf_create create a new fdf document fdf_enum_values call a user defined function for each document value fdf_errno return error code for last fdf operation fdf_error return error description for fdf error code fdf_get_ap get the appearance of a field fdf_get_attachment extracts uploaded file embedded in the fdf fdf_get_encoding get the value of the /encoding key fdf_get_file get the value of the /f key fdf_get_flags gets the flags of a field fdf_get_opt gets a value from the opt array of a field fdf_get_status get the value of the /status key fdf_get_value get the value of a field fdf_get_version gets version number for fdf api or file fdf_header sets fdf-specific output headers fdf_next_field_name get the next field name fdf_open open a fdf document fdf_open_string read a fdf document from a string fdf_remove_item sets target frame for form fdf_save save a fdf document fdf_save_string returns the fdf document as a string fdf_set_ap set the appearance of a field fdf_set_encoding sets fdf character encoding fdf_set_file set pdf document to display fdf data in fdf_set_flags sets a flag of a field fdf_set_javascript_action sets an javascript action of a field fdf_set_on_import_javascript adds javascript code to be executed when acrobat opens the fdf fdf_set_opt sets an option of a field fdf_set_status set the value of the /status key fdf_set_submit_form_action sets a submit form action of a field fdf_set_target_frame set target frame for form display fdf_set_value set the value of a field fdf_set_version sets version number for a fdf file feof 测试文件指针是否到了文件结束的位置 fflush 将缓冲内容输出到文件 fgetc 从文件指针中读取字符 fgetcsv 从文件指针中读入一行并解析 csv 字段 fgets 从文件指针中读取一行 fgetss 从文件指针中读取一行并过滤掉 html 标记 file 把整个文件读入一个数组中 fileatime 取得文件的上次访问时间 filectime 取得文件的 inode 修改时间 filegroup 取得文件的组 fileinode 取得文件的 inode filemtime 取得文件修改时间 fileowner 取得文件的所有者 fileperms 取得文件的权限 filepro read and verify the map file filepro_fieldcount find out how many fields are in a filepro database filepro_fieldname gets the name of a field filepro_fieldtype gets the type of a field filepro_fieldwidth gets the width of a field filepro_retrieve retrieves data from a filepro database filepro_rowcount find out how many rows are in a filepro database filesize 取得文件大小 filetype 取得文件类型 file_exists 检查文件或目录是否存在 file_get_contents 将整个文件读入一个字符串 file_put_contents 将一个字符串写入文件 filter_has_var checks if variable of specified type exists filter_id 返回与某个特定名称的过滤器相关联的id filter_input 通过名称获取特定的外部变量，并且可以通过过滤器处理它 filter_input_array 获取一系列外部变量，并且可以通过过滤器处理它们 filter_list 返回所支持的过滤器列表 filter_var 使用特定的过滤器过滤一个变量 filter_var_array 获取多个变量并且过滤它们 finfo_close 关闭 fileinfo 资源 finfo_open 创建一个 fileinfo 资源 floatval 获取变量的浮点值 flock 轻便的咨询文件锁定 floor 舍去法取整 flush 刷新输出缓冲 fmod 返回除法的浮点数余数 fnmatch 用模式匹配文件名 fopen 打开文件或者 url forward_static_call call a static method forward_static_call_array call a static method and pass the arguments as array fpassthru 输出文件指针处的所有剩余数据 fprintf 将格式化后的字符串写入到流 fputcsv 将行格式化为 csv 并写入文件指针 fputs fwrite 的别名 fread 读取文件（可安全用于二进制文件） frenchtojd 从一个french republican历法的日期得到julian day计数。 fribidi_log2vis convert a logical string to a visual one fscanf 从文件中格式化输入 fseek 在文件指针中定位 fsockopen 打开一个网络连接或者一个unix套接字连接 fstat 通过已打开的文件指针取得文件信息 ftell 返回文件指针读/写的位置 ftok convert a pathname and a project identifier to a system v ipc key ftp context options ftp context option listing ftp_alloc 为要上传的文件分配空间 ftp_cdup 切换到当前目录的父目录 ftp_chdir 在 ftp 服务器上改变当前目录 ftp_chmod 设置 ftp 服务器上的文件权限 ftp_close 关闭一个 ftp 连接 ftp_connect 建立一个新的 ftp 连接 ftp_delete 删除 ftp 服务器上的一个文件 ftp_exec 请求运行一条 ftp 命令 ftp_fget 从 ftp 服务器上下载一个文件并保存到本地一个已经打开的文件中 ftp_fput 上传一个已经打开的文件到 ftp 服务器 ftp_get 从 ftp 服务器上下载一个文件 ftp_get_option 返回当前 ftp 连接的各种不同的选项设置 ftp_login 登录 ftp 服务器 ftp_mdtm 返回指定文件的最后修改时间 ftp_mkdir 建立新目录 ftp_nb_continue 连续获取／发送文件（non-blocking） ftp_nb_fget 从 ftp 服务器获取文件并写入到一个打开的文件（非阻塞） ftp_nb_fput 将文件存储到 ftp 服务器 （非阻塞） ftp_nb_get 从 ftp 服务器上获取文件并写入本地文件（non-blocking） ftp_nb_put 存储一个文件至 ftp 服务器（non-blocking） ftp_nlist 返回给定目录的文件列表 ftp_pasv 返回当前 ftp 被动模式是否打开 ftp_put 上传文件到 ftp 服务器 ftp_pwd 返回当前目录名 ftp_quit ftp_close 的 别名 ftp_raw 向 ftp 服务器发送命令 ftp_rawlist 返回指定目录下文件的详细列表 ftp_rename 更改 ftp 服务器上的文件或目录名 ftp_rmdir 删除 ftp 服务器上的一个目录 ftp_set_option 设置各种 ftp 运行时选项 ftp_site 向服务器发送 site 命令 ftp_size 返回指定文件的大小 ftp_ssl_connect 打开 ssl-ftp 连接 ftp_systype 返回远程 ftp 服务器的操作系统类型 ftruncate 将文件截断到给定的长度 function_exists 如果给定的函数已经被定义就返回 true func_get_arg 返回参数列表的某一项 func_get_args 返回一个包含函数参数列表的数组 func_num_args returns the number of arguments passed to the function fwrite 写入文件（可安全用于二进制文件） g 函数 说明 gc_collect_cycles 强制收集所有现存的垃圾循环周期 gc_disable 停用循环引用收集器 gc_enable 激活循环引用收集器 gc_enabled 返回循环引用计数器的状态 gc_mem_caches reclaims memory used by the zend engine memory manager gd_info 取得当前安装的 gd 库的信息 geoip_asnum_by_name get the autonomous system numbers (asn) geoip_continent_code_by_name get the two letter continent code geoip_country_code3_by_name get the three letter country code geoip_country_code_by_name get the two letter country code geoip_country_name_by_name get the full country name geoip_database_info get geoip database information geoip_db_avail determine if geoip database is available geoip_db_filename returns the filename of the corresponding geoip database geoip_db_get_all_info returns detailed information about all geoip database types geoip_domain_by_name get the second level domain name geoip_id_by_name get the internet connection type geoip_isp_by_name get the internet service provider (isp) name geoip_netspeedcell_by_name get the internet connection speed geoip_org_by_name get the organization name geoip_record_by_name returns the detailed city information found in the geoip database geoip_region_by_name get the country code and region geoip_region_name_by_code returns the region name for some country and region code combo geoip_setup_custom_directory set a custom directory for the geoip database. geoip_time_zone_by_country_and_region returns the time zone for some country and region code combo getallheaders 获取全部 http 请求头信息 getcwd 取得当前工作目录 getdate 取得日期／时间信息 getenv 获取一个环境变量的值 gethostbyaddr 获取指定的ip地址对应的主机名 gethostbyname get the ipv4 address corresponding to a given internet host name gethostbynamel get a list of ipv4 addresses corresponding to a given internet host name gethostname gets the host name getimagesize 取得图像大小 getimagesizefromstring 从字符串中获取图像尺寸信息 getlastmod 获取页面最后修改的时间 getmxrr get mx records corresponding to a given internet host name getmygid 获取当前 php 脚本拥有者的 gid getmyinode 获取当前脚本的索引节点（inode） getmypid 获取 php 进程的 id getmyuid 获取 php 脚本所有者的 uid getopt 从命令行参数列表中获取选项 getprotobyname get protocol number associated with protocol name getprotobynumber get protocol name associated with protocol number getrandmax 显示随机数最大的可能值 getrusage 获取当前资源使用状况 getservbyname get port number associated with an internet service and protocol getservbyport get internet service which corresponds to port and protocol gettext lookup a message in the current domain gettimeofday 取得当前时间 gettype 获取变量的类型 get_browser 获取浏览器具有的功能 get_called_class 后期静态绑定（”late static binding”）类的名称 get_cfg_var 获取 php 配置选项的值 get_class 返回对象的类名 get_class_methods 返回由类的方法名组成的数组 get_class_vars 返回由类的默认属性组成的数组 get_current_user 获取当前 php 脚本所有者名称 get_declared_classes 返回由已定义类的名字所组成的数组 get_declared_interfaces 返回一个数组包含所有已声明的接口 get_declared_traits 返回所有已定义的 traits 的数组 get_defined_constants 返回所有常量的关联数组，键是常量名，值是常量值 get_defined_functions returns an array of all defined functions get_defined_vars 返回由所有已定义变量所组成的数组 get_extension_funcs 返回模块函数名称的数组 get_headers 取得服务器响应一个 http 请求所发送的所有标头 get_html_translation_table 返回使用 htmlspecialchars 和 htmlentities 后的转换表 get_included_files 返回被 include 和 require 文件名的 array get_include_path 获取当前的 include_path 配置选项 get_loaded_extensions 返回所有编译并加载模块名的 array get_magic_quotes_gpc 获取当前 magic_quotes_gpc 的配置选项设置 get_magic_quotes_runtime 获取当前 magic_quotes_runtime 配置选项的激活状态 get_meta_tags 从一个文件中提取所有的 meta 标签 content 属性，返回一个数组 get_object_vars 返回由对象属性组成的关联数组 get_parent_class 返回对象或类的父类名 get_required_files 别名 get_included_files get_resources returns active resources get_resource_type 返回资源（resource）类型 glob 寻找与模式匹配的文件路径 gmdate 格式化一个 gmt/utc 日期／时间 gmmktime 取得 gmt 日期的 unix 时间戳 gmp_abs absolute value gmp_add add numbers gmp_and bitwise and gmp_clrbit clear bit gmp_cmp compare numbers gmp_com calculates one’s complement gmp_div 别名 gmp_div_q gmp_divexact exact division of numbers gmp_div_q divide numbers gmp_div_qr divide numbers and get quotient and remainder gmp_div_r remainder of the division of numbers gmp_export export to a binary string gmp_fact factorial gmp_gcd calculate gcd gmp_gcdext calculate gcd and multipliers gmp_hamdist hamming distance gmp_import import from a binary string gmp_init create gmp number gmp_intval convert gmp number to integer gmp_invert inverse by modulo gmp_jacobi jacobi symbol gmp_legendre legendre symbol gmp_mod modulo operation gmp_mul multiply numbers gmp_neg negate number gmp_nextprime find next prime number gmp_or bitwise or gmp_perfect_square perfect square check gmp_popcount population count gmp_pow raise number into power gmp_powm raise number into power with modulo gmp_prob_prime check if number is “probably prime” gmp_random random number gmp_random_bits random number gmp_random_range random number gmp_random_seed sets the rng seed gmp_root take the integer part of nth root gmp_rootrem take the integer part and remainder of nth root gmp_scan0 scan for 0 gmp_scan1 scan for 1 gmp_setbit set bit gmp_sign sign of number gmp_sqrt calculate square root gmp_sqrtrem square root with remainder gmp_strval convert gmp number to string gmp_sub subtract numbers gmp_testbit tests if a bit is set gmp_xor bitwise xor gmstrftime 根据区域设置格式化 gmt/utc 时间／日期 gnupg_adddecryptkey add a key for decryption gnupg_addencryptkey add a key for encryption gnupg_addsignkey add a key for signing gnupg_cleardecryptkeys removes all keys which were set for decryption before gnupg_clearencryptkeys removes all keys which were set for encryption before gnupg_clearsignkeys removes all keys which were set for signing before gnupg_decrypt decrypts a given text gnupg_decryptverify decrypts and verifies a given text gnupg_encrypt encrypts a given text gnupg_encryptsign encrypts and signs a given text gnupg_export exports a key gnupg_geterror returns the errortext, if a function fails gnupg_getprotocol returns the currently active protocol for all operations gnupg_import imports a key gnupg_init initialize a connection gnupg_keyinfo returns an array with information about all keys that matches the given pattern gnupg_setarmor toggle armored output gnupg_seterrormode sets the mode for error_reporting gnupg_setsignmode sets the mode for signing gnupg_sign signs a given text gnupg_verify verifies a signed text gopher_parsedir translate a gopher formatted directory entry into an associative array. grapheme_extract function to extract a sequence of default grapheme clusters from a text buffer, which must be encoded in utf-8. grapheme_stripos find position (in grapheme units) of first occurrence of a case-insensitive string grapheme_stristr returns part of haystack string from the first occurrence of case-insensitive needle to the end of haystack. grapheme_strlen get string length in grapheme units grapheme_strpos find position (in grapheme units) of first occurrence of a string grapheme_strripos find position (in grapheme units) of last occurrence of a case-insensitive string grapheme_strrpos find position (in grapheme units) of last occurrence of a string grapheme_strstr returns part of haystack string from the first occurrence of needle to the end of haystack. grapheme_substr return part of a string gregoriantojd 转变一个gregorian历法日期到julian day计数 gupnp_context_get_host_ip get the ip address gupnp_context_get_port get the port gupnp_context_get_subscription_timeout get the event subscription timeout gupnp_context_host_path start hosting gupnp_context_new create a new context gupnp_context_set_subscription_timeout sets the event subscription timeout gupnp_context_timeout_add sets a function to be called at regular intervals gupnp_context_unhost_path stop hosting gupnp_control_point_browse_start start browsing gupnp_control_point_browse_stop stop browsing gupnp_control_point_callback_set set control point callback gupnp_control_point_new create a new control point gupnp_device_action_callback_set set device callback function gupnp_device_info_get get info of root device gupnp_device_info_get_service get the service with type gupnp_root_device_get_available check whether root device is available gupnp_root_device_get_relative_location get the relative location of root device. gupnp_root_device_new create a new root device gupnp_root_device_set_available set whether or not root_device is available gupnp_root_device_start start main loop gupnp_root_device_stop stop main loop gupnp_service_action_get retrieves the specified action arguments gupnp_service_action_return return successfully gupnp_service_action_return_error return error code gupnp_service_action_set sets the specified action return values gupnp_service_freeze_notify freeze new notifications gupnp_service_info_get get full info of service gupnp_service_info_get_introspection get resource introspection of service gupnp_service_introspection_get_state_variable returns the state variable data gupnp_service_notify notifies listening clients gupnp_service_proxy_action_get send action to the service and get value gupnp_service_proxy_action_set send action to the service and set value gupnp_service_proxy_add_notify sets up callback for variable change notification gupnp_service_proxy_callback_set set service proxy callback for signal gupnp_service_proxy_get_subscribed check whether subscription is valid to the service gupnp_service_proxy_remove_notify cancels the variable change notification gupnp_service_proxy_send_action send action with multiple parameters synchronously gupnp_service_proxy_set_subscribed (un)subscribes to the service. gupnp_service_thaw_notify sends out any pending notifications and stops queuing of new ones. gzclose close an open gz-file pointer gzcompress compress a string gzdecode decodes a gzip compressed string gzdeflate deflate a string gzencode create a gzip compressed string gzeof test for eof on a gz-file pointer gzfile read entire gz-file into an array gzgetc get character from gz-file pointer gzgets get line from file pointer gzgetss get line from gz-file pointer and strip html tags gzinflate inflate a deflated string gzopen open gz-file gzpassthru output all remaining data on a gz-file pointer gzputs 别名 gzwrite gzread binary-safe gz-file read gzrewind rewind the position of a gz-file pointer gzseek seek on a gz-file pointer gztell tell gz-file pointer read/write position gzuncompress uncompress a compressed string gzwrite binary-safe gz-file write h 函数 说明 hash 生成哈希值 （消息摘要） hash_algos 返回已注册的哈希算法列表 hash_copy 拷贝哈希运算上下文 hash_equals 可防止时序攻击的字符串比较 hash_file 使用给定文件的内容生成哈希值 hash_final 结束增量哈希，并且返回摘要结果 hash_hmac 使用 hmac 方法生成带有密钥的哈希值 hash_hmac_file 使用 hmac 方法和给定文件的内容生成带密钥的哈希值 hash_init 初始化增量哈希运算上下文 hash_pbkdf2 生成所提供密码的 pbkdf2 密钥导出 hash_update 向活跃的哈希运算上下文中填充数据 hash_update_file 从文件向活跃的哈希运算上下文中填充数据 hash_update_stream 从打开的流向活跃的哈希运算上下文中填充数据 header 发送原生 http 头 headers_list returns a list of response headers sent (or ready to send) headers_sent checks if or where headers have been sent header_register_callback call a header function header_remove remove previously set headers hebrev 将逻辑顺序希伯来文（logical-hebrew）转换为视觉顺序希伯来文（visual-hebrew） hebrevc 将逻辑顺序希伯来文（logical-hebrew）转换为视觉顺序希伯来文（visual-hebrew），并且转换换行符 hex2bin 转换十六进制字符串为二进制字符串 hexdec 十六进制转换为十进制 highlight_file 语法高亮一个文件 highlight_string 字符串的语法高亮 htmlentities convert all applicable characters to html entities htmlspecialchars convert special characters to html entities htmlspecialchars_decode 将特殊的 html 实体转换回普通字符 html_entity_decode convert all html entities to their applicable characters http context 选项 http context 的选项列表 http_build_cookie build cookie string http_build_query 生成 url-encode 之后的请求字符串 http_build_str 产生一个查询字符串 http_build_url 产生一个 url http_cache_etag caching by etag http_cache_last_modified caching by last modification http_chunked_decode decode chunked-encoded data http_date compose http rfc compliant date http_deflate deflate data http_get perform get request http_get_request_body get request body as string http_get_request_body_stream get request body as stream http_get_request_headers get request headers as array http_head perform head request http_inflate inflate data http_match_etag match etag http_match_modified match last modification http_match_request_header match any header http_negotiate_charset negotiate client’s preferred character set http_negotiate_content_type negotiate client’s preferred content type http_negotiate_language negotiate client’s preferred language http_parse_cookie parse http cookie http_parse_headers parse http headers http_parse_message parse http messages http_parse_params parse parameter list http_persistent_handles_clean clean up persistent handles http_persistent_handles_count stat persistent handles http_persistent_handles_ident get/set ident of persistent handles http_post_data perform post request with pre-encoded data http_post_fields perform post request with data to be encoded http_put_data perform put request with data http_put_file perform put request with file http_put_stream perform put request with stream http_redirect issue http redirect http_request perform custom request http_request_body_encode encode request body http_request_method_exists check whether request method exists http_request_method_name get request method name http_request_method_register register request method http_request_method_unregister unregister request method http_response_code get or set the http response code http_send_content_disposition send content-disposition http_send_content_type send content-type http_send_data send arbitrary data http_send_file send file http_send_last_modified send last-modified http_send_status send http response status http_send_stream send stream http_support check built-in http support http_throttle http throttling hwapi_attribute_new creates instance of class hw_api_attribute hwapi_content_new create new instance of class hw_api_content hwapi_hgcsp returns object of class hw_api hwapi_object_new creates a new instance of class hwapi_object_new hypot 计算一直角三角形的斜边长度 i 函数 说明 ibase_add_user add a user to a security database ibase_affected_rows return the number of rows that were affected by the previous query ibase_backup initiates a backup task in the service manager and returns immediately ibase_blob_add add data into a newly created blob ibase_blob_cancel cancel creating blob ibase_blob_close close blob ibase_blob_create create a new blob for adding data ibase_blob_echo output blob contents to browser ibase_blob_get get len bytes data from open blob ibase_blob_import create blob, copy file in it, and close it ibase_blob_info return blob length and other useful info ibase_blob_open open blob for retrieving data parts ibase_close close a connection to an interbase database ibase_commit commit a transaction ibase_commit_ret commit a transaction without closing it ibase_connect open a connection to a database ibase_db_info request statistics about a database ibase_delete_user delete a user from a security database ibase_drop_db drops a database ibase_errcode return an error code ibase_errmsg return error messages ibase_execute execute a previously prepared query ibase_fetch_assoc fetch a result row from a query as an associative array ibase_fetch_object get an object from a interbase database ibase_fetch_row fetch a row from an interbase database ibase_field_info get information about a field ibase_free_event_handler cancels a registered event handler ibase_free_query free memory allocated by a prepared query ibase_free_result free a result set ibase_gen_id increments the named generator and returns its new value ibase_maintain_db execute a maintenance command on the database server ibase_modify_user modify a user to a security database ibase_name_result assigns a name to a result set ibase_num_fields get the number of fields in a result set ibase_num_params return the number of parameters in a prepared query ibase_param_info return information about a parameter in a prepared query ibase_pconnect open a persistent connection to an interbase database ibase_prepare prepare a query for later binding of parameter placeholders and execution ibase_query execute a query on an interbase database ibase_restore initiates a restore task in the service manager and returns immediately ibase_rollback roll back a transaction ibase_rollback_ret roll back a transaction without closing it ibase_server_info request information about a database server ibase_service_attach connect to the service manager ibase_service_detach disconnect from the service manager ibase_set_event_handler register a callback function to be called when events are posted ibase_trans begin a transaction ibase_wait_event wait for an event to be posted by the database iconv 字符串按要求的字符编码来转换 iconv_get_encoding 获取 iconv 扩展的内部配置变量 iconv_mime_decode decodes a mime header field iconv_mime_decode_headers 一次性解码多个 mime 头字段 iconv_mime_encode composes a mime header field iconv_set_encoding 为字符编码转换设定当前设置 iconv_strlen 返回字符串的字符数统计 iconv_strpos finds position of first occurrence of a needle within a haystack iconv_strrpos finds the last occurrence of a needle within a haystack iconv_substr 截取字符串的部分 id3_get_frame_long_name get the long name of an id3v2 frame id3_get_frame_short_name get the short name of an id3v2 frame id3_get_genre_id get the id for a genre id3_get_genre_list get all possible genre values id3_get_genre_name get the name for a genre id id3_get_tag get all information stored in an id3 tag id3_get_version get version of an id3 tag id3_remove_tag remove an existing id3 tag id3_set_tag update information stored in an id3 tag idate 将本地时间日期格式化为整数 idn_to_ascii convert domain name to idna ascii form. idn_to_unicode 别名 idn_to_utf8 idn_to_utf8 convert domain name from idna ascii to unicode. ifxus_close_slob deletes the slob object ifxus_create_slob creates an slob object and opens it ifxus_free_slob deletes the slob object ifxus_open_slob opens an slob object ifxus_read_slob reads nbytes of the slob object ifxus_seek_slob sets the current file or seek position ifxus_tell_slob returns the current file or seek position ifxus_write_slob writes a string into the slob object ifx_affected_rows get number of rows affected by a query ifx_blobinfile_mode set the default blob mode for all select queries ifx_byteasvarchar set the default byte mode ifx_close close informix connection ifx_connect open informix server connection ifx_copy_blob duplicates the given blob object ifx_create_blob creates an blob object ifx_create_char creates an char object ifx_do execute a previously prepared sql-statement ifx_error returns error code of last informix call ifx_errormsg returns error message of last informix call ifx_fetch_row get row as an associative array ifx_fieldproperties list of sql fieldproperties ifx_fieldtypes list of informix sql fields ifx_free_blob deletes the blob object ifx_free_char deletes the char object ifx_free_result releases resources for the query ifx_getsqlca get the contents of sqlca.sqlerrd[0..5] after a query ifx_get_blob return the content of a blob object ifx_get_char return the content of the char object ifx_htmltbl_result formats all rows of a query into a html table ifx_nullformat sets the default return value on a fetch row ifx_num_fields returns the number of columns in the query ifx_num_rows count the rows already fetched from a query ifx_pconnect open persistent informix connection ifx_prepare prepare an sql-statement for execution ifx_query send informix query ifx_textasvarchar set the default text mode ifx_update_blob updates the content of the blob object ifx_update_char updates the content of the char object ignore_user_abort 设置客户端断开连接时是否中断脚本的执行 iis_add_server creates a new virtual web server iis_get_dir_security gets directory security iis_get_script_map gets script mapping on a virtual directory for a specific extension iis_get_server_by_comment return the instance number associated with the comment iis_get_server_by_path return the instance number associated with the path iis_get_server_rights gets server rights iis_get_service_state returns the state for the service defined by serviceid iis_remove_server removes the virtual web server indicated by serverinstance iis_set_app_settings creates application scope for a virtual directory iis_set_dir_security sets directory security iis_set_script_map sets script mapping on a virtual directory iis_set_server_rights sets server rights iis_start_server starts the virtual web server iis_start_service starts the service defined by serviceid iis_stop_server stops the virtual web server iis_stop_service stops the service defined by serviceid image2wbmp 以 wbmp 格式将图像输出到浏览器或文件 imageaffine 返回经过仿射变换后的图像，剪切区域可选 imageaffinematrixconcat concat two matrices (as in doing many ops in one go) imageaffinematrixget return an image containing the affine tramsformed src image, using an optional clipping area imagealphablending 设定图像的混色模式 imageantialias 是否使用抗锯齿（antialias）功能 imagearc 画椭圆弧 imagechar 水平地画一个字符 imagecharup 垂直地画一个字符 imagecolorallocate 为一幅图像分配颜色 imagecolorallocatealpha 为一幅图像分配颜色 + alpha imagecolorat 取得某像素的颜色索引值 imagecolorclosest 取得与指定的颜色最接近的颜色的索引值 imagecolorclosestalpha 取得与指定的颜色加透明度最接近的颜色 imagecolorclosesthwb 取得与给定颜色最接近的色度的黑白色的索引 imagecolordeallocate 取消图像颜色的分配 imagecolorexact 取得指定颜色的索引值 imagecolorexactalpha 取得指定的颜色加透明度的索引值 imagecolormatch 使一个图像中调色板版本的颜色与真彩色版本更能匹配 imagecolorresolve 取得指定颜色的索引值或有可能得到的最接近的替代值 imagecolorresolvealpha 取得指定颜色 + alpha 的索引值或有可能得到的最接近的替代值 imagecolorset 给指定调色板索引设定颜色 imagecolorsforindex 取得某索引的颜色 imagecolorstotal 取得一幅图像的调色板中颜色的数目 imagecolortransparent 将某个颜色定义为透明色 imageconvolution 用系数 div 和 offset 申请一个 3x3 的卷积矩阵 imagecopy 拷贝图像的一部分 imagecopymerge 拷贝并合并图像的一部分 imagecopymergegray 用灰度拷贝并合并图像的一部分 imagecopyresampled 重采样拷贝部分图像并调整大小 imagecopyresized 拷贝部分图像并调整大小 imagecreate 新建一个基于调色板的图像 imagecreatefromgd 从 gd 文件或 url 新建一图像 imagecreatefromgd2 从 gd2 文件或 url 新建一图像 imagecreatefromgd2part 从给定的 gd2 文件或 url 中的部分新建一图像 imagecreatefromgif 由文件或 url 创建一个新图象。 imagecreatefromjpeg 由文件或 url 创建一个新图象。 imagecreatefrompng 由文件或 url 创建一个新图象。 imagecreatefromstring 从字符串中的图像流新建一图像 imagecreatefromwbmp 由文件或 url 创建一个新图象。 imagecreatefromwebp 由文件或 url 创建一个新图象。 imagecreatefromxbm 由文件或 url 创建一个新图象。 imagecreatefromxpm 由文件或 url 创建一个新图象。 imagecreatetruecolor 新建一个真彩色图像 imagecrop crop an image using the given coordinates and size, x, y, width and height imagecropauto crop an image automatically using one of the available modes imagedashedline 画一虚线 imagedestroy 销毁一图像 imageellipse 画一个椭圆 imagefill 区域填充 imagefilledarc 画一椭圆弧且填充 imagefilledellipse 画一椭圆并填充 imagefilledpolygon 画一多边形并填充 imagefilledrectangle 画一矩形并填充 imagefilltoborder 区域填充到指定颜色的边界为止 imagefilter 对图像使用过滤器 imageflip flips an image using a given mode imagefontheight 取得字体高度 imagefontwidth 取得字体宽度 imageftbbox 给出一个使用 freetype 2 字体的文本框 imagefttext 使用 freetype 2 字体将文本写入图像 imagegammacorrect 对 gd 图像应用 gamma 修正 imagegd 将 gd 图像输出到浏览器或文件 imagegd2 将 gd2 图像输出到浏览器或文件 imagegif 输出图象到浏览器或文件。 imagegrabscreen captures the whole screen imagegrabwindow captures a window imageinterlace 激活或禁止隔行扫描 imageistruecolor 检查图像是否为真彩色图像 imagejpeg 输出图象到浏览器或文件。 imagelayereffect 设定 alpha 混色标志以使用绑定的 libgd 分层效果 imageline 画一条线段 imageloadfont 载入一新字体 imagepalettecopy 将调色板从一幅图像拷贝到另一幅 imagepalettetotruecolor converts a palette based image to true color imagepng 以 png 格式将图像输出到浏览器或文件 imagepolygon 画一个多边形 imagepsbbox 给出一个使用 postscript type1 字体的文本方框 imagepsencodefont 改变字体中的字符编码矢量 imagepsextendfont 扩充或精简字体 imagepsfreefont 释放一个 postscript type 1 字体所占用的内存 imagepsloadfont 从文件中加载一个 postscript type 1 字体 imagepsslantfont 倾斜某字体 imagepstext 用 postscript type1 字体把文本字符串画在图像上 imagerectangle 画一个矩形 imagerotate 用给定角度旋转图像 imagesavealpha 设置标记以在保存 png 图像时保存完整的 alpha 通道信息（与单一透明色相反） imagescale scale an image using the given new width and height imagesetbrush 设定画线用的画笔图像 imagesetinterpolation set the interpolation method imagesetpixel 画一个单一像素 imagesetstyle 设定画线的风格 imagesetthickness 设定画线的宽度 imagesettile 设定用于填充的贴图 imagestring 水平地画一行字符串 imagestringup 垂直地画一行字符串 imagesx 取得图像宽度 imagesy 取得图像高度 imagetruecolortopalette 将真彩色图像转换为调色板图像 imagettfbbox 取得使用 truetype 字体的文本的范围 imagettftext 用 truetype 字体向图像写入文本 imagetypes 返回当前 php 版本所支持的图像类型 imagewbmp 以 wbmp 格式将图像输出到浏览器或文件 imagewebp 将 webp 格式的图像输出到浏览器或文件 imagexbm 将 xbm 图像输出到浏览器或文件 image_type_to_extension 取得图像类型的文件后缀 image_type_to_mime_type 取得 getimagesize，exif_read_data，exif_thumbnail，exif_imagetype 所返回的图像类型的 mime 类型 imap_8bit convert an 8bit string to a quoted-printable string imap_alerts returns all imap alert messages that have occurred imap_append append a string message to a specified mailbox imap_base64 decode base64 encoded text imap_binary convert an 8bit string to a base64 string imap_body read the message body imap_bodystruct read the structure of a specified body section of a specific message imap_check check current mailbox imap_clearflag_full clears flags on messages imap_close close an imap stream imap_create 别名 imap_createmailbox imap_createmailbox create a new mailbox imap_delete mark a message for deletion from current mailbox imap_deletemailbox delete a mailbox imap_errors returns all of the imap errors that have occurred imap_expunge delete all messages marked for deletion imap_fetchbody fetch a particular section of the body of the message imap_fetchheader returns header for a message imap_fetchmime fetch mime headers for a particular section of the message imap_fetchstructure read the structure of a particular message imap_fetchtext 别名 imap_body imap_fetch_overview read an overview of the information in the headers of the given message imap_gc clears imap cache imap_getacl gets the acl for a given mailbox imap_getmailboxes read the list of mailboxes, returning detailed information on each one imap_getsubscribed list all the subscribed mailboxes imap_get_quota retrieve the quota level settings, and usage statics per mailbox imap_get_quotaroot retrieve the quota settings per user imap_header 别名 imap_headerinfo imap_headerinfo read the header of the message imap_headers returns headers for all messages in a mailbox imap_last_error gets the last imap error that occurred during this page request imap_list read the list of mailboxes imap_listmailbox 别名 imap_list imap_listscan returns the list of mailboxes that matches the given text imap_listsubscribed 别名 imap_lsub imap_lsub list all the subscribed mailboxes imap_mail send an email message imap_mailboxmsginfo get information about the current mailbox imap_mail_compose create a mime message based on given envelope and body sections imap_mail_copy copy specified messages to a mailbox imap_mail_move move specified messages to a mailbox imap_mime_header_decode decode mime header elements imap_msgno gets the message sequence number for the given uid imap_num_msg gets the number of messages in the current mailbox imap_num_recent gets the number of recent messages in current mailbox imap_open open an imap stream to a mailbox imap_ping check if the imap stream is still active imap_qprint convert a quoted-printable string to an 8 bit string imap_rename 别名 imap_renamemailbox imap_renamemailbox rename an old mailbox to new mailbox imap_reopen reopen imap stream to new mailbox imap_rfc822_parse_adrlist parses an address string imap_rfc822_parse_headers parse mail headers from a string imap_rfc822_write_address returns a properly formatted email address given the mailbox, host, and personal info imap_savebody save a specific body section to a file imap_scan 别名 imap_listscan imap_scanmailbox 别名 imap_listscan imap_search this function returns an array of messages matching the given search criteria imap_setacl sets the acl for a given mailbox imap_setflag_full sets flags on messages imap_set_quota sets a quota for a given mailbox imap_sort gets and sort messages imap_status returns status information on a mailbox imap_subscribe subscribe to a mailbox imap_thread returns a tree of threaded message imap_timeout set or fetch imap timeout imap_uid this function returns the uid for the given message sequence number imap_undelete unmark the message which is marked deleted imap_unsubscribe unsubscribe from a mailbox imap_utf7_decode decodes a modified utf-7 encoded string imap_utf7_encode converts iso-8859-1 string to modified utf-7 text imap_utf8 converts mime-encoded text to utf-8 implode 将一个一维数组的值转化为字符串 import_request_variables 将 get／post／cookie 变量导入到全局作用域中 inclued_get_data get the inclued data inet_ntop converts a packed internet address to a human readable representation inet_pton converts a human readable ip address to its packed in_addr representation ingres_autocommit switch autocommit on or off ingres_autocommit_state test if the connection is using autocommit ingres_charset returns the installation character set ingres_close close an ingres database connection ingres_commit commit a transaction ingres_connect open a connection to an ingres database ingres_cursor get a cursor name for a given result resource ingres_errno get the last ingres error number generated ingres_error get a meaningful error message for the last error generated ingres_errsqlstate get the last sqlstate error code generated ingres_escape_string escape special characters for use in a query ingres_execute execute a prepared query ingres_fetch_array fetch a row of result into an array ingres_fetch_assoc fetch a row of result into an associative array ingres_fetch_object fetch a row of result into an object ingres_fetch_proc_return get the return value from a procedure call ingres_fetch_row fetch a row of result into an enumerated array ingres_field_length get the length of a field ingres_field_name get the name of a field in a query result ingres_field_nullable test if a field is nullable ingres_field_precision get the precision of a field ingres_field_scale get the scale of a field ingres_field_type get the type of a field in a query result ingres_free_result free the resources associated with a result identifier ingres_next_error get the next ingres error ingres_num_fields get the number of fields returned by the last query ingres_num_rows get the number of rows affected or returned by a query ingres_pconnect open a persistent connection to an ingres database ingres_prepare prepare a query for later execution ingres_query send an sql query to ingres ingres_result_seek set the row position before fetching data ingres_rollback roll back a transaction ingres_set_environment set environment features controlling output options ingres_unbuffered_query send an unbuffered sql query to ingres ini_alter 别名 ini_set ini_get 获取一个配置选项的值 ini_get_all 获取所有配置选项 ini_restore 恢复配置选项的值 ini_set 为一个配置选项设置值 inotify_add_watch add a watch to an initialized inotify instance inotify_init initialize an inotify instance inotify_queue_len return a number upper than zero if there are pending events inotify_read read events from an inotify instance inotify_rm_watch remove an existing watch from an inotify instance intdiv integer division interface_exists 检查接口是否已被定义 intl_error_name get symbolic name for a given error code intl_get_error_code get the last error code intl_get_error_message get description of the last error intl_is_failure check whether the given error code indicates failure intval 获取变量的整数值 in_array 检查数组中是否存在某个值 ip2long 将一个ipv4的字符串互联网协议转换成数字格式 iptcembed 将二进制 iptc 数据嵌入到一幅 jpeg 图像中 iptcparse 将二进制 iptc 块解析为单个标记 isset 检测变量是否设置 is_a 如果对象属于该类或该类是此对象的父类则返回 true is_array 检测变量是否是数组 is_bool 检测变量是否是布尔型 is_callable 检测参数是否为合法的可调用结构 is_dir 判断给定文件名是否是一个目录 is_double is_float 的别名 is_executable 判断给定文件名是否可执行 is_file 判断给定文件名是否为一个正常的文件 is_finite 判断是否为有限值 is_float 检测变量是否是浮点型 is_infinite 判断是否为无限值 is_int 检测变量是否是整数 is_integer is_int 的别名 is_link 判断给定文件名是否为一个符号连接 is_long is_int 的别名 is_nan 判断是否为合法数值 is_null 检测变量是否为 null is_numeric 检测变量是否为数字或数字字符串 is_object 检测变量是否是一个对象 is_readable 判断给定文件名是否可读 is_real is_float 的别名 is_resource 检测变量是否为资源类型 is_scalar 检测变量是否是一个标量 is_soap_fault checks if a soap call has failed is_string 检测变量是否是字符串 is_subclass_of 如果此对象是该类的子类，则返回 true is_tainted checks whether a string is tainted is_uploaded_file 判断文件是否是通过 http post 上传的 is_writable 判断给定的文件名是否可写 is_writeable is_writable 的别名 iterator_apply 为迭代器中每个元素调用一个用户自定义函数 iterator_count 计算迭代器中元素的个数 iterator_to_array 将迭代器中的元素拷贝到数组 j 函数 说明 jddayofweek 返回星期的日期 jdmonthname 返回月份的名称 jdtofrench 转变一个julian day计数到french republican历法的日期 jdtogregorian 转变一个julian day计数为gregorian历法日期 jdtojewish 转换一个julian天数为jewish历法的日期 jdtojulian 转变一个julian day计数到julian历法的日期 jdtounix 转变julian day计数为一个unix时间戳 jewishtojd 转变一个jewish历法的日期为一个julian day计数 join 别名 implode jpeg2wbmp 将 jpeg 图像文件转换为 wbmp 图像文件 json_decode 对 json 格式的字符串进行编码 json_encode 对变量进行 json 编码 json_last_error 返回最后发生的错误 json_last_error_msg returns the error string of the last json_encode() or json_decode() call judy_type return the type of a judy array judy_version return or print the current php judy version juliantojd 转变一个julian历法的日期为julian day计数 k 函数 说明 kadm5_chpass_principal changes the principal’s password kadm5_create_principal creates a kerberos principal with the given parameters kadm5_delete_principal deletes a kerberos principal kadm5_destroy closes the connection to the admin server and releases all related resources kadm5_flush flush all changes to the kerberos database kadm5_get_policies gets all policies from the kerberos database kadm5_get_principal gets the principal’s entries from the kerberos database kadm5_get_principals gets all principals from the kerberos database kadm5_init_with_password opens a connection to the kadm5 library kadm5_modify_principal modifies a kerberos principal with the given parameters key 从关联数组中取得键名 key_exists 别名 array_key_exists krsort 对数组按照键名逆向排序 ksort 对数组按照键名排序 l 函数 说明 lcfirst 使一个字符串的第一个字符小写 lcg_value 组合线性同余发生器 lchgrp changes group ownership of symlink lchown changes user ownership of symlink ldap_8859_to_t61 translate 8859 characters to t61 characters ldap_add add entries to ldap directory ldap_bind 绑定 ldap 目录 ldap_close 别名 ldap_unbind ldap_compare compare value of attribute found in entry specified with dn ldap_connect connect to an ldap server ldap_control_paged_result send ldap pagination control ldap_control_paged_result_response retrieve the ldap pagination cookie ldap_count_entries count the number of entries in a search ldap_delete delete an entry from a directory ldap_dn2ufn convert dn to user friendly naming format ldap_err2str convert ldap error number into string error message ldap_errno return the ldap error number of the last ldap command ldap_error return the ldap error message of the last ldap command ldap_escape escape a string for use in an ldap filter or dn ldap_explode_dn splits dn into its component parts ldap_first_attribute return first attribute ldap_first_entry return first result id ldap_first_reference return first reference ldap_free_result free result memory ldap_get_attributes get attributes from a search result entry ldap_get_dn get the dn of a result entry ldap_get_entries get all result entries ldap_get_option get the current value for given option ldap_get_values get all values from a result entry ldap_get_values_len get all binary values from a result entry ldap_list single-level search ldap_modify modify an ldap entry ldap_modify_batch batch and execute modifications on an ldap entry ldap_mod_add add attribute values to current attributes ldap_mod_del delete attribute values from current attributes ldap_mod_replace replace attribute values with new ones ldap_next_attribute get the next attribute in result ldap_next_entry get next result entry ldap_next_reference get next reference ldap_parse_reference extract information from reference entry ldap_parse_result extract information from result ldap_read read an entry ldap_rename modify the name of an entry ldap_sasl_bind bind to ldap directory using sasl ldap_search search ldap tree ldap_set_option set the value of the given option ldap_set_rebind_proc set a callback function to do re-binds on referral chasing ldap_sort sort ldap result entries ldap_start_tls start tls ldap_t61_to_8859 translate t61 characters to 8859 characters ldap_unbind unbind from ldap directory levenshtein 计算两个字符串之间的编辑距离 libxml_clear_errors clear libxml error buffer libxml_disable_entity_loader disable the ability to load external entities libxml_get_errors retrieve array of errors libxml_get_last_error retrieve last error from libxml libxml_set_external_entity_loader changes the default external entity loader libxml_set_streams_context set the streams context for the next libxml document load or write libxml_use_internal_errors disable libxml errors and allow user to fetch error information as needed link 建立一个硬连接 linkinfo 获取一个连接的信息 list 把数组中的值赋给一些变量 localeconv get numeric formatting information localtime 取得本地时间 log 自然对数 log1p 返回 log(1 + number)，甚至当 number 的值接近零也能计算出准确结果 log10 以 10 为底的对数 long2ip converts an long integer address into a string in (ipv4) internet standard dotted format lstat 给出一个文件或符号连接的信息 ltrim 删除字符串开头的空白字符（或其他字符） lzf_compress lzf compression lzf_decompress lzf decompression lzf_optimized_for determines what lzf extension was optimized for m 函数 说明 magic_quotes_runtime 别名 set_magic_quotes_runtime mail 发送邮件 mailparse_determine_best_xfer_encoding gets the best way of encoding mailparse_msg_create create a mime mail resource mailparse_msg_extract_part extracts/decodes a message section mailparse_msg_extract_part_file extracts/decodes a message section mailparse_msg_extract_whole_part_file extracts a message section including headers without decoding the transfer encoding mailparse_msg_free frees a mime resource mailparse_msg_get_part returns a handle on a given section in a mimemessage mailparse_msg_get_part_data returns an associative array of info about the message mailparse_msg_get_structure returns an array of mime section names in the supplied message mailparse_msg_parse incrementally parse data into buffer mailparse_msg_parse_file parses a file mailparse_rfc822_parse_addresses parse rfc 822 compliant addresses mailparse_stream_encode streams data from source file pointer, apply encoding and write to destfp mailparse_uudecode_all scans the data from fp and extract each embedded uuencoded file main 虚拟的main max 找出最大值 maxdb_affected_rows gets the number of affected rows in a previous maxdb operation maxdb_autocommit turns on or off auto-commiting database modifications maxdb_bind_param 别名 maxdb_stmt_bind_param maxdb_bind_result 别名 maxdb_stmt_bind_result maxdb_change_user changes the user of the specified database connection maxdb_character_set_name returns the default character set for the database connection maxdb_client_encoding 别名 maxdb_character_set_name maxdb_close closes a previously opened database connection maxdb_close_long_data 别名 maxdb_stmt_close_long_data maxdb_commit commits the current transaction maxdb_connect open a new connection to the maxdb server maxdb_connect_errno returns the error code from last connect call maxdb_connect_error returns a string description of the last connect error maxdb_data_seek adjusts the result pointer to an arbitary row in the result maxdb_debug performs debugging operations maxdb_disable_reads_from_master disable reads from master maxdb_disable_rpl_parse disable rpl parse maxdb_dump_debug_info dump debugging information into the log maxdb_embedded_connect open a connection to an embedded maxdb server maxdb_enable_reads_from_master enable reads from master maxdb_enable_rpl_parse enable rpl parse maxdb_errno returns the error code for the most recent function call maxdb_error returns a string description of the last error maxdb_escape_string 别名 maxdb_real_escape_string maxdb_execute 别名 maxdb_stmt_execute maxdb_fetch 别名 maxdb_stmt_fetch maxdb_fetch_array fetch a result row as an associative, a numeric array, or both maxdb_fetch_assoc fetch a result row as an associative array maxdb_fetch_field returns the next field in the result set maxdb_fetch_fields returns an array of resources representing the fields in a result set maxdb_fetch_field_direct fetch meta-data for a single field maxdb_fetch_lengths returns the lengths of the columns of the current row in the result set maxdb_fetch_object returns the current row of a result set as an object maxdb_fetch_row get a result row as an enumerated array maxdb_field_count returns the number of columns for the most recent query maxdb_field_seek set result pointer to a specified field offset maxdb_field_tell get current field offset of a result pointer maxdb_free_result frees the memory associated with a result maxdb_get_client_info returns the maxdb client version as a string maxdb_get_client_version get maxdb client info maxdb_get_host_info returns a string representing the type of connection used maxdb_get_metadata 别名 maxdb_stmt_result_metadata maxdb_get_proto_info returns the version of the maxdb protocol used maxdb_get_server_info returns the version of the maxdb server maxdb_get_server_version returns the version of the maxdb server as an integer maxdb_info retrieves information about the most recently executed query maxdb_init initializes maxdb and returns an resource for use with maxdb_real_connect maxdb_insert_id returns the auto generated id used in the last query maxdb_kill disconnects from a maxdb server maxdb_master_query enforce execution of a query on the master in a master/slave setup maxdb_more_results check if there any more query results from a multi query maxdb_multi_query performs a query on the database maxdb_next_result prepare next result from multi_query maxdb_num_fields get the number of fields in a result maxdb_num_rows gets the number of rows in a result maxdb_options set options maxdb_param_count 别名 maxdb_stmt_param_count maxdb_ping pings a server connection, or tries to reconnect if the connection has gone down maxdb_prepare prepare an sql statement for execution maxdb_query performs a query on the database maxdb_real_connect opens a connection to a maxdb server maxdb_real_escape_string escapes special characters in a string for use in an sql statement, taking into account the current charset of the connection maxdb_real_query execute an sql query maxdb_report enables or disables internal report functions maxdb_rollback rolls back current transaction maxdb_rpl_parse_enabled check if rpl parse is enabled maxdb_rpl_probe rpl probe maxdb_rpl_query_type returns rpl query type maxdb_select_db selects the default database for database queries maxdb_send_long_data 别名 maxdb_stmt_send_long_data maxdb_send_query send the query and return maxdb_server_end shut down the embedded server maxdb_server_init initialize embedded server maxdb_set_opt 别名 maxdb_options maxdb_sqlstate returns the sqlstate error from previous maxdb operation maxdb_ssl_set used for establishing secure connections using ssl maxdb_stat gets the current system status maxdb_stmt_affected_rows returns the total number of rows changed, deleted, or inserted by the last executed statement maxdb_stmt_bind_param binds variables to a prepared statement as parameters maxdb_stmt_bind_result binds variables to a prepared statement for result storage maxdb_stmt_close closes a prepared statement maxdb_stmt_close_long_data ends a sequence of maxdb_stmt_send_long_data maxdb_stmt_data_seek seeks to an arbitray row in statement result set maxdb_stmt_errno returns the error code for the most recent statement call maxdb_stmt_error returns a string description for last statement error maxdb_stmt_execute executes a prepared query maxdb_stmt_fetch fetch results from a prepared statement into the bound variables maxdb_stmt_free_result frees stored result memory for the given statement handle maxdb_stmt_init initializes a statement and returns an resource for use with maxdb_stmt_prepare maxdb_stmt_num_rows return the number of rows in statements result set maxdb_stmt_param_count returns the number of parameter for the given statement maxdb_stmt_prepare prepare an sql statement for execution maxdb_stmt_reset resets a prepared statement maxdb_stmt_result_metadata returns result set metadata from a prepared statement maxdb_stmt_send_long_data send data in blocks maxdb_stmt_sqlstate returns sqlstate error from previous statement operation maxdb_stmt_store_result transfers a result set from a prepared statement maxdb_store_result transfers a result set from the last query maxdb_thread_id returns the thread id for the current connection maxdb_thread_safe returns whether thread safety is given or not maxdb_use_result initiate a result set retrieval maxdb_warning_count returns the number of warnings from the last query for the given link mb_check_encoding 检查字符串在指定的编码里是否有效 mb_convert_case 对字符串进行大小写转换 mb_convert_encoding 转换字符的编码 mb_convert_kana convert “kana” one from another (“zen-kaku”, “han-kaku” and more) mb_convert_variables 转换一个或多个变量的字符编码 mb_decode_mimeheader 解码 mime 头字段中的字符串 mb_decode_numericentity 根据 html 数字字符串解码成字符 mb_detect_encoding 检测字符的编码 mb_detect_order 设置/获取 字符编码的检测顺序 mb_encode_mimeheader 为 mime 头编码字符串 mb_encode_numericentity encode character to html numeric string reference mb_encoding_aliases get aliases of a known encoding type mb_ereg regular expression match with multibyte support mb_eregi regular expression match ignoring case with multibyte support mb_eregi_replace replace regular expression with multibyte support ignoring case mb_ereg_match regular expression match for multibyte string mb_ereg_replace replace regular expression with multibyte support mb_ereg_replace_callback perform a regular expresssion seach and replace with multibyte support using a callback mb_ereg_search multibyte regular expression match for predefined multibyte string mb_ereg_search_getpos returns start point for next regular expression match mb_ereg_search_getregs retrieve the result from the last multibyte regular expression match mb_ereg_search_init setup string and regular expression for a multibyte regular expression match mb_ereg_search_pos returns position and length of a matched part of the multibyte regular expression for a predefined multibyte string mb_ereg_search_regs returns the matched part of a multibyte regular expression mb_ereg_search_setpos set start point of next regular expression match mb_get_info 获取 mbstring 的内部设置 mb_http_input 检测 http 输入字符编码 mb_http_output 设置/获取 http 输出字符编码 mb_internal_encoding 设置/获取内部字符编码 mb_language 设置/获取当前的语言 mb_list_encodings 返回所有支持编码的数组 mb_output_handler 在输出缓冲中转换字符编码的回调函数 mb_parse_str 解析 get/post/cookie 数据并设置全局变量 mb_preferred_mime_name 获取 mime 字符串 mb_regex_encoding set/get character encoding for multibyte regex mb_regex_set_options set/get the default options for mbregex functions mb_send_mail 发送编码过的邮件 mb_split 使用正则表达式分割多字节字符串 mb_strcut 获取字符的一部分 mb_strimwidth 获取按指定宽度截断的字符串 mb_stripos 大小写不敏感地查找字符串在另一个字符串中首次出现的位置 mb_stristr 大小写不敏感地查找字符串在另一个字符串里的首次出现 mb_strlen 获取字符串的长度 mb_strpos 查找字符串在另一个字符串中首次出现的位置 mb_strrchr 查找指定字符在另一个字符串中最后一次的出现 mb_strrichr 大小写不敏感地查找指定字符在另一个字符串中最后一次的出现 mb_strripos 大小写不敏感地在字符串中查找一个字符串最后出现的位置 mb_strrpos 查找字符串在一个字符串中最后出现的位置 mb_strstr 查找字符串在另一个字符串里的首次出现 mb_strtolower 使字符串小写 mb_strtoupper 使字符串大写 mb_strwidth 返回字符串的宽度 mb_substitute_character 设置/获取替代字符 mb_substr 获取字符串的部分 mb_substr_count 统计字符串出现的次数 mcrypt_cbc 以 cbc 模式加解密数据 mcrypt_cfb 以 cfb 模式加解密数据 mcrypt_create_iv 从随机源创建初始向量 mcrypt_decrypt 使用给定参数解密密文 mcrypt_ecb 已废弃：使用 ecb 模式加解密数据 mcrypt_encrypt 使用给定参数加密明文 mcrypt_enc_get_algorithms_name 返回打开的算法名称 mcrypt_enc_get_block_size 返回打开的算法的分组大小 mcrypt_enc_get_iv_size 返回打开的算法的初始向量大小 mcrypt_enc_get_key_size 返回打开的模式所能支持的最长密钥 mcrypt_enc_get_modes_name 返回打开的模式的名称 mcrypt_enc_get_supported_key_sizes 以数组方式返回打开的算法所支持的密钥长度 mcrypt_enc_is_block_algorithm 检测打开模式的算法是否为分组算法 mcrypt_enc_is_block_algorithm_mode 检测打开的模式是否支持分组加密 mcrypt_enc_is_block_mode 检测打开的模式是否以分组方式输出 mcrypt_enc_self_test 在打开的模块上进行自检 mcrypt_generic 加密数据 mcrypt_generic_deinit 对加密模块进行清理工作 mcrypt_generic_end 终止加密 mcrypt_generic_init 初始化加密所需的缓冲区 mcrypt_get_block_size 获得加密算法的分组大小 mcrypt_get_cipher_name 获取加密算法名称 mcrypt_get_iv_size 返回指定算法/模式组合的初始向量大小 mcrypt_get_key_size 获取指定加密算法的密钥大小 mcrypt_list_algorithms 获取支持的加密算法 mcrypt_list_modes 获取所支持的模式 mcrypt_module_close 关闭加密模块 mcrypt_module_get_algo_block_size 返回指定算法的分组大小 mcrypt_module_get_algo_key_size 获取打开模式所支持的最大密钥大小 mcrypt_module_get_supported_key_sizes 以数组形式返回打开的算法所支持的密钥大小 mcrypt_module_is_block_algorithm 检测指定算法是否为分组加密算法 mcrypt_module_is_block_algorithm_mode 返回指定模块是否是分组加密模式 mcrypt_module_is_block_mode 检测指定模式是否以分组方式输出 mcrypt_module_open 打开算法和模式对应的模块 mcrypt_module_self_test 在指定模块上执行自检 mcrypt_ofb 使用 ofb 模式加密/解密数据 md5 计算字符串的 md5 散列值 md5_file 计算指定文件的 md5 散列值 mdecrypt_generic 解密数据 memcache_debug 转换调试输出的开/关 memory_get_peak_usage 返回分配给 php 内存的峰值 memory_get_usage 返回分配给 php 的内存量 metaphone calculate the metaphone key of a string method_exists 检查类的方法是否存在 mhash computes hash mhash_count gets the highest available hash id mhash_get_block_size gets the block size of the specified hash mhash_get_hash_name gets the name of the specified hash mhash_keygen_s2k generates a key microtime 返回当前 unix 时间戳和微秒数 mime_content_type 检测文件的 mime 类型（已废弃） min 找出最小值 ming_keypress returns the action flag for keypress(char) ming_setcubicthreshold set cubic threshold ming_setscale set the global scaling factor. ming_setswfcompression sets the swf output compression ming_useconstants use constant pool ming_useswfversion sets the swf version mkdir 新建目录 mktime 取得一个日期的 unix 时间戳 money_format formats a number as a currency string mongodb context options mongodb context option listing mongodb\\bson\\fromjson returns the bson representation of a json value mongodb\\bson\\fromphp returns the bson representation of a php value mongodb\\bson\\tojson returns the json representation of a bson value mongodb\\bson\\tophp returns the php representation of a bson value move_uploaded_file 将上传的文件移动到新位置 mqseries_back mqseries mqback mqseries_begin mqseries mqbegin mqseries_close mqseries mqclose mqseries_cmit mqseries mqcmit mqseries_conn mqseries mqconn mqseries_connx mqseries mqconnx mqseries_disc mqseries mqdisc mqseries_get mqseries mqget mqseries_inq mqseries mqinq mqseries_open mqseries mqopen mqseries_put mqseries mqput mqseries_put1 mqseries mqput1 mqseries_set mqseries mqset mqseries_strerror returns the error message corresponding to a result code (mqrc). msession_connect connect to msession server msession_count get session count msession_create create a session msession_destroy destroy a session msession_disconnect close connection to msession server msession_find find all sessions with name and value msession_get get value from session msession_get_array get array of msession variables msession_get_data get data session unstructured data msession_inc increment value in session msession_list list all sessions msession_listvar list sessions with variable msession_lock lock a session msession_plugin call an escape function within the msession personality plugin msession_randstr get random string msession_set set value in session msession_set_array set msession variables from an array msession_set_data set data session unstructured data msession_timeout set/get session timeout msession_uniq get unique id msession_unlock unlock a session msg_get_queue create or attach to a message queue msg_queue_exists check whether a message queue exists msg_receive receive a message from a message queue msg_remove_queue destroy a message queue msg_send send a message to a message queue msg_set_queue set information in the message queue data structure msg_stat_queue returns information from the message queue data structure msql alias of msql_db_query msql_affected_rows returns number of affected rows msql_close close msql connection msql_connect open msql connection msql_createdb 别名 msql_create_db msql_create_db create msql database msql_data_seek move internal row pointer msql_dbname 别名 msql_result msql_db_query send msql query msql_drop_db drop (delete) msql database msql_error returns error message of last msql call msql_fetch_array fetch row as array msql_fetch_field get field information msql_fetch_object fetch row as object msql_fetch_row get row as enumerated array msql_fieldflags alias of msql_field_flags msql_fieldlen alias of msql_field_len msql_fieldname alias of msql_field_name msql_fieldtable alias of msql_field_table msql_fieldtype alias of msql_field_type msql_field_flags get field flags msql_field_len get field length msql_field_name get the name of the specified field in a result msql_field_seek set field offset msql_field_table get table name for field msql_field_type get field type msql_free_result free result memory msql_list_dbs list msql databases on server msql_list_fields list result fields msql_list_tables list tables in an msql database msql_numfields alias of msql_num_fields msql_numrows alias of msql_num_rows msql_num_fields get number of fields in result msql_num_rows get number of rows in result msql_pconnect open persistent msql connection msql_query send msql query msql_regcase alias of sql_regcase msql_result get result data msql_select_db select msql database msql_tablename alias of msql_result mssql_bind adds a parameter to a stored procedure or a remote stored procedure mssql_close 关闭ms sql server链接 mssql_connect 打开ms sql server链接 mssql_data_seek moves internal row pointer mssql_execute executes a stored procedure on a ms sql server database mssql_fetch_array fetch a result row as an associative array, a numeric array, or both mssql_fetch_assoc returns an associative array of the current row in the result mssql_fetch_batch returns the next batch of records mssql_fetch_field get field information mssql_fetch_object fetch row as object mssql_fetch_row get row as enumerated array mssql_field_length get the length of a field mssql_field_name get the name of a field mssql_field_seek seeks to the specified field offset mssql_field_type gets the type of a field mssql_free_result free result memory mssql_free_statement free statement memory mssql_get_last_message returns the last message from the server mssql_guid_string converts a 16 byte binary guid to a string mssql_init initializes a stored procedure or a remote stored procedure mssql_min_error_severity sets the minimum error severity mssql_min_message_severity sets the minimum message severity mssql_next_result move the internal result pointer to the next result mssql_num_fields gets the number of fields in result mssql_num_rows gets the number of rows in result mssql_pconnect open persistent ms sql connection mssql_query send ms sql query mssql_result get result data mssql_rows_affected returns the number of records affected by the query mssql_select_db select ms sql database mt_getrandmax 显示随机数的最大可能值 mt_rand 生成更好的随机数 mt_srand 播下一个更好的随机数发生器种子 mysqli_bind_param mysqli_stmt_bind_param的别名 mysqli_bind_result mysqli_stmt_bind_result的别名 mysqli_client_encoding mysqli_character_set_name的别名 mysqli_disable_rpl_parse 禁用rpl解析 mysqli_enable_reads_from_master 开启从主机读取 mysqli_enable_rpl_parse 开启rpl解析 mysqli_escape_string 别名 mysqli_real_escape_string mysqli_execute mysqli_stmt_execute的别名 mysqli_fetch mysqli_stmt_fetch的别名。 mysqli_get_cache_stats 返回客户端zval缓存统计信息 mysqli_get_client_stats returns client per-process statistics mysqli_get_client_version returns the mysql client version as an integer mysqli_get_links_stats return information about open and cached links mysqli_get_metadata mysqli_stmt_result_metadata的别名 mysqli_master_query 在主/从机制中强制在主机中执行一个查询 mysqli_param_count mysqli_stmt_param_count的别名 mysqli_report 开启或禁用（mysql）内部（错误）报告函数 mysqli_rpl_parse_enabled 检查是否开启了rpl解析 mysqli_rpl_probe rpl探测 mysqli_send_long_data mysqli_stmt_send_long_data的别名 mysqli_set_opt mysqli_options的别名 mysqli_slave_query 在主/从机制中强制在从机上执行一个查询 mysqlnd_memcache_get_config returns information about the plugin configuration mysqlnd_memcache_set associate a mysql connection with a memcache connection mysqlnd_ms_dump_servers returns a list of currently configured servers mysqlnd_ms_fabric_select_global switch to global sharding server for a given table mysqlnd_ms_fabric_select_shard switch to shard mysqlnd_ms_get_last_gtid 返回最后的全局同步 id (gtid) mysqlnd_ms_get_last_used_connection returns an array which describes the last used connection mysqlnd_ms_get_stats returns query distribution and connection statistics mysqlnd_ms_match_wild finds whether a table name matches a wildcard pattern or not mysqlnd_ms_query_is_select 查询给定的 sql 会发送给 master、slave 还是最后使用的 mysql server 执行。 mysqlnd_ms_set_qos sets the quality of service needed from the cluster mysqlnd_ms_set_user_pick_server sets a callback for user-defined read/write splitting mysqlnd_ms_xa_begin starts a distributed/xa transaction among mysql servers mysqlnd_ms_xa_commit commits a distributed/xa transaction among mysql servers mysqlnd_ms_xa_gc garbage collects unfinished xa transactions after severe errors mysqlnd_ms_xa_rollback rolls back a distributed/xa transaction among mysql servers mysqlnd_qc_clear_cache flush all cache contents mysqlnd_qc_get_available_handlers returns a list of available storage handler mysqlnd_qc_get_cache_info returns information on the current handler, the number of cache entries and cache entries, if available mysqlnd_qc_get_core_stats statistics collected by the core of the query cache mysqlnd_qc_get_normalized_query_trace_log returns a normalized query trace log for each query inspected by the query cache mysqlnd_qc_get_query_trace_log returns a backtrace for each query inspected by the query cache mysqlnd_qc_set_cache_condition set conditions for automatic caching mysqlnd_qc_set_is_select installs a callback which decides whether a statement is cached mysqlnd_qc_set_storage_handler change current storage handler mysqlnd_qc_set_user_handlers sets the callback functions for a user-defined procedural storage handler mysqlnd_uh_convert_to_mysqlnd converts a mysql connection handle into a mysqlnd connection handle mysqlnd_uh_set_connection_proxy installs a proxy for mysqlnd connections mysqlnd_uh_set_statement_proxy installs a proxy for mysqlnd statements mysql_affected_rows 取得前一次 mysql 操作所影响的记录行数 mysql_client_encoding 返回字符集的名称 mysql_close 关闭 mysql 连接 mysql_connect 打开一个到 mysql 服务器的连接 mysql_create_db 新建一个 mysql 数据库 mysql_data_seek 移动内部结果的指针 mysql_db_name 取得结果数据 mysql_db_query 发送一条 mysql 查询 mysql_drop_db 丢弃（删除）一个 mysql 数据库 mysql_errno 返回上一个 mysql 操作中的错误信息的数字编码 mysql_error 返回上一个 mysql 操作产生的文本错误信息 mysql_escape_string 转义一个字符串用于 mysql_query mysql_fetch_array 从结果集中取得一行作为关联数组，或数字数组，或二者兼有 mysql_fetch_assoc 从结果集中取得一行作为关联数组 mysql_fetch_field 从结果集中取得列信息并作为对象返回 mysql_fetch_lengths 取得结果集中每个输出的长度 mysql_fetch_object 从结果集中取得一行作为对象 mysql_fetch_row 从结果集中取得一行作为枚举数组 mysql_field_flags 从结果中取得和指定字段关联的标志 mysql_field_len 返回指定字段的长度 mysql_field_name 取得结果中指定字段的字段名 mysql_field_seek 将结果集中的指针设定为制定的字段偏移量 mysql_field_table 取得指定字段所在的表名 mysql_field_type 取得结果集中指定字段的类型 mysql_free_result 释放结果内存 mysql_get_client_info 取得 mysql 客户端信息 mysql_get_host_info 取得 mysql 主机信息 mysql_get_proto_info 取得 mysql 协议信息 mysql_get_server_info 取得 mysql 服务器信息 mysql_info 取得最近一条查询的信息 mysql_insert_id 取得上一步 insert 操作产生的 id mysql_list_dbs 列出 mysql 服务器中所有的数据库 mysql_list_fields 列出 mysql 结果中的字段 mysql_list_processes 列出 mysql 进程 mysql_list_tables 列出 mysql 数据库中的表 mysql_num_fields 取得结果集中字段的数目 mysql_num_rows 取得结果集中行的数目 mysql_pconnect 打开一个到 mysql 服务器的持久连接 mysql_ping ping 一个服务器连接，如果没有连接则重新连接 mysql_query 发送一条 mysql 查询 mysql_real_escape_string 转义 sql 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集 mysql_result 取得结果数据 mysql_select_db 选择 mysql 数据库 mysql_set_charset 设置客户端的字符集 mysql_stat 取得当前系统状态 mysql_tablename 取得表名 mysql_thread_id 返回当前线程的 id mysql_unbuffered_query 向 mysql 发送一条 sql 查询，并不获取和缓存结果的行 m_checkstatus check to see if a transaction has completed m_completeauthorizations number of complete authorizations in queue, returning an array of their identifiers m_connect establish the connection to mcve m_connectionerror get a textual representation of why a connection failed m_deletetrans delete specified transaction from mcve_conn structure m_destroyconn destroy the connection and mcve_conn structure m_destroyengine free memory associated with ip/ssl connectivity m_getcell get a specific cell from a comma delimited response by column name m_getcellbynum get a specific cell from a comma delimited response by column number m_getcommadelimited get the raw comma delimited data returned from mcve m_getheader get the name of the column in a comma-delimited response m_initconn create and initialize an mcve_conn structure m_initengine ready the client for ip/ssl communication m_iscommadelimited checks to see if response is comma delimited m_maxconntimeout the maximum amount of time the api will attempt a connection to mcve m_monitor perform communication with mcve (send/receive data) non-blocking m_numcolumns number of columns returned in a comma delimited response m_numrows number of rows returned in a comma delimited response m_parsecommadelimited parse the comma delimited response so m_getcell, etc will work m_responsekeys returns array of strings which represents the keys that can be used for response parameters on this transaction m_responseparam get a custom response parameter m_returnstatus check to see if the transaction was successful m_setblocking set blocking/non-blocking mode for connection m_setdropfile set the connection method to drop-file m_setip set the connection method to ip m_setssl set the connection method to ssl m_setssl_cafile set ssl ca (certificate authority) file for verification of server certificate m_setssl_files set certificate key files and certificates if server requires client certificate verification m_settimeout set maximum transaction time (per trans) m_sslcert_gen_hash generate hash for ssl client certificate verification m_transactionssent check to see if outgoing buffer is clear m_transinqueue number of transactions in client-queue m_transkeyval add key/value pair to a transaction. replaces deprecated transparam() m_transnew start a new transaction m_transsend finalize and send the transaction m_uwait wait x microsecs m_validateidentifier whether or not to validate the passed identifier on any transaction it is passed to m_verifyconnection set whether or not to ping upon connect to verify connection m_verifysslcert set whether or not to verify the server ssl certificate n 函数 说明 natcasesort 用“自然排序”算法对数组进行不区分大小写字母的排序 natsort 用“自然排序”算法对数组排序 ncurses_addch add character at current position and advance cursor ncurses_addchnstr add attributed string with specified length at current position ncurses_addchstr add attributed string at current position ncurses_addnstr add string with specified length at current position ncurses_addstr output text at current position ncurses_assume_default_colors define default colors for color 0 ncurses_attroff turn off the given attributes ncurses_attron turn on the given attributes ncurses_attrset set given attributes ncurses_baudrate returns baudrate of terminal ncurses_beep let the terminal beep ncurses_bkgd set background property for terminal screen ncurses_bkgdset control screen background ncurses_border draw a border around the screen using attributed characters ncurses_bottom_panel moves a visible panel to the bottom of the stack ncurses_can_change_color checks if terminal color definitions can be changed ncurses_cbreak switch off input buffering ncurses_clear clear screen ncurses_clrtobot clear screen from current position to bottom ncurses_clrtoeol clear screen from current position to end of line ncurses_color_content retrieves rgb components of a color ncurses_color_set set active foreground and background colors ncurses_curs_set set cursor state ncurses_define_key define a keycode ncurses_def_prog_mode saves terminals (program) mode ncurses_def_shell_mode saves terminals (shell) mode ncurses_delay_output delay output on terminal using padding characters ncurses_delch delete character at current position, move rest of line left ncurses_deleteln delete line at current position, move rest of screen up ncurses_delwin delete a ncurses window ncurses_del_panel remove panel from the stack and delete it (but not the associated window) ncurses_doupdate write all prepared refreshes to terminal ncurses_echo activate keyboard input echo ncurses_echochar single character output including refresh ncurses_end stop using ncurses, clean up the screen ncurses_erase erase terminal screen ncurses_erasechar returns current erase character ncurses_filter set lines for iniscr() and newterm() to 1 ncurses_flash flash terminal screen (visual bell) ncurses_flushinp flush keyboard input buffer ncurses_getch read a character from keyboard ncurses_getmaxyx returns the size of a window ncurses_getmouse reads mouse event ncurses_getyx returns the current cursor position for a window ncurses_halfdelay put terminal into halfdelay mode ncurses_has_colors checks if terminal has color capabilities ncurses_has_ic check for insert- and delete-capabilities ncurses_has_il check for line insert- and delete-capabilities ncurses_has_key check for presence of a function key on terminal keyboard ncurses_hide_panel remove panel from the stack, making it invisible ncurses_hline draw a horizontal line at current position using an attributed character and max. n characters long ncurses_inch get character and attribute at current position ncurses_init initialize ncurses ncurses_init_color define a terminal color ncurses_init_pair define a color pair ncurses_insch insert character moving rest of line including character at current position ncurses_insdelln insert lines before current line scrolling down (negative numbers delete and scroll up) ncurses_insertln insert a line, move rest of screen down ncurses_insstr insert string at current position, moving rest of line right ncurses_instr reads string from terminal screen ncurses_isendwin ncurses is in endwin mode, normal screen output may be performed ncurses_keyok enable or disable a keycode ncurses_keypad turns keypad on or off ncurses_killchar returns current line kill character ncurses_longname returns terminals description ncurses_meta enables/disable 8-bit meta key information ncurses_mouseinterval set timeout for mouse button clicks ncurses_mousemask sets mouse options ncurses_mouse_trafo transforms coordinates ncurses_move move output position ncurses_move_panel moves a panel so that its upper-left corner is at [startx, starty] ncurses_mvaddch move current position and add character ncurses_mvaddchnstr move position and add attributed string with specified length ncurses_mvaddchstr move position and add attributed string ncurses_mvaddnstr move position and add string with specified length ncurses_mvaddstr move position and add string ncurses_mvcur move cursor immediately ncurses_mvdelch move position and delete character, shift rest of line left ncurses_mvgetch move position and get character at new position ncurses_mvhline set new position and draw a horizontal line using an attributed character and max. n characters long ncurses_mvinch move position and get attributed character at new position ncurses_mvvline set new position and draw a vertical line using an attributed character and max. n characters long ncurses_mvwaddstr add string at new position in window ncurses_napms sleep ncurses_newpad creates a new pad (window) ncurses_newwin create a new window ncurses_new_panel create a new panel and associate it with window ncurses_nl translate newline and carriage return / line feed ncurses_nocbreak switch terminal to cooked mode ncurses_noecho switch off keyboard input echo ncurses_nonl do not translate newline and carriage return / line feed ncurses_noqiflush do not flush on signal characters ncurses_noraw switch terminal out of raw mode ncurses_pair_content retrieves foreground and background colors of a color pair ncurses_panel_above returns the panel above panel ncurses_panel_below returns the panel below panel ncurses_panel_window returns the window associated with panel ncurses_pnoutrefresh copies a region from a pad into the virtual screen ncurses_prefresh copies a region from a pad into the virtual screen ncurses_putp apply padding information to the string and output it ncurses_qiflush flush on signal characters ncurses_raw switch terminal into raw mode ncurses_refresh refresh screen ncurses_replace_panel replaces the window associated with panel ncurses_resetty restores saved terminal state ncurses_reset_prog_mode resets the prog mode saved by def_prog_mode ncurses_reset_shell_mode resets the shell mode saved by def_shell_mode ncurses_savetty saves terminal state ncurses_scrl scroll window content up or down without changing current position ncurses_scr_dump dump screen content to file ncurses_scr_init initialize screen from file dump ncurses_scr_restore restore screen from file dump ncurses_scr_set inherit screen from file dump ncurses_show_panel places an invisible panel on top of the stack, making it visible ncurses_slk_attr returns current soft label key attribute ncurses_slk_attroff turn off the given attributes for soft function-key labels ncurses_slk_attron turn on the given attributes for soft function-key labels ncurses_slk_attrset set given attributes for soft function-key labels ncurses_slk_clear clears soft labels from screen ncurses_slk_color sets color for soft label keys ncurses_slk_init initializes soft label key functions ncurses_slk_noutrefresh copies soft label keys to virtual screen ncurses_slk_refresh copies soft label keys to screen ncurses_slk_restore restores soft label keys ncurses_slk_set sets function key labels ncurses_slk_touch forces output when ncurses_slk_noutrefresh is performed ncurses_standend stop using ‘standout’ attribute ncurses_standout start using ‘standout’ attribute ncurses_start_color initializes color functionality ncurses_termattrs returns a logical or of all attribute flags supported by terminal ncurses_termname returns terminals (short)-name ncurses_timeout set timeout for special key sequences ncurses_top_panel moves a visible panel to the top of the stack ncurses_typeahead specify different filedescriptor for typeahead checking ncurses_ungetch put a character back into the input stream ncurses_ungetmouse pushes mouse event to queue ncurses_update_panels refreshes the virtual screen to reflect the relations between panels in the stack ncurses_use_default_colors assign terminal default colors to color id -1 ncurses_use_env control use of environment information about terminal size ncurses_use_extended_names control use of extended names in terminfo descriptions ncurses_vidattr display the string on the terminal in the video attribute mode ncurses_vline draw a vertical line at current position using an attributed character and max. n characters long ncurses_waddch adds character at current position in a window and advance cursor ncurses_waddstr outputs text at current postion in window ncurses_wattroff turns off attributes for a window ncurses_wattron turns on attributes for a window ncurses_wattrset set the attributes for a window ncurses_wborder draws a border around the window using attributed characters ncurses_wclear clears window ncurses_wcolor_set sets windows color pairings ncurses_werase erase window contents ncurses_wgetch reads a character from keyboard (window) ncurses_whline draws a horizontal line in a window at current position using an attributed character and max. n characters long ncurses_wmouse_trafo transforms window/stdscr coordinates ncurses_wmove moves windows output position ncurses_wnoutrefresh copies window to virtual screen ncurses_wrefresh refresh window on terminal screen ncurses_wstandend end standout mode for a window ncurses_wstandout enter standout mode for a window ncurses_wvline draws a vertical line in a window at current position using an attributed character and max. n characters long newt_bell send a beep to the terminal newt_button create a new button newt_button_bar this function returns a grid containing the buttons created. newt_centered_window open a centered window of the specified size newt_checkbox 说明 newt_checkbox_get_value retreives value of checkox resource newt_checkbox_set_flags configures checkbox resource newt_checkbox_set_value sets the value of the checkbox newt_checkbox_tree 说明 newt_checkbox_tree_add_item adds new item to the checkbox tree newt_checkbox_tree_find_item finds an item in the checkbox tree newt_checkbox_tree_get_current returns checkbox tree selected item newt_checkbox_tree_get_entry_value 说明 newt_checkbox_tree_get_multi_selection 说明 newt_checkbox_tree_get_selection 说明 newt_checkbox_tree_multi 说明 newt_checkbox_tree_set_current 说明 newt_checkbox_tree_set_entry 说明 newt_checkbox_tree_set_entry_value 说明 newt_checkbox_tree_set_width 说明 newt_clear_key_buffer discards the contents of the terminal’s input buffer without waiting for additional input newt_cls 说明 newt_compact_button 说明 newt_component_add_callback 说明 newt_component_takes_focus 说明 newt_create_grid 说明 newt_cursor_off 说明 newt_cursor_on 说明 newt_delay 说明 newt_draw_form 说明 newt_draw_root_text displays the string text at the position indicated newt_entry 说明 newt_entry_get_value 说明 newt_entry_set 说明 newt_entry_set_filter 说明 newt_entry_set_flags 说明 newt_finished uninitializes newt interface newt_form create a form newt_form_add_component adds a single component to the form newt_form_add_components add several components to the form newt_form_add_hot_key 说明 newt_form_destroy destroys a form newt_form_get_current 说明 newt_form_run runs a form newt_form_set_background 说明 newt_form_set_height 说明 newt_form_set_size 说明 newt_form_set_timer 说明 newt_form_set_width 说明 newt_form_watch_fd 说明 newt_get_screen_size fills in the passed references with the current size of the terminal newt_grid_add_components_to_form 说明 newt_grid_basic_window 说明 newt_grid_free 说明 newt_grid_get_size 说明 newt_grid_h_close_stacked 说明 newt_grid_h_stacked 说明 newt_grid_place 说明 newt_grid_set_field 说明 newt_grid_simple_window 说明 newt_grid_v_close_stacked 说明 newt_grid_v_stacked 说明 newt_grid_wrapped_window 说明 newt_grid_wrapped_window_at 说明 newt_init initialize newt newt_label 说明 newt_label_set_text 说明 newt_listbox 说明 newt_listbox_append_entry 说明 newt_listbox_clear 说明 newt_listbox_clear_selection 说明 newt_listbox_delete_entry 说明 newt_listbox_get_current 说明 newt_listbox_get_selection 说明 newt_listbox_insert_entry 说明 newt_listbox_item_count 说明 newt_listbox_select_item 说明 newt_listbox_set_current 说明 newt_listbox_set_current_by_key 说明 newt_listbox_set_data 说明 newt_listbox_set_entry 说明 newt_listbox_set_width 说明 newt_listitem 说明 newt_listitem_get_data 说明 newt_listitem_set 说明 newt_open_window open a window of the specified size and position newt_pop_help_line replaces the current help line with the one from the stack newt_pop_window removes the top window from the display newt_push_help_line saves the current help line on a stack, and displays the new line newt_radiobutton 说明 newt_radio_get_current 说明 newt_redraw_help_line 说明 newt_reflow_text 说明 newt_refresh updates modified portions of the screen newt_resize_screen 说明 newt_resume resume using the newt interface after calling newt_suspend newt_run_form runs a form newt_scale 说明 newt_scale_set 说明 newt_scrollbar_set 说明 newt_set_help_callback 说明 newt_set_suspend_callback set a callback function which gets invoked when user presses the suspend key newt_suspend tells newt to return the terminal to its initial state newt_textbox 说明 newt_textbox_get_num_lines 说明 newt_textbox_reflowed 说明 newt_textbox_set_height 说明 newt_textbox_set_text 说明 newt_vertical_scrollbar 说明 newt_wait_for_key doesn’t return until a key has been pressed newt_win_choice 说明 newt_win_entries 说明 newt_win_menu 说明 newt_win_message 说明 newt_win_messagev 说明 newt_win_ternary 说明 next 将数组中的内部指针向前移动一位 ngettext plural version of gettext nl2br 在字符串所有新行之前插入 html 换行标记 nl_langinfo query language and locale information nsapi_request_headers fetch all http request headers nsapi_response_headers fetch all http response headers nsapi_virtual perform an nsapi sub-request nthmac obtain a nthmac key (needs 2 arguments) number_format 以千位分隔符方式格式化一个数字 o 函数 说明 oauth_get_sbs 生成一个签名字符基串 oauth_urlencode 将 uri 编码为 rfc 3986 规范 ob_clean 清空（擦掉）输出缓冲区 ob_deflatehandler deflate output handler ob_end_clean 清空（擦除）缓冲区并关闭输出缓冲 ob_end_flush 冲刷出（送出）输出缓冲区内容并关闭缓冲 ob_etaghandler etag output handler ob_flush 冲刷出（送出）输出缓冲区中的内容 ob_get_clean 得到当前缓冲区的内容并删除当前输出缓。 ob_get_contents 返回输出缓冲区的内容 ob_get_flush 刷出（送出）缓冲区内容，以字符串形式返回内容，并关闭输出缓冲区。 ob_get_length 返回输出缓冲区内容的长度 ob_get_level 返回输出缓冲机制的嵌套级别 ob_get_status 得到所有输出缓冲区的状态 ob_gzhandler 在ob_start中使用的用来压缩输出缓冲区中内容的回调函数。ob_start callback function to gzip output buffer ob_iconv_handler 以输出缓冲处理程序转换字符编码 ob_implicit_flush 打开/关闭绝对刷送 ob_inflatehandler inflate output handler ob_list_handlers 列出所有使用中的输出处理程序。 ob_start 打开输出控制缓冲 ob_tidyhandler ob_start callback function to repair the buffer ocibindbyname 别名 oci_bind_by_name ocicancel 别名 oci_cancel ocicolumnisnull 别名 oci_field_is_null ocicolumnname 别名 oci_field_name ocicolumnprecision 别名 oci_field_precision ocicolumnscale 别名 oci_field_scale ocicolumnsize 别名 oci_field_size ocicolumntype 别名 oci_field_type ocicolumntyperaw 别名 oci_field_type_raw ocicommit 别名 oci_commit ocidefinebyname 别名 oci_define_by_name ocierror 别名 oci_error ociexecute 别名 oci_execute ocifetch 别名 oci_fetch ocifetchinto obsolete variant of oci_fetch_array, oci_fetch_object, oci_fetch_assoc and oci_fetch_row ocifetchstatement 别名 oci_fetch_all ocifreecursor 别名 oci_free_statement ocifreestatement 别名 oci_free_statement ociinternaldebug 别名 oci_internal_debug ocilogoff 别名 oci_close ocilogon 别名 oci_connect ocinewcollection 别名 oci_new_collection ocinewcursor 别名 oci_new_cursor ocinewdescriptor 别名 oci_new_descriptor ocinlogon 别名 oci_new_connect ocinumcols 别名 oci_num_fields ociparse 别名 oci_parse ociplogon 别名 oci_pconnect ociresult 别名 oci_result ocirollback 别名 oci_rollback ocirowcount 别名 oci_num_rows ociserverversion 别名 oci_server_version ocisetprefetch 别名 oci_set_prefetch ocistatementtype 别名 oci_statement_type oci_bind_array_by_name binds a php array to an oracle pl/sql array parameter oci_bind_by_name 绑定一个 php 变量到一个 oracle 位置标志符 oci_cancel 中断游标读取数据 oci_client_version returns the oracle client library version oci_close 关闭 oracle 连接 oci_commit 提交未执行的事务处理 oci_connect 建立一个到 oracle 服务器的连接 oci_define_by_name 在 select 中使用 php 变量作为定义的步骤 oci_error 返回上一个错误 oci_execute 执行一条语句 oci_fetch fetches the next row into result-buffer oci_fetch_all 获取结果数据的所有行到一个数组 oci_fetch_array returns the next row from a query as an associative or numeric array oci_fetch_assoc returns the next row from a query as an associative array oci_fetch_object returns the next row from a query as an object oci_fetch_row returns the next row from a query as a numeric array oci_field_is_null 检查字段是否为 null oci_field_name 返回字段名 oci_field_precision 返回字段精度 oci_field_scale 返回字段范围 oci_field_size 返回字段大小 oci_field_type 返回字段的数据类型 oci_field_type_raw 返回字段的原始 oracle 数据类型 oci_free_descriptor frees a descriptor oci_free_statement 释放关联于语句或游标的所有资源 oci_get_implicit_resultset returns the next child statement resource from a parent statement resource that has oracle database 12c implicit result sets oci_internal_debug 打开或关闭内部调试输出 oci_lob_copy copies large object oci_lob_is_equal compares two lob/file locators for equality oci_new_collection 分配新的 collection 对象 oci_new_connect 建定一个到 oracle 服务器的新连接 oci_new_cursor 分配并返回一个新的游标（语句句柄） oci_new_descriptor 初始化一个新的空 lob 或 file 描述符 oci_num_fields 返回结果列的数目 oci_num_rows 返回语句执行后受影响的行数 oci_parse 配置 oracle 语句预备执行 oci_password_change 修改 oracle 用户的密码 oci_pconnect 使用一个持久连接连到 oracle 数据库 oci_result 返回所取得行中字段的值 oci_rollback 回滚未提交的事务 oci_server_version 返回服务器版本信息 oci_set_action sets the action name oci_set_client_identifier sets the client identifier oci_set_client_info sets the client information oci_set_edition sets the database edition oci_set_module_name sets the module name oci_set_prefetch 设置预提取行数 oci_statement_type 返回 oci 语句的类型 octdec 八进制转换为十进制 odbc_autocommit toggle autocommit behaviour odbc_binmode handling of binary column data odbc_close close an odbc connection odbc_close_all close all odbc connections odbc_columnprivileges lists columns and associated privileges for the given table odbc_columns lists the column names in specified tables odbc_commit commit an odbc transaction odbc_connect connect to a datasource odbc_cursor get cursorname odbc_data_source returns information about a current connection odbc_do 别名 odbc_exec odbc_error get the last error code odbc_errormsg get the last error message odbc_exec prepare and execute an sql statement odbc_execute execute a prepared statement odbc_fetch_array fetch a result row as an associative array odbc_fetch_into fetch one result row into array odbc_fetch_object fetch a result row as an object odbc_fetch_row fetch a row odbc_field_len get the length (precision) of a field odbc_field_name get the columnname odbc_field_num return column number odbc_field_precision 别名 odbc_field_len odbc_field_scale get the scale of a field odbc_field_type datatype of a field odbc_foreignkeys retrieves a list of foreign keys odbc_free_result free resources associated with a result odbc_gettypeinfo retrieves information about data types supported by the data source odbc_longreadlen handling of long columns odbc_next_result checks if multiple results are available odbc_num_fields number of columns in a result odbc_num_rows number of rows in a result odbc_pconnect open a persistent database connection odbc_prepare prepares a statement for execution odbc_primarykeys gets the primary keys for a table odbc_procedurecolumns retrieve information about parameters to procedures odbc_procedures get the list of procedures stored in a specific data source odbc_result get result data odbc_result_all print result as html table odbc_rollback rollback a transaction odbc_setoption adjust odbc settings odbc_specialcolumns retrieves special columns odbc_statistics retrieve statistics about a table odbc_tableprivileges lists tables and the privileges associated with each table odbc_tables get the list of table names stored in a specific data source opcache_compile_file 无需运行，即可编译并缓存 php 脚本 opcache_get_configuration 获取缓存的配置信息 opcache_get_status 获取缓存的状态信息 opcache_invalidate 废除脚本缓存 opcache_is_script_cached tells whether a script is cached in opcache opcache_reset 重置字节码缓存的内容 openal_buffer_create generate openal buffer openal_buffer_data load a buffer with data openal_buffer_destroy destroys an openal buffer openal_buffer_get retrieve an openal buffer property openal_buffer_loadwav load a .wav file into a buffer openal_context_create create an audio processing context openal_context_current make the specified context current openal_context_destroy destroys a context openal_context_process process the specified context openal_context_suspend suspend the specified context openal_device_close close an openal device openal_device_open initialize the openal audio layer openal_listener_get retrieve a listener property openal_listener_set set a listener property openal_source_create generate a source resource openal_source_destroy destroy a source resource openal_source_get retrieve an openal source property openal_source_pause pause the source openal_source_play start playing the source openal_source_rewind rewind the source openal_source_set set source property openal_source_stop stop playing the source openal_stream begin streaming on a source opendir 打开目录句柄 openlog open connection to system logger openssl_cipher_iv_length gets the cipher iv length openssl_csr_export exports a csr as a string openssl_csr_export_to_file exports a csr to a file openssl_csr_get_public_key returns the public key of a cert openssl_csr_get_subject returns the subject of a cert openssl_csr_new generates a csr openssl_csr_sign sign a csr with another certificate (or itself) and generate a certificate openssl_decrypt decrypts data openssl_dh_compute_key computes shared secret for public value of remote dh key and local dh key openssl_digest computes a digest openssl_encrypt encrypts data openssl_error_string return openssl error message openssl_free_key free key resource openssl_get_cert_locations retrieve the available certificate locations openssl_get_cipher_methods gets available cipher methods openssl_get_md_methods gets available digest methods openssl_get_privatekey 别名 openssl_pkey_get_private openssl_get_publickey 别名 openssl_pkey_get_public openssl_open open sealed data openssl_pbkdf2 generates a pkcs5 v2 pbkdf2 string, defaults to sha-1 openssl_pkcs7_decrypt decrypts an s/mime encrypted message openssl_pkcs7_encrypt encrypt an s/mime message openssl_pkcs7_sign sign an s/mime message openssl_pkcs7_verify verifies the signature of an s/mime signed message openssl_pkcs12_export exports a pkcs#12 compatible certificate store file to variable. openssl_pkcs12_export_to_file exports a pkcs#12 compatible certificate store file openssl_pkcs12_read parse a pkcs#12 certificate store into an array openssl_pkey_export gets an exportable representation of a key into a string openssl_pkey_export_to_file gets an exportable representation of a key into a file openssl_pkey_free frees a private key openssl_pkey_get_details returns an array with the key details openssl_pkey_get_private get a private key openssl_pkey_get_public extract public key from certificate and prepare it for use openssl_pkey_new generates a new private key openssl_private_decrypt decrypts data with private key openssl_private_encrypt encrypts data with private key openssl_public_decrypt decrypts data with public key openssl_public_encrypt encrypts data with public key openssl_random_pseudo_bytes generate a pseudo-random string of bytes openssl_seal seal (encrypt) data openssl_sign generate signature openssl_spki_export exports a valid pem formatted public key signed public key and challenge openssl_spki_export_challenge exports the challenge assoicated with a signed public key and challenge openssl_spki_new generate a new signed public key and challenge openssl_spki_verify verifies a signed public key and challenge openssl_verify verify signature openssl_x509_checkpurpose verifies if a certificate can be used for a particular purpose openssl_x509_check_private_key checks if a private key corresponds to a certificate openssl_x509_export exports a certificate as a string openssl_x509_export_to_file exports a certificate to file openssl_x509_fingerprint calculates the fingerprint, or digest, of a given x.509 certificate openssl_x509_free free certificate resource openssl_x509_parse parse an x509 certificate and return the information as an array openssl_x509_read parse an x.509 certificate and return a resource identifier for it ord 返回字符的 ascii 码值 output_add_rewrite_var 添加url重写器的值（add url rewriter values） output_reset_rewrite_vars 重设url重写器的值（reset url rewriter values） override_function overrides built-in functions p 函数 说明 pack pack data into binary string parsekit_compile_file compile a php file and return the resulting op array parsekit_compile_string compile a string of php code and return the resulting op array parsekit_func_arginfo return information regarding function argument(s) parse_ini_file 解析一个配置文件 parse_ini_string parse a configuration string parse_str 将字符串解析成多个变量 parse_url 解析 url，返回其组成部分 passthru 执行外部程序并且显示原始输出 password_get_info returns information about the given hash password_hash creates a password hash password_needs_rehash checks if the given hash matches the given options password_verify verifies that a password matches a hash pathinfo 返回文件路径的信息 pclose 关闭进程文件指针 pcntl_alarm 为进程设置一个alarm闹钟信号 pcntl_errno 别名 pcntl_strerror pcntl_exec 在当前进程空间执行指定程序 pcntl_fork 在当前进程当前位置产生分支（子进程）。译注：fork是创建了一个子进程，父进程和子进程 都从fork的位置开始向下继续执行，不同的是父进程执行过程中，得到的fork返回值为子进程 号，而子进程得到的是0。 pcntl_getpriority 获取任意进程的优先级 pcntl_get_last_error retrieve the error number set by the last pcntl function which failed pcntl_setpriority 修改任意进程的优先级 pcntl_signal 安装一个信号处理器 pcntl_signal_dispatch 调用等待信号的处理器 pcntl_sigprocmask 设置或检索阻塞信号 pcntl_sigtimedwait 带超时机制的信号等待 pcntl_sigwaitinfo 等待信号 pcntl_strerror retrieve the system error message associated with the given errno pcntl_wait 等待或返回fork的子进程状态 pcntl_waitpid 等待或返回fork的子进程状态 pcntl_wexitstatus 返回一个中断的子进程的返回代码 pcntl_wifexited 检查状态代码是否代表一个正常的退出。 pcntl_wifsignaled 检查子进程状态码是否代表由于某个信号而中断 pcntl_wifstopped 检查子进程当前是否已经停止 pcntl_wstopsig 返回导致子进程停止的信号 pcntl_wtermsig 返回导致子进程中断的信号 pdf_activate_item activate structure element or other content item pdf_add_annotation add annotation [deprecated] pdf_add_bookmark add bookmark for current page [deprecated] pdf_add_launchlink add launch annotation for current page [deprecated] pdf_add_locallink add link annotation for current page [deprecated] pdf_add_nameddest create named destination pdf_add_note set annotation for current page [deprecated] pdf_add_outline add bookmark for current page [deprecated] pdf_add_pdflink add file link annotation for current page [deprecated] pdf_add_table_cell add a cell to a new or existing table pdf_add_textflow create textflow or add text to existing textflow pdf_add_thumbnail add thumbnail for current page pdf_add_weblink add weblink for current page [deprecated] pdf_arc draw a counterclockwise circular arc segment pdf_arcn draw a clockwise circular arc segment pdf_attach_file add file attachment for current page [deprecated] pdf_begin_document create new pdf file pdf_begin_font start a type 3 font definition pdf_begin_glyph start glyph definition for type 3 font pdf_begin_item open structure element or other content item pdf_begin_layer start layer pdf_begin_page start new page [deprecated] pdf_begin_page_ext start new page pdf_begin_pattern start pattern definition pdf_begin_template start template definition [deprecated] pdf_begin_template_ext start template definition pdf_circle draw a circle pdf_clip clip to current path pdf_close close pdf resource [deprecated] pdf_closepath close current path pdf_closepath_fill_stroke close, fill and stroke current path pdf_closepath_stroke close and stroke path pdf_close_image close image pdf_close_pdi close the input pdf document [deprecated] pdf_close_pdi_page close the page handle pdf_concat concatenate a matrix to the ctm pdf_continue_text output text in next line pdf_create_3dview create 3d view pdf_create_action create action for objects or events pdf_create_annotation create rectangular annotation pdf_create_bookmark create bookmark pdf_create_field create form field pdf_create_fieldgroup create form field group pdf_create_gstate create graphics state object pdf_create_pvf create pdflib virtual file pdf_create_textflow create textflow object pdf_curveto draw bezier curve pdf_define_layer create layer definition pdf_delete delete pdflib object pdf_delete_pvf delete pdflib virtual file pdf_delete_table delete table object pdf_delete_textflow delete textflow object pdf_encoding_set_char add glyph name and/or unicode value pdf_endpath end current path pdf_end_document close pdf file pdf_end_font terminate type 3 font definition pdf_end_glyph terminate glyph definition for type 3 font pdf_end_item close structure element or other content item pdf_end_layer deactivate all active layers pdf_end_page finish page pdf_end_page_ext finish page pdf_end_pattern finish pattern pdf_end_template finish template pdf_fill fill current path pdf_fill_imageblock fill image block with variable data pdf_fill_pdfblock fill pdf block with variable data pdf_fill_stroke fill and stroke path pdf_fill_textblock fill text block with variable data pdf_findfont prepare font for later use [deprecated] pdf_fit_image place image or template pdf_fit_pdi_page place imported pdf page pdf_fit_table place table on page pdf_fit_textflow format textflow in rectangular area pdf_fit_textline place single line of text pdf_get_apiname get name of unsuccessfull api function pdf_get_buffer get pdf output buffer pdf_get_errmsg get error text pdf_get_errnum get error number pdf_get_font get font [deprecated] pdf_get_fontname get font name [deprecated] pdf_get_fontsize font handling [deprecated] pdf_get_image_height get image height [deprecated] pdf_get_image_width get image width [deprecated] pdf_get_majorversion get major version number [deprecated] pdf_get_minorversion get minor version number [deprecated] pdf_get_parameter get string parameter pdf_get_pdi_parameter get pdi string parameter [deprecated] pdf_get_pdi_value get pdi numerical parameter [deprecated] pdf_get_value get numerical parameter pdf_info_font query detailed information about a loaded font pdf_info_matchbox query matchbox information pdf_info_table retrieve table information pdf_info_textflow query textflow state pdf_info_textline perform textline formatting and query metrics pdf_initgraphics reset graphic state pdf_lineto draw a line pdf_load_3ddata load 3d model pdf_load_font search and prepare font pdf_load_iccprofile search and prepare icc profile pdf_load_image open image file pdf_makespotcolor make spot color pdf_moveto set current point pdf_new create pdflib object pdf_open_ccitt open raw ccitt image [deprecated] pdf_open_file create pdf file [deprecated] pdf_open_gif open gif image [deprecated] pdf_open_image use image data [deprecated] pdf_open_image_file read image from file [deprecated] pdf_open_jpeg open jpeg image [deprecated] pdf_open_memory_image open image created with php’s image functions [not supported] pdf_open_pdi open pdf file [deprecated] pdf_open_pdi_document prepare a pdi document pdf_open_pdi_page prepare a page pdf_open_tiff open tiff image [deprecated] pdf_pcos_get_number get value of pcos path with type number or boolean pdf_pcos_get_stream get contents of pcos path with type stream, fstream, or string pdf_pcos_get_string get value of pcos path with type name, string, or boolean pdf_place_image place image on the page [deprecated] pdf_place_pdi_page place pdf page [deprecated] pdf_process_pdi process imported pdf document pdf_rect draw rectangle pdf_restore restore graphics state pdf_resume_page resume page pdf_rotate rotate coordinate system pdf_save save graphics state pdf_scale scale coordinate system pdf_setcolor set fill and stroke color pdf_setdash set simple dash pattern pdf_setdashpattern set dash pattern pdf_setflat set flatness pdf_setfont set font pdf_setgray set color to gray [deprecated] pdf_setgray_fill set fill color to gray [deprecated] pdf_setgray_stroke set stroke color to gray [deprecated] pdf_setlinecap set linecap parameter pdf_setlinejoin set linejoin parameter pdf_setlinewidth set line width pdf_setmatrix set current transformation matrix pdf_setmiterlimit set miter limit pdf_setpolydash set complicated dash pattern [deprecated] pdf_setrgbcolor set fill and stroke rgb color values [deprecated] pdf_setrgbcolor_fill set fill rgb color values [deprecated] pdf_setrgbcolor_stroke set stroke rgb color values [deprecated] pdf_set_border_color set border color of annotations [deprecated] pdf_set_border_dash set border dash style of annotations [deprecated] pdf_set_border_style set border style of annotations [deprecated] pdf_set_char_spacing set character spacing [deprecated] pdf_set_duration set duration between pages [deprecated] pdf_set_gstate activate graphics state object pdf_set_horiz_scaling set horizontal text scaling [deprecated] pdf_set_info fill document info field pdf_set_info_author fill the author document info field [deprecated] pdf_set_info_creator fill the creator document info field [deprecated] pdf_set_info_keywords fill the keywords document info field [deprecated] pdf_set_info_subject fill the subject document info field [deprecated] pdf_set_info_title fill the title document info field [deprecated] pdf_set_layer_dependency define relationships among layers pdf_set_leading set distance between text lines [deprecated] pdf_set_parameter set string parameter pdf_set_text_matrix set text matrix [deprecated] pdf_set_text_pos set text position pdf_set_text_rendering determine text rendering [deprecated] pdf_set_text_rise set text rise [deprecated] pdf_set_value set numerical parameter pdf_set_word_spacing set spacing between words [deprecated] pdf_shading define blend pdf_shading_pattern define shading pattern pdf_shfill fill area with shading pdf_show output text at current position pdf_show_boxed output text in a box [deprecated] pdf_show_xy output text at given position pdf_skew skew the coordinate system pdf_stringwidth return width of text pdf_stroke stroke path pdf_suspend_page suspend page pdf_translate set origin of coordinate system pdf_utf8_to_utf16 convert string from utf-8 to utf-16 pdf_utf16_to_utf8 convert string from utf-16 to utf-8 pdf_utf32_to_utf16 convert string from utf-32 to utf-16 pdo_4d dsn connecting to 4d sql server pdo_cubrid dsn connecting to cubrid databases pdo_dblib dsn connecting to microsoft sql server and sybase databases pdo_firebird dsn connecting to firebird databases pdo_ibm dsn connecting to ibm databases pdo_informix dsn connecting to informix databases pdo_mysql dsn connecting to mysql databases pdo_oci dsn connecting to oracle databases pdo_odbc dsn connecting to odbc or db2 databases pdo_pgsql dsn connecting to postgresql databases pdo_sqlite dsn connecting to sqlite databases pdo_sqlsrv dsn connecting to ms sql server and sql azure databases pfsockopen 打开一个持久的网络连接或者unix套接字连接。 pg_affected_rows 返回受影响的记录数目 pg_cancel_query 取消异步查询 pg_client_encoding 取得客户端编码方式 pg_close 关闭一个 postgresql 连接 pg_connect 打开一个 postgresql 连接 pg_connection_busy 获知连接是否为忙 pg_connection_reset 重置连接（再次连接） pg_connection_status 获得连接状态 pg_connect_poll poll the status of an in-progress asynchronous postgresql connection attempt. pg_consume_input reads input on the connection pg_convert 将关联的数组值转换为适合 sql 语句的格式。 pg_copy_from 根据数组将记录插入表中 pg_copy_to 将一个表拷贝到数组中 pg_dbname 获得数据库名 pg_delete 删除记录 pg_end_copy 与 postgresql 后端同步 pg_escape_bytea 转义 bytea 类型的二进制数据 pg_escape_identifier escape a identifier for insertion into a text field pg_escape_literal escape a literal for insertion into a text field pg_escape_string 转义 text/char 类型的字符串 pg_execute sends a request to execute a prepared statement with given parameters, and waits for the result. pg_fetch_all 从结果中提取所有行作为一个数组 pg_fetch_all_columns fetches all rows in a particular result column as an array pg_fetch_array 提取一行作为数组 pg_fetch_assoc 提取一行作为关联数组 pg_fetch_object 提取一行作为对象 pg_fetch_result 从结果资源中返回值 pg_fetch_row 提取一行作为枚举数组 pg_field_is_null 测试字段是否为 null pg_field_name 返回字段的名字 pg_field_num 返回字段的编号 pg_field_prtlen 返回打印出来的长度 pg_field_size 返回指定字段占用内部存储空间的大小 pg_field_table returns the name or oid of the tables field pg_field_type 返回相应字段的类型名称 pg_field_type_oid returns the type id (oid) for the corresponding field number pg_flush flush outbound query data on the connection pg_free_result 释放查询结果占用的内存 pg_get_notify ping 数据库连接 pg_get_pid ping 数据库连接 pg_get_result 取得异步查询结果 pg_host 返回和某连接关联的主机名 pg_insert 将数组插入到表中 pg_last_error 得到某连接的最后一条错误信息 pg_last_notice 返回 postgresql 服务器最新一条公告信息 pg_last_oid 返回上一个对象的 oid pg_lo_close 关闭一个大型对象 pg_lo_create 新建一个大型对象 pg_lo_export 将大型对象导出到文件 pg_lo_import 将文件导入为大型对象 pg_lo_open 打开一个大型对象 pg_lo_read 从大型对象中读入数据 pg_lo_read_all 读入整个大型对象并直接发送给浏览器 pg_lo_seek 移动大型对象中的指针 pg_lo_tell 返回大型对象的当前指针位置 pg_lo_truncate truncates a large object pg_lo_unlink 删除一个大型对象 pg_lo_write 向大型对象写入数据 pg_meta_data 获得表的元数据 pg_num_fields 返回字段的数目 pg_num_rows 返回行的数目 pg_options 获得和连接有关的选项 pg_parameter_status looks up a current parameter setting of the server. pg_pconnect 打开一个持久的 postgresql 连接 pg_ping ping 数据库连接 pg_port 返回该连接的端口号 pg_prepare submits a request to create a prepared statement with the given parameters, and waits for completion. pg_put_line 向 postgresql 后端发送以 null 结尾的字符串 pg_query 执行查询 pg_query_params submits a command to the server and waits for the result, with the ability to pass parameters separately from the sql command text. pg_result_error 获得查询结果的错误信息 pg_result_error_field returns an individual field of an error report. pg_result_seek 在结果资源中设定内部行偏移量 pg_result_status 获得查询结果的状态 pg_select 选择记录 pg_send_execute sends a request to execute a prepared statement with given parameters, without waiting for the result(s). pg_send_prepare sends a request to create a prepared statement with the given parameters, without waiting for completion. pg_send_query 发送异步查询 pg_send_query_params submits a command and separate parameters to the server without waiting for the result(s). pg_set_client_encoding 设定客户端编码 pg_set_error_verbosity determines the verbosity of messages returned by pg_last_error and pg_result_error. pg_socket get a read only handle to the socket underlying a postgresql connection pg_trace 启动一个 postgresql 连接的追踪功能 pg_transaction_status returns the current in-transaction status of the server. pg_tty 返回该连接的 tty 号 pg_unescape_bytea 取消 bytea 类型中的字符串转义 pg_untrace 关闭 postgresql 连接的追踪功能 pg_update 更新表 pg_version returns an array with client, protocol and server version (when available) pharexception the pharexception class provides a phar-specific exception class for try/catch blocks. phar 上下文（context）选项 phar 上下文（context）选项列表 phpcredits 打印 php 贡献者名单 phpinfo 输出关于 php 配置的信息 phpversion 获取当前的php版本 php_check_syntax 检查php的语法（并执行）指定的文件 php_ini_loaded_file 取得已加载的 php.ini 文件的路径 php_ini_scanned_files 返回从额外 ini 目录里解析的 .ini 文件列表 php_logo_guid 获取 logo 的 guid php_sapi_name 返回 web 服务器和 php 之间的接口类型 php_strip_whitespace 返回删除注释和空格后的php源码 php_uname 返回运行 php 的系统的有关信息 pi 得到圆周率值 png2wbmp 将 png 图像文件转换为 wbmp 图像文件 popen 打开进程文件指针 pos current 的别名 posix_access determine accessibility of a file posix_ctermid get path name of controlling terminal posix_errno 别名 posix_get_last_error posix_getcwd pathname of current directory posix_getegid return the effective group id of the current process posix_geteuid return the effective user id of the current process posix_getgid return the real group id of the current process posix_getgrgid return info about a group by group id posix_getgrnam return info about a group by name posix_getgroups return the group set of the current process posix_getlogin return login name posix_getpgid get process group id for job control posix_getpgrp return the current process group identifier posix_getpid 返回当前进程 id posix_getppid return the parent process identifier posix_getpwnam return info about a user by username posix_getpwuid return info about a user by user id posix_getrlimit return info about system resource limits posix_getsid get the current sid of the process posix_getuid return the real user id of the current process posix_get_last_error retrieve the error number set by the last posix function that failed posix_initgroups calculate the group access list posix_isatty determine if a file descriptor is an interactive terminal posix_kill send a signal to a process posix_mkfifo create a fifo special file (a named pipe) posix_mknod create a special or ordinary file (posix.1) posix_setegid set the effective gid of the current process posix_seteuid set the effective uid of the current process posix_setgid set the gid of the current process posix_setpgid set process group id for job control posix_setrlimit set system resource limits posix_setsid make the current process a session leader posix_setuid set the uid of the current process posix_strerror retrieve the system error message associated with the given errno posix_times get process times posix_ttyname determine terminal device name posix_uname get system name pow 指数表达式 preg_filter 执行一个正则表达式搜索和替换 preg_grep 返回匹配模式的数组条目 preg_last_error 返回最后一个pcre正则执行产生的错误代码 preg_match 执行一个正则表达式匹配 preg_match_all 执行一个全局正则表达式匹配 preg_quote 转义正则表达式字符 preg_replace 执行一个正则表达式的搜索和替换 preg_replace_callback 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace_callback_array perform a regular expression search and replace using callbacks preg_split 通过一个正则表达式分隔字符串 prev 将数组的内部指针倒回一位 print 输出字符串 printf 输出格式化字符串 print_r 打印关于变量的易于理解的信息。 proc_close 关闭由 proc_open 打开的进程并且返回进程退出码 proc_get_status 获取由 proc_open 函数打开的进程的信息 proc_nice 修改当前进程的优先级 proc_open 执行一个命令，并且打开用来输入/输出的文件指针。 proc_terminate 杀除由 proc_open 打开的进程 property_exists 检查对象或类是否具有该属性 pspell_add_to_personal add the word to a personal wordlist pspell_add_to_session add the word to the wordlist in the current session pspell_check check a word pspell_clear_session clear the current session pspell_config_create create a config used to open a dictionary pspell_config_data_dir location of language data files pspell_config_dict_dir location of the main word list pspell_config_ignore ignore words less than n characters long pspell_config_mode change the mode number of suggestions returned pspell_config_personal set a file that contains personal wordlist pspell_config_repl set a file that contains replacement pairs pspell_config_runtogether consider run-together words as valid compounds pspell_config_save_repl determine whether to save a replacement pairs list along with the wordlist pspell_new load a new dictionary pspell_new_config load a new dictionary with settings based on a given config pspell_new_personal load a new dictionary with personal wordlist pspell_save_wordlist save the personal wordlist to a file pspell_store_replacement store a replacement pair for a word pspell_suggest suggest spellings of a word ps_add_bookmark add bookmark to current page ps_add_launchlink adds link which launches file ps_add_locallink adds link to a page in the same document ps_add_note adds note to current page ps_add_pdflink adds link to a page in a second pdf document ps_add_weblink adds link to a web location ps_arc draws an arc counterclockwise ps_arcn draws an arc clockwise ps_begin_page start a new page ps_begin_pattern start a new pattern ps_begin_template start a new template ps_circle draws a circle ps_clip clips drawing to current path ps_close closes a postscript document ps_closepath closes path ps_closepath_stroke closes and strokes path ps_close_image closes image and frees memory ps_continue_text continue text in next line ps_curveto draws a curve ps_delete deletes all resources of a postscript document ps_end_page end a page ps_end_pattern end a pattern ps_end_template end a template ps_fill fills the current path ps_fill_stroke fills and strokes the current path ps_findfont loads a font ps_get_buffer fetches the full buffer containig the generated ps data ps_get_parameter gets certain parameters ps_get_value gets certain values ps_hyphenate hyphenates a word ps_include_file reads an external file with raw postscript code ps_lineto draws a line ps_makespotcolor create spot color ps_moveto sets current point ps_new creates a new postscript document object ps_open_file opens a file for output ps_open_image reads an image for later placement ps_open_image_file opens image from file ps_open_memory_image takes an gd image and returns an image for placement in a ps document ps_place_image places image on the page ps_rect draws a rectangle ps_restore restore previously save context ps_rotate sets rotation factor ps_save save current context ps_scale sets scaling factor ps_setcolor sets current color ps_setdash sets appearance of a dashed line ps_setflat sets flatness ps_setfont sets font to use for following output ps_setgray sets gray value ps_setlinecap sets appearance of line ends ps_setlinejoin sets how contected lines are joined ps_setlinewidth sets width of a line ps_setmiterlimit sets the miter limit ps_setoverprintmode sets overprint mode ps_setpolydash sets appearance of a dashed line ps_set_border_color sets color of border for annotations ps_set_border_dash sets length of dashes for border of annotations ps_set_border_style sets border style of annotations ps_set_info sets information fields of document ps_set_parameter sets certain parameters ps_set_text_pos sets position for text output ps_set_value sets certain values ps_shading creates a shading for later use ps_shading_pattern creates a pattern based on a shading ps_shfill fills an area with a shading ps_show output text ps_show2 output a text at current position ps_show_boxed output text in a box ps_show_xy output text at given position ps_show_xy2 output text at position ps_stringwidth gets width of a string ps_string_geometry gets geometry of a string ps_stroke draws the current path ps_symbol output a glyph ps_symbol_name gets name of a glyph ps_symbol_width gets width of a glyph ps_translate sets translation putenv 设置环境变量的值 px_close closes a paradox database px_create_fp create a new paradox database px_date2string converts a date into a string. px_delete deletes resource of paradox database px_delete_record deletes record from paradox database px_get_field returns the specification of a single field px_get_info return lots of information about a paradox file px_get_parameter gets a parameter px_get_record returns record of paradox database px_get_schema returns the database schema px_get_value gets a value px_insert_record inserts record into paradox database px_new create a new paradox object px_numfields returns number of fields in a database px_numrecords returns number of records in a database px_open_fp open paradox database px_put_record stores record into paradox database px_retrieve_record returns record of paradox database px_set_blob_file sets the file where blobs are read from px_set_parameter sets a parameter px_set_tablename sets the name of a table (deprecated) px_set_targetencoding sets the encoding for character fields (deprecated) px_set_value sets a value px_timestamp2string converts the timestamp into a string. px_update_record updates record in paradox database q 函数 说明 quoted_printable_decode 将 quoted-printable 字符串转换为 8-bit 字符串 quoted_printable_encode 将 8-bit 字符串转换成 quoted-printable 字符串 quotemeta 转义元字符集 r 函数 说明 rad2deg 将弧度数转换为相应的角度数 radius_acct_open creates a radius handle for accounting radius_add_server adds a server radius_auth_open creates a radius handle for authentication radius_close frees all ressources radius_config causes the library to read the given configuration file radius_create_request create accounting or authentication request radius_cvt_addr converts raw data to ip-address radius_cvt_int converts raw data to integer radius_cvt_string converts raw data to string radius_demangle demangles data radius_demangle_mppe_key derives mppe-keys from mangled data radius_get_attr extracts an attribute radius_get_tagged_attr_data extracts the data from a tagged attribute radius_get_tagged_attr_tag extracts the tag from a tagged attribute radius_get_vendor_attr extracts a vendor specific attribute radius_put_addr attaches an ip address attribute radius_put_attr attaches a binary attribute radius_put_int attaches an integer attribute radius_put_string attaches a string attribute radius_put_vendor_addr attaches a vendor specific ip address attribute radius_put_vendor_attr attaches a vendor specific binary attribute radius_put_vendor_int attaches a vendor specific integer attribute radius_put_vendor_string attaches a vendor specific string attribute radius_request_authenticator returns the request authenticator radius_salt_encrypt_attr salt-encrypts a value radius_send_request sends the request and waites for a reply radius_server_secret returns the shared secret radius_strerror returns an error message rand 产生一个随机整数 random_bytes generates cryptographically secure pseudo-random bytes random_int generates cryptographically secure pseudo-random integers range 建立一个包含指定范围单元的数组 rar_wrapper_cache_stats cache hits and misses for the url wrapper rawurldecode 对已编码的 url 字符串进行解码 rawurlencode 按照 rfc 3986 对 url 进行编码 readdir 从目录句柄中读取条目 readfile 输出一个文件 readgzfile output a gz-file readline 读取一行 readline_add_history 添加一行命令行历史记录 readline_callback_handler_install 初始化一个 readline 回调接口，然后终端输出提示信息并立即返回 readline_callback_handler_remove 移除上一个安装的回调函数句柄并且恢复终端设置 readline_callback_read_char 当一个行被接收时读取一个字符并且通知 readline 调用回调函数 readline_clear_history 清除历史 readline_completion_function 注册一个完成函数 readline_info 获取/设置readline内部的各个变量 readline_list_history 获取命令历史列表 readline_on_new_line 通知readline将光标移动到新行 readline_read_history 读取命令历史 readline_redisplay 重绘显示区 readline_write_history 写入历史记录 readlink 返回符号连接指向的目标 read_exif_data 别名 exif_read_data realpath 返回规范化的绝对路径名 realpath_cache_get get realpath cache entries realpath_cache_size get realpath cache size recode 别名 recode_string recode_file recode from file to file according to recode request recode_string recode a string according to a recode request register_shutdown_function register a function for execution on shutdown register_tick_function register a function for execution on each tick rename 重命名一个文件或目录 rename_function renames orig_name to new_name in the global function table reset 将数组的内部指针指向第一个单元 restore_error_handler 还原之前的错误处理函数 restore_exception_handler 恢复之前定义过的异常处理函数。 restore_include_path 还原 include_path 配置选项的值 rewind 倒回文件指针的位置 rewinddir 倒回目录句柄 rmdir 删除目录 round 对浮点数进行四舍五入 rpm_close closes an rpm file rpm_get_tag retrieves a header tag from an rpm file rpm_is_valid tests a filename for validity as an rpm file rpm_open opens an rpm file rpm_version returns a string representing the current version of the rpmreader extension rrdc_disconnect close any outstanding connection to rrd caching daemon rrd_create creates rrd database file rrd_error gets latest error message. rrd_fetch fetch the data for graph as array. rrd_first gets the timestamp of the first sample from rrd file. rrd_graph creates image from a data. rrd_info gets information about rrd file rrd_last gets unix timestamp of the last sample. rrd_lastupdate gets information about last updated data. rrd_restore restores the rrd file from xml dump. rrd_tune tunes some rrd database file header options. rrd_update updates the rrd database. rrd_version gets information about underlying rrdtool library rrd_xport exports the information about rrd database. rsort 对数组逆向排序 rtrim 删除字符串末端的空白字符（或者其他字符） runkit_class_adopt convert a base class to an inherited class, add ancestral methods when appropriate runkit_class_emancipate convert an inherited class to a base class, removes any method whose scope is ancestral runkit_constant_add similar to define(), but allows defining in class definitions as well runkit_constant_redefine redefine an already defined constant runkit_constant_remove remove/delete an already defined constant runkit_function_add add a new function, similar to create_function runkit_function_copy copy a function to a new function name runkit_function_redefine replace a function definition with a new implementation runkit_function_remove remove a function definition runkit_function_rename change a function’s name runkit_import process a php file importing function and class definitions, overwriting where appropriate runkit_lint check the php syntax of the specified php code runkit_lint_file check the php syntax of the specified file runkit_method_add dynamically adds a new method to a given class runkit_method_copy copies a method from class to another runkit_method_redefine dynamically changes the code of the given method runkit_method_remove dynamically removes the given method runkit_method_rename dynamically changes the name of the given method runkit_return_value_used determines if the current functions return value will be used runkit_sandbox runkit sandbox class – php virtual machine runkit_sandbox_output_handler specify a function to capture and/or process output from a runkit sandbox runkit_sandbox_parent runkit anti-sandbox class runkit_superglobals return numerically indexed array of registered superglobals s 函数 说明 scandir 列出指定路径中的文件和目录 sem_acquire acquire a semaphore sem_get get a semaphore id sem_release release a semaphore sem_remove remove a semaphore serialize 产生一个可存储的值的表示 session_abort discard session array changes and finish session session_cache_expire 返回当前缓存的到期时间 session_cache_limiter 读取/设置缓存限制器 session_commit session_write_close 的别名 session_decode 解码会话数据 session_destroy 销毁一个会话中的全部数据 session_encode 将当前会话数据编码为一个字符串 session_get_cookie_params 获取会话 cookie 参数 session_id 获取/设置当前会话 id session_is_registered 检查变量是否在会话中已经注册 session_module_name 获取/设置会话模块名称 session_name 读取/设置会话名称 session_pgsql_add_error increments error counts and sets last error message session_pgsql_get_error returns number of errors and last error message session_pgsql_get_field get custom field value session_pgsql_reset reset connection to session database servers session_pgsql_set_field set custom field value session_pgsql_status get current save handler status session_regenerate_id 使用新生成的会话 id 更新现有会话 id session_register register one or more global variables with the current session session_register_shutdown 关闭会话 session_reset re-initialize session array with original values session_save_path 读取/设置当前会话的保存路径 session_set_cookie_params 设置会话 cookie 参数 session_set_save_handler 设置用户自定义会话存储函数 session_start 启动新会话或者重用现有会话 session_status returns the current session status session_unregister unregister a global variable from the current session session_unset free all session variables session_write_close write session data and end session setcookie send a cookie setlocale 设置地区信息 setproctitle set the process title setrawcookie send a cookie without urlencoding the cookie value setthreadtitle set the thread title settype 设置变量的类型 set_error_handler 设置一个用户定义的错误处理函数 set_exception_handler 设置一个用户定义的异常处理函数。 set_file_buffer stream_set_write_buffer 的别名 set_include_path 设置 include_path 配置选项 set_magic_quotes_runtime 设置当前 magic_quotes_runtime 配置选项的激活状态 set_socket_blocking 别名 stream_set_blocking set_time_limit 设置脚本最大执行时间 sha1 计算字符串的 sha1 散列值 sha1_file 计算文件的 sha1 散列值 shell_exec 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。 shmop_close close shared memory block shmop_delete delete shared memory block shmop_open create or open shared memory block shmop_read read data from shared memory block shmop_size get size of shared memory block shmop_write write data into shared memory block shm_attach creates or open a shared memory segment shm_detach disconnects from shared memory segment shm_get_var returns a variable from shared memory shm_has_var check whether a specific entry exists shm_put_var inserts or updates a variable in shared memory shm_remove removes shared memory from unix systems shm_remove_var removes a variable from shared memory show_source 别名 highlight_file shuffle 将数组打乱 signeurlpaiement obtain the payment url (needs 2 arguments) similar_text 计算两个字符串的相似度 simplexml_import_dom get a simplexmlelement object from a dom node. simplexml_load_file interprets an xml file into an object simplexml_load_string interprets a string of xml into an object sin 正弦 sinh 双曲正弦 sizeof count 的别名 sleep 延缓执行 snmp2_get fetch an snmp object snmp2_getnext fetch the snmp object which follows the given object id snmp2_real_walk return all objects including their respective object id within the specified one snmp2_set set the value of an snmp object snmp2_walk fetch all the snmp objects from an agent snmp3_get fetch an snmp object snmp3_getnext fetch the snmp object which follows the given object id snmp3_real_walk return all objects including their respective object id within the specified one snmp3_set set the value of an snmp object snmp3_walk fetch all the snmp objects from an agent snmpget 获取一个 snmp 对象 snmpgetnext fetch the snmp object which follows the given object id snmprealwalk 返回指定的所有对象，包括它们各自的对象 id snmpset 设置一个 snmp 对象 snmpwalk 从代理返回所有的 snmp 对象 snmpwalkoid 查询关于网络实体的信息树 snmp_get_quick_print 返回 ucd 库中 quick_print 设置的当前值 snmp_get_valueretrieval return the method how the snmp values will be returned snmp_read_mib reads and parses a mib file into the active mib tree snmp_set_enum_print return all values that are enums with their enum value instead of the raw integer snmp_set_oid_numeric_print set the oid output format snmp_set_oid_output_format set the oid output format snmp_set_quick_print 设置 ucd snmp 库中 quick_print 的值 snmp_set_valueretrieval specify the method how the snmp values will be returned socket_accept accepts a connection on a socket socket_bind 给套接字绑定名字 socket_clear_error 清除套接字或者最后的错误代码上的错误 socket_close 关闭套接字资源 socket_cmsg_space calculate message buffer size socket_connect 开启一个套接字连接 socket_create 创建一个套接字（通讯节点） socket_create_listen opens a socket on port to accept connections socket_create_pair creates a pair of indistinguishable sockets and stores them in an array socket_getpeername queries the remote side of the given socket which may either result in host/port or in a unix filesystem path, dependent on its type socket_getsockname queries the local side of the given socket which may either result in host/port or in a unix filesystem path, dependent on its type socket_get_option gets socket options for the socket socket_get_status 别名 stream_get_meta_data socket_import_stream import a stream socket_last_error returns the last error on the socket socket_listen listens for a connection on a socket socket_read reads a maximum of length bytes from a socket socket_recv receives data from a connected socket socket_recvfrom receives data from a socket whether or not it is connection-oriented socket_recvmsg read a message socket_select runs the select() system call on the given arrays of sockets with a specified timeout socket_send sends data to a connected socket socket_sendmsg send a message socket_sendto sends a message to a socket, whether it is connected or not socket_set_block sets blocking mode on a socket resource socket_set_blocking 别名 stream_set_blocking socket_set_nonblock sets nonblocking mode for file descriptor fd socket_set_option sets socket options for the socket socket_set_timeout 别名 stream_set_timeout socket_shutdown shuts down a socket for receiving, sending, or both socket_strerror return a string describing a socket error socket_write write to a socket solr_get_version 返回当前solr扩展的版本 sort 对数组排序 soundex calculate the soundex key of a string split 用正则表达式将字符串分割到数组中 spliti 用正则表达式不区分大小写将字符串分割到数组中 spl_autoload __autoload()函数的默认实现 spl_autoload_call 尝试调用所有已注册的__autoload()函数来装载请求类 spl_autoload_extensions 注册并返回spl_autoload函数使用的默认文件扩展名。 spl_autoload_functions 返回所有已注册的__autoload()函数。 spl_autoload_register 注册给定的函数作为 __autoload 的实现 spl_autoload_unregister 注销已注册的__autoload()函数 spl_classes 返回所有可用的spl类 spl_object_hash 返回指定对象的hash id sprintf return a formatted string sql acceptable by 4d pdo and sql 4d sqlite_array_query execute a query against a given database and returns an array sqlite_busy_timeout set busy timeout duration, or disable busy handlers sqlite_changes returns the number of rows that were changed by the most recent sql statement sqlite_close closes an open sqlite database sqlite_column fetches a column from the current row of a result set sqlite_create_aggregate register an aggregating udf for use in sql statements sqlite_create_function registers a “regular” user defined function for use in sql statements sqlite_current fetches the current row from a result set as an array sqlite_error_string returns the textual description of an error code sqlite_escape_string escapes a string for use as a query parameter sqlite_exec executes a result-less query against a given database sqlite_factory opens an sqlite database and returns an sqlitedatabase object sqlite_fetch_all fetches all rows from a result set as an array of arrays sqlite_fetch_array fetches the next row from a result set as an array sqlite_fetch_column_types return an array of column types from a particular table sqlite_fetch_object fetches the next row from a result set as an object sqlite_fetch_single fetches the first column of a result set as a string sqlite_fetch_string 别名 sqlite_fetch_single sqlite_field_name returns the name of a particular field sqlite_has_more finds whether or not more rows are available sqlite_has_prev returns whether or not a previous row is available sqlite_key returns the current row index sqlite_last_error returns the error code of the last error for a database sqlite_last_insert_rowid returns the rowid of the most recently inserted row sqlite_libencoding returns the encoding of the linked sqlite library sqlite_libversion returns the version of the linked sqlite library sqlite_next seek to the next row number sqlite_num_fields returns the number of fields in a result set sqlite_num_rows returns the number of rows in a buffered result set sqlite_open opens an sqlite database and create the database if it does not exist sqlite_popen opens a persistent handle to an sqlite database and create the database if it does not exist sqlite_prev seek to the previous row number of a result set sqlite_query executes a query against a given database and returns a result handle sqlite_rewind seek to the first row number sqlite_seek seek to a particular row number of a buffered result set sqlite_single_query executes a query and returns either an array for one single column or the value of the first row sqlite_udf_decode_binary decode binary data passed as parameters to an udf sqlite_udf_encode_binary encode binary data before returning it from an udf sqlite_unbuffered_query execute a query that does not prefetch and buffer all data sqlite_valid returns whether more rows are available sqlsrv_begin_transaction begins a database transaction sqlsrv_cancel cancels a statement sqlsrv_client_info returns information about the client and specified connection sqlsrv_close closes an open connection and releases resourses associated with the connection sqlsrv_commit commits a transaction that was begun with sqlsrv_begin_transaction sqlsrv_configure changes the driver error handling and logging configurations sqlsrv_connect opens a connection to a microsoft sql server database sqlsrv_errors returns error and warning information about the last sqlsrv operation performed sqlsrv_execute executes a statement prepared with sqlsrv_prepare sqlsrv_fetch makes the next row in a result set available for reading sqlsrv_fetch_array returns a row as an array sqlsrv_fetch_object retrieves the next row of data in a result set as an object sqlsrv_field_metadata retrieves metadata for the fields of a statement prepared by sqlsrv_prepare or sqlsrv_query sqlsrv_free_stmt frees all resources for the specified statement sqlsrv_get_config returns the value of the specified configuration setting sqlsrv_get_field gets field data from the currently selected row sqlsrv_has_rows indicates whether the specified statement has rows sqlsrv_next_result makes the next result of the specified statement active sqlsrv_num_fields retrieves the number of fields (columns) on a statement sqlsrv_num_rows retrieves the number of rows in a result set sqlsrv_prepare prepares a query for execution sqlsrv_query prepares and executes a query. sqlsrv_rollback rolls back a transaction that was begun with sqlsrv_begin_transaction sqlsrv_rows_affected returns the number of rows modified by the last insert, update, or delete query executed sqlsrv_send_stream_data sends data from parameter streams to the server sqlsrv_server_info returns information about the server sql types with pdo_4d and php sql types with pdo_4d and php sql_regcase 产生用于不区分大小的匹配的正则表达式 sqrt 平方根 srand 播下随机数发生器种子 sscanf 根据指定格式解析输入的字符 ssdeep_fuzzy_compare calculates the match score between two fuzzy hash signatures ssdeep_fuzzy_hash create a fuzzy hash from a string ssdeep_fuzzy_hash_filename create a fuzzy hash from a file ssh2_auth_agent authenticate over ssh using the ssh agent ssh2_auth_hostbased_file authenticate using a public hostkey ssh2_auth_none authenticate as “none” ssh2_auth_password authenticate over ssh using a plain password ssh2_auth_pubkey_file authenticate using a public key ssh2_connect connect to an ssh server ssh2_exec execute a command on a remote server ssh2_fetch_stream fetch an extended data stream ssh2_fingerprint retrieve fingerprint of remote server ssh2_methods_negotiated return list of negotiated methods ssh2_publickey_add add an authorized publickey ssh2_publickey_init initialize publickey subsystem ssh2_publickey_list list currently authorized publickeys ssh2_publickey_remove remove an authorized publickey ssh2_scp_recv request a file via scp ssh2_scp_send send a file via scp ssh2_sftp initialize sftp subsystem ssh2_sftp_chmod changes file mode ssh2_sftp_lstat stat a symbolic link ssh2_sftp_mkdir create a directory ssh2_sftp_readlink return the target of a symbolic link ssh2_sftp_realpath resolve the realpath of a provided path string ssh2_sftp_rename rename a remote file ssh2_sftp_rmdir remove a directory ssh2_sftp_stat stat a file on a remote filesystem ssh2_sftp_symlink create a symlink ssh2_sftp_unlink delete a file ssh2_shell request an interactive shell ssh2_tunnel open a tunnel through a remote server ssl 上下文选项 ssl 上下文选项清单 stat 给出文件的信息 stats_absolute_deviation returns the absolute deviation of an array of values stats_cdf_beta cdf function for beta distribution. calculates any one parameter of the beta distribution given values for the others. stats_cdf_binomial calculates any one parameter of the binomial distribution given values for the others. stats_cdf_cauchy not documented stats_cdf_chisquare calculates any one parameter of the chi-square distribution given values for the others. stats_cdf_exponential not documented stats_cdf_f calculates any one parameter of the f distribution given values for the others. stats_cdf_gamma calculates any one parameter of the gamma distribution given values for the others. stats_cdf_laplace not documented stats_cdf_logistic not documented stats_cdf_negative_binomial calculates any one parameter of the negative binomial distribution given values for the others. stats_cdf_noncentral_chisquare calculates any one parameter of the non-central chi-square distribution given values for the others. stats_cdf_noncentral_f calculates any one parameter of the non-central f distribution given values for the others. stats_cdf_poisson calculates any one parameter of the poisson distribution given values for the others. stats_cdf_t calculates any one parameter of the t distribution given values for the others. stats_cdf_uniform not documented stats_cdf_weibull not documented stats_covariance computes the covariance of two data sets stats_dens_beta not documented stats_dens_cauchy not documented stats_dens_chisquare not documented stats_dens_exponential not documented stats_dens_f 说明 stats_dens_gamma not documented stats_dens_laplace not documented stats_dens_logistic not documented stats_dens_negative_binomial not documented stats_dens_normal not documented stats_dens_pmf_binomial not documented stats_dens_pmf_hypergeometric 说明 stats_dens_pmf_poisson not documented stats_dens_t not documented stats_dens_weibull not documented stats_den_uniform not documented stats_harmonic_mean returns the harmonic mean of an array of values stats_kurtosis computes the kurtosis of the data in the array stats_rand_gen_beta generates beta random deviate stats_rand_gen_chisquare generates random deviate from the distribution of a chisquare with “df” degrees of freedom random variable. stats_rand_gen_exponential generates a single random deviate from an exponential distribution with mean “av” stats_rand_gen_f generates a random deviate stats_rand_gen_funiform generates uniform float between low (exclusive) and high (exclusive) stats_rand_gen_gamma generates random deviates from a gamma distribution stats_rand_gen_ibinomial generates a single random deviate from a binomial distribution whose number of trials is “n” (n \u0026gt;= 0) and whose probability of an event in each trial is “pp” ([0;1]). method : algorithm btpe stats_rand_gen_ibinomial_negative generates a single random deviate from a negative binomial distribution. arguments : n stats_rand_gen_int generates random integer between 1 and 2147483562 stats_rand_gen_ipoisson generates a single random deviate from a poisson distribution with mean “mu” (mu \u0026gt;= 0.0). stats_rand_gen_iuniform generates integer uniformly distributed between low (inclusive) and high (inclusive) stats_rand_gen_noncenral_chisquare generates random deviate from the distribution of a noncentral chisquare with “df” degrees of freedom and noncentrality parameter “xnonc”. d must be \u0026gt;= 1.0, xnonc must \u0026gt;= 0.0 stats_rand_gen_noncentral_f generates a random deviate from the noncentral f (variance ratio) distribution with “dfn” degrees of freedom in the numerator, and “dfd” degrees of freedom in the denominator, and noncentrality parameter “xnonc”. method : directly generates ratio of noncentral numerator chisquare variate to central denominator chisquare variate. stats_rand_gen_noncentral_t generates a single random deviate from a noncentral t distribution stats_rand_gen_normal generates a single random deviate from a normal distribution with mean, av, and standard deviation, sd (sd \u0026gt;= 0). method : renames snorm from toms as slightly modified by bwb to use ranf instead of sunif. stats_rand_gen_t generates a single random deviate from a t distribution stats_rand_get_seeds not documented stats_rand_phrase_to_seeds generate two seeds for the rgn random number generator stats_rand_ranf returns a random floating point number from a uniform distribution over 0 stats_rand_setall not documented stats_skew computes the skewness of the data in the array stats_standard_deviation returns the standard deviation stats_stat_binomial_coef not documented stats_stat_correlation not documented stats_stat_gennch not documented stats_stat_independent_t not documented stats_stat_innerproduct 说明 stats_stat_noncentral_t calculates any one parameter of the noncentral t distribution give values for the others. stats_stat_paired_t not documented stats_stat_percentile not documented stats_stat_powersum not documented stats_variance returns the population variance stomp_connect_error returns a string description of the last connect error stomp_version gets the current stomp extension version strcasecmp 二进制安全比较字符串（不区分大小写） strchr 别名 strstr strcmp 二进制安全字符串比较 strcoll 基于区域设置的字符串比较 strcspn 获取不匹配遮罩的起始子字符串的长度 stream_bucket_append append bucket to brigade stream_bucket_make_writeable return a bucket object from the brigade for operating on stream_bucket_new create a new bucket for use on the current stream stream_bucket_prepend prepend bucket to brigade stream_context_create 创建资源流上下文 stream_context_get_default retrieve the default stream context stream_context_get_options 获取资源流/数据包/上下文的参数 stream_context_get_params retrieves parameters from a context stream_context_set_default set the default stream context stream_context_set_option 对资源流、数据包或者上下文设置参数 stream_context_set_params set parameters for a stream/wrapper/context stream_copy_to_stream copies data from one stream to another stream_encoding 设置数据流的字符集 stream_filter_append attach a filter to a stream stream_filter_prepend attach a filter to a stream stream_filter_register register a user defined stream filter stream_filter_remove 从资源流里移除某个过滤器 stream_get_contents 读取资源流到一个字符串 stream_get_filters 获取已注册的数据流过滤器列表 stream_get_line 从资源流里读取一行直到给定的定界符 stream_get_meta_data 从封装协议文件指针中取得报头／元数据 stream_get_transports 获取已注册的套接字传输协议列表 stream_get_wrappers 获取已注册的流类型 stream_is_local checks if a stream is a local stream stream_notification_callback a callback function for the notification context parameter stream_register_wrapper 注册一个用 php 类实现的 url 封装协议 stream_resolve_include_path resolve filename against the include path stream_select runs the equivalent of the select() system call on the given arrays of streams with a timeout specified by tv_sec and tv_usec stream_set_blocking 为资源流设置阻塞或者阻塞模式 stream_set_chunk_size 设置资源流区块大小 stream_set_read_buffer set read file buffering on the given stream stream_set_timeout set timeout period on a stream stream_set_write_buffer sets write file buffering on the given stream stream_socket_accept 接受由 stream_socket_server 创建的套接字连接 stream_socket_client open internet or unix domain socket connection stream_socket_enable_crypto turns encryption on/off on an already connected socket stream_socket_get_name 获取本地或者远程的套接字名称 stream_socket_pair 创建一对完全一样的网络套接字连接流 stream_socket_recvfrom receives data from a socket, connected or not stream_socket_sendto sends a message to a socket, whether it is connected or not stream_socket_server create an internet or unix domain server socket stream_socket_shutdown shutdown a full-duplex connection stream_supports_lock tells whether the stream supports locking. stream_wrapper_restore restores a previously unregistered built-in wrapper stream_wrapper_unregister unregister a url wrapper strftime 根据区域设置格式化本地时间／日期 stripcslashes 反引用一个使用 addcslashes 转义的字符串 stripos 查找字符串首次出现的位置（不区分大小写） stripslashes 反引用一个引用字符串 strip_tags 从字符串中去除 html 和 php 标记 stristr strstr 函数的忽略大小写版本 strlen 获取字符串长度 strnatcasecmp 使用“自然顺序”算法比较字符串（不区分大小写） strnatcmp 使用自然排序算法比较字符串 strncasecmp 二进制安全比较字符串开头的若干个字符（不区分大小写） strncmp 二进制安全比较字符串开头的若干个字符 strpbrk 在字符串中查找一组字符的任何一个字符 strpos 查找字符串首次出现的位置 strptime 解析由 strftime 生成的日期／时间 strrchr 查找指定字符在字符串中的最后一次出现 strrev 反转字符串 strripos 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写） strrpos 计算指定字符串在目标字符串中最后一次出现的位置 strspn 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。 strstr 查找字符串的首次出现 strtok 标记分割字符串 strtolower 将字符串转化为小写 strtotime 将任何英文文本的日期时间描述解析为 unix 时间戳 strtoupper 将字符串转化为大写 strtr 转换指定字符 strval 获取变量的字符串值 str_getcsv 解析 csv 字符串为一个数组 str_ireplace str_replace 的忽略大小写版本 str_pad 使用另一个字符串填充字符串为指定长度 str_repeat 重复一个字符串 str_replace 子字符串替换 str_rot13 对字符串执行 rot13 转换 str_shuffle 随机打乱一个字符串 str_split 将字符串转换为数组 str_word_count 返回字符串中单词的使用情况 substr 返回字符串的子串 substr_compare 二进制安全比较字符串（从偏移位置比较指定长度） substr_count 计算字串出现的次数 substr_replace 替换字符串的子串 svn_add 计划在工作目录添加项 svn_auth_get_parameter retrieves authentication parameter svn_auth_set_parameter sets an authentication parameter svn_blame get the svn blame for a file svn_cat returns the contents of a file in a repository svn_checkout checks out a working copy from the repository svn_cleanup recursively cleanup a working copy directory, finishing incomplete operations and removing locks svn_client_version returns the version of the svn client libraries svn_commit sends changes from the local working copy to the repository svn_delete delete items from a working copy or repository. svn_diff recursively diffs two paths svn_export export the contents of a svn directory svn_fs_abort_txn abort a transaction, returns true if everything is okay, false otherwise svn_fs_apply_text creates and returns a stream that will be used to replace svn_fs_begin_txn2 create a new transaction svn_fs_change_node_prop return true if everything is ok, false otherwise svn_fs_check_path determines what kind of item lives at path in a given repository fsroot svn_fs_contents_changed return true if content is different, false otherwise svn_fs_copy copies a file or a directory, returns true if all is ok, false otherwise svn_fs_delete deletes a file or a directory, return true if all is ok, false otherwise svn_fs_dir_entries enumerates the directory entries under path; returns a hash of dir names to file type svn_fs_file_contents returns a stream to access the contents of a file from a given version of the fs svn_fs_file_length returns the length of a file from a given version of the fs svn_fs_is_dir return true if the path points to a directory, false otherwise svn_fs_is_file return true if the path points to a file, false otherwise svn_fs_make_dir creates a new empty directory, returns true if all is ok, false otherwise svn_fs_make_file creates a new empty file, returns true if all is ok, false otherwise svn_fs_node_created_rev returns the revision in which path under fsroot was created svn_fs_node_prop returns the value of a property for a node svn_fs_props_changed return true if props are different, false otherwise svn_fs_revision_prop fetches the value of a named property svn_fs_revision_root get a handle on a specific version of the repository root svn_fs_txn_root creates and returns a transaction root svn_fs_youngest_rev returns the number of the youngest revision in the filesystem svn_import imports an unversioned path into a repository svn_log returns the commit log messages of a repository url svn_ls returns list of directory contents in repository url, optionally at revision number svn_mkdir creates a directory in a working copy or repository svn_repos_create create a new subversion repository at path svn_repos_fs gets a handle on the filesystem for a repository svn_repos_fs_begin_txn_for_commit create a new transaction svn_repos_fs_commit_txn commits a transaction and returns the new revision svn_repos_hotcopy make a hot-copy of the repos at repospath; copy it to destpath svn_repos_open open a shared lock on a repository. svn_repos_recover run recovery procedures on the repository located at path. svn_revert revert changes to the working copy svn_status returns the status of working copy files and directories svn_update update working copy sybase_affected_rows gets number of affected rows in last query sybase_close closes a sybase connection sybase_connect opens a sybase server connection sybase_data_seek moves internal row pointer sybase_deadlock_retry_count sets the deadlock retry count sybase_fetch_array fetch row as array sybase_fetch_assoc fetch a result row as an associative array sybase_fetch_field get field information from a result sybase_fetch_object fetch a row as an object sybase_fetch_row get a result row as an enumerated array sybase_field_seek sets field offset sybase_free_result frees result memory sybase_get_last_message returns the last message from the server sybase_min_client_severity sets minimum client severity sybase_min_error_severity sets minimum error severity sybase_min_message_severity sets minimum message severity sybase_min_server_severity sets minimum server severity sybase_num_fields gets the number of fields in a result set sybase_num_rows get number of rows in a result set sybase_pconnect open persistent sybase connection sybase_query sends a sybase query sybase_result get result data sybase_select_db selects a sybase database sybase_set_message_handler sets the handler called when a server message is raised sybase_unbuffered_query send a sybase query and do not block symlink 建立符号连接 syslog generate a system log message system 执行外部程序，并且显示输出 sys_getloadavg 获取系统的负载（load average） sys_get_temp_dir 返回用于临时文件的目录 t 函数 说明 taint taint a string tan 正切 tanh 双曲正切 tcpwrap_check performs a tcpwrap check tempnam 建立一个具有唯一文件名的文件 textdomain sets the default domain tidy_access_count returns the number of tidy accessibility warnings encountered for specified document tidy_config_count returns the number of tidy configuration errors encountered for specified document tidy_error_count returns the number of tidy errors encountered for specified document tidy_get_output return a string representing the parsed tidy markup tidy_load_config load an ascii tidy configuration file with the specified encoding tidy_reset_config restore tidy configuration to default values tidy_save_config save current settings to named file tidy_setopt updates the configuration settings for the specified tidy document tidy_set_encoding set the input/output character encoding for parsing markup tidy_warning_count returns the number of tidy warnings encountered for specified document time 返回当前的 unix 时间戳 timezone_name_from_abbr returns the timezone name from abbreviation timezone_version_get gets the version of the timezonedb time_nanosleep 延缓执行若干秒和纳秒 time_sleep_until 使脚本睡眠到指定的时间为止。 tmpfile 建立一个临时文件 token_get_all 将提供的源码按 php 标记进行分割 token_name 获取提供的 php 解析器代号的符号名称 touch 设定文件的访问和修改时间 trader_acos vector trigonometric acos trader_ad chaikin a/d line trader_add vector arithmetic add trader_adosc chaikin a/d oscillator trader_adx average directional movement index trader_adxr average directional movement index rating trader_apo absolute price oscillator trader_aroon aroon trader_aroonosc aroon oscillator trader_asin vector trigonometric asin trader_atan vector trigonometric atan trader_atr average true range trader_avgprice average price trader_bbands bollinger bands trader_beta beta trader_bop balance of power trader_cci commodity channel index trader_cdl2crows two crows trader_cdl3blackcrows three black crows trader_cdl3inside three inside up/down trader_cdl3linestrike three-line strike trader_cdl3outside three outside up/down trader_cdl3starsinsouth three stars in the south trader_cdl3whitesoldiers three advancing white soldiers trader_cdlabandonedbaby abandoned baby trader_cdladvanceblock advance block trader_cdlbelthold belt-hold trader_cdlbreakaway breakaway trader_cdlclosingmarubozu closing marubozu trader_cdlconcealbabyswall concealing baby swallow trader_cdlcounterattack counterattack trader_cdldarkcloudcover dark cloud cover trader_cdldoji doji trader_cdldojistar doji star trader_cdldragonflydoji dragonfly doji trader_cdlengulfing engulfing pattern trader_cdleveningdojistar evening doji star trader_cdleveningstar evening star trader_cdlgapsidesidewhite up/down-gap side-by-side white lines trader_cdlgravestonedoji gravestone doji trader_cdlhammer hammer trader_cdlhangingman hanging man trader_cdlharami harami pattern trader_cdlharamicross harami cross pattern trader_cdlhighwave high-wave candle trader_cdlhikkake hikkake pattern trader_cdlhikkakemod modified hikkake pattern trader_cdlhomingpigeon homing pigeon trader_cdlidentical3crows identical three crows trader_cdlinneck in-neck pattern trader_cdlinvertedhammer inverted hammer trader_cdlkicking kicking trader_cdlkickingbylength kicking trader_cdlladderbottom ladder bottom trader_cdllongleggeddoji long legged doji trader_cdllongline long line candle trader_cdlmarubozu marubozu trader_cdlmatchinglow matching low trader_cdlmathold mat hold trader_cdlmorningdojistar morning doji star trader_cdlmorningstar morning star trader_cdlonneck on-neck pattern trader_cdlpiercing piercing pattern trader_cdlrickshawman rickshaw man trader_cdlrisefall3methods rising/falling three methods trader_cdlseparatinglines separating lines trader_cdlshootingstar shooting star trader_cdlshortline short line candle trader_cdlspinningtop spinning top trader_cdlstalledpattern stalled pattern trader_cdlsticksandwich stick sandwich trader_cdltakuri takuri (dragonfly doji with very long lower shadow) trader_cdltasukigap tasuki gap trader_cdlthrusting thrusting pattern trader_cdltristar tristar pattern trader_cdlunique3river unique 3 river trader_cdlupsidegap2crows upside gap two crows trader_cdlxsidegap3methods upside/downside gap three methods trader_ceil vector ceil trader_cmo chande momentum oscillator trader_correl pearson’s correlation coefficient (r) trader_cos vector trigonometric cos trader_cosh vector trigonometric cosh trader_dema double exponential moving average trader_div vector arithmetic div trader_dx directional movement index trader_ema exponential moving average trader_errno get error code trader_exp vector arithmetic exp trader_floor vector floor trader_get_compat get compatibility mode trader_get_unstable_period get unstable period trader_ht_dcperiod hilbert transform trader_ht_dcphase hilbert transform trader_ht_phasor hilbert transform trader_ht_sine hilbert transform trader_ht_trendline hilbert transform trader_ht_trendmode hilbert transform trader_kama kaufman adaptive moving average trader_linearreg linear regression trader_linearreg_angle linear regression angle trader_linearreg_intercept linear regression intercept trader_linearreg_slope linear regression slope trader_ln vector log natural trader_log10 vector log10 trader_ma moving average trader_macd moving average convergence/divergence trader_macdext macd with controllable ma type trader_macdfix moving average convergence/divergence fix 12/26 trader_mama mesa adaptive moving average trader_mavp moving average with variable period trader_max highest value over a specified period trader_maxindex index of highest value over a specified period trader_medprice median price trader_mfi money flow index trader_midpoint midpoint over period trader_midprice midpoint price over period trader_min lowest value over a specified period trader_minindex index of lowest value over a specified period trader_minmax lowest and highest values over a specified period trader_minmaxindex indexes of lowest and highest values over a specified period trader_minus_di minus directional indicator trader_minus_dm minus directional movement trader_mom momentum trader_mult vector arithmetic mult trader_natr normalized average true range trader_obv on balance volume trader_plus_di plus directional indicator trader_plus_dm plus directional movement trader_ppo percentage price oscillator trader_roc rate of change : ((price/prevprice)-1)*100 trader_rocp rate of change percentage: (price-prevprice)/prevprice trader_rocr rate of change ratio: (price/prevprice) trader_rocr100 rate of change ratio 100 scale: (price/prevprice)*100 trader_rsi relative strength index trader_sar parabolic sar trader_sarext parabolic sar trader_set_compat set compatibility mode trader_set_unstable_period set unstable period trader_sin vector trigonometric sin trader_sinh vector trigonometric sinh trader_sma simple moving average trader_sqrt vector square root trader_stddev standard deviation trader_stoch stochastic trader_stochf stochastic fast trader_stochrsi stochastic relative strength index trader_sub vector arithmetic subtraction trader_sum summation trader_t3 triple exponential moving average (t3) trader_tan vector trigonometric tan trader_tanh vector trigonometric tanh trader_tema triple exponential moving average trader_trange true range trader_trima triangular moving average trader_trix 1-day rate-of-change (roc) of a triple smooth ema trader_tsf time series forecast trader_typprice typical price trader_ultosc ultimate oscillator trader_var variance trader_wclprice weighted close price trader_willr williams’ %r trader_wma weighted moving average trait_exists 检查指定的 trait 是否存在 trigger_error 产生一个用户级别的 error/warning/notice 信息 trim 去除字符串首尾处的空白字符（或者其他字符） u 函数 说明 uasort 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 ucfirst 将字符串的首字母转换为大写 ucwords 将字符串中每个单词的首字母转换为大写 udm_add_search_limit add various search limits udm_alloc_agent allocate mnogosearch session udm_alloc_agent_array allocate mnogosearch session udm_api_version get mnogosearch api version udm_cat_list get all the categories on the same level with the current one udm_cat_path get the path to the current category udm_check_charset check if the given charset is known to mnogosearch udm_clear_search_limits clear all mnogosearch search restrictions udm_crc32 return crc32 checksum of given string udm_errno get mnogosearch error number udm_error get mnogosearch error message udm_find perform search udm_free_agent free mnogosearch session udm_free_ispell_data free memory allocated for ispell data udm_free_res free mnogosearch result udm_get_doc_count get total number of documents in database udm_get_res_field fetch a result field udm_get_res_param get mnogosearch result parameters udm_hash32 return hash32 checksum of given string udm_load_ispell_data load ispell data udm_set_agent_param set mnogosearch agent session parameters uksort 使用用户自定义的比较函数对数组中的键名进行排序 umask 改变当前的 umask uniqid 生成一个唯一id unixtojd 转变unix时间戳为julian day计数 unlink 删除文件 unpack unpack data from binary string unregister_tick_function de-register a function for execution on each tick unserialize 从已存储的表示中创建 php 的值 unset 释放给定的变量 untaint untaint strings uopz_backup backup a function uopz_compose compose a class uopz_copy copy a function uopz_delete delete a function uopz_extend extend a class at runtime uopz_flags get or set flags on function or class uopz_function creates a function at runtime uopz_implement implements an interface at runtime uopz_overload overload a vm opcode uopz_redefine redefine a constant uopz_rename rename a function at runtime uopz_restore restore a previously backed up function uopz_undefine undefine a constant urldecode 解码已编码的 url 字符串 urlencode 编码 url 字符串 user_error trigger_error 的别名 use_soap_error_handler set whether to use the soap error handler usleep 以指定的微秒数延迟执行 usort 使用用户自定义的比较函数对数组中的值进行排序 utf8_decode 将用 utf-8 方式编码的 iso-8859-1 字符串转换成单字节的 iso-8859-1 字符串。 utf8_encode 将 iso-8859-1 编码的字符串转换为 utf-8 编码 v 函数 说明 variant_abs returns the absolute value of a variant variant_add “adds” two variant values together and returns the result variant_and performs a bitwise and operation between two variants variant_cast convert a variant into a new variant object of another type variant_cat concatenates two variant values together and returns the result variant_cmp compares two variants variant_date_from_timestamp returns a variant date representation of a unix timestamp variant_date_to_timestamp converts a variant date/time value to unix timestamp variant_div returns the result from dividing two variants variant_eqv performs a bitwise equivalence on two variants variant_fix returns the integer portion of a variant variant_get_type returns the type of a variant object variant_idiv converts variants to integers and then returns the result from dividing them variant_imp performs a bitwise implication on two variants variant_int returns the integer portion of a variant variant_mod divides two variants and returns only the remainder variant_mul multiplies the values of the two variants variant_neg performs logical negation on a variant variant_not performs bitwise not negation on a variant variant_or performs a logical disjunction on two variants variant_pow returns the result of performing the power function with two variants variant_round rounds a variant to the specified number of decimal places variant_set assigns a new value for a variant object variant_set_type convert a variant into another type “in-place” variant_sub subtracts the value of the right variant from the left variant value variant_xor performs a logical exclusion on two variants var_dump 打印变量的相关信息 var_export 输出或返回一个变量的字符串表示 version_compare 对比两个「php 规范化」的版本数字字符串 vfprintf 将格式化字符串写入流 virtual 执行 apache 子请求 vpopmail_add_alias_domain add an alias for a virtual domain vpopmail_add_alias_domain_ex add alias to an existing virtual domain vpopmail_add_domain add a new virtual domain vpopmail_add_domain_ex add a new virtual domain vpopmail_add_user add a new user to the specified virtual domain vpopmail_alias_add insert a virtual alias vpopmail_alias_del deletes all virtual aliases of a user vpopmail_alias_del_domain deletes all virtual aliases of a domain vpopmail_alias_get get all lines of an alias for a domain vpopmail_alias_get_all get all lines of an alias for a domain vpopmail_auth_user attempt to validate a username/domain/password vpopmail_del_domain delete a virtual domain vpopmail_del_domain_ex delete a virtual domain vpopmail_del_user delete a user from a virtual domain vpopmail_error get text message for last vpopmail error vpopmail_passwd change a virtual user’s password vpopmail_set_user_quota sets a virtual user’s quota vprintf 输出格式化字符串 vsprintf 返回格式化字符串 w 函数 说明 wddx_add_vars add variables to a wddx packet with the specified id wddx_deserialize unserializes a wddx packet wddx_packet_end ends a wddx packet with the specified id wddx_packet_start starts a new wddx packet with structure inside it wddx_serialize_value serialize a single value into a wddx packet wddx_serialize_vars serialize variables into a wddx packet win32_continue_service resumes a paused service win32_create_service creates a new service entry in the scm database win32_delete_service deletes a service entry from the scm database win32_get_last_control_message returns the last control message that was sent to this service win32_pause_service pauses a service win32_ps_list_procs list running processes win32_ps_stat_mem stat memory utilization win32_ps_stat_proc stat process win32_query_service_status queries the status of a service win32_set_service_status update the service status win32_start_service starts a service win32_start_service_ctrl_dispatcher registers the script with the scm, so that it can act as the service with the given name win32_stop_service stops a service wincache_fcache_fileinfo retrieves information about files cached in the file cache wincache_fcache_meminfo retrieves information about file cache memory usage wincache_lock acquires an exclusive lock on a given key wincache_ocache_fileinfo retrieves information about files cached in the opcode cache wincache_ocache_meminfo retrieves information about opcode cache memory usage wincache_refresh_if_changed refreshes the cache entries for the cached files wincache_rplist_fileinfo retrieves information about resolve file path cache wincache_rplist_meminfo retrieves information about memory usage by the resolve file path cache wincache_scache_info retrieves information about files cached in the session cache wincache_scache_meminfo retrieves information about session cache memory usage wincache_ucache_add adds a variable in user cache only if variable does not already exist in the cache wincache_ucache_cas compares the variable with old value and assigns new value to it wincache_ucache_clear deletes entire content of the user cache wincache_ucache_dec decrements the value associated with the key wincache_ucache_delete deletes variables from the user cache wincache_ucache_exists checks if a variable exists in the user cache wincache_ucache_get gets a variable stored in the user cache wincache_ucache_inc increments the value associated with the key wincache_ucache_info retrieves information about data stored in the user cache wincache_ucache_meminfo retrieves information about user cache memory usage wincache_ucache_set adds a variable in user cache and overwrites a variable if it already exists in the cache wincache_unlock releases an exclusive lock on a given key wordwrap 打断字符串为指定数量的字串 x 函数 说明 xattr_get get an extended attribute xattr_list get a list of extended attributes xattr_remove remove an extended attribute xattr_set set an extended attribute xattr_supported check if filesystem supports extended attributes xdiff_file_bdiff make binary diff of two files xdiff_file_bdiff_size read a size of file created by applying a binary diff xdiff_file_bpatch patch a file with a binary diff xdiff_file_diff make unified diff of two files xdiff_file_diff_binary alias of xdiff_file_bdiff xdiff_file_merge3 merge 3 files into one xdiff_file_patch patch a file with an unified diff xdiff_file_patch_binary alias of xdiff_file_bpatch xdiff_file_rabdiff make binary diff of two files using the rabin’s polynomial fingerprinting algorithm xdiff_string_bdiff make binary diff of two strings xdiff_string_bdiff_size read a size of file created by applying a binary diff xdiff_string_bpatch patch a string with a binary diff xdiff_string_diff make unified diff of two strings xdiff_string_diff_binary alias of xdiff_string_bdiff xdiff_string_merge3 merge 3 strings into one xdiff_string_patch patch a string with an unified diff xdiff_string_patch_binary alias of xdiff_string_bpatch xdiff_string_rabdiff make binary diff of two strings using the rabin’s polynomial fingerprinting algorithm xhprof_disable 停止 xhprof 分析器 xhprof_enable 启动 xhprof 性能分析器 xhprof_sample_disable 停止 xhprof 性能采样分析器 xhprof_sample_enable 以采样模式启动 xhprof 性能分析 xmlrpc_decode 将 xml 译码为 php 本身的类型 xmlrpc_decode_request 将 xml 译码为 php 本身的类型 xmlrpc_encode 为 php 的值生成 xml xmlrpc_encode_request 为 php 的值生成 xml xmlrpc_get_type 为 php 的值获取 xmlrpc 的类型 xmlrpc_is_fault determines if an array value represents an xmlrpc fault xmlrpc_parse_method_descriptions 将 xml 译码成方法描述的列表 xmlrpc_server_add_introspection_data 添加自我描述的文档 xmlrpc_server_call_method 解析 xml 请求同时调用方法 xmlrpc_server_create 创建一个 xmlrpc 服务端 xmlrpc_server_destroy 销毁服务端资源 xmlrpc_server_register_introspection_callback 注册一个 php 函数用于生成文档 xmlrpc_server_register_method 注册一个 php 函数用于匹配 xmlrpc 方法名 xmlrpc_set_type 为一个 php 字符串值设置 xmlrpc 的类型、base64 或日期时间 xml_error_string 获取 xml 解析器的错误字符串 xml_get_current_byte_index 获取 xml 解析器的当前字节索引 xml_get_current_column_number 获取 xml 解析器的当前列号 xml_get_current_line_number 获取 xml 解析器的当前行号 xml_get_error_code 获取 xml 解析器错误代码 xml_parse 开始解析一个 xml 文档 xml_parser_create 建立一个 xml 解析器 xml_parser_create_ns 生成一个支持命名空间的 xml 解析器 xml_parser_free 释放指定的 xml 解析器 xml_parser_get_option 从 xml 解析器获取选项设置信息 xml_parser_set_option 为指定 xml 解析进行选项设置 xml_parse_into_struct 将 xml 数据解析到数组中 xml_set_character_data_handler 建立字符数据处理器 xml_set_default_handler 建立默认处理器 xml_set_element_handler 建立起始和终止元素处理器 xml_set_end_namespace_decl_handler 建立终止命名空间声明处理器 xml_set_external_entity_ref_handler 建立外部实体指向处理器 xml_set_notation_decl_handler 建立注释声明处理器 xml_set_object 在对象中使用 xml 解析器 xml_set_processing_instruction_handler 建立处理指令（pi）处理器 xml_set_start_namespace_decl_handler 建立起始命名空间声明处理器 xml_set_unparsed_entity_decl_handler 建立未解析实体定义声明处理器 y 函数 说明 yaml_emit returns the yaml representation of a value yaml_emit_file send the yaml representation of a value to a file yaml_parse parse a yaml stream yaml_parse_file parse a yaml stream from a file yaml_parse_url parse a yaml stream from a url yaz_addinfo returns additional error information yaz_ccl_conf configure ccl parser yaz_ccl_parse invoke ccl parser yaz_close close yaz connection yaz_connect prepares for a connection to a z39.50 server yaz_database specifies the databases within a session yaz_element specifies element-set name for retrieval yaz_errno returns error number yaz_error returns error description yaz_es prepares for an extended service request yaz_es_result inspects extended services result yaz_get_option returns value of option for connection yaz_hits returns number of hits for last search yaz_itemorder prepares for z39.50 item order with an ill-request package yaz_present prepares for retrieval (z39.50 present) yaz_range specifies a range of records to retrieve yaz_record returns a record yaz_scan prepares for a scan yaz_scan_result returns scan response result yaz_schema specifies schema for retrieval yaz_search prepares for a search yaz_set_option sets one or more options for connection yaz_sort sets sorting criteria yaz_syntax specifies the preferred record syntax for retrieval yaz_wait wait for z39.50 requests to complete yp_all traverse the map and call a function on each entry yp_cat return an array containing the entire map yp_errno returns the error code of the previous operation yp_err_string returns the error string associated with the given error code yp_first returns the first key-value pair from the named map yp_get_default_domain fetches the machine’s default nis domain yp_master returns the machine name of the master nis server for a map yp_match returns the matched line yp_next returns the next key-value pair in the named map yp_order returns the order number for a map z 函数 说明 zend_logo_guid 获取 zend guid zend_thread_id 返回当前线程的唯一识别符 zend_version 获取当前 zend 引擎的版本 zip_close 关闭一个zip档案文件 zip_entry_close 关闭目录项 zip_entry_compressedsize 检索目录项压缩过后的大小 zip_entry_compressionmethod 检索目录实体的压缩方法 zip_entry_filesize 检索目录实体的实际大小 zip_entry_name 检索目录项的名称 zip_entry_open 打开用于读取的目录实体 zip_entry_read 读取一个打开了的压缩目录实体 zip_open 打开zip存档文件 zip_read 读取zip存档文件中下一项 zlib_decode uncompress any raw/gzip/zlib encoded data zlib_encode compress data with the specified encoding zlib_get_coding_type returns the coding type used for output compression ","date":"2019-03-09","permalink":"https://blog.akvicor.com/posts/php/manual/","summary":"\u003cp\u003ePHP 手册\u003c/p\u003e","title":"manual"},{"content":"基础 数据库（database / schema） 表（table） 数据库表是一系列二维数组的集合\n行被称为记录\n列被称为字段\n主键（primary key） 主键又称主码，用于唯一的标识表中的每一条记录。\n可以定义表中的一列或多列为主键，主键列上不能有两行相同的值，也不能为空\n数据库系统 数据库（database / db）：用于存储数据的地方 数据库管理系统（database management system / dbms）：用于管理数据库的软件 数据库应用程序（database application）：为了提高数据库系统的处理能力所使用的管理数据库的软件补充。 sql语言 数据定义语言（ddl）：drop、create、alter 数据操作语言（dml）：insert、update、delete 数据查询语言（dql）：select 数据控制语言（dcl）：grant、revoke、commit、rollback 数据库访问接口 odbc open database connectivity（odbc，开放数据库互连）\njdbc java data base connectivity\nado.net pdo php data object\n命令行操作 c:\\program files\\mysql\\mysql server 8.0\\bin 登录：mysql -h hostname -u username -p 数据库存储引擎 使用show engines查看系统支持的引擎类型\nshow engines \\g\ninnodb存储引擎 事务型数据库的首选引擎，支持事务安全表（acid），支持行锁定和外键。\nmyisam存储引擎 基于isam的存储引擎，并对其进行拓展。\n拥有较高的插入、查询速度，但不支持事务。\narchive存储引擎 压缩比率非常高，大概是innodb的0-15分之1\narchivec存储引擎使用行锁来实现高并发插入操作，但是它不支持事务，其设计目标只是提供高速的插入和压缩功能。\n基本操作 查看已经创建好的数据库/表 show databases;\nshow tables;\n创建数据库 create database database_name;\ncreate schema database_name;\n删除数据库/表 drop database database_name;\ndrop table table_name;\n指定当前数据库 use database_name;\n查看数据库信息 show create database database_name \\g\n查看默认存储引擎 show variables like `%storage_engine%`;\n创建数据表 create table \u0026lt;表名\u0026gt; ( 字段名1 数据类型 [列级别约束条件] [默认值], 字段名2 数据类型 [列级别约束条件] [默认值], ······ [表级别约束条件] ); create table test ( id int(11), name varchar(25), salary float ); 主键约束(primary key constraint) 单字段主键 定义列的同时指定主键：字段名 数据类型 primary key [默认值]\n定义完所有列之后指定主键：[constraint \u0026lt;约束名\u0026gt;] primary key [字段名]\ncreate table test ( id int(11) primary key, name varchar(25), salary float ); create table test ( id int(11), name varchar(25), salary float, primary key (id) ); 多字段联合主键 primary key [字段1，字段2，···，字段n]\ncreate table test ( id int(11), name varchar(25), salary float, primary key (id,name) ); 外键约束 __外键：__首先它是表中的一个字段，他可以不是本表的主键，但对应另一个表的主键\n__主表（父表）：__对于两个具有关联关系的表而言，相关字段中主键所在的那个表即是主表。\n__从表（子表）：__对于两个具有关联关系的表而言，相关字段中外键所在的那个表即是从表。\n[constraint \u0026lt;外键名\u0026gt;] foreign key 字段名1 [ ，字段名2，···] references \u0026lt;主表名\u0026gt; 主键列1 [ ，主键列2，···] 非空约束(not null constraint) 字段名 数据类型 not null\ncreate table test ( id int(11), name varchar(25) not null, salary float ); 唯一性约束(unique constraint) 一个表中可以有多个字段声明为unique，但只能有一个primary key声明；\nprimary key 不允许有空值\nunique 允许空值(null) 存在\n字段名 数据类型 unique\ncreate table test ( id int(11), name varchar(25) unique, salary float ); 定义完所有列之后指定唯一约束：[constraint \u0026lt;约束名\u0026gt;] unique(\u0026lt;字段名\u0026gt;)\ncreate table test ( id int(11), name varchar(25), salary float, primary key (id,name), constraint sth unique(name) ); 默认约束(default constraint) 字段名 数据类型 default 默认值\ncreate table test ( id int(11), name varchar(25), salary float default 100.0 ); 设置表的属性值自动增加 auto_increment约束的字段可以是任何整数类型（tinyint、smallint、int、bigint）\n字段名 数据类型 auto_increment\ncreate table test ( id int(11) primary key auto_increment, name varchar(25), salary float ); 查看表基本结构 可以查看表的字段信息，包括：字段名、数据类型、是否为主键、是否有默认值等。\ndescribe 表名; 简写为 desc 表名;\n查看表详细结构 加上\\g使显示结果更加直观，易于查看\nshow create table \u0026lt;表名\\g\u0026gt;;\n修改表名 alter table \u0026lt;旧表名\u0026gt; rename [to] \u0026lt;新表名\u0026gt;;\n修改字段类型 alter table \u0026lt;表名\u0026gt; modify \u0026lt;字段名\u0026gt; \u0026lt;数据类型\u0026gt;;\n修改字段名 alter table \u0026lt;表名\u0026gt; change \u0026lt;旧字段名\u0026gt; \u0026lt;新字段名\u0026gt; \u0026lt;新数据类型\u0026gt;;\n添加字段 alter table \u0026lt;表名\u0026gt; add \u0026lt;新字段名\u0026gt; \u0026lt;数据类型\u0026gt; [约束条件] [first | after 已存在字段名];\n删除字段 alter table \u0026lt;表名\u0026gt; drop \u0026lt;字段名\u0026gt;;\n修改字段排列 alter table \u0026lt;表名\u0026gt; modify \u0026lt;字段1\u0026gt; \u0026lt;数据类型\u0026gt; first|after \u0026lt;字段2\u0026gt;;\n修改表的存储引擎 引擎名 是否支持 federated 否 mrg_myisam 是 myisam 是 blackhole 是 csv 是 memory 是 archive 是 innodb 默认 performance_schema 是 alter table \u0026lt;表名\u0026gt; engines=\u0026lt;更改后的存储引擎名\u0026gt;;\n删除表的外键约束 alter table \u0026lt;表名\u0026gt; drop foreign key \u0026lt;外键约束名\u0026gt;\n删除没有被关联的表 drop table [if exists] 表1，表2，··· ;\n数据类型和运算符 数值数据类型：\n整数：tinyint、smallint、mediumint、int、bigint 浮点：float、double 定点：decimal 日期/时间类型：\nyear、time、date、datetime、timestamp 字符串类型：\nchar、varchar、binary、varbinary、blob、text、enum、set 整数类型 类型名 说明 储存要求(字节) tinyint 很小的整数 1 smallint 小的整数 2 mediumint 中等大小的整数 3 int(integer) 普通大小的整数 4 bigint 大的整数 8 数据类型 有符号 无符号 tinyint -128~127 0~255 smallint -32768~32767 0~65535 mediumint -8388608~8388607 0~16777215 int(integer) -2147483648~2147483647 0~4294967295 bigint -9223372036854775808~9223372036854775807 0~18446744073709551615 例如tinyint需要1字节(8bits)，最大值等于2^8-1，即255。有符号最大值等于2^7-1\nyear int(4)，指名year字段的数据一般只显示4位数字的宽度，显示宽度与取值范围是无关的。\n​\t例如插入数值19999，使用select查询出来显示的将是完整的5位19999。\n浮点数类型和定点数类型 类型名称 说明 存储需求(字节) float 单精度浮点 4 double 双精度浮点 8 decimal (m,d), dec 压缩的”严格“定点数 m+2 日期与时间类型 类型名称 日期格式 日期范围 存储需求(字节) year yyyy 1901~2155 1 time hh:mm:ss -838:59:59~838:59:59 3 date yyyy-mm-dd 1000-01-01~9999-12-31 3 datetime yyyy-mm-dd hh:mm:ss 1000-01-01 00:00:00~9999-12-31 23:59:59 8 timestamp yyyy-mm-dd hh:mm:ss 1970-01-01 00:00:01 utc~2038-01-19 03:14:07 4 可以使用各种格式指定time值：\nd hh:mm:ss格式字符串 hh:mm:ss、hh:mm、d hh:mm、d hh、ss d表示日，可以取0~34之间的值，插入数据库时，d被转换为小时保存\nhhmmss格式的、没有间隔的字符串或者数值、如果有时间意义。例如101112被理解为10:11:12但109712不合法，因为他有一个没有意义的分钟部分，存储时变为00:00:00 current_date获取yyyy-mm-dd\ncurrent_time获取hh:mm:ss\nnow()获取yyyy-mm-dd hh:mm:ss\ntimestamp储存时间时会将时间转换为utc时间，检索时再转换为当前时区。根据当前时区的不同显示的时间值是不同的 datetime，输入什么就储存什么 文本字符串类型 类型名称 说明 存储需求 char(m) 固定长度非二进制字符串 m字节，1\u0026lt;=m\u0026lt;=255 varchar(m) 变长非二进制字符串 l+1字节，l\u0026lt;=m和1\u0026lt;=m\u0026lt;=255 tinytext 非常小的非二进制字符串 l+1字节，l\u0026lt;28 text 小的非二进制字符串 l+2字节，l\u0026lt;216 mediumtext 中等大小的非二进制字符串 l+3字节，l\u0026lt;224 longtext 大的非二进制字符串 l+4字节，l\u0026lt;232 enum 枚举类型，只能有一个枚举字符串值非二进制字符串 1或2字节，取决于枚举值的数目（最大值65535） set 一个设置，字符串对象可以有零个或多个set成员非二进制字符串 1，2，3，4或8字节，取决于集合成员的数量(最多64个成员) enum是一个字符串对象，其值为表创建时在列规定中枚举的一列值，只能选择一个值插入。字段名 enum ('值1','值2',...)\nset与enum不同的是，插入时可以选择多个字符联合。\n二进制字符串类型 类型名 说明 储存需求 bit(m) 位字段类型 大约(m+7)/8个字节 binary(m) 固定长度二进制字符串 m字节 varbinary(m) 可变长度的二进制字符串 m+1字节 tinyblob(m) 非常小的blob l+1字节，l\u0026lt;28 blob(m) 小blob l+2字节，l\u0026lt;216 mediumblob(m) 中等大小的blob l+3字节，l\u0026lt;224 longblob(m) 非常大的blob l+4字节，l\u0026lt;232 bit数据类型用来保存位字段值\n例如：以二进制的形式保存数据13，13的二进制形式1101，这里需要位数至少为4的bit类型，即可定义bit(4)。大于二进制1111的数据是不能插入bit(4)的。\nbinary类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充\\0。\n数据类型 储存最大长度 tinyblob 255(28-1)b blob 65535(216-1)b mediumblob 16777215(224-1)b longblob 4294967295b或4gb(232-1)b blob列存储的是二进制字符串（字节字符串）；text列存储的是非二进制字符串（字符字符串）\nblob列没有字符集，并且排序和比较基于列值字节的数值；\ntext列有一个字符集，并且根据字符集对值进行排序和比较。\n数据类型选择 浮点数相对于定点数的优势是：在长度一定的情况下，浮点数能表示更大的数据范围，但由于浮点数容易产生误差，因此对精度要求较高时，建议使用decimal来储存。\nchar时固定长度，所以处理速度比varchar的速度快，但缺点是浪费储存空间。\n对于myisam存储引擎：最好使用固定长度的数据列替代可变长度的数据列。这样可以使整个表静态化，从而使数据检索更快，用空间换时间。\n对于innodb存储引擎：使用可变长度的数据列，因为innodb数据表的储存格式不分固定长度和可变长度，因此使用char不一定比使用varchar更好，但由于varchar是按照实际的长度储存，比较节省空间，对磁盘i/o和数据存储总量比较好。\nblob是二进制字符串，text是非二进制字符串，两者均可存放大量的信息。blob主要储存图片、音频信息等，而text只能存储文本文件。\n常见运算符 算术运算符： + - * / %\n比较运算符： \u0026gt; \u0026lt; = \u0026gt;= \u0026lt;= != 以及in、between and、is null、greates、least、like、regexp\n逻辑运算符： not( ! )、and( \u0026amp;\u0026amp; )、or( || )、xor\n位运算符：\u0026amp; | ~ ^ \u0026lt;\u0026lt; \u0026gt;\u0026gt;\n运算符 作用 = 等于 \u0026lt;=\u0026gt; 安全的等于 \u0026lt;\u0026gt;(!=) 不等于 \u0026lt;= 小于等于 \u0026gt;= 大于 is null 判断一个值是否为null is not null 判断一个值是否不为null least 有两个或多个参数时返回最小值 greatest 当有两个或多个参数时，返回最大值 between and 一个值是否在两个值之间 isnull 与is null作用相同 in 判断一个值是in列表中的任意一个值 not in 判断一个值不是in列表中的任意一个值 like 通配符匹配 regexp 正则表达式匹配 等于(=) select 1=0, 2=\u0026#39;2\u0026#39;, null=null; 由于=不能用于判断空值null，返回null\n1=0 2=\u0026lsquo;2\u0026rsquo; 2=2 null=null 0 1 1 null 安全等于(\u0026lt;=\u0026gt;) 与=操作符执行相同的比较操作，不过\u0026lt;=\u0026gt;可以用来判断null值。两个操作数均为null时，返回1。一个操作数为null时，返回0\n不能用于判断null 不等于(\u0026lt;\u0026gt;或!=) \u0026amp;\u0026amp; 小于(\u0026lt;) \u0026amp;\u0026amp; 小于等于(\u0026lt;=) \u0026amp;\u0026amp; 大于等于(\u0026gt;=) \u0026amp;\u0026amp; 大于(\u0026gt;)\nbetween and 语法格式：exper between min and max如果expr大于或等于min并且小于或等于max，则返回0\nleast 语法格式：least(值1, 值2, 值3...)，在有两个或多个参数的情况下，返回最小值。假如任意一个自变量为null，则返回null。\ngreatest 语法格式：greatest(值1,值2...)，在有两个或多个参数的情况下，返回最大值。假如任意一个自变量为null，则返回null。\nin、not in select 2 in (1，3，5, \u0026#39;thks\u0026#39;), \u0026#39;thks\u0026#39; in (1,3,5,\u0026#39;thks\u0026#39;); # 0 1 在左侧表达式为null的情况下，或是表中找不到匹配项并且表中的一个表达式为null的情况下，in返回值均为null。\nselect null in (1，3，5, \u0026#39;thks\u0026#39;), 10 in (1,3,null,\u0026#39;thks\u0026#39;); # null null like 语法格式：expr like 匹配条件, expr满足条件返回1，否则0\n若expr或者匹配条件中任何一个为null，结果返回null\n%，匹配任何数目的字符，甚至包括0字符 _，只能匹配一个字符 select \u0026#39;stud\u0026#39; like \u0026#39;stud\u0026#39;, \u0026#39;stud\u0026#39; like \u0026#39;stu_\u0026#39;, \u0026#39;stud\u0026#39; like \u0026#39;%d\u0026#39;, \u0026#39;stud\u0026#39; like \u0026#39;t___\u0026#39;; #\t1\t1\t1\t0 regexp 语法格式：expr regexp 匹配条件，满足返回1，否则0\n若expr或者匹配条件中任何一个为null，结果返回null\n^匹配以该字符后面的字符开头的字符串 $匹配以该字符串后面的字符结尾的字符串 .匹配任何一个单字符 [...]匹配方括号内的任何字符。例如[abc]匹配a b或c。为了命名字符的范围，使用一个-。 [a-z]匹配任何字母，[0-9]匹配任何数字 *匹配零个或多个在它前面的字符。例如x*匹配然和数量的x字符，[0-9]*匹配任何数量的数字，而*匹配任何数量的任何字符。 select \u0026#39;ssky\u0026#39; regexp \u0026#39;^s\u0026#39;, \u0026#39;ssky\u0026#39; regexp \u0026#39;y$\u0026#39;, \u0026#39;ssky\u0026#39; regexp \u0026#39;.sky\u0026#39;, \u0026#39;ssky\u0026#39; regexp \u0026#39;[ab]\u0026#39; # 1 1 1 0 not 或者 ！ 当操作数为null时，返回null\nand 或者 \u0026amp;\u0026amp; 所有操作数均为非零值、并且不为null时，计算所得结果为1；当一个或多个操作数为0时，所得结果为0，其余情况返回null。\nor 或者 || 两个数均为非null值，且任意一个操作数为非零值时，结果为1，否则结果为0；当有一个操作数为null，且另一个操作数为非零值时，结果为1，否则为null；两个操作数均为null时，结果为null。\nselect 1 or null, 0 or null; #\t1 null xor 当任意一个操作数为null时，返回null；对于非null操作数，如果连个操作数都是非0值或者都是0值，返回0；如果一个为0值，另一个为非0值，返回1。\na xor b的计算等同于(a and (not b))或者((not a) and b)\n位运算符 运算符 作用 | 位或 \u0026amp; 位与 ^ 位异或 \u0026lt;\u0026lt; 位左移 \u0026gt;\u0026gt; 位右移 ~ 位取反，反转所有比特 select 10|15, 9|4|2; #\t15 15 select 10\u0026amp;15, 9\u0026amp;4\u0026amp;2; #\t10 0 select 10^15, 1^0, 1^1; #\t5 1 0 select 1\u0026lt;\u0026lt;2, 4\u0026lt;\u0026lt;2; #\t4 16 select 1\u0026gt;\u0026gt;1, 16\u0026gt;\u0026gt;2; #\t0 4 select 5 \u0026amp; ~1; #\t4 ~级别高于\u0026amp; 运算符优先级 优先级 运算符 最低 =(赋值运算)，:= ||, or xor \u0026amp;\u0026amp;, and not between, case, when, then, else =(比较运算符), \u0026lt;=\u0026gt;, \u0026gt;=, \u0026gt;, \u0026lt;=, \u0026lt;, \u0026lt;\u0026gt;, !=, is, like, regexp, in | \u0026amp; \u0026lt;\u0026lt;, \u0026gt;\u0026gt; -, + *, /(div), %(mod) ^ -(负号), ~(位反转) 最高 ! 数学函数 绝对值函数abs(x)和返回圆周率的函数pi() pi函数默认的显示小数位数是6位\nselect abs(-2), pi(); #\t2 3.141593 #保留了7位有效数字 平方根函数sqrt(x)和求余函数mod(x,y) sqrt返回非负数的二次方根\nselect sqrt(9), sqrt(-9), mod(31, 10), mod(45.5, 6) # 3 null\t1\t3.5 取整函数ceil(x)、ceiling(x)和floor(x) ceil(x)和ceiling(x)意义相同，返回不小于x的最小整数值，返回值转化为一个bigint。\nfloor返回不大于x的最大整数值，返回值转化为一个bigint\nselect ceil(-3.35), ceiling(3.35), floor(-3.35), floor(3.35) # -3 4 -4 3 获取随机数rand()和rand(x) rand(x)返回一个随即浮点值v，范围在0到1之间（0 \u0026lt;= v \u0026lt;= 1.0），若已指定一个整数参数x，则它将被用作种子值，用来产生重复序列\nselect rand(), rand(), rand(10), rand(10) 0.7443382784205845 0.1631086432962759 0.6570515219653505 0.6570515219653505 round(x)、round(x, y)和truncate(x, y) round(x)返回最接近于参数x的整数，对x值进行四舍五入\nselect round(-1.14), round(-1.67), round(1.14), round(1.66) #\t-1 -2 1 2 round(x, y)返回最接近于参数x的数，其值保留到小数点后面y位，若y为负数，则将保留x值到小数点左边y位。\nselect round(1.38, 1), round(1.38, 0), round(232.38, 1) # 1.4 1 230 truncate(x, y)函数对操作数进行截取操作，结果保留小数点后面指定y位\n若y为0，则结果不带有小数点或不带有小数部分。若y设为负数，则截取(归零)x小数点左起y位开始的后面所有低位的值。\nselect truncate(1.31, 1), truncate(1.99, 1), truncate(1.99, 0), truncate(19.99, -1) # 1.3 1.9 1 10 符号函数 sign(x) 返回参数的符号，x值为负、零、或正时返回结果依次是-1、0和1\nselect sign(-21), sign(0),sign(21) -1\t0 1 幂函数pow(x,y)、power(x,y)、exp(x) select pow(2,2), power(2,2), pow(2,-2), power(2,-2) 4 4\t0.25\t0.25 exp计算e的乘方\nselect exp(3), exp(-3), exp(0) 20.085536923187668 | 0.049787068367863944 | 1 对数运算函数log(x)和log10(x) log(x)返回x的自然对数，x相对于基数e的对数。\nselect log(3), log(-3); 1.0986122886681098 | null log10(x)计算以10为基数的对数\nselect log10(2), log10(100), log10(-100); 0.3010299956639812 | 2 | null 角度与弧度互相转换的函数radians(x)和degrees(x) # 角度转化为弧度 select radians(90), radians(180); 1.5707963267948966 | 3.141592653589793 # 弧度转化为角度 select degrees(pi()), degrees(pi()/2); 180 | 90 正弦函数sin(x)和反正弦函数asin(x) x为弧度值\nselect sin(1), round(sin(pi())), sin(radians(30)); 0.8414709848078965 | 0 | 0.49999999999999994 select asin(0.8414709848078965), asin(3); 1 | null 余弦函数cos(x)和反余弦函数acos(x) select cos(0), cos(pi()), cos(1); 1 | -1 | 0.5403023058681398 select acos(1), acos(0), round(acos(0.5403023058681398)); 0 | 1.5707963267948966 | 1 正切函数tan(x)、反正切函数atan(x)和余切函数cot(x) select tan(0.3), round(tan(pi()/4)); 0.30933624960962325 | 1 select atan(0.30933624960962325), atan(1); 0.3 | 0.7853981633974483 select cot(0.3), 1/atan(0.3), cot(pi()/4); 3.2327281437658275 | 3.4310402740531716 | 1.0000000000000002 字符串函数 计算字符串字符数的函数和字符串长度的函数 char_length(str)返回字符串str所包含的字符个数，一个多字节字符算作一个字符\nlength(str)返回为字符串的长度，使用utf8编码字符集时，一个汉字是3字节，一个字母或数字为1字节\nselect char_length(\u0026#39;str\u0026#39;), char_length(\u0026#39;estr\u0026#39;), char_length(\u0026#39;哈\u0026#39;); 3 | 4 | 1 select length(\u0026#39;str\u0026#39;), length(\u0026#39;estr\u0026#39;), length(\u0026#39;哈哈哈！\u0026#39;); 3 | 4 | 8 合并字符串函数 concat(s1,s1,\u0026hellip;)\n返回结果为连接参数产生的字符串，若有任何一个参数为null返回null。 若有任意一个参数为二进制字符串，返回二进制字符串 concat_ws(x,s1,s2,\u0026hellip;)\nconcat with separator 第一个参数x是其他参数的分隔符，分隔符的位置放在要链接的两个字符串之间。 分隔符可以是一个字符串也可以是其他参数， 分隔符为null，返回null。函数会忽略任何分隔符参数后的null值 select concat(\u0026#39;my sql\u0026#39;, \u0026#39;5.7\u0026#39;), concat(\u0026#39;my sql\u0026#39;, null, \u0026#39;5.7\u0026#39;); my sql5.7 | null select concat_ws(\u0026#39;-\u0026#39;, \u0026#39;1st\u0026#39;, \u0026#39;2nd\u0026#39;, \u0026#39;3rd\u0026#39;), concat_ws(\u0026#39;*\u0026#39;, \u0026#39;1st\u0026#39;, null, \u0026#39;3rd\u0026#39;); 1st-2nd-3rd | 1st*3rd 替换字符串函数 insert(s1,x,s2)\n返回字符串s1，其子字符串起始于x位置和被字符串s2取代的len字符，如果x超过字符串长度，则返回原始字符串。加入len的长度大于七大字符串长度，则从x开始替换，若任何一个参数为null，则返回null\nselect insert(\u0026#39;quest\u0026#39;, 2, 4, \u0026#39;what\u0026#39;) as col1, insert(\u0026#39;quest\u0026#39;, -1, 4, \u0026#39;what\u0026#39;) as col2, insert(\u0026#39;quest\u0026#39;, 3, 100, \u0026#39;what\u0026#39;) as col3, insert(\u0026#39;questhjklhjkl\u0026#39;, 6, 100, \u0026#39;what\u0026#39;) as col4; | col1 | col2 | col3 | col4 | +-------+-------+--------+-----------+ | qwhat | quest | quwhat | questwhat | 字母大小写转换函数 lower(str)或者lcase(str)可以将字符串str中的字母字符全部转换成小写字母\nupper(str)或者ucase(str)可以将字符串str中的字母字符全部转换成大写字母\nselect lower(\u0026#39;beautiful\u0026#39;),lcase(\u0026#39;well\u0026#39;),upper(\u0026#39;black\u0026#39;), ucase(\u0026#39;black\u0026#39;); +--------------------+---------------+----------------+----------------+ | lower(\u0026#39;beautiful\u0026#39;) | lcase(\u0026#39;well\u0026#39;) | upper(\u0026#39;black\u0026#39;) | ucase(\u0026#39;black\u0026#39;) | +--------------------+---------------+----------------+----------------+ | beautiful | well | black | black | +--------------------+---------------+----------------+----------------+ 获取指定长度的字符串的函数 left(s, n)返回字符串s开始的最左边n个字符\nright(s, n)返回字符串中最右边的n个字符\nselect left(\u0026#39;football\u0026#39;, 5), right(\u0026#39;football\u0026#39;, 4); +---------------------+----------------------+ | left(\u0026#39;football\u0026#39;, 5) | right(\u0026#39;football\u0026#39;, 4) | +---------------------+----------------------+ | footb | ball | +---------------------+----------------------+ 填充字符串函数 lpad(sl, len, s2)返回字符串s1，其左边由字符串s2填补到len字符长度。假如s1的长度大于len，则返回值被缩短至len字符\nrpad(s1, len, s2)返回字符串s1，其右边由字符串s2填补到len字符长度。假如s1的长度大于len，则返回值被缩短至len字符\nselect lpad(\u0026#39;hello\u0026#39;, 4, \u0026#39;??\u0026#39;), lpad(\u0026#39;hello\u0026#39;, 10, \u0026#39;??\u0026#39;); +------------------------+-------------------------+ | lpad(\u0026#39;hello\u0026#39;, 4, \u0026#39;??\u0026#39;) | lpad(\u0026#39;hello\u0026#39;, 10, \u0026#39;??\u0026#39;) | +------------------------+-------------------------+ | hell | ?????hello | +------------------------+-------------------------+ select rpad(\u0026#39;hello\u0026#39;, 4, \u0026#39;?\u0026#39;), lpad(\u0026#39;hello\u0026#39;, 10, \u0026#39;?\u0026#39;); +-----------------------+------------------------+ | rpad(\u0026#39;hello\u0026#39;, 4, \u0026#39;?\u0026#39;) | lpad(\u0026#39;hello\u0026#39;, 10, \u0026#39;?\u0026#39;) | +-----------------------+------------------------+ | hell | ?????hello | +-----------------------+------------------------+ 删除空格的函数 ltrim(s)返回字符串s，字符串左侧空格字符被删除\nrtrim(s)返回字符串s，字符串右侧空格字符被删除\ntrim(s)返回字符串s，字符串两侧空格字符被删除\nselect \u0026#39;(book)\u0026#39;, concat(\u0026#39;(\u0026#39;,ltrim(\u0026#39; book \u0026#39;),\u0026#39;)\u0026#39;); +--------+---------------------------------+ | (book) | concat(\u0026#39;(\u0026#39;,ltrim(\u0026#39; book \u0026#39;),\u0026#39;)\u0026#39;) | +--------+---------------------------------+ | (book) | (book ) | +--------+---------------------------------+ select \u0026#39;(book)\u0026#39;, concat(\u0026#39;(\u0026#39;,rtrim(\u0026#39; book \u0026#39;),\u0026#39;)\u0026#39;); +--------+---------------------------------+ | (book) | concat(\u0026#39;(\u0026#39;,rtrim(\u0026#39; book \u0026#39;),\u0026#39;)\u0026#39;) | +--------+---------------------------------+ | (book) | ( book) | +--------+---------------------------------+ select \u0026#39;(book)\u0026#39;, concat(\u0026#39;(\u0026#39;,trim(\u0026#39; book \u0026#39;),\u0026#39;)\u0026#39;); +--------+--------------------------------+ | (book) | concat(\u0026#39;(\u0026#39;,trim(\u0026#39; book \u0026#39;),\u0026#39;)\u0026#39;) | +--------+--------------------------------+ | (book) | (book) | +--------+--------------------------------+ 删除自定字符串的函数 trim(s1 from s)删除字符串s中两端所有的子字符串s1。s1为可选项，在未指定的情况下，删除空格\n删除两端所有的，但并不删除中间的\nselect trim(\u0026#39;xy\u0026#39; from \u0026#39;xyxboxyokxxyxy\u0026#39;); +----------------------------------+ | trim(\u0026#39;xy\u0026#39; from \u0026#39;xyxboxyokxxyxy\u0026#39;) | +----------------------------------+ | xboxyokx | +----------------------------------+ 重复生成字符串的函数 repeat(s, n)返回一个由重复的字符串s组成的字符串，字符串s的数目等于n。若n\u0026lt;=0，则返回一个空字符串。\n若s或n为null，返回null\nselect repeat(\u0026#39;mysql\u0026#39;, 3); +--------------------+ | repeat(\u0026#39;mysql\u0026#39;, 3) | +--------------------+ | mysqlmysqlmysql | +--------------------+ 空格函数和替换函数 space(n) 返回一个由n个空格组成的字符串\nreplace(s, s1, s2) 使用字符串s2代替字符串中所有的s1\nselect concat( \u0026#39;(\u0026#39;, space(6), \u0026#39;)\u0026#39; ); +------------------------------+ | concat( \u0026#39;(\u0026#39;, space(6), \u0026#39;)\u0026#39; ) | +------------------------------+ | ( ) | +------------------------------+ select replace(\u0026#39;xxx.mysql.com\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;w\u0026#39;); +------------------------------------+ | replace(\u0026#39;xxx.mysql.com\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;w\u0026#39;) | +------------------------------------+ | www.mysql.com | +------------------------------------+ 比较字符串大小的函数 strcmp(s1, s2) 若所有字符均相同，返回0； 若根据当前分类次序，第一个参数小于第二个，则返回-1，其他情况返回1.\nselect strcmp(\u0026#39;txt\u0026#39;, \u0026#39;txt2\u0026#39;), strcmp(\u0026#39;txt2\u0026#39;, \u0026#39;txt\u0026#39;), strcmp(\u0026#39;txt\u0026#39;, \u0026#39;txt\u0026#39;); +-----------------------+-----------------------+----------------------+ | strcmp(\u0026#39;txt\u0026#39;, \u0026#39;txt2\u0026#39;) | strcmp(\u0026#39;txt2\u0026#39;, \u0026#39;txt\u0026#39;) | strcmp(\u0026#39;txt\u0026#39;, \u0026#39;txt\u0026#39;) | +-----------------------+-----------------------+----------------------+ | -1 | 1 | 0 | +-----------------------+-----------------------+----------------------+ 获取字符串的函数 substring(s, n, len) 带有len参数的格式，从字符串s返回一个长度同len字符相同的字字符串，起始于位置n。也可能对n使用一个负值。假若这样，则字字符串的位置起始于字符串结尾的n字符，即倒数第n个字符，而不是字符串的开头。\nmid(s, n, len)与substring(s, n, len)的作用相同\nselect substring(\u0026#39;breakfast\u0026#39;, 5) as coll, substring(\u0026#39;breakfast\u0026#39;, 5, 3) as coll2, substring(\u0026#39;lunch\u0026#39;, -3) as coll3, substring(\u0026#39;lunch\u0026#39;, -5, 3) as coll4; +-------+-------+-------+-------+ | coll | coll2 | coll3 | coll4 | +-------+-------+-------+-------+ | kfast | kfa | nch | lun | +-------+-------+-------+-------+ 匹配字串开始位置的函数 locate(str1, str)、position(str1 in str)和instr(str, str1)三个函数作用相同,返回字字符串str1在字符串str中的开始位置\nselect locate(\u0026#39;ball\u0026#39;, \u0026#39;football\u0026#39;), position(\u0026#39;ball\u0026#39; in \u0026#39;football\u0026#39;), instr(\u0026#39;football\u0026#39;, \u0026#39;ball\u0026#39;); +----------------------------+--------------------------------+---------------------------+ | locate(\u0026#39;ball\u0026#39;, \u0026#39;football\u0026#39;) | position(\u0026#39;ball\u0026#39; in \u0026#39;football\u0026#39;) | instr(\u0026#39;football\u0026#39;, \u0026#39;ball\u0026#39;) | +----------------------------+--------------------------------+---------------------------+ | 5 | 5 | 5 | +----------------------------+--------------------------------+---------------------------+ 字符串逆序 reverse(s)将字符串s反转, 返回的字符串的顺序和s字符串顺序相反.\nselect reverse(\u0026#39;abc\u0026#39;); +----------------+ | reverse(\u0026#39;abc\u0026#39;) | +----------------+ | cba | +----------------+ 返回指定位置的字符串 elt(n, str1, str2, str3,…, strn) 若n==1, 则返回值为str1, 若n==2, 则返回字符串2, 以此类推. 若n小于1或大于参数的数目, 则返回值为null\nselect elt(\u0026#39;3\u0026#39;, \u0026#39;1st\u0026#39;, \u0026#39;2nd\u0026#39;, \u0026#39;3rd\u0026#39;), elt(3, \u0026#39;net\u0026#39;, \u0026#39;os\u0026#39;); +-------------------------------+---------------------+ | elt(\u0026#39;3\u0026#39;, \u0026#39;1st\u0026#39;, \u0026#39;2nd\u0026#39;, \u0026#39;3rd\u0026#39;) | elt(3, \u0026#39;net\u0026#39;, \u0026#39;os\u0026#39;) | +-------------------------------+---------------------+ | 3rd | null | +-------------------------------+---------------------+ 返回指定字符串位置 field(s, s1, s2,…) 返回字符串s在列表s1, s2,…中第一次出现的位置,在找不到s的情况下, 返回值为0. 如果s为null, 则返回值为0, 原因是null不能同任何值进行同等比较\nselect field(\u0026#39;hi\u0026#39;, \u0026#39;hihi\u0026#39;, \u0026#39;hey\u0026#39;, \u0026#39;hi\u0026#39;, \u0026#39;bas\u0026#39;) as coll, field(\u0026#39;hi\u0026#39;, \u0026#39;hey\u0026#39;, \u0026#39;lo\u0026#39;, \u0026#39;hilo\u0026#39;, \u0026#39;foo\u0026#39;) as col2; +------+------+ | coll | col2 | +------+------+ | 3 | 0 | +------+------+ 返回字串位置 find_in_set(s1, s2)返回字符串s1在字符串列表s2中出现的位置, 字符串列表是一个由多个\u0026rsquo;,\u0026lsquo;分开的字符串组成的列表. 如果s1不在s2或s2为空字符串. 则返回0. 如果任意一个参数为null, 则返回值为null.这个函数在第一个参数包含一个逗号\u0026rsquo;,\u0026lsquo;时将无法运行.\nselect find_in_set(\u0026#39;hi\u0026#39;, \u0026#39;hihi,hey,hi,bas\u0026#39;); +--------------------------------------+ | find_in_set(\u0026#39;hi\u0026#39;, \u0026#39;hihi,hey,hi,bas\u0026#39;) | +--------------------------------------+ | 3 | +--------------------------------------+ 选取字符串 make_set(x, s1, s2,…)返回由x的二进制数指定的相应位的字符串组成的字符串, s1对应比特1, s2对应比特01, 以此类推. s1, s2,… 中的null值不会被添加到结果中.\nselect make_set(1, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) as coll, make_set(1 | 4, \u0026#39;hello\u0026#39;, \u0026#39;nice\u0026#39;, \u0026#39;world\u0026#39;) as coll2, make_set(1 | 4, \u0026#39;hello\u0026#39;, \u0026#39;nice\u0026#39;, null, \u0026#39;world\u0026#39;) as coll3, make_set(0, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) as coll4; +------+-------------+-------+-------+ | coll | coll2 | coll3 | coll4 | +------+-------------+-------+-------+ | a | hello,world | hello | | +------+-------------+-------+-------+ 时间和日期函数 获取当前日期的函数和获取当前时间的函数 curdate()和current_date()函数的作用相同,将当前日期按照\u0026rsquo;yyyy-mm-dd\u0026rsquo; 或 yyyymmdd格式的值返回, 具体格式根据函数在字符串或是数字语境中而定.\nselect curdate(), current_date(), curdate() + 0; +------------+----------------+---------------+ | curdate() | current_date() | curdate() + 0 | +------------+----------------+---------------+ | 2019-04-18 | 2019-04-18 | 20190418 | +------------+----------------+---------------+ curtime()和current_time() 函数作用相同, 将当前时间以\u0026rsquo;hh:mm:ss\u0026rsquo;或者\u0026rsquo;hhmmss\u0026rsquo;的格式返回, 具体格式根据函数在字符串或是数字语境中而定.\nselect curtime(), current_time(), curtime() + 0; +-----------+----------------+---------------+ | curtime() | current_time() | curtime() + 0 | +-----------+----------------+---------------+ | 21:02:35 | 21:02:35 | 210235 | +-----------+----------------+---------------+ 获取当前日期和时间的函数 current_timestamp()、localtime()、 now()和sysdate()四个函数的作用相同, 均返回当前日期和时间值, 格式为\u0026rsquo;yyyy-mm-dd hh:mm:ss\u0026rsquo;或\u0026rsquo;yyyymmddhhmmss\u0026rsquo;, 具体格式根据函数在字符串或是数字语境中而定.\nselect current_timestamp(), localtime(), now(), sysdate(); +---------------------+---------------------+---------------------+---------------------+ | current_timestamp() | localtime() | now() | sysdate() | +---------------------+---------------------+---------------------+---------------------+ | 2019-04-18 21:11:50 | 2019-04-18 21:11:50 | 2019-04-18 21:11:50 | 2019-04-18 21:11:50 | +---------------------+---------------------+---------------------+---------------------+ unix时间函数 unix_timestamp(date)若无参数调用, 则返回一个unix时间戳(\u0026lsquo;1970-01-01 00:00:00\u0026rsquo; gmt之后的秒数) 作为无符号整数. 其中, gmt(greenwich mean time) 为格林尼治标准时间. 若用date来调用unix_timestamp(), 它会将参数以'1970-01-01 00:00:00\u0026rsquo; gmt 后的秒数的形式返回. date可以是一个date字符串、datetime字符串、timestamp或一个当地时间的yymmdd或yyyymmdd格式的数字.\nselect unix_timestamp(), unix_timestamp(now()), now(); +------------------+-----------------------+---------------------+ | unix_timestamp() | unix_timestamp(now()) | now() | +------------------+-----------------------+---------------------+ | 1555593491 | 1555593491 | 2019-04-18 21:18:11 | +------------------+-----------------------+---------------------+ from_unixtime(date) 函数把unix时间戳转换成普通格式时间, 与unix_timestamp(date)函数互为反函数.\nselect from_unixtime(1555593491); +---------------------------+ | from_unixtime(1555593491) | +---------------------------+ | 2019-04-18 21:18:11 | +---------------------------+ 返回utc日期的函数和返回utc时间的函数 utc_date()函数返回当前时间utc (世界标准时间) 日期值, 其格式为\u0026rsquo;yyyy-mm-dd\u0026rsquo;或yyymmdd, 具体格式根据函数在字符串或是数字语境中而定.\nselect utc_date(), utc_date() + 0; +------------+----------------+ | utc_date() | utc_date() + 0 | +------------+----------------+ | 2019-04-18 | 20190418 | +------------+----------------+ utc_time()返回值为当前utc时间值, 其格式为\u0026rsquo;hh:mm:ss\u0026rsquo;或者\u0026rsquo;hhmmss\u0026rsquo;, 具体格式根据函数在字符串或是数字语境中而定.\nselect utc_time(), utc_time() + 0; +------------+----------------+ | utc_time() | utc_time() + 0 | +------------+----------------+ | 13:25:21 | 132521 | +------------+----------------+ 获取月份的函数 month(date) 函数返回 date 对应的月份，范围值从1～12\nmonthname(date) 函数返回日期 date 对应的月份的英文全名。\nselect month(\u0026#39;2016-02-13\u0026#39;), monthname(\u0026#39;2016-02-13\u0026#39;); +---------------------+-------------------------+ | month(\u0026#39;2016-02-13\u0026#39;) | monthname(\u0026#39;2016-02-13\u0026#39;) | +---------------------+-------------------------+ | 2 | february | +---------------------+-------------------------+ 获取星期 dayname(d)函数返回d对应的工作日的英文名称, 例如sunday、monday 等.\nselect dayname(\u0026#39;2016-02-10\u0026#39;); +-----------------------+ | dayname(\u0026#39;2016-02-10\u0026#39;) | +-----------------------+ | wednesday | +-----------------------+ dayofweek(d) 函数返回 d 对应的一周中的索引（位置）。1 表示星期日、2 表示星期一\nselect dayofweek(\u0026#39;2016-02-14\u0026#39;); +-------------------------+ | dayofweek(\u0026#39;2016-02-14\u0026#39;) | +-------------------------+ | 1 | +-------------------------+ week(d) 返回 d 对应的工作日索引。 0表示周一、1表示周二\nselect weekday(\u0026#39;2016-02-14 22:23:00\u0026#39;), weekday(\u0026#39;2016-04-01\u0026#39;); +--------------------------------+-----------------------+ | weekday(\u0026#39;2016-02-14 22:23:00\u0026#39;) | weekday(\u0026#39;2016-04-01\u0026#39;) | +--------------------------------+-----------------------+ | 6 | 4 | +--------------------------------+-----------------------+ 获取星期数的函数 week(d) 计算星期 d 是一年中的第几周。week() 的双参形式允许指定该星期是否起始于周日或周一，以及返回值的范围是否为从0～53 或从 1～53. 若mode参数被省略，则使用default_week_format系统自变量的值\nmode 一周的第一天 范围 week 1 为第一周… 0 周日 0～53 本年度中有一个周日 1 周一 0～53 本年度中有3天以上 2 周日 1～53 本年度中有一个周日 3 周一 1～53 本年度中有3天以上 4 周日 0～53 本年度中有3天以上 5 周一 0～53 本年度中有一个周一 6 周日 1～53 本年度中有3天以上 7 周一 1～53 本年度中有一个周一 select week(\u0026#39;2011-02-20\u0026#39;), week(\u0026#39;2011-02-20\u0026#39;, 0), week(\u0026#39;2011-02-20\u0026#39;, 1); +--------------------+-----------------------+-----------------------+ | week(\u0026#39;2011-02-20\u0026#39;) | week(\u0026#39;2011-02-20\u0026#39;, 0) | week(\u0026#39;2011-02-20\u0026#39;, 1) | +--------------------+-----------------------+-----------------------+ | 8 | 8 | 7 | +--------------------+-----------------------+-----------------------+ weekofyear(d) 计算某一天位于一年中的第几周， 范围是1～53，相当于week(d, 3)。\nselect week(\u0026#39;2011-02-20\u0026#39;, 3), weekofyear(\u0026#39;2011-02-20\u0026#39;); +-----------------------+--------------------------+ | week(\u0026#39;2011-02-20\u0026#39;, 3) | weekofyear(\u0026#39;2011-02-20\u0026#39;) | +-----------------------+--------------------------+ | 7 | 7 | +-----------------------+--------------------------+ 获取天数的函数 dayofyear(d) 函数返回d是一年中的第几天， 范围是从1～366。\ndayofmonth(d) 函数返回d是一个月中的第几天，范围是从1～31。\nselect dayofyear(\u0026#39;2016-02-20\u0026#39;), dayofmonth(\u0026#39;2016-02-20\u0026#39;); +-------------------------+--------------------------+ | dayofyear(\u0026#39;2016-02-20\u0026#39;) | dayofmonth(\u0026#39;2016-02-20\u0026#39;) | +-------------------------+--------------------------+ | 51 | 20 | +-------------------------+--------------------------+ 获取年份、季度、小时、分钟、秒数的函数 year(date) 返回date对应的年份，范围是1970～2069。\nselect year(\u0026#39;11-02-03\u0026#39;), year(\u0026#39;96-02-03\u0026#39;); # 00~69 转换为 2000～2069 # 70～99 转换为 1970～1999 +------------------+------------------+ | year(\u0026#39;11-02-03\u0026#39;) | year(\u0026#39;96-02-03\u0026#39;) | +------------------+------------------+ | 2011 | 1996 | +------------------+------------------+ quarter(date) 返回date对应的一年中的季度值，范围从1～4\nselect quarter(\u0026#39;16-04-01\u0026#39;); +---------------------+ | quarter(\u0026#39;16-04-01\u0026#39;) | +---------------------+ | 2 | +---------------------+ minute() 函数返回指定时间的分钟值\nselect second(\u0026#39;16-02-03 10:10:03\u0026#39;); +-----------------------------+ | second(\u0026#39;16-02-03 10:10:03\u0026#39;) | +-----------------------------+ | 3 | +-----------------------------+ second(time) 返回time对应的秒数，范围从0～59\nselect second(\u0026#39;10:05:03\u0026#39;); +--------------------+ | second(\u0026#39;10:05:03\u0026#39;) | +--------------------+ | 3 | +--------------------+ 获取日期的指定值的函数 extract(type from date) 函数所使用的时间间隔类型说明符同 date_add() 或 date_sub() 的相同，但它从日期中提取一部分，而不是执行日期运算。\nselect extract(year from \u0026#39;2016-07-02\u0026#39;) as coll, extract(year_month from \u0026#39;2016-07-12 01:02:03\u0026#39;) as coll2, extract(day_minute from \u0026#39;2016-07-12 01:02:03\u0026#39;) as coll3; +------+--------+--------+ | coll | coll2 | coll3 | +------+--------+--------+ | 2016 | 201607 | 120102 | +------+--------+--------+ 时间和秒钟转换的函数 time_to_sec(time) 返回已转化为秒的time参数。转换公式：小时3600+分钟60+秒\nselect time_to_sec(\u0026#39;23:23:00\u0026#39;); +-------------------------+ | time_to_sec(\u0026#39;23:23:00\u0026#39;) | +-------------------------+ | 84180 | +-------------------------+ sec_to_time(seconds) 返回被转化为小时、分钟和秒数的seconds参数值，其格式为\u0026rsquo;hh:mm:ss\u0026rsquo; 或 hhmmss，具体格式根据该函数是够用在字符串或数字语境中而定。\nselect sec_to_time(2345), sec_to_time(2345)+0, time_to_sec(\u0026#39;23:23:00\u0026#39;), sec_to_time(84180); +-------------------+---------------------+-------------------------+--------------------+ | sec_to_time(2345) | sec_to_time(2345)+0 | time_to_sec(\u0026#39;23:23:00\u0026#39;) | sec_to_time(84180) | +-------------------+---------------------+-------------------------+--------------------+ | 00:39:05 | 3905 | 84180 | 23:23:00 | +-------------------+---------------------+-------------------------+--------------------+ 计算日期和时间的函数 计算日期和时间的函数有：date_add()、 adddate()、date_sub()、subdate()、addtime()、 subtime()和date_diff() 。\ndate_add(date, interval expo type) 和 date_sub(date, interval expo type)，其中，date 是一个datetime 或 date 值，用来指定起始时间。expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。expr 是一个字符串；对于负值的时间间隔，他可以以一个符号-开头。type 为关键字，它指示了表达式被解释的方式。\ntype 值 预期的 expr 格式 microsecond microseconds second seconds minute minutes hour hours day days week weeks month months quarter quarters year years second_microsecond \u0026lsquo;seconds.microseconds\u0026rsquo; minute_microsecond \u0026lsquo;minutes.microseconds\u0026rsquo; minute_second \u0026lsquo;minutes:seconds\u0026rsquo; hour_microsecond \u0026lsquo;hours.microseconds\u0026rsquo; hour_second \u0026lsquo;hours:minutes:seconds\u0026rsquo; hour_minute \u0026lsquo;hours:minutes\u0026rsquo; day_microsecond \u0026lsquo;days.microseconds\u0026rsquo; day_second \u0026lsquo;days hours:minutes:seconds\u0026rsquo; day_minute \u0026lsquo;days hours:minutes\u0026rsquo; day_hour \u0026lsquo;days hours\u0026rsquo; year_month \u0026lsquo;years-months\u0026rsquo; 若date参数是一个date值，计算只会包括year、month和day部分（即没有时间部分），其结果是一个date值。否则，结果将是一个datetime值。\ndate_add(date, interval expo type) 和 adddate(date, interval expo type) 两个函数的作用相同，执行日期的加减运算。\nselect date_add(\u0026#39;2010-12-31 23:59:59\u0026#39;, interval 1 second) as col1, adddate(\u0026#39;2010-12-31 23:59:59\u0026#39;, interval 1 second) as col2, date_add(\u0026#39;2010-12-31 23:59:59\u0026#39;, interval \u0026#39;1:1\u0026#39; minute_second) as col3; +---------------------+---------------------+---------------------+ | col1 | col2 | col3 | +---------------------+---------------------+---------------------+ | 2011-01-01 00:00:00 | 2011-01-01 00:00:00 | 2011-01-01 00:01:00 | +---------------------+---------------------+---------------------+ date_sub(date, interval expr type) 或者 dubdate(date, interval expo type) 两个函数作用相同，执行日期的减运算。\nselect date_sub(\u0026#39;2011-01-02\u0026#39;, interval 31 day) as col1, subdate(\u0026#39;2011-01-02\u0026#39;, interval 31 day) as col2, date_sub(\u0026#39;2011-01-01 00:01:00\u0026#39;, interval \u0026#39;0 0:1:1\u0026#39; day_second) as col3; +------------+------------+---------------------+ | col1 | col2 | col3 | +------------+------------+---------------------+ | 2010-12-02 | 2010-12-02 | 2010-12-31 23:59:59 | +------------+------------+---------------------+ addtime(date, expr) 函数将expr值添加到date，并返回修改后的值，date是一个日期或者日期时间表达式，而expr是一个时间表达式。\nselect addtime(\u0026#39;2000-12-31 23:59:59\u0026#39;, \u0026#39;1:1:1\u0026#39;), addtime(\u0026#39;02:02:02\u0026#39;, \u0026#39;02:00:00\u0026#39;); +-----------------------------------------+---------------------------------+ | addtime(\u0026#39;2000-12-31 23:59:59\u0026#39;, \u0026#39;1:1:1\u0026#39;) | addtime(\u0026#39;02:02:02\u0026#39;, \u0026#39;02:00:00\u0026#39;) | +-----------------------------------------+---------------------------------+ | 2001-01-01 01:01:00 | 04:02:02 | +-----------------------------------------+---------------------------------+ datediff(date1, date2) 返回起始时间date1和结束时间date2之间的天数。date1和date2为日期或date-and-time表达式。计算中只用到这些值的日期部分。\nselect datediff(\u0026#39;2010-12-31 23:59:59\u0026#39;, \u0026#39;2010-12-30\u0026#39;) as col1, datediff(\u0026#39;2010-11-30 23:59:59\u0026#39;, \u0026#39;2010-12-31\u0026#39;) as col2; +------+------+ | col1 | col2 | +------+------+ | 1 | -31 | +------+------+ 将日期和时间格式化的函数 date_format(date, format) 根据format指定的格式显示date值。主要format格式如下\n说明符 说明 %a 工作日的缩写名称(sun..sat) %b 月份的缩写名称(jan..dec) %c 月份，数字形式(0..12) %d 带有英语后缀的该月日期(0th, 1st, 2nd, 3rd,\u0026hellip;) %d 该月日期，数字形式(00..31) %e 该月日期，数字形式(0..31) %f 微秒(000000..999999) %h 以2位数表示24小时(00..23) %h, %i 以2位数表示12小时(01..12) %i 分钟，数字形式(00..59) %j 一年中的天数(001..366) %k 以24(0..23)小时表示时间 %l 以12(1..12)小时表示时间 %m 月份名称(january..december) %m 月份，数字形式(00..12) %p 上午(am)或下午(pm) %r 时间，12小时制(小时 hh: 分钟 mm: 秒数 ss 后加am或pm) %s, %s 以2位数形式表示秒(00..59) %t 时间，24小时制(小时 hh: 分钟 mm: 秒数 ss) %u 周(00..53)，其中周日为每周的第一天 %u 周(00..53)，其中周一为每周的第一天 %v 周(01..53)，其中周日为每周的第一天；和%x同时使用 %v 周(01..53)，其中周一为每周的第一天；和%x同时使用 %w 工作日名称(周日..周六) %w 一周中的每日(0=周日..6=周六) %x 该周的年份，其中周日为每周的第一天；数字形式，4位数；和%v同时使用 %x 该周的年份，其中周一为每周的第一天；数字形式，4位数；和%v同时使用 %y 4位数形式表示年份 %y 2位数形式表示年份 %% \u0026lsquo;%\u0026lsquo;文字字符 select date_format(\u0026#39;1997-10-04 22:23:00\u0026#39;, \u0026#39;%w %m %y\u0026#39;) as col1, date_format(\u0026#39;1997-10-04 22:23:00\u0026#39;, \u0026#39;%d %y %a %d %m %b %j\u0026#39;) as col2; +-----------------------+--------------------------+ | col1 | col2 | +-----------------------+--------------------------+ | saturday october 1997 | 4th 97 sat 04 10 oct 277 | +-----------------------+--------------------------+ time_format(time, format) 根据format字符串安排time值的格式。format字符串可能仅会处理包含小时、分钟和秒的格式说明符，其他说明符产生一个null值或0。若time值包含一个大于23的小时部分，则%h和%k小时格式说明符会产生一个大于0..23的通常范围的值。\nselect time_format(\u0026#39;16:00:00\u0026#39;, \u0026#39;%h %k %h %i %l\u0026#39;); +-------------------------------------------+ | time_format(\u0026#39;16:00:00\u0026#39;, \u0026#39;%h %k %h %i %l\u0026#39;) | +-------------------------------------------+ | 16 16 04 04 4 | +-------------------------------------------+ get_format(val_type, format_type) 返回日期时间字符串的显示格式，val_type 表示日期数据类型，包括date、datetime和time；format_type表示格式化显示类型，包括eur、interval、ios、jis、usa。get_format 根据两个值类型组合返回的字符串显示格式如下表。\n值类型 格式化类型 显示格式字符串 date eur %d.%m.%y date interval %y%m%d date iso %y-%m-%d date jis %y-%m-%d date usa %m.%d.%y time eur %h.%i.%s time interval %h%i%s time iso %h:%i:%s time jis %h:%i:%s time usa %h:%i:%s %p datetime eur %y-%m-%d %h.%i.%s datetime interval %y%m%d%h%i%s datetime iso %y-%m-%d %h:%i:%s datetime jis %y-%m-%d %h:%i:%s datetime usa %y-%m-%d %h.%i.%s select get_format(date, \u0026#39;eur\u0026#39;), get_format(date, \u0026#39;usa\u0026#39;); +-------------------------+-------------------------+ | get_format(date, \u0026#39;eur\u0026#39;) | get_format(date, \u0026#39;usa\u0026#39;) | +-------------------------+-------------------------+ | %d.%m.%y | %m.%d.%y | +-------------------------+-------------------------+ select date_format(\u0026#39;2000-10-05 22:23:00\u0026#39;, get_format(date, \u0026#39;usa\u0026#39;)); +-------------------------------------------------------------+ | date_format(\u0026#39;2000-10-05 22:23:00\u0026#39;, get_format(date, \u0026#39;usa\u0026#39;)) | +-------------------------------------------------------------+ | 10.05.2000 | +-------------------------------------------------------------+ 条件判断函数 if(expr, v1, v2)函数 if(expr, v1, v2)，如果表达式expr是true(expr \u0026lt;\u0026gt; 0 and expr \u0026lt;\u0026gt; null)，则if()的返回值为v1；否则返回值为v2。if()的返回值为数字值或字符串值，具体情况视其所在语境而定。\nselect if(1\u0026gt;2,2,3), if(1\u0026lt;2,\u0026#39;yes \u0026#39;, \u0026#39;no\u0026#39;), if(strcmp(\u0026#39;test\u0026#39;,\u0026#39;test1\u0026#39;),\u0026#39;no\u0026#39;,\u0026#39;yes\u0026#39;); +-------------+----------------------+---------------------------------------+ | if(1\u0026gt;2,2,3) | if(1\u0026lt;2,\u0026#39;yes \u0026#39;, \u0026#39;no\u0026#39;) | if(strcmp(\u0026#39;test\u0026#39;,\u0026#39;test1\u0026#39;),\u0026#39;no\u0026#39;,\u0026#39;yes\u0026#39;) | +-------------+----------------------+---------------------------------------+ | 3 | yes | no | +-------------+----------------------+---------------------------------------+ ifnull(v1,v2)函数 ifnull(v1,v2)假如v1不为null，则ifnull()的返回值为v1；否则其返回值为v2.\nifnull()的返回值为数字值或字符串值，具体情况视其所在语境而定。\nselect ifnull(1,2), ifnull(null, 10), ifnull(1/0, \u0026#39;wrong\u0026#39;); +-------------+------------------+----------------------+ | ifnull(1,2) | ifnull(null, 10) | ifnull(1/0, \u0026#39;wrong\u0026#39;) | +-------------+------------------+----------------------+ | 1 | 10 | wrong | +-------------+------------------+----------------------+ case 函数 case expr when v1 then r1 [when v2 then r2] [else rn] end\n该函数表示，如果expr值等于某个vn，则返回对应位置then后面的结果。如果与所有值都不想等，返回else后面的rn。\nselect case 2 when 1 then \u0026#39;one\u0026#39; when 2 then \u0026#39;two\u0026#39; else \u0026#39;more\u0026#39; end; +------------------------------------------------------------+ | case 2 when 1 then \u0026#39;one\u0026#39; when 2 then \u0026#39;two\u0026#39; else \u0026#39;more\u0026#39; end | +------------------------------------------------------------+ | two | +------------------------------------------------------------+ select case when 1\u0026lt;0 then \u0026#39;true\u0026#39; else \u0026#39;false\u0026#39; end; +--------------------------------------------+ | case when 1\u0026lt;0 then \u0026#39;true\u0026#39; else \u0026#39;false\u0026#39; end | +--------------------------------------------+ | false | +--------------------------------------------+ 系统信息函数","date":"2019-03-04","permalink":"https://blog.akvicor.com/posts/mysql/manual/","summary":"\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"数据库database--schema\"\u003e数据库（Database / Schema）\u003c/h3\u003e\n\u003ch3 id=\"表table\"\u003e表（Table）\u003c/h3\u003e\n\u003cp\u003e数据库表是一系列二维数组的集合\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e行\u003c/strong\u003e被称为记录\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e列\u003c/strong\u003e被称为字段\u003c/p\u003e\n\u003ch3 id=\"主键primary-key\"\u003e主键（Primary Key）\u003c/h3\u003e\n\u003cp\u003e主键又称\u003cstrong\u003e主码\u003c/strong\u003e，用于唯一的标识表中的每一条记录。\u003c/p\u003e\n\u003cp\u003e可以定义表中的一列或多列为主键，主键列上不能有两行相同的值，也不能为空\u003c/p\u003e\n\u003ch3 id=\"数据库系统\"\u003e数据库系统\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e数据库（DataBase / DB）：用于存储数据的地方\u003c/li\u003e\n\u003cli\u003e数据库管理系统（DataBase Management System / DBMS）：用于管理数据库的软件\u003c/li\u003e\n\u003cli\u003e数据库应用程序（DataBase Application）：为了提高数据库系统的处理能力所使用的管理数据库的软件补充。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sql语言\"\u003eSQL语言\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e数据定义语言（DDL）：DROP、CREATE、ALTER\u003c/li\u003e\n\u003cli\u003e数据操作语言（DML）：INSERT、UPDATE、DELETE\u003c/li\u003e\n\u003cli\u003e数据查询语言（DQL）：SELECT\u003c/li\u003e\n\u003cli\u003e数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK\u003c/li\u003e\n\u003c/ul\u003e","title":"manual"},{"content":"一些扩展的markdown语法支持采用latex语法写数学公式，而在网页中使用mathjax插件来显示数学公式。\n本教程介绍如何在markdown中书写数学公式。\n插入数学公式 在markdown中插入数学公式的语法是$数学公式$和$$数学公式$$。\n行内公式是可以让公式在文中与文字或其他东西混编，不独占一行。\n示例\n$$ 质能方程e = mc^2 $$ 显示\n$$质能方程e = mc^2$$\n独立公式使公式单独占一行，不与文中其他文字等混编。\n示例\n质能方程 $$ e = mc^2 $$ 显示\n质能方程\n$$ e = mc^2 $$\n普通公式 普通的加减乘除数学公式的输入方法与平常的书写一样。\n示例\n$$ x = 100 * y + z - 10 / 33 + 10 % 3 $$ 显示\n$$ x = 100 * y + z - 10 / 33 + 10 % 3 $$\n上下标 使用^来表示上标，_来表示下标，同时如果上下标的内容多于一个字符，可以使用{}来将这些内容括起来当做一个整体。 与此同时，上下标是可以嵌套的。\n示例\n$$ x = a_{1}^n + a_{2}^n + a_{3}^n $$ 显示\n$$ x = a_{1}^n + a_{2}^n + a_{3}^n $$\n如果希望左右两边都能有上下标，可以使用\\sideset语法\n示例\n$$ \\sideset{^1_2}{^3_4}a $$ 显示\n$$ \\sideset{^1_2}{^3_4}a $$\n括号 ()，[]和|都表示它们自己，但是{}因为有特殊作用因此当需要显示大括号时一般使用\\lbrace \\rbrace来表示。\n示例\n$$ f(x, y) = 100 * \\lbrace[(x + y) * 3] - 5\\rbrace $$ 显示\n$$ f(x, y) = 100 * \\lbrace[(x + y) * 3] - 5\\rbrace $$\n原始符号不会随着公式大小自动缩放，需要使用 \\left 和 \\right 来实现自动缩放： $$\\left \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\right \\rbrace$$ 效果：\n$$\\left \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\right \\rbrace$$\n不使用\\left 和 \\right的效果：\n$$ \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\rbrace$$ $$ \\lbrace \\sum_{i=0}^n i^3 = \\frac{(n^2+n)(n+6)}{9} \\rbrace$$\n分数 分数使用\\frac{分母}{分子}这样的语法，不过推荐使用\\cfrac来代替\\frac，显示公式不会太挤。\n示例\n$$ \\frac{1}{3} 与 \\cfrac{1}{3} $$ 显示\n$$ \\frac{1}{3} 与 \\cfrac{1}{3} $$\n开方 开方使用\\sqrt[次数]{被开方数}这样的语法\n示例\n$$ \\sqrt[3]{x} $$ $$ \\sqrt{5 - x} $$ 显示\n$$ \\sqrt[3]{x} $$\n$$ \\sqrt{5 - x} $$\n求和与积分 求和使用\\sum,可加上下标，积分使用\\int可加上下限，双重积分用\\iint: $ \\sum_{i=0}^n $ $ \\int_1^\\infty $ $ \\iint_1^\\infty $ 分别显示:$ \\sum_{i=0}^n $ 和$ \\int_1^\\infty $以及$ \\iint_1^\\infty $\n极限 极限使用\\lim: $ \\lim_{x \\to 0} $ 显示为：$ \\lim_{x \\to 0} $\n表格与矩阵 表格样式lcr表示居中，|加入一条竖线，\\hline表示行间横线，列之间用\u0026amp;分隔，行之间用\\分隔 $$\\begin{array}{c|lcr} n \u0026amp; \\text{left} \u0026amp; \\text{center} \u0026amp; \\text{right} \\\\\\\\ \\hline 1 \u0026amp; 1.97 \u0026amp; 5 \u0026amp; 12 \\\\\\\\ 2 \u0026amp; -11 \u0026amp; 19 \u0026amp; -80 \\\\\\\\ 3 \u0026amp; 70 \u0026amp; 209 \u0026amp; 1+i \\\\\\\\ \\end{array}$$ 显示效果为：\n$$\\begin{array}{c|lcr} n \u0026amp; \\text{left} \u0026amp; \\text{center} \u0026amp; \\text{right} \\\\ \\hline 1 \u0026amp; 1.97 \u0026amp; 5 \u0026amp; 12 \\\\ 2 \u0026amp; -11 \u0026amp; 19 \u0026amp; -80 \\\\ 3 \u0026amp; 70 \u0026amp; 209 \u0026amp; 1+i \\\\ \\end{array}$$\n表格的插入也可以使用以下方式：\n名称|说明 ---|---|--- temperature| 室内温度 set temperature| 设定温度 height| 室内高度 显示效果：\n名称 说明 temperature 室内温度 set temperature 设定温度 height 室内高度 矩阵显示和表格很相似 $$\\left[ \\begin{matrix} v_a \\\\\\\\ v_b \\\\\\\\ v_c \\\\\\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 \u0026amp; 0 \u0026amp; l \\\\\\\\ -cosψ \u0026amp; sinψ \u0026amp; l \\\\\\\\ -cosψ \u0026amp; -sinψ \u0026amp; l \\end{matrix} \\right] \\left[ \\begin{matrix} v_x \\\\\\\\ v_y \\\\\\\\ w \\\\\\\\ \\end{matrix} \\right] $$ 显示效果：　$$\\left[ \\begin{matrix} v_a \\\\ v_b \\\\ v_c \\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 \u0026amp; 0 \u0026amp; l \\\\ -cosψ \u0026amp; sinψ \u0026amp; l \\\\ -cosψ \u0026amp; -sinψ \u0026amp; l \\end{matrix} \\right] \\left[ \\begin{matrix} v_x \\\\ v_y \\\\ w \\\\ \\end{matrix} \\right] $$\n希腊字母 见下表\n代码 大写 代码 小写 a a \\alpha α b b \\beta β \\gamma γ \\gamma γ \\delta δ \\delta δ e e \\epsilon ϵ z z \\zeta ζ h h \\eta η \\theta θ \\theta θ i i \\iota ι k k \\kappa κ \\lambda λ \\lambda λ m m \\mu μ n n \\nu ν \\xi ξ \\xi ξ o o \\omicron ο \\pi π \\pi π p p \\rho ρ \\sigma σ \\sigma σ t t \\tau τ \\upsilon υ \\upsilon υ \\phi φ \\phi ϕ x x \\chi χ \\psi ψ \\psi ψ \\omega ω \\omega ω 其他字符 关系运算符 符号 代码 ± \\pm × \\times ÷ \\div ∣ \\mid ∤ \\nmid ⋅ \\cdot ∘ \\circ ∗ \\ast ⨀ \\bigodot ⨂ \\bigotimes ⨁ \\bigoplus ≤ \\leq ≥ \\geq ≠ \\neq ≈ \\approx ≡ \\equiv ∑ \\sum ∏ \\prod ∐ \\coprod 集合运算符 符号 代码 ∅ \\emptyset ∈ \\in ∉ \\notin ⊂ \\subset ⊃ \\supset ⊆ \\subseteq ⊇ \\supseteq ⋂ \\bigcap ⋃ \\bigcup ⋁ \\bigvee ⋀ \\bigwedge ⨄ \\biguplus ⨆ \\bigsqcup 对数运算符 符号 代码 log \\log lg \\lg ln \\ln 三角运算符 符号 代码 ⊥ \\bot ∠ \\angle sin \\sin cos \\cos tan \\tan cot \\cot sec \\sec csc \\csc 微积分运算符 符号 代码 ′ \\prime ∫ \\int ∬ \\iint ∭ \\iiint ⨌ \\iiiint ∮∮ \\oint lim \\lim ∞ \\infty ∇ \\nabla d \\mathrm{d} ","date":"2019-03-04","permalink":"https://blog.akvicor.com/posts/latex/markdown_math/","summary":"\u003cp\u003e一些扩展的\u003ccode\u003eMarkdown\u003c/code\u003e语法支持采用\u003ccode\u003eLaTex\u003c/code\u003e语法写数学公式，而在网页中使用\u003ccode\u003eMathjax\u003c/code\u003e插件来显示数学公式。\u003c/p\u003e\n\u003cp\u003e本教程介绍\u003cstrong\u003e如何在Markdown中书写数学公式\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"插入数学公式\"\u003e插入数学公式\u003c/h2\u003e\n\u003cp\u003e在Markdown中插入数学公式的语法是\u003ccode\u003e$数学公式$\u003c/code\u003e和\u003ccode\u003e$$数学公式$$\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e行内公式\u003c/strong\u003e是可以让公式在文中与文字或其他东西混编，不独占一行。\u003c/p\u003e","title":"markdown 添加数学公式"},{"content":"$ npm install hexo-math --save 在站点配置文件_config.yml中添加：\nmath: engine: \u0026#39;mathjax\u0026#39; # or \u0026#39;katex\u0026#39; mathjax: # src: custom_mathjax_source config: # mathjax config 在 next 主题配置文件中 themes/next-theme/_config.yml 中将 mathjax 设为 true:\n# mathjax support mathjax: enable: true per_page: false cdn: //cdn.mathjax.org/mathjax/latest/mathjax.js?config=tex-ams-mml_htmlormml 也可以在文章的开始集成插件支持，但不建议这么做：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://cdn.mathjax.org/mathjax/latest/mathjax.js?config=tex-ams-mml_htmlormml\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; ","date":"2019-03-04","permalink":"https://blog.akvicor.com/posts/hexo/math/","summary":"$ npm install hexo-math --save 在站点配置文件_config.yml中添加： math: engine: \u0026#39;mathjax\u0026#39; # or \u0026#39;katex\u0026#39; mathjax: # src: custom_mathjax_source config: # MathJax config 在 next 主题配置文件中 themes/next-theme/_config.yml 中将 mathJax 设为 true: # MathJax Support mathjax: enable: true per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML 也可以在文章的开始集成插件","title":"支持数学公式"},{"content":"什么叫正则表达式 正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。\n$pre = \u0026#39;/apple/\u0026#39;; $str = \u0026#34;apple banna orange\u0026#34;; if (preg_match($pre, $str)) { echo \u0026#39;matched\u0026#39;; } 其中字符串/apple/就是一个正则表达式，他用来匹配源字符串中是否存在apple字符串。\nphp中使用pcre库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配，常用来判断一类字符模式是否存在。\n正则表达式的基本语法 pcre库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如：\n/foo bar/ #^[^0-9]$# ~php~ 如果模式中包含分隔符，则分隔符需要使用反斜杠（\\）进行转义。\n/http:\\/\\// 如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。\n$pre = \u0026#39;http://\u0026#39;; $pre = \u0026#39;/\u0026#39;.preg_quote($pre, \u0026#39;/\u0026#39;).\u0026#39;/\u0026#39;; echo $p; 分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，例如使用i修饰符可以忽略大小写匹配：\n$str = \u0026#34;https://www.kvxi.org/\u0026#34;; if (preg_match(\u0026#39;/https/i\u0026#39;, $str)) { echo \u0026#39;matched\u0026#39;; } 元字符与转义 正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有：\n\\ 一般用于转义字符 ^ 断言目标的开始位置(或在多行模式下是行首) $ 断言目标的结束位置(或在多行模式下是行尾) . 匹配除换行符外的任何字符(默认) [ 开始字符类定义 ] 结束字符类定义 | 开始一个可选分支 ( 子组的开始标记 ) 子组的结束标记 ? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词) * 量词，0 次或多次匹配 + 量词，1 次或多次匹配 { 自定义量词开始标记 } 自定义量词结束标记 //下面的\\s匹配任意的空白符，包括空格，制表符，换行符。[\\s]代表非空白符。[\\s]+表示一次或多次匹配非空白符。\n$p = \u0026#39;/^i[^\\s]+(apple|banna)$/\u0026#39;; $str = \u0026#34;i love apple\u0026#34;; if (preg_match($p, $str)) { echo \u0026#39;matched\u0026#39;; } 元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有：\n\\ 转义字符 ^ 仅在作为第一个字符(方括号内)时，表明字符类取反 - 标记字符范围 其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。\n//下面的\\w匹配字母或数字或下划线。\n$pre = \u0026#39;/[\\w\\.\\-]+@[a-z0-9\\-]+\\.(com|cn)/\u0026#39;; $str = \u0026#34;my email akvicor@gmail.com\u0026#34;; preg_match($pre, $str, $match); echo $match[0]; 贪婪模式与懒惰模式 贪婪模式 在可匹配与可不匹配的时候，优先匹配\n//下面的\\d表示匹配数字\n$pre = \u0026#39;/\\d+\\-\\d+/\u0026#39;; $str = \u0026#34;my phone number 21-1234567890\u0026#34;; preg_match($pre, $str, $match); echo $match[0]; // 结果为：21-1234567890 懒惰模式 在可匹配与可不匹配的时候，优先不匹配\n$pre = \u0026#39;/\\d?\\-\\d?/\u0026#39;; $str = \u0026#34;my phone number 21-1234567890\u0026#34;; preg_match($pre, $str, $match); echo $match[0]; // 结果为：1-1 当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数\n$pre = \u0026#39;/\\d{2}\\-\\d{10}/\u0026#39;; $str = \u0026#34;my phone number 21-1234567890\u0026#34;; preg_match($pre, $str, $match); echo $match[0]; //结果为：21-1234567890 使用正则表达式进行匹配 使用正则表达式的目的是为了实现比字符串处理函数更加灵活的处理方式，因此跟字符串处理函数一样，其主要用来判断子字符串是否存在、字符串替换、分割字符串、获取模式子串等。 php使用pcre库函数来进行正则处理，通过设定好模式，然后调用相关的处理函数来取得匹配结果。 preg_match用来执行一个匹配，可以简单的用来判断模式是否匹配成功，或者取得一个匹配结果，他的返回值是匹配成功的次数0或者1，在匹配到1次以后就会停止搜索。\n$subject = \u0026#34;abcdef\u0026#34;; $pattern = \u0026#39;/def/\u0026#39;; preg_match($pattern, $subject, $matches); print_r($matches); // 结果为：array ( [0] =\u0026gt; def ) 上面的代码简单的执行了一个匹配，简单的判断def是否能匹配成功，但是正则表达式的强大的地方是进行模式匹配，因此更多的时候，会使用模式：\n$subject = \u0026#34;abcdef\u0026#34;; $pattern = \u0026#39;/a(.*?)d/\u0026#39;; preg_match($pattern, $subject, $matches); print_r($matches); // 结果为：array ( [0] =\u0026gt; abcd [1] =\u0026gt; bc ) 通过正则表达式可以匹配一个模式，得到更多的有用的数据。\n查找所有匹配结果 preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，preg_match_all可以循环获取一个列表的匹配结果数组。\n$pre = \u0026#34;|\u0026lt;[^\u0026gt;]+\u0026gt;(.*?)\u0026lt;/[^\u0026gt;]+\u0026gt;|i\u0026#34;; $str = \u0026#34;\u0026lt;b\u0026gt;example: \u0026lt;/b\u0026gt;\u0026lt;div align=left\u0026gt;this is a test\u0026lt;/div\u0026gt;\u0026#34;; preg_match_all($pre, $str, $matches); print_r($matches); 可以使用preg_match_all匹配一个表格中的数据：\n$pre = \u0026#34;/\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;(.*?)\u0026lt;\\/td\u0026gt;\\s*\u0026lt;td\u0026gt;(.*?)\u0026lt;\\/td\u0026gt;\\s*\u0026lt;\\/tr\u0026gt;/i\u0026#34;; $str = \u0026#34;\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;eric\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;john\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;26\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;\u0026#34;; preg_match_all($pre, $str, $matches); print_r($matches); $matches结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推。\n正则表达式的搜索和替换 正则表达式的搜索与替换在某些方面具有重要用途，比如调整目标字符串的格式，改变目标字符串中匹配字符串的顺序等。\n例如我们可以简单的调整字符串的日期格式：\n$string = \u0026#39;april 15, 2014\u0026#39;; $pattern = \u0026#39;/(\\w+) (\\d+), (\\d+)/i\u0026#39;; $replacement = \u0026#39;$3, ${1} $2\u0026#39;; echo preg_replace($pattern, $replacement, $string); //结果为：2014, april 15 其中${1}与$1的写法是等效的，表示第一个匹配的字串，$2代表第二个匹配的。\n通过复杂的模式，我们可以更加精确的替换目标字符串的内容。\n$patterns = array (\u0026#39;/(19|20)(\\d{2})-(\\d{1,2})-(\\d{1,2})/\u0026#39;, \u0026#39;/^\\s*{(\\w+)}\\s*=/\u0026#39;); $replace = array (\u0026#39;\\3/\\4/\\1\\2\u0026#39;, \u0026#39;$\\1 =\u0026#39;);//\\3等效于$3,\\4等效于$4，依次类推 echo preg_replace($patterns, $replace, \u0026#39;{startdate} = 1999-5-27\u0026#39;); //结果为：$startdate = 5/27/1999 //详细解释下结果：(19|20)表示取19或者20中任意一个数字，(\\d{2})表示两个数字，(\\d{1,2})表示1个或2个数字，(\\d{1,2})表示1个或2个数字。^\\s*{(\\w+)\\s*=}表示以任意空格开头的，并且包含在{}中的字符，并且以任意空格结尾的，最后有个=号的。 用正则替换来去掉多余的空格与字符：\n$str = \u0026#39;one two\u0026#39;; $str = preg_replace(\u0026#39;/\\s+/\u0026#39;, \u0026#39; \u0026#39;, $str); echo $str; // 结果改变为\u0026#39;one two\u0026#39; pcre 函数 函数 描述 preg_filter 执行一个正则表达式搜索和替换 preg_grep 返回匹配模式的数组条目 preg_last_error 返回最后一个pcre正则执行产生的错误代码 preg_match_all 执行一个全局正则表达式匹配 preg_match 执行一个正则表达式匹配 preg_quote 转义正则表达式字符 preg_replace_callback_array 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace_callback 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace 执行一个正则表达式的搜索和替换 preg_split 通过一个正则表达式分隔字符串 preg 常量 常量 描述 自从 preg_pattern_order 结果按照\u0026quot;规则\u0026quot;排序，仅用于preg_match_all()， 即$matches[0]是完整规则的匹配结果， $matches[1]是第一个子组匹配的结果，等等。 since preg_set_order 结果按照\u0026quot;集合\u0026quot;排序，仅用于preg_match_all()， 即$matches[0]保存第一次匹配结果的所有结果(包含子组)信息, $matches[1]保存第二次的结果信息，等等。 preg_offset_capture 查看preg_split_offset_capture的描述。 4.3.0 preg_split_no_empty 这个标记告诉 preg_split() 进返回非空部分。 preg_split_delim_capture 这个标记告诉 preg_split() 同时捕获括号表达式匹配到的内容。 4.0.5 preg_split_offset_capture 如果设置了这个标记，每次出现的匹配子串的偏移量也会被返回。注意，这会改变返回数组中的值， 每个元素都是由匹配子串作为第0个元素，它相对目标字符串的偏移量作为第1个元素的数组。这个 标记只能用于 preg_split()。 4.3.0 preg_no_error 没有匹配错误时调用 preg_last_error() 返回。 5.2.0 preg_internal_error 如果有pcre内部错误时调用 preg_last_error() 返回。 5.2.0 preg_backtrack_limit_error 如果调用回溯限制超出，调用preg_last_error()时返回。 5.2.0 preg_recursion_limit_error 如果递归限制超出，调用preg_last_error()时返回。 5.2.0 preg_bad_utf8_error 如果最后一个错误时由于异常的utf-8数据(仅在运行在 utf-8 模式正则表达式下可用)。 导致的，调用preg_last_error()返回。 5.2.0 preg_bad_utf8_offset_error 如果偏移量与合法的urf-8代码不匹配(仅在运行在 utf-8 模式正则表达式下可用)。 调用preg_last_error()返回。 5.3.0 pcre_version pcre版本号和发布日期(比如： \u0026ldquo;7.0 18-dec-2006\u0026quot;)。 5.2.4 etc 正则表达式是一种描述字符串结果的语法规则，是一个特定的格式化模式，可以匹配、替换、截取匹配的字符串。常用的语言基本上都有正则表达式，如javascript、java等。其实，只有了解一种语言的正则使用，其他语言的正则使用起来，就相对简单些。好了，开始写正则了。\n正则表达式在匹配字符串时，遵循以下2个基本原则： 1.最左原则：正则表达式总是从目标字符串的最左侧开始，依次匹配，直到匹配到符合表达式要求的部分，或直到匹配目标字符串的结束。 2.最长原则：对于匹配到的目标字符串，正则表达式总是会匹配到符合正则表达式要求的最长的部分；即贪婪模式\n那怎么开始呢，首先从分隔符开始写起，常用包括 / ; #；~，用于表明一串正则的开始。如：‘/a.*a/’。当表达式有过多的转义字符时，建议优先使用#，如url;\n$str = \u0026#39;http://baidu.com\u0026#39;; $pattern = \u0026#39;/http:\\/\\/.*com/\u0026#39;;//需要转义/ preg_match($pattern,$str,$match); var_dump( $match); $str = \u0026#39;http://baidu.com\u0026#39;; $pattern = \u0026#39;#http://.*com#\u0026#39;;//不需要转义/ preg_match($pattern,$str,$match); var_dump( $match); 知道开始和结尾的写法了，接下来就是中间的判断了。正则表达式是自左向右的顺序使用原子和元字符进行拼接。比如\u0026rsquo;\u0026lt;b\u0026gt;zxcv\u0026lt;/b\u0026gt;\u0026rsquo;,进行匹配时，‘/\u0026lt;b\u0026gt;.*\u0026lt;\\/b\u0026gt;/’,其中.*代表zxcv 。那么通用原子和元字符有哪些呢?\n\\d\t匹配一个数字字符。等价于 [0-9]。 \\d\t匹配一个非数字字符。等价于 [^0-9]。 \\f\t匹配一个换页符。等价于 \\x0c 和 \\cl。 \\n\t匹配一个换行符。等价于 \\x0a 和 \\cj。 \\r\t匹配一个回车符。等价于 \\x0d 和 \\cm。 \\s\t匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\s\t匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t\t匹配一个制表符。等价于 \\x09 和 \\ci。 \\v\t匹配一个垂直制表符。等价于 \\x0b 和 \\ck。 \\w\t匹配包括下划线的任何单词字符。等价于’[a-za-z0-9_]’。 \\w\t匹配任何非单词字符。等价于 ‘[^a-za-z0-9_]’。 \\xn\t匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “a”。’\\x041’ 则等价于 ‘\\x04’ \u0026amp; “1”。正则表达式中可以使用 ascii 编码。 \\nm\t标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 • \\nm 将匹配八进制转义值 nm。 \\nml\t如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un\t十六进制数字表示的 unicode 字符。例如， \\u00a9 匹配版权符号(?)。 .\t匹配除 “\\n” 之外的任何单个字符 ^ 匹配输入字符串的开始位置。在字符域[]中表示取反，如\u0026rsquo;[^\\w]\u0026lsquo;等于\u0026rsquo;\\w\u0026rsquo;;而^\\w表示以单词字符开头。 $ 匹配输入字符串的结束位置。例\u0026rsquo;\\w$\u0026lsquo;表示以单词字符结尾。 ？ 匹配前面的子表达式零次或一次 等价于 {0,1}，例如，\u0026quot;do(es)?\u0026rdquo; 可以匹配 \u0026ldquo;do\u0026rdquo; 或 \u0026ldquo;does\u0026quot;。 * 匹配前面的子表达式零次或多次，等价于{0,}。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 、 \u0026ldquo;zo\u0026quot;、\u0026rsquo;zoo\u0026rsquo;。 + 匹配前面的子表达式一次或多次，等价于{1,}例如，\u0026lsquo;zo+\u0026rsquo; 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。 {n} n 为非负整数,匹配确定的 n 次。例如，\u0026rsquo;o{2}\u0026rsquo; 不能匹配 \u0026ldquo;bob\u0026rdquo; 或‘booob’，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o。 {n,} n 为非负整数。至少匹配n 次。例如，\u0026rsquo;o{2,}\u0026rsquo; 不能匹配 \u0026ldquo;bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。\u0026rsquo;o{1,}\u0026rsquo; 等价于 \u0026lsquo;o+\u0026rsquo;。\u0026rsquo;o{0,}\u0026rsquo; 则等价于 \u0026lsquo;o*\u0026rsquo;。 {n,m} m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，\u0026quot;o{1,3}\u0026rdquo; 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。\u0026rsquo;o{0,1}\u0026rsquo; 等价于 \u0026lsquo;o?\u0026rsquo;。请注意在逗号和两个数之间不能有空格。 [] 字符集合(字符域)。匹配所包含的任意一个字符。例如， \u0026lsquo;[abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的 \u0026lsquo;a\u0026rsquo;。 () 匹配 ()内的内容 并获取这一匹配。搭配\\n(n为大于1的整数)，‘http://baidu.com’若表达式：‘（\\w+） (:)\\/\\/.*\\1’则匹配‘http://baidu.comhttp’,\\1表示http。 (?:) 匹 配 但不获取匹配结果，不进行存储供以后使用。这在使用 \u0026ldquo;或\u0026rdquo; 字符 (|) 来组合一个模式的各个部分是很有用。例如， \u0026lsquo;industr(?:y|ies) 就是一个比 \u0026lsquo;industry|industries\u0026rsquo; 更简略的表达式。上面表达式若改为\u0026rsquo;（?:\\w+）(:)\\/\\/.*\\1\u0026rsquo;，则\\1表示为： | x|y,匹配 x 或 y。例如，\u0026rsquo;z|food\u0026rsquo; 能匹配 \u0026ldquo;z\u0026rdquo; 或 \u0026ldquo;food\u0026quot;。\u0026rsquo;(z|f)ood\u0026rsquo; 则匹配 \u0026ldquo;zood\u0026rdquo; 或 \u0026ldquo;food\u0026quot;。 [-] 字符范围。匹配指定范围内的任意字符。例如，\u0026rsquo;[a-z]\u0026rsquo; 可以匹配 \u0026lsquo;a\u0026rsquo; 到 \u0026lsquo;z\u0026rsquo; 范围内的任意小写字母字符。 (?=pattern)\t正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹 配不需要获取供以后使用。例如，\u0026rsquo;windows (?=95|98|nt|2000)\u0026rsquo; 能匹配 \u0026ldquo;windows 2000\u0026rdquo; 中的 \u0026ldquo;windows\u0026rdquo; ，但不能匹配 \u0026ldquo;windows 3.1\u0026rdquo; 中的 \u0026ldquo;windows\u0026rdquo;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹 配的搜索，而不是从包含预查的字符之后开始。 (?!pattern)\t负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不 需要获取供以后使用。例如\u0026rsquo;windows (?!95|98|nt|2000)\u0026rsquo; 能匹配 \u0026ldquo;windows 3.1\u0026rdquo; 中的 \u0026ldquo;windows\u0026rdquo;，但不能匹配 \u0026ldquo;windows 2000\u0026rdquo; 中的 \u0026ldquo;windows\u0026rdquo;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜 索，而不是从包含预查的字符之后开始 有时候最后定界符会有一个字母，如‘/as.*/i’,那这个i又是什么呢，这就是模式修正符；\ni\t表示在和模式进行匹配进不区分大小写 m\t将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束 s\t如果没有使用这个模式修正符号，元字符中的\u0026rdquo;.\u0026ldquo;默认不能表示换行符号,将字符串视为单行 x\t表示模式中的空白忽略不计 e\t正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说) a\t以模式字符串开头，相当于元字符^ z\t以模式字符串结尾，相当于元字符$ u\t正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式 例：\n$str = \u0026#39;asddadsdasd\u0026#39;; $pattern = \u0026#39;/a.*d/\u0026#39;; preg_match($pattern,$str,$match); var_dump($match) ;//asddadsdasd; $str = \u0026#39;asddadsdasd\u0026#39;; $pattern = \u0026#39;/a.*d/u\u0026#39;;//$pattern = \u0026#39;/a.*?d/\u0026#39;; preg_match($pattern,$str,$match); var_dump($match) ;//asd php常用正则函数;\n匹配：preg_match() 与 preg_match_all()\n1 preg_match($pattern,$subject,[array \u0026amp;$matches]) 2 preg_match_all($pattern,$subject,array \u0026amp;$matches)\n1只会匹配一次，2会把所有符合的字符串都匹配出来，并且放置到matches数组中，而且这两个函数都有一个整形的返回 值。1是一维数组，2是二维数组\n替换：preg_replace()\nmixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int \u0026amp;$count ]] ) 搜索subject中匹配pattern的部分， 以replacement进行替换。\n","date":"2019-02-19","permalink":"https://blog.akvicor.com/posts/php/regular_expression/","summary":"\u003ch2 id=\"什么叫正则表达式\"\u003e什么叫正则表达式\u003c/h2\u003e\n\u003cp\u003e正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-PHP\" data-lang=\"PHP\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#008080\"\u003e$pre\u003c/span\u003e \u003cspan style=\"color:#000;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#d14\"\u003e\u0026#39;/apple/\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#008080\"\u003e$str\u003c/span\u003e \u003cspan style=\"color:#000;font-weight:bold\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#d14\"\u003e\u0026#34;apple banna orange\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#000;font-weight:bold\"\u003eif\u003c/span\u003e (preg_match(\u003cspan style=\"color:#008080\"\u003e$pre\u003c/span\u003e, \u003cspan style=\"color:#008080\"\u003e$str\u003c/span\u003e)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#000;font-weight:bold\"\u003eecho\u003c/span\u003e \u003cspan style=\"color:#d14\"\u003e\u0026#39;matched\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中字符串\u003ccode\u003e/apple/\u003c/code\u003e就是一个正则表达式，他用来匹配源字符串中是否存在apple字符串。\u003c/p\u003e\n\u003cp\u003ePHP中使用PCRE库函数进行正则匹配，比如上例中的\u003ccode\u003epreg_match\u003c/code\u003e用于执行一个正则匹配，常用来判断一类字符模式是否存在。\u003c/p\u003e","title":"正则表达式"},{"content":"欧拉φ函数：在数论中，对正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数、欧拉商数等。\nφ(1)=1; φ(2)=1; φ(3)=2; φ(4)=2; φ(9)=6\n欧拉φ函数 int geteuler(int n) { //欧拉函数 int res = n; for(int i = 2;i*i \u0026lt;= n; ++i){ if(a%i == 0){ res -= res/i; while(n%i == 0) n /= i; } } if(a \u0026gt; 1) // 因为是遍历到sqrt(n)，所以可能存在未除尽或者n本身就为质数的情况 res -= res/n; return res; } int phi(int x) { //欧拉函数 int i, re = x; for (i = 2; i * i \u0026lt;= x; i++) if (x % i == 0) { re /= i; re *= i - 1; while (x % i == 0) x /= i; } if (x ^ 1) re /= x, re *= x - 1; return re; } 欧拉降幂公式 ab(modc) = abmodφ(c)+φ(c)mod(c)\n快速幂 ll quickpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y \u0026gt;\u0026gt;= 1, x = x * x % mod) if (y \u0026amp; 1)res = res * x % mod; return res; } long long quickpow(long long a, int n) { long long answer = 1; for (; n; n /= 2, a = a * a % mod) if (n % 2 == 1) answer = answer * a % mod; return answer % mod; } 应用题目 题目目标：2的n次方mod1e9+7（1\u0026lt;=n\u0026lt;=10100000）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; typedef long long ll; const int mod = 1e9 + 7; int geteuler(int n) //欧拉函数 { int i; int res = n, a = n; for (i = 2; i * i \u0026lt;= a; ++i) { if (a % i == 0) { res -= res / i; while (a % i == 0) a /= i; } } if (a \u0026gt; 1) res -= res / a; return res; } ll quickpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y \u0026gt;\u0026gt;= 1, x = x * x % mod) if (y \u0026amp; 1)res = res * x % mod; return res; } char n[100006]; char m[100006]; int main() { scanf(\u0026#34;%s %s\u0026#34;, n, m); int phi_c = geteuler(mod); int len = strlen(n); ll sum = 0; for (int i = 0; i \u0026lt; len; ++i) { sum = (sum * 10 + n[i] - \u0026#39;0\u0026#39;) % phi_c; } cout \u0026lt;\u0026lt; quickpow(2,sum+phi_c,mod) \u0026lt;\u0026lt; endl; } 快速幂方法推导 算法1.直接设计算法 int ans = 1; for(int i = 1;i\u0026lt;=b;i++) { ans = ans * a; } ans = ans % c; 缺点：这个算法存在着明显的问题，如果a和b过大，很容易就会溢出。\n我们先来看看第一个改进方案：在讲这个方案之前，要先看这样一个公式：ab mod c = (a mod c)b mod c\n算法2.改进算法 int ans = 1; a = a % c; //加上这一句 for(int i = 1;i\u0026lt;=b;i++) { ans = ans * a; } ans = ans % c; 既然某个因子取余之后相乘再取余保持余数不变，那么新算得的ans也可以进行取余，所以得到比较良好的改进版本。\n算法3.进一步改进算法 int ans = 1; a = a % c; //加上这一句 for(int i = 1;i\u0026lt;=b;i++) { ans = (ans * a) % c;//这里再取了一次余 } ans = ans % c; 这个算法在时间复杂度上没有改进，仍为o(b)，不过已经好很多的，但是在c过大的条件下，还是很有可能超时，所以，我们推出以下的快速幂算法。\n算法4.快速幂算法 快速幂算法依赖于以下明显的公式：\nab mod c = ((a2)b/2) mod c\t,b是偶数\nab mod c = ((a2)b/2×a) mod c\t,b是奇数\nint powermod(int a, int b, int c) { int ans = 1; a = a % c; while(b\u0026gt;0) { if(b % 2 = = 1) ans = (ans * a) % c; b = b/2; a = (a * a) % c; } return ans; } 本算法的时间复杂度为o(logb)\n","date":"2019-02-18","permalink":"https://blog.akvicor.com/posts/algorithm/euler_quick_pow/","summary":"\u003cp\u003e\u003cstrong\u003e欧拉φ函数\u003c/strong\u003e：在数论中，对正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数、欧拉商数等。\u003c/p\u003e\n\u003cp\u003eφ(1)=1;  φ(2)=1;  φ(3)=2;  φ(4)=2;  φ(9)=6\u003c/p\u003e","title":"欧拉降幂 \u0026\u0026 快速幂"},{"content":"\n使用chrome浏览器访问百度，在页面上右键点击“检查”–\u0026gt;console，可以看到上面这样的信息，如何在自己的网站上实现这样的功能？\n其实上面一段是利用console.log输出的，此功能前端调试方面很实用。\n只要在header中加入以下代码即可\n\u0026lt;script\u0026gt; try{ if(window.console\u0026amp;\u0026amp;window.console.log) { console.log(\u0026#34;不谢：%chttps://akvicor.com/\u0026#34;,\u0026#34;color:blue\u0026#34;); } } catch(e){}; \u0026lt;/script\u0026gt; %c的作用是为后面的字符串加上css样式，与后面的css代码对应\n","date":"2019-02-12","permalink":"https://blog.akvicor.com/posts/js/personalized_console/","summary":"\u003cp\u003e\u003cimg src=\"https://img.akvicor.com/i/2024/09/17/66e9a23e24352.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e使用Chrome浏览器访问百度，在页面上右键点击“检查”–\u0026gt;Console，可以看到上面这样的信息，如何在自己的网站上实现这样的功能？\u003c/p\u003e","title":"网站添加个性的console"},{"content":"下载文件 下载\n解压后右键以管理员权限运行\n压缩包中包含 去除小箭头.bat 恢复小箭头.bat 或者使用dism++ dism++\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/windows/shortcut_arrow/","summary":"\u003ch2 id=\"下载文件\"\u003e下载文件\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://cloud.akvicor.com/Tools/win10shortcut.zip\"\u003e下载\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e解压后右键以管理员权限运行\u003c/p\u003e","title":"隐藏快捷方式小箭头"},{"content":"适合喜欢win7风格图片查看器的用户\nwin + r 快捷键调出“运行”对话框，输入“regedit” 进入hkey_local_machine\\software\\microsoft\\windows photo viewer\\capabilities\\fileassociations 在右侧窗口中点击右键，选择“新建 - 字符串值”，然后把新建的字符串值重命名为 .jpg ，数值数据设置为photoviewer.fileassoc.tiff 。 然后按同样的方法新建名为 .jpeg .png .gif .bmp .pcx .tiff .ico 等常用图片格式的字符串值，数值数据均设置为 photoviewer.fileassoc.tiff 。 或者使用dism++ dism++\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/windows/enabel_win7_photo_viewer/","summary":"\u003cp\u003e适合喜欢Win7风格图片查看器的用户\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://img.akvicor.com/i/2024/09/17/66e9a63ea895c.png\" alt=\"img\"\u003e\u003c/p\u003e","title":"在win10上使用win7图片查看器"},{"content":"在操作某些系统文件时，会遇到权限不足而无法操作的问题，这时候我们就需要获取该文件的管理员权限才能继续操作\n下载文件 中文系统点这下载\n英文系统点这下载\n获取管理员权限.reg - 在右键菜单添加“获取管理员权限”选项 恢复原始权限.reg - 在右键菜单添加“恢复原始权限”选项 移除权限选项.reg - 在右键菜单中移除前面两个选项 使用notepad++编辑修改 如果觉得“获取管理员权限”不好看也可以修改成自己喜欢的文字（最好使用常见字符以免系统无法识别）\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/windows/right_click_admin/","summary":"\u003cp\u003e在操作某些系统文件时，会遇到权限不足而无法操作的问题，这时候我们就需要获取该文件的管理员权限才能继续操作\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://img.akvicor.com/i/2024/09/18/66e9a783d264d.png\" alt=\"\"\u003e\u003c/p\u003e","title":"为鼠标右键菜单添加g获取管理员权限"},{"content":"这种方法只有在数据文件ibd存在及知道表结构时才能使用\n连接mysql 切换到对应的数据库：\nuse databasename\n执行：\nalter table 表的名字 discard tablespace;\n复制表ibd文件\n修改ibd文件权限 ：\nchown -r mysql.mysql 表的名字.ibd\n执行：\nalter table 表的名字 import tablespace;\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/mysql/restore/","summary":"\u003cp\u003e这种方法只有在数据文件ibd存在及知道表结构时才能使用\u003c/p\u003e","title":"恢复mysql数据库数据"},{"content":"安装好的git环境 https://git-scm.com/\n在u盘上创建空仓库test.git(我的u盘盘符在pc端是i盘)。\n$ cd /i $ mkdir test $ cd test $ git init --bare 得到如下显示即表明git仓库创建成功\ninitialized empty git repository in i:/test/\n现有git工程与u盘仓库关联(在git工程根目录下执行)\n$ git remote add usb /i/test\n版本管理，仓库有了，剩下就是推送和拉取文件了\n$ git push usb master $ git pull usb master git命令 （先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库\ngit init\n把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件\ngit add . git config --global user.name \u0026#34;yourname\u0026#34; git config --global user.email \u0026#34;your@email.com\u0026#34; 用命令 git commit告诉git，把文件提交到仓库。引号内为提交说明\ngit commit -m 'first commit'\n你的远程库地址`关联到远程库\ngit remote add origin\n获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）\ngit pull --rebase origin master\n把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。\ngit push -u origin master\n状态查询命令\ngit status\n使用git时出现：warning: lf will be replaced by crlf 如果项目已经创建，则需要先删除之前创建的.git 文件后添加上面的设置\n删除.git\nrm -rf .git\n禁用自动转换\n$ git config --global core.autocrlf false $ git init $ git add . ","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/git/usb_private/","summary":"\u003cp\u003e安装好的git环境 \u003ca href=\"https://git-scm.com/\"\u003ehttps://git-scm.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在U盘上创建空仓库test.git(我的U盘盘符在PC端是I盘)。\u003c/p\u003e","title":"在u盘中建立自己的私有git云"},{"content":"在编译opencv的时候，出现内存不够的情况，/root使用率100%，导致编译错误，所以需要拓展sd卡容量\ngoogle了一下，发现树莓派在默认情况下，仅仅使用了sd卡的4g容量，剩下的空间，属于空白分区，完全没有利用起来 所以，我们可以通过df命令，来调整linux分区的size\n重新树莓派，进入命令行页面 登陆树莓派，用户名pi，密码raspberry 切换至超级用户sudo su 显示出当前分区的状态和使用率df -h 输入fdisk /dev/mmcblk0 加载sd卡 p打印当前分区 你应该会看到三个分区(mmcblk0, mmcblk0p1, mmcblk0p2)，现在把分区2的信息写下来（/dev/mmcblk0p2） 我主要记录了开始扇区（122880）和结束扇区（8447999）的数值 按d开始删除分区 系统提示输入删除分区号，输入2 按n新建分区，然后依次输入p, 2 接下来输入原来记录的2扇区开始号(122880)，记得替换成你自己的数字 按w保持配置 输入reboot重启树莓派 输入sudo resize2fs /dev/mmcblk0p2 更新系统 输入df -h看看，是不是已经完全使用了剩余空间 ","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/raspberry/use_full_sdcard/","summary":"\u003cp\u003e在编译opencv的时候，出现内存不够的情况，/root使用率100%，导致编译错误，所以需要拓展SD卡容量\u003c/p\u003e\n\u003cp\u003egoogle了一下，发现树莓派在默认情况下，仅仅使用了SD卡的4G容量，剩下的空间，属于空白分区，完全没有利用起来 所以，我们可以通过\u003ccode\u003edf\u003c/code\u003e命令，来调整linux分区的size\u003c/p\u003e","title":"修复树莓派等无法正常使用sd卡全部空间"},{"content":"在日常使用过程中突然sftp无法连接到服务器\n将/etc/ssh/sshd_config 中的\nsubsystem sftp /usr/libexec/openssh/sftp-server\n改为\nsubsystem sftp internal-sftp\n重启 sshd 后，sftp 正常工作了。\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/ssh/sftp_connect_failed/","summary":"\u003cp\u003e在日常使用过程中突然sftp无法连接到服务器\u003c/p\u003e","title":"修复sftp无法正常工作"},{"content":"硬盘首先进行分区和格式化，这里推荐用minitool partition wizard home edition来格式化成ext4，下载地址为http://www.partitionwizard.com/download.html 。其实你也可以使用树莓派自带的sudo mkfs -t ext4 /dev/sdb1来进行格式化，这里不推荐啊，因为速度比较慢。：）\n用xshell5软件连接树莓派，输入df -h来查看挂载情况。\n接下来就直接挂载到samba上面，为以后方便。\n新建文件夹\nsudo mkdir /samba\n设置权限\nsudo chmod 0777 /samba\n取消默认挂载\nsudo umount /dev/sda1\n挂载到samba上\nsudo mount /dev/sda1 /samba\n这里再用df -h查看挂载情况，上图画红圈的/dev/sda1表示已经挂载，这里我挂载到了samba上面。\n每次树莓派重启或者硬盘插拔都需要对硬盘进行重新挂载，比较麻烦，因此需要自动挂载。这里要修改/etc/fstab文件。\n这里使用sudo nano /etc/fstab来修改挂载情况。按照如下图来修改就好了。\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/raspberry/mount_hhd/","summary":"\u003cp\u003e硬盘首先进行分区和格式化，这里推荐用MiniTool Partition Wizard Home Edition来格式化成ext4，下载地址为\u003ccode\u003ehttp://www.partitionwizard.com/download.html\u003c/code\u003e 。其实你也可以使用树莓派自带的sudo mkfs -t ext4 /dev/sdb1来进行格式化，这里不推荐啊，因为速度比较慢。：）\u003c/p\u003e\n\u003cp\u003e用Xshell5软件连接树莓派，输入df -h来查看挂载情况。\u003c/p\u003e\n\u003cp\u003e接下来就直接挂载到samba上面，为以后方便。\u003c/p\u003e","title":"为树莓派等挂载硬盘"},{"content":"由于部分服务器提供商出于安全考虑默认关闭了服务器的ssh密码登录，例如google cloud platform\n登录服务器 使用网页登录或手机客户端连接到服务器，或者使用key登录\n切换到root用户 # 执行 sudo su # 编辑文件 vi /etc/ssh/sshd_config 找到以下部分\n# authentication: logingracetime 120 permitrootlogin yes //默认为no，需要开启root用户访问改为yes strictmodes yes # change to no to disable tunnelled clear text passwords passwordauthentication yes //默认为no，改为yes开启密码登陆 重启ssh服务使修改生效\n/etc/init.d/ssh restart\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/ssh/enable_password_login/","summary":"\u003cp\u003e由于部分服务器提供商出于安全考虑默认关闭了服务器的ssh密码登录，例如Google Cloud Platform\u003c/p\u003e","title":"开启vps服务器的ssh密码登录"},{"content":"在windows环境下配置java开发环境变量，并配置多版本java\n本文使用java8和java11\n下载jdk http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n打开环境变量变量 在系统变量下新建\njava_home\nc:\\language\\java\\jdk1.8.0_171\nclasspath\n.;%java_home%\\lib;%java_home%\\lib\\tools.jar\n在path下添加\n%java_home%\\bin %java_home%\\jre\\bin 检查是否配置正确 打开cmd 输入命令以下命令检查是否配置正确 均能得到返回信息则配置正确\njavac java java -version 多版本配置 在系统变量下新建\njava8_home c:\\language\\java\\jdk1.8.0_171 java11_home c:\\language\\java\\jdk-11.0.2 修改java_home为\n%java8_home% 若需要java11只需要将java_home中的8改为11即可\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/java/install/","summary":"\u003cp\u003e在Windows环境下配置Java开发环境变量，并配置多版本Java\u003c/p\u003e\n\u003cp\u003e本文使用java8和java11\u003c/p\u003e","title":"java install"},{"content":"h5ai是一款功能强大 php 文件目录列表程序，由德国开发者 lars jung 主导开发，它提供多种文件目录列表呈现方式，支持多种主流 web 服务器，例如 nginx、apache、cherokee、lighttpd 等，支持多国语言，可以使用本程序在线预览文本、图片、音频、视频等。\n请注意，默认情况下，放到目录下的 .php 文件将会被直接执行，并不以文本显示。\nweb环境 首先需要搭建好 web 服务器，例如 lnmp（linux/nginx/mysql/php）组合，本文直接以 lnmp 组合为例。\n推荐使用 php 7 版本。\n下载 h5ai 安装包 转至官网下载：链接\n设置好虚拟主机后，编辑虚拟主机配置文件： vim /usr/local/nginx/conf/vhost/your_domain.conf\n将 root 一行，改为：\nindex index.html index.php /_h5ai/public/index.php;\n去除被禁用的 php 函数：\nvim /usr/local/php/etc/php.ini\n搜索 scandir、exec、passthru，将其从被禁用的函数中删除。\n重启 web 服务器：\nservice php-fpm restart service nginx reload 将要在网站上显示的目录和 _h5ai 文件夹放在一起：\n到目前为止，h5ai 可以正常使用了，但是我们可以开启 _h5ai 全部功能。通过 http(s)://your_domain/_h5ai/public/index.php 可以查看 _h5ai 的全部功能开启情况，默认密码是空的。\n安装 ffmpeg debian 8： 编辑软件源文件：\nvim /etc/apt/sources.list\n添加四个软件源\ndeb http://www.deb-multimedia.org jessie main non-free deb ftp://ftp.deb-multimedia.org jessie main non-free deb http://www.deb-multimedia.org stable main non-free deb ftp://ftp.deb-multimedia.org stable main non-free 更新软件源\napt-get -y update\n安装 ffmpeg\napt-get -y install ffmpeg\nubuntu 16.04+： 直接通过命令安装：\napt-get -y install ffmpeg\n**注意：**请转至 http://www.ffmpeg.org/releases/ 查看最新的 ffmpeg 版本。\n编译安装。 apt-get -y install ffmpeg tar -zxvf ffmpeg-*.*.tar.gz cd ffmpeg-*.* ./configure make make install 略缩图功能 图片：\n将 _h5ai 中，private 与 public 文件夹中的 cache 目录设置权限为 755。\nexif：\n通过 phpize 安装 php 的 exif 模块即可。\n视频略缩图：\n参考 2.1 安装 ffmpeg 即可。\n安装 imagemagick。 可使用如下命令：\nubuntu/debian:\napt-get install -y imagemagick\ncentos:\nyum install imagemagick -y\nshell tar、shell zip和shell du\n参考 1.4 去除在 php.ini 中被禁用函数 exec与 passthru 即可。\n另外去除禁用的 scandir 函数（如果有），不然会导致无法显示目录。\noptions.json 中的更多功能\n位于 _h5ai/private/conf 目录下。\n打包下载： 搜索 “download”\n127 行，enabled 由 false 改为 true。\n文件信息及二维码：\n搜索 “info”\n185 行，enabled 由 false 改为 true。\n默认简体中文：\n搜索 “l10n”\n202 行，enabled 由 false 改为 true。\n文件及文件夹多选：\n搜索 “select”\n323 行，enabled 由 false 改为 true。\n默认密码：\n首先生成自定义 sha512 密码：http://md5hashing.net/hashing/sha512\n然后搜索 “passhash”，大概第 10 行，将其密码改成自己生成的。\n上一张完整开启所有功能的截图：\n在目录头部或尾部显示 html 内容\n在需要显示自定义 html 的目录下，添加 _h5ai.headers.html 或 _h5ai.footers.html。这个通常用于对该目录的一些说明。支持 html 标签。\n","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/h5ai/install/","summary":"\u003cp\u003eh5ai是一款功能强大 php 文件目录列表程序，由德国开发者 Lars Jung 主导开发，它提供多种文件目录列表呈现方式，支持多种主流 Web 服务器，例如 Nginx、Apache、Cherokee、Lighttpd 等，支持多国语言，可以使用本程序在线预览文本、图片、音频、视频等。\u003c/p\u003e\n\u003cp\u003e请注意，默认情况下，放到目录下的 .php 文件将会被直接执行，并不以文本显示。\u003c/p\u003e","title":"h5ai install"},{"content":"给使用appache网站添加重定向\n在网站根目录下建立.htaccess文件\n开启rewrite\nrewriteengine on 默认跳转https\nrewritecond %{server_port} !^443$ rewriterule ^(.*)?$ https://%{server_name}/$1 [l,r] 隐藏.php后缀\nrewritecond %{request_filename} !-f rewriterule ^([^.]+)$ $1.php [nc,l] 隐藏.html后缀\nrewritecond %{request_filename} !-f rewriterule ^([^.]+)$ $1.html [nc,l] ","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/apache/rewrite/","summary":"\u003cp\u003e给使用Appache网站添加重定向\u003c/p\u003e\n\u003cp\u003e在网站根目录下建立\u003ccode\u003e.htaccess\u003c/code\u003e文件\u003c/p\u003e","title":"添加重定向"},{"content":"搭建自己的在线私密剪贴板\nprivatebin类似于ubuntu pastebin，是一个开源的剪切板。\n作为一个用于临时分享文本(当然也有很多人拿来分享代码啥的)的网站，在有些时候还是挺方便的\n官网——\u0026gt;传送门\n不仅支持加密，阅后即焚等功能，还可以在配置中开启支持文件上传等动能\n安装要求 php版本 \u0026gt;= 5.4 为保证加密的安全和随机性，需要满足以下条件之一: 2.1. php版本 \u0026gt;= 7(自带openssl扩展) 2.2. php版本 \u0026gt;= 7(自带openssl扩展) 2.3. libsodium和它的php扩展(php_libsodium) 2.4. open_basedir配置了能够有权限访问/dev/urandom(用于生成随机数据) 2.5. mcrypt扩展(php7用openssl取代了这个) 2.6. com_dotnet扩展 gd扩展(php_gd用于图像处理) 一部分磁盘空间(默认存储数据直接用文件系统)或者一个被pdo支持的数据库(可选) 有权限在安装目录以及在index.php中定义的path所指代的路径(额外指定路径以便提高安全性)创建文件和文件夹 一个支持javascript的浏览器(加解密依赖js，所以这是必须的) 安装 # 进入网站vhost根目录 cd /home/wwwroot/vhost # 下载程序并解压 wget -o privatebin-v1.1.1.tar.gz https://github.com/privatebin/privatebin/archive/1.1.1.tar.gz tar xzf privatebin-v1.1.1.tar.gz # 将二级目录内的程序移动到网站根目录 mv privatebin-1.1.1/* . mv privatebin-1.1.1/.htaccess.disabled . # 清理文件 rm -rf privatebin-1.1.1 privatebin-v1.1.1.tar.gz rm -rf changelog.md install.md readme.md license.md credits.md # 创建程序需要的目录 mkdir data tmp # 创建配置文件 cp cfg/conf.sample.php cfg/conf.php # 修改所有者 chown -r www:www * #这时候其实已经能用了，但是我们也可以做些安全方面的优化，也可以对配置做些修改 配置以及优化 修改路径 这个是把你的php文件以及存储目录啥的全部移到网站目录外，然后在index.php中指定目录的位置，从而提高安全性，防止某些注入漏洞和文件上传提权\n# 进入网站vhost根目录 cd /path/to/vhost/root # 在网站根目录的父目录创建文件夹(请确保这个路径是无法被直接访问到的) mkdir ../privatebin # 将数据目录和php程序目录移动到这个目录中 mv cfg data lib tpl vendor ../privatebin/ # 修改所有者，确保能被web服务器和php有权限读写，另外如果开了open_basedir请配置包含此目录 chown -r www:www ../privatebin # 修改privatebin的index.php文件 vi index.php # 在define含有path那行改成类似如下的 define(\u0026#39;path\u0026#39;, \u0026#39;../privatebin/\u0026#39;); 使用https 正确的文件(夹)权限 # 设置权限(这儿的网站路径如果你做了上面的修改路径请自己注意了) find 网站路径 -type f -exec chmod 0640 {} \\; find 网站路径 -type d -exec chmod 0550 {} \\; find data目录路径 -type f -exec chmod 0640 {} \\; find data目录路径 -type d -exec chmod 0750 {} \\; # 修改所有者 chown -r www:www 网站路径 chown -r www:www data目录路径 修改配置 使用robots.txt与.htaccess 默认程序包含了robots.txt，而如果网站是apache的话请将自带的.htaccess.disabled改名为.htaccess来启用，这个是屏蔽了一些爬虫和程序的网页预览功能啥的\n使用数据库代替默认的文件存储 配置文件翻译 ;\u0026lt;?php http_response_code(403); /* ; privatebin 配置文件 ; ; 每个选项的解释可以参考 https://github.com/privatebin/privatebin/wiki/configuration. ; 本配置由senra翻译 [main] ; (可选) 设置一个用于在网站上显示的项目名(网站名) ; name = \u0026#34;privatebin\u0026#34; ; 启用或禁用讨论功能(针对paste内容留言讨论)，默认为true discussion = true ; 预选讨论功能(是否在创建新的paste时默认勾选开启讨论)，默认为false opendiscussion = false ; 启用或禁用密码功能，默认为true password = true ; 启用或禁用文件上传功能，默认false fileupload = false ; (是否在创建新的paste时默认勾选阅后即焚)，默认为false burnafterreadingselected = false ; 当启用了阅后即焚的paste被第一次访问后马上进行删除，而不是等待一次成功的解密 ; 按照说明，privatebin默认在你浏览器成功解密后才会使用js来做一个回调以便删除paste，这个功能将无视你是否成功解密，直接进行删除 instantburnafterreading = false ; 预选的默认显示模式(在创建新的paste时默认选择的显示\\渲染格式)，默认为\u0026#34;plaintext\u0026#34;(纯文本) ; 请确保这个值存在于[formatter_options]中 defaultformatter = \u0026#34;plaintext\u0026#34; ; (可选) 设置一种代码高亮的主题，可以在 css/prettify/ 目录中查看 ; syntaxhighlightingtheme = \u0026#34;sons-of-obsidian\u0026#34; ; 每个paste或者评论留言的大小限制，单位为bytes，默认是2mb sizelimit = 2097152 ; 使用的模板，默认是\u0026#34;bootstrap\u0026#34; (tpl/bootstrap.php) template = \u0026#34;bootstrap\u0026#34; ; (可选) 显示的提示 ; notice = \u0026#34;note: this is a test service: data may be deleted anytime. kittens will die if you abuse this service.\u0026#34; ; 默认情况下privatebin会根据用户的浏览器设置来猜测用户使用的语言，启用该选项将使得用户能够在菜单中选择语言 ; 语言的选择记录会以session cookie的形式存储在你的浏览器中，保存到你的浏览器关闭之前 languageselection = false ; 设置默认语言，默认为english ; 如果这个选项被设置了且上一个语言选择功能被关闭，则这将成为唯一的语言 ; languagedefault = \u0026#34;en\u0026#34; ; (可选) 链接缩短程序的地址(api)，通过配置这个能在创建新的paste时同时创建短链以方便使用 ; 需要注意的是请选择可靠的或者是自建的短链，因为这会使得短链提供者能够获取你带有加密密钥的完整链接 ; urlshortener = \u0026#34;https://shortener.example.com/api?link=\u0026#34; ; (可选) 是用户能够一键生成一个用于分享paste链接的二维码 ; 这个会对你创建paste以及浏览paste的页面同时生效 ; qrcode = true ; (可选) 使用基于ip的评论头像来区分一条评论是否是来自于一个使用了相同的用户名的不同用户是一个比较差劲的机制。 ; 因为这种情况下如果服务器的salt泄露，可以通过为ip生成彩虹版的方式来碰撞获得所有非匿名的评论者的ip ; 这个选项可以被设置为 none / vizhash / identicon(默认) ; icon = none ; content security policy(csp)这个http头允许网站限制什么内容可以在它的页面加载(用于防止插入恶意内容) ; 如果你修改模板来添加第三方域名的自定义脚本(比如追踪脚本或者使用了某些抗d服务)，你可能需要修改这个。 ; 可以参考 https://content-security-policy.com/ 来配置 ; 注意: 如果你使用bootstrap主题，你可以去除sandbox限制中的allow-popups ; cspheader = \u0026#34;default-src \u0026#39;none\u0026#39;; manifest-src \u0026#39;self\u0026#39;; connect-src *; form-action \u0026#39;none\u0026#39;; script-src \u0026#39;self\u0026#39;; style-src \u0026#39;self\u0026#39;; font-src \u0026#39;self\u0026#39;; img-src \u0026#39;self\u0026#39; data:; referrer no-referrer; sandbox allow-same-origin allow-scripts allow-forms allow-popups\u0026#34; ; 和privatebin alpha 0.19保持兼容，会导致降低一定的安全性 ; 如果启用这项，将使用base64.js的1.7版本，而不是2.1.9版本，并且在hmac中将使用sha1而不是sha256(用于生成删除paste的token) zerobincompatibility = false [expire] ; 预选的过期时间(创建新的paste时默认选择的过期时间)，请确保这个值存在于[expire_options]中 default = \u0026#34;1week\u0026#34; ; (可选) 克隆按钮可以在过期的pastes中关闭，但是请注意这只是隐藏了按钮，复制和粘贴还是可能的 ; clone = false [expire_options] ; 为每个过期的时间段设置具体的秒数，0代表永不过期 5min = 300 10min = 600 1hour = 3600 1day = 86400 1week = 604800 ; 这个一个月只有30天，所以不算准确 1month = 2592000 1year = 31536000 never = 0 [formatter_options] ; 设置可选的格式(用于渲染和显示)，它们的顺序和标签 plaintext = \u0026#34;plain text\u0026#34; syntaxhighlighting = \u0026#34;source code\u0026#34; markdown = \u0026#34;markdown\u0026#34; [traffic] ; 同一个ip的访问频率限制，单位为秒，设为0代表禁用 limit = 10 ; (可选) 如果你的网站运行在一个反代或者负载均衡之后，设置包含用户ip的http头可以将用户正确的ip传递给程序 ; header = \u0026#34;x_forwarded_for\u0026#34; ; 存储访问频率限制的目录 dir = path \u0026#34;data\u0026#34; [purge] ; 清除过期paste的最小时间间隔，清除只会在创建paste的时候触发，设为0代表每次创建都进行清除 limit = 300 ; 清除过期paste一次最多删除的paste数量，设为0代表禁用清除。如果网站使用人数较多建议把这个值设置的稍微大点 batchsize = 10 ; 存储清除频率限制的目录 dir = path \u0026#34;data\u0026#34; [model] ; 加载的模型类(指定了把数据存哪)，以及存储用的目录 ; 默认的模型\u0026#34;filesystem\u0026#34;(文件系统)将所有数据都直接存储在文件中 class = filesystem [model_options] dir = path \u0026#34;data\u0026#34; ;[model] ; 使用mysql存储的配置示例 ;class = database ;[model_options] ;dsn = \u0026#34;mysql:host=localhost;dbname=privatebin;charset=utf8\u0026#34; ;tbl = \u0026#34;privatebin_\u0026#34; ; table prefix ;usr = \u0026#34;privatebin\u0026#34; ;pwd = \u0026#34;z3r0p4ss\u0026#34; ;opt[12] = true ; pdo::attr_persistent ;[model] ; 使用sqlite存储的配置示例 ;class = database ;[model_options] ;dsn = \u0026#34;sqlite:\u0026#34; path \u0026#34;data/db.sq3\u0026#34; ;usr = null ;pwd = null ;opt[12] = true ; pdo::attr_persistent ","date":"2019-02-11","permalink":"https://blog.akvicor.com/posts/privatebin/install/","summary":"\u003cp\u003e搭建自己的在线私密剪贴板\u003c/p\u003e\n\u003cp\u003ePrivateBin类似于Ubuntu PasteBin，是一个开源的剪切板。\u003c/p\u003e\n\u003cp\u003e作为一个用于临时分享文本(当然也有很多人拿来分享代码啥的)的网站，在有些时候还是挺方便的\u003c/p\u003e\n\u003cp\u003e官网——\u0026gt;\u003ca href=\"https://privatebin.net/\"\u003e传送门\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e不仅支持加密，阅后即焚等功能，还可以在配置中开启支持文件上传等动能\u003c/p\u003e","title":"privatebin install"},{"content":"搭建hexo并安装next主题\n本地 安装node js\n安装hexo命令行工具\nnpm install hexo-cli -g 生成一个本地的hexo项目 # 创建blog目录，并初始化hexo项目 hexo init blog cd blog # 安装hexo依赖，hexo是基于nodejs开发的，npm是nodejs的包管理工具 npm install # 启动本地服务，打开localhost:4000测试是否成功 hexo server 新建一篇文章 hexo new \u0026#34;my first post\u0026#34; # 这个命令是用于在 source/_posts 下生成一个命名的.md 文件，效果等同于新建.md文件并拷贝至该处。 hexo generate # 将这个新建的博文生成静态文件并部署到本地来预览效果, 简写为hexo g hexo server # 启动本地服务，查看效果, 简写为hexo s 有时会出现 4000 端口被其他进程占用的问题，这里有两种解决方案：1. 解除其他进程端口占用，2. 使用 hexo server -p 5000 来修改端口并预览\n上述命令完成后，就可以打开浏览器，输入 localhost:4000 就可以预览你刚刚生成的博文啦。\n执行 hexo deploy出错 在执行 hexo deploy 后,出现 error deployer not found:git 的错误处理\n输入代码： npm install hexo-deployer-git --save\n远程（服务端） 服务器端安装配置git、nodejs、nginx或apache。 创建git用户，建立git裸库，配置git-hooks。 配置本地hexo，完成git自动化部署。 本教程默认已经配置好网站环境和域名解析\n环境搭建 以下均需要通过ssh工具连接vps进行操作\n安装git和nodejs # 安装git apt-get install git # 安装nodejs curl --silent --location https://rpm.nodesource.com/setup_10.x | bash - 使用git --version和node --version查看，显示版本号则安装成功，\n创建git用户 创建一个git用户，并git根据提示设置密码，用来专门运行git服务 # 命令一：这种命令会在登录界面显示用户名 sudo useradd -m xxx -d /home/xxx -s /bin/bash # 命令二：这种命令会在登录界面隐藏用户名 sudo useradd -r -m -s /bin/bash xxx # xx指代创建的用户名 sudo passwd xxx\t# xxx指创建的用户名 赋予git用户sudo权限 # chmod 740 /etc/sudoers sudo chmod +w /etc/sudoers vim /etc/sudoers 找到以下内容：\n## allow root to run any commands anywhere root all=(all) all 在下面添加一行：git all=(all) all\n保存退出后改回权限：chmod 400 /etc/sudoers 或 sudo chmod -w /etc/sudoers\n切换用户，配置ssh 使用su git切换到git用户，再执行下列操作：\n# 切换到git用户目录 cd /home/git # 创建.ssh文件夹 mkdir ~/.ssh # 创建authorized_keys文件并编辑 vim ~/.ssh/authorized_keys # 如果你还没有生成公钥，那么首先在本地电脑中执行生成公钥, 步骤在后面 # 再将公钥复制粘贴到authorized_keys # 保存关闭authorized_keys后，修改相应权限 chmod 600 ~/.ssh/authorized_keys chmod 700 ~/.ssh git ssh 创建key的步骤 # 打开git bash cd ~/.ssh/ # 进入ssh文件夹，如果没有就执行 mkdir ~/.ssh 创建一个 # 配置全局的name和email，这里是的你github或者bitbucket的name和email，如果配置了就跳过 git config --global user.name \u0026#34;your name\u0026#34; git config --global user.email \u0026#34;your email\u0026#34; # 生成key ssh-keygen -t rsa -c \u0026#34;your email\u0026#34; # 最后得到了两个文件：id_rsa和id_rsa.pub cat ~/.ssh/id_rsa.pub 然后可以通过本地git bash执行ssh命令测试是否可以免密登录\nssh -v git@服务器ip地址 这样git用户就添加好了。\n建立git裸库 # 回到git目录 cd /home/git # 使用git用户创建git裸仓库，以blog.git为例 git init --bare blog.git 检查用户组权限 我们的git裸仓库已经建立好了，离成功又近了一步。为了以防万一，我们要检查一下之前的blog.git、.ssh、blog目录的用户组权限是否都为git:git\n# 网站目录 ll -a /home/wwwroot/ # git目录 ll -a /home/git/ 如果有哪个不是，执行下面相应的命令后再查看\nsudo chown git:git -r /home/wwwroot/blog.akvicor.com sudo chown git:git -r /home/git/blog.git 使用git-hooks同步网站根目录 简单来说，我们使用一个钩子文件：post-receive，每当git仓库接收到内容的时候，就会自动调用这个钩子，把内容同步到网站根目录。\n在git用户下执行：\n# 新建一个post-receive文件并编辑 vim ~/blog.git/hooks/post-receive 在里面输入以下内容，注意修改为自己的设置：\n#!/bin/bash git_repo=/home/git/blog.git tmp_git_clone=/tmp/blog public_www=/home/wwwroot/blog.akvicor.com rm -rf ${tmp_git_clone} git clone $git_repo $tmp_git_clone rm -rf ${public_www}/* cp -rf ${tmp_git_clone}/* ${public_www} 保存退出后，执行：chmod +x ~/blog.git/hooks/post-receive赋予这个文件可执行权限。\n配置本地hexo的_config.yml 非常简单，只需要找到本地hexo博客的站点配置文件_config.yml，找到以下内容并修改：\ndeploy: type: git repo: git@你的服务器ip:/home/git/blog.git branch: master 保存后，剩下的就是hexo的日常操作了，这里就不赘述了，写完文章后，在你的本地博客根目录执行以下命令：\nhexo clean hexo g -d 就可以实现线上博客的自动更新了！一切搞定！\n添加添加关于、分类及标签 # 执行以下命令添加页面 hexo new page about hexo new page tag hexo new page categories --- title: this is me date: 2019-02-09 21:24:37 --- --- title: categories date: 2019-02-09 21:26:13 type: \u0026#34;categories\u0026#34; --- --- title: tags date: 2019-02-09 21:27:50 type: \u0026#34;tags\u0026#34; --- 让hexo的首页只显示文章的部分内容而不是全部 法1 用文本编辑器打开 themes/ 目录下的对应的主题的theme文件夹下的 _config.yml 文件，找到这段代码，如果没有则新建，可能不同的主题会不支持这种方法：\n# automatically excerpt. not recommend. # please use \u0026lt;!-- more --\u0026gt; in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。\n修改后重启 hexo 就ok了。\n法2 在你写 md 文章的时候，可以在内容中加上 \u0026lt;!--more--\u0026gt;，这样首页和列表页展示的文章内容就是 \u0026lt;!--more--\u0026gt; 之前的文字，而之后的就不会显示了。\n效果\n上面两种方式展示出来的效果是不一样的。\n第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。\n而第二种加上 \u0026lt;!--more--\u0026gt;展示出来的就是你原本文章的样式，最后不会有…。\n法3 在文章的 front-matter 中添加 description，并提供文章摘录\n--- title: 让hexo的首页只显示文章的部分内容而不是全部 id: set-hexo-show-more-button-on-index categories: - web开发 date: 2017-09-30 11:01:40 tags: - blog - hexo description: hexo 的 next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？正如你现在看到的本篇文章，只显示到这里。 --- 但是使用这种方式生成的描述信息在文章的详情页是不再显示的。\n插件 hexo-abbrlink npm install hexo-abbrlink --save 修改配置文件\npermalink: :category/:year/:month/:day/:title/ abbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex 创建站点地图 安装插件 在 hexo 根目录下，执行如下命令以安装插件：\ngoogle 版本\nnpm install hexo-generator-sitemap --save baidu 版本\nnpm install hexo-generator-baidu-sitemap --save 开始生成站点地图文件 安装好插件后，插件会在每次 hexo g 命令将 markdown 文件转化为 html 文件时执行\n执行结果为，在存放 html 文件根目录下，即[hexo install location]/public下生成一 ‘sitemap.xml’/‘baidusitemap.xml’\n紧接着在你执行hexo d将网站文件部署到 github 仓库上之后，准备工作算是完成大半了\n添加站点地图 url 最后，你只需将该站点地图文件的 url 添加至搜索引擎的 search console ，旋即完成了整个过程\n添加搜索功能 要使用搜索，必须先生成博客索引数据，hexo 可以通过下面的这个插件生成： npm install hexo-generator-search --save npm install hexo-generator-searchdb --save 在 hexo 站点 _config.yml 中添加如下配置即可： # 搜索 search: path: search.xml field: post format: html limit: 10000 在主题配置文件中开启 # local search local_search: enable: true ","date":"2019-02-10","permalink":"https://blog.akvicor.com/posts/hexo/install/","summary":"\u003cp\u003e搭建Hexo并安装Next主题\u003c/p\u003e\n\u003ch2 id=\"本地\"\u003e本地\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e安装\u003ca href=\"https://nodejs.org/en/\"\u003eNode js\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装Hexo命令行工具\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enpm install hexo-cli -g\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e生成一个本地的Hexo项目\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#998;font-style:italic\"\u003e# 创建blog目录，并初始化hexo项目\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehexo init blog\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0086b3\"\u003ecd\u003c/span\u003e blog\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#998;font-style:italic\"\u003e# 安装hexo依赖，hexo是基于nodejs开发的，npm是nodejs的包管理工具\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enpm install\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#998;font-style:italic\"\u003e# 启动本地服务，打开localhost:4000测试是否成功\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehexo server\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"hexo install"},{"content":"centos-7 一共有四种方法安装\n源码安装 使用已编译版本安装 使用epel安装 使用nvm安装 源码安装 下载源码（官网查看最新版本链接） wget http://nodejs.org/dist/v0.10.30/node-v0.10.30.tar.gz 解压源码 tar xzvf node-v* \u0026amp;\u0026amp; cd node-v* 安装必要的编译软件 sudo yum install gcc gcc-c++ 编译 ./configure make 编译\u0026amp;安装 sudo make install 查看版本（测试安装是否成功） node --version 使用已编译版本安装 下载已编译版本 传送门 cd ~ wget http://nodejs.org/dist/v11.7.0/node-v11.7.0-linux-x64.tar.gz 解压 sudo tar --strip-components 1 -xzvf node-v* -c /usr/local 老样子，测试安装 node --version 使用epel安装 下载epel sudo rpm -i http://download.fedoraproject.org/pub/epel/beta/7/x86_64/epel-release-7-0.2.noarch.rpm 安装 sudo yum install nodejs 测试安装 node --version （可选）安装npm管理包 sudo yum install npm 通过nvm安装 nvm（node version manager）顾名思义，就是node.js的版本管理软件，可以轻松的在node.js各个版本间切换，项目源码github\n下载并安装nvm脚本 https://github.com/nvm-sh/nvm#install\u0026ndash;update-script\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash # 安装到指定目录 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | nvm_dir=\u0026#34;/akvicor/vivc/env/nvm\u0026#34; bash 列出所需要的版本 nvm list-remote 返回结果如下\n. . . v0.10.29 v0.10.30 v0.11.0 v0.11.1 v0.11.2 v0.11.3 v0.11.4 v0.11.5 v0.11.6 v0.11.7 v0.11.8 v0.11.9 v0.11.10 v0.11.11 v0.11.12 v0.11.13 3.安装相应的版本\nnvm install 14 nvm install 16 nvm install 20 nvm install v20.11.1 4.查看已安装的版本\n$ nvm list -\u0026gt; v14.21.3 v16.20.2 v20.11.1 default -\u0026gt; 14 (-\u0026gt; v14.21.3) iojs -\u0026gt; n/a (default) unstable -\u0026gt; n/a (default) node -\u0026gt; stable (-\u0026gt; v20.11.1) (default) stable -\u0026gt; 20.11 (-\u0026gt; v20.11.1) (default) lts/* -\u0026gt; lts/iron (-\u0026gt; v20.11.1) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; n/a) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; n/a) lts/carbon -\u0026gt; v8.17.0 (-\u0026gt; n/a) lts/dubnium -\u0026gt; v10.24.1 (-\u0026gt; n/a) lts/erbium -\u0026gt; v12.22.12 (-\u0026gt; n/a) lts/fermium -\u0026gt; v14.21.3 lts/gallium -\u0026gt; v16.20.2 lts/hydrogen -\u0026gt; v18.19.1 (-\u0026gt; n/a) lts/iron -\u0026gt; v20.11.1 5.切换版本\nnvm use 16 nvm use v20.11.1 6.设置默认版本\nnvm alias default v20.11.1 配置 # 方便设置yarn版本 corepack enable ","date":"2019-02-10","permalink":"https://blog.akvicor.com/posts/nodejs/install/","summary":"\u003ch2 id=\"centos-7\"\u003eCentos-7\u003c/h2\u003e\n\u003cp\u003e一共有四种方法安装\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e源码安装\u003c/li\u003e\n\u003cli\u003e使用已编译版本安装\u003c/li\u003e\n\u003cli\u003e使用EPEL安装\u003c/li\u003e\n\u003cli\u003e使用NVM安装\u003c/li\u003e\n\u003c/ul\u003e","title":"node.js install"},{"content":"在git bash链接远程主机时连接失败\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ warning: remote host identification has changed! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ it is possible that someone is doing something nasty! someone could be eavesdropping on you right now (man-in-the-middle attack)! it is also possible that a host key has just been changed. the fingerprint for the rsa key sent by the remote host is 51:82:00:1c:7e:6f:ac:ac:de:f1:53:08:1c:7d:55:68. please contact your system administrator. add correct host key in /users/isaacalves/.ssh/known_hosts to get rid of this message. offending rsa key in /users/isaacalves/.ssh/known_hosts:12 rsa host key for 104.131.16.158 has changed and you have requested strict checking. host key verification failed. 这种情况下并非是远程主机配置出现问题，而是曾经连接过一次此主机，而此次连接时缓存密钥不匹配\n# 编辑此文件，删除缓存密钥即可 vim ~/.ssh/known_hosts ","date":"2019-02-10","permalink":"https://blog.akvicor.com/posts/ssh/known_hosts_changed/","summary":"在git bash链接远程主机时连接失败 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is 51:82:00:1c:7e:6f:ac:ac:de:f1:53:08:1c:7d:55:68. Please contact your system administrator. Add correct","title":"ssh/git-连接远程主机错误"},{"content":"aos32-gb2312.tgz\n一个gb2312汉字是由两个字节编码的，范围为a1a1~fefe。a1-a9为符号区，b0到f7为汉字区。每一个区有94个字符。\n点阵结构 从图片可以看出：\n日文编码的第一个字节为点阵的左半部分，第二个字节为点阵的右半部分。 中文编码的第一个字节为点阵的上半部分，第二个字节为点阵的下半部分 偏移 在汉字占的两个字节中，前一个字节为该汉字的区号，后一个字节为该字的位号。其中，每个区记录94个汉字，位号为该字在该区中的位置。\n区码：区号（汉字的第一个字节）- 0xa0 (因为汉字编码是从0xa0区开始的，所以文件最前面就是从0xa0区开始，要算出相对区码) 位码：位号（汉字的第二个字节）- 0xa0 由此可以得到汉字在hzk16中的绝对偏移位置：offset=(94*(区码-1)+(位码-1))*32\n区码减1是因为数组是以0为开始而区号位号是以1为开始的 (94*(区号-1)+位号-1)是一个汉字字模占用的字节数 最后乘以32是因为汉字库文应从该位置起的32字节信息记录该字的字模信息（前面提到一个汉字要有32个字节显示） 代码实现 由于点阵结构不同，原先的putfont8函数并不适用于gb2312，所以重新编写一个函数来显示中文\nvoid putfont8_ud_rev(char *vram, int xsize, int x, int y, char c, char *font) { int i, k; char *p, d ; for(i = 0; i \u0026lt; 8; i++) { p = vram + (y + i) * xsize + x; d = font[2 * i]; for(k = 0; k \u0026lt; 8; k++) { if(d\u0026amp;(0x01\u0026lt;\u0026lt;k)) { p[k] = c; } } p += 8; d = font[2 * i + 1]; for(k = 0; k \u0026lt; 8; k++) { if(d\u0026amp;(0x01\u0026lt;\u0026lt;k)) { p[k] = c; } } } return; } 在putfonts8_asc中添加新的模式用以显示中文\nif (task-\u0026gt;langmode == 3) { for (; *s != 0x00; s++) { if (task-\u0026gt;langbyte1 == 0) { if (0xa1 \u0026lt;= *s \u0026amp;\u0026amp; *s \u0026lt;= 0xfe) { task-\u0026gt;langbyte1 = *s; } else { //只要是半角就使用hankaku里面的字符 putfont8(vram, xsize, x, y, c, hankaku + *s * 16); } } else { k = task-\u0026gt;langbyte1 - 0xa1; t = *s - 0xa1; task-\u0026gt;langbyte1 = 0; font = chinese + (k * 94 + t) * 32; putfont8_ud_rev(vram, xsize, x - 8, y , c, font ); putfont8_ud_rev(vram, xsize, x - 8, y + 8, c, font + 16); } x += 8; } } 如果不需要日文字体，可以直接将中文字体数据读入bootpack.c中的nihongo变量（注意分配的内存大小需要修改为memman_alloc_4k(memman, 0x5d5d * 32)）。\n如果想要共存则需要添加新的变量，并且增大读入的扇区数量。\n在chklang.c文件中添加下列代码，用户测试中文\nstatic char s3[16] = { // 中文 0xc4, 0xe3, 0xba, 0xc3, 0xce, 0xd2, 0xca, 0xc7, 0x41, 0x6b, 0x76, 0x69, 0x63, 0x6f, 0x72, 0x00 }; if (langmode == 3) { api_putstr0(s3); } 修改ipl.nas中读入的扇区数量\ncyls\tequ\t30 修改bootpack.c\n// 定义全局变量 unsigned char *chinese; unsigned char *nihongo; // 函数void harimain(void) 中 nihongo = (unsigned char *) memman_alloc_4k(memman, 16 * 256 + 32 * 94 * 47); chinese = (unsigned char *) memman_alloc_4k(memman, 0x5d5d * 32); fat = (int *) memman_alloc_4k(memman, 4 * 2880); file_readfat(fat, (unsigned char *) (adr_diskimg + 0x000200)); finfo = file_search(\u0026#34;nihongo.fnt\u0026#34;, (struct fileinfo *) (adr_diskimg + 0x002600), 224); if (finfo != 0) { file_loadfile(finfo-\u0026gt;clustno, finfo-\u0026gt;size, nihongo, fat, (char *) (adr_diskimg + 0x003e00)); } else { for (i = 0; i \u0026lt; 16 * 256; i++) { nihongo[i] = hankaku[i]; // 没有字库，半角部分直接复制英文字裤 } for (i = 16 * 256; i \u0026lt; 16 * 256 + 32 * 94 * 47; i++) { nihongo[i] = 0xff; // 没有字库，全角部分以0xff填充 } } finfo = file_search(\u0026#34;hzk16.fnt\u0026#34;, (struct fileinfo *) (adr_diskimg + 0x002600), 224); if (finfo != 0) { file_loadfile(finfo-\u0026gt;clustno, finfo-\u0026gt;size, chinese, fat, (char *) (adr_diskimg + 0x003e00)); } else { for (i = 0; i \u0026lt; 16 * 256; i++) { chinese[i] = hankaku[i]; // 没有字库，半角部分直接复制英文字裤 } for (i = 16 * 256; i \u0026lt; 16 * 256 + 32 * 94 * 47; i++) { chinese[i] = 0xff; // 没有字库，全角部分以0xff填充 } } memman_free_4k(memman, (int) fat, 4 * 2880); 修改graphic.c文件putfonts8_asc的代码，添加下面两行\nextern char *nihongo; extern char *chinese; 修改console.c文件cmd_langmode函数中的if (mode \u0026lt;= 2)为if (mode \u0026lt;= 3)\n","date":"0001-01-01","permalink":"https://blog.akvicor.com/posts/aos32/gb2312/","summary":"aos32-gb2312.tgz 一个GB2312汉字是由两个字节编码的，范围为A1A1~FEFE。A1-A9为符号区，B0到F7为汉字区。每一个区有94个字符。 点阵结构 从图片可以看出： 日文编","title":"aos32 显示中文字符gb2312"},{"content":"#1、生成rsa密钥的方法 openssl genrsa -des3 -out key.pem 2048 #这个命令会生成一个2048位的密钥，同时有一个des3方法加密的密码，如果你不想要每次都输入密码，可以改成： openssl genrsa -out key.pem 2048 #建议用2048位密钥，少于此可能会不安全或很快将不安全。 #2、生成一个证书请求 openssl req -new -key key.pem -out cert.csr #这个命令将会生成一个证书请求，当然，用到了前面生成的密钥key.pem文件 #这里将生成一个新的文件cert.csr，即一个证书请求文件，你可以拿着这个文件去数字证书颁发机构（即ca）申请一个数字证书。ca会给你一个新的文件cert.pem，那才是你的数字证书。 #如果是自己做测试，那么证书的申请机构和颁发机构都是自己。就可以用下面这个命令来生成证书： openssl req -new -x509 -key key.pem -out cert.pem -days 1095 #这个命令将用上面生成的密钥key.pem生成一个数字证书cert.pem #3、使用数字证书和密钥 #有了key.pem和cert.pem文件后就可以在自己的程序中使用了，比如做一个加密通讯的服务器 go语言中调用\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/net/http2\u0026#34; \u0026#34;net/http\u0026#34; ) type myhandler struct { } func (h *myhandler) servehttp(w http.responsewriter, r *http.request) { fmt.fprintf(w, \u0026#34;hello world!\u0026#34;) } func main() { handler := myhandler{} server := http.server{ addr: \u0026#34;127.0.0.1:80\u0026#34;, handler: \u0026amp;handler, } http2.configureserver(\u0026amp;server, \u0026amp;http2.server{}) server.listenandservetls(\u0026#34;cert.pem\u0026#34;, \u0026#34;key.pem\u0026#34;) } ","date":"0001-01-01","permalink":"https://blog.akvicor.com/posts/ssl/pem/","summary":"#1、生成RSA密钥的方法 openssl genrsa -des3 -out key.pem 2048 #这个命令会生成一个2048位的密钥，同时有一个des3方法加密的密码，如果你不想要每次都输入密码，可以改成： openssl genrsa -out key.pem 2048 #","title":"生成cert.pem和key.pem"},]
            
        
    </div>

    <div id="search">
        
        <span class="sc-icon"><img src="/imgs/icons/search.svg" width="48"> </span>
        <span id="sc-clear" onclick="clearInputVal()">✖</span>
        <input id="sc-input" oninput="search()" type="text" placeholder="here search search..." />
        <div id="sc-res"></div>
    </div>
    <script src="/js/search.js" defer></script>
</div>

    

    
    
    

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    
    <a href="https://icp.gov.moe/?keyword=20250177" target="_blank">
        萌ICP备20250177号
    </a>
    
    
    <a href="/" target="_blank">
        <span class="some">世界一、 幸せな女の子だ<span>
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>
