<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="Search - https://blog.akvicor.com/search/">
    <meta name="author" content="Akvicor - https://blog.akvicor.com/">
    
    
    <title>Search</title>
    
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
	<script defer src="https://analy.akvicor.com/script.js" data-website-id="c0cbafdd-207e-431e-a252-4a64c31d98b9"></script>
    
    <link rel="stylesheet" href="https://blog.akvicor.com/style.min.4151072d6fc9fe1a3df6b17d57d2d8ca2e6573201efdbc03d4e8e48525582b64.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    <script src="/js/hide_and_seek.js"></script>
    <link rel="stylesheet" href="/css/hide_and_seek.css">
    <link rel="stylesheet" href="/css/heimu.css">
	
		<script>
			console.log(String.raw`
          _           _                _ 
    /\   | |         (_)              | |
   /  \  | | ____   ___  ___ ___  _ __| |
  / /\ \ | |/ /\ \ / / |/ __/ _ \| '__| |
 / ____ \|   <  \ V /| | (_| (_) | |  |_|
/_/    \_\_|\_\  \_/ |_|\___\___/|_|  (_)`);
		</script>
		<script>
			try{
				if(window.console&&window.console.log) {
					console.log("%cFor the Horde! %cFor the Azeroth!","color:red","color:blue");
					console.log("%c火墙火墙火墙火墙！","color:red");
					console.log("%c快打大怪！","color:red");
					console.log("%c快打断！","color:red");
					console.log("%c注意脚下！","color:red");
					console.log("%c快躲开！","color:red");
					console.log("%c震慑波！","color:red");
					console.log("%c快转身！","color:red");
					console.log("%c注意减伤！","color:red");
					console.log("%c<Deadly Boss Mods> %cCombat against 10 Player - Garrosh Hellscream(1%) ended after 8 minutes ad 19 seconds. you have 3 total wipes on this difficulty.","color:red","color:blue");
				}
			}
			catch(e){};
        </script>
	
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$math_inline$','$math_inline$'], ['\\(','\\)']],
				displayMath: [['$math_noinline$','$math_noinline$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$math_noinline$", right: "$math_noinline$", display: true},
									{left: "$math_inline$", right: "$math_inline$", display: false}
							]
					});
			});
			</script>
	
    
</head>
<body class="active-animate ">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": false,
		"svgColor": "",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            搜索
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-search 
    ">

    <div class="desc">
        
    </div>
    
    <div class="toc">
        
        <nav id="TableOfContents"></nav>
    </div>

    <div class='content  content '>
        
    </div>

    <div class="container-search">
    <div id="data" style="display: none;">
        
            
                [{"content":"搬家中\u0026hellip;\n","date":"2024-09-15","permalink":"https://blog.akvicor.com/posts/init/","summary":"搬家中\u0026hellip;","title":"少女祈祷中..."},{"content":"通过adb停用系统更新和去除更新统治\n# 屏蔽更新 adb shell pm disable-user com.oneplus.opbackup # 清除更新通知 adb shell pm clear com.oneplus.opbackup # 恢复更新 adb shell pm enable com.oneplus.opbackup ","date":"2024-04-20","permalink":"https://blog.akvicor.com/posts/android/oneplus_disable_update/","summary":"通过ADB停用系统更新和去除更新统治 # 屏蔽更新 adb shell pm disable-user com.oneplus.opbackup # 清除更新通知 adb shell pm clear com.oneplus.opbackup # 恢复更新 adb shell pm enable com.oneplus.opbackup","title":"关闭一加氧系统更新"},{"content":"unreal mode consists of breaking the 64kib limit of real mode segments (while retaining 16-bit instructions and the segment * 16 + offset addressing mode) by tweaking the descriptor caches.\n","date":"2023-02-27","permalink":"https://blog.akvicor.com/posts/aos/unreal_mode/","summary":"Unreal mode consists of breaking the 64KiB limit of real mode segments (while retaining 16-bit instructions and the segment * 16 + offset addressing mode) by tweaking the descriptor caches.","title":"unreal mode"},{"content":"gcc会在call指令之前让rsp按16字节对齐。\ncpu在call的时候将rip压栈rsp -= 8，所以进入被调用者之后rsp = 8 (mod 16)。如果在这个函数里面还要call其他函数的话就要将rsp减掉奇数个8让它重新16字节对齐。\n","date":"2022-08-23","permalink":"https://blog.akvicor.com/posts/aos/stack_alignment_in_x64_assembly/","summary":"gcc会在call指令之前让rsp按16字节对齐。 cpu在call的时候将rip压栈rsp -= 8，所以进入被调用者之后rsp = 8 (mod 16)。如果在这个函数里面还要c","title":"stack alignment in x64 assembly"},{"content":"初始化寄存器 我将物理地址0x050000-0x070008之间的内存分配给了堆栈。栈顶设置为0x070008的原因是，kernel函数在编译后会在函数开头加上这样一行汇编代码sub $0x8,%rsp，将栈顶设置为0x070008可以保证在经过此操作后，栈顶为0x070000。\n段寄存器 cs: 指向存放程序的内存段，ip用来存放下条待执行的指令在该段的偏移量。cs:ip所指向的指令就是下次要执行的指令。 ss: 指向用于堆栈的内存段，sp用来指向该堆栈的栈顶。 ds: 指向数据段 es: 指向附加段 (辅助段寄存器) fs: 指向标志段 (辅助段寄存器) gs: 指向全局段 (辅助段寄存器) 缺省段寄存器 当偏移量用到了指针寄存器bp，则其缺省的段寄存器也是ss，并且用bp可访问整个堆栈，不仅仅是只访问栈顶。 通常，缺省的数据段寄存器是ds 在进行串操作时，其目的地址的段寄存器规定为es 代码 use this command to check your usb stick fat32 fields\nsudo hexdump -c -n 512 /dev/sdb write the bootloader to first 512 bytes of the usb stick\nsudo dd if=boot.bin of=/dev/sdb conv=notrunc boot.asm\n[bits 16] [org 0x7c00] ;----------------------------------------------- [jump instruction; offset: 0x00; length: 3 bytes] jmp short label_start ; 2 bytes nop ; 1 bytes ;----------------------------------------------- [fat32; offset: 0x03; length: 87 bytes] %include \u0026#34;fat32.asm\u0026#34; ;----------------------------------------------- [bootstrap code; offset: 0x5a; length: 420 bytes] label_start: call print_startboot mov sp, baseofstack push cs pop ds ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; search and read \u0026#34;loader.bin\u0026#34; ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; and byte [bs_rootdirectorystart+3], 0x0f ; mask cluster value mov esi, [bs_rootdirectorystart] ; esi=cluster # of root dir rootdirreadcontinue: push baseofloader pop es xor bx, bx call readcluster ; read one cluster of root dir push esi ; save esi=next cluster # of root dir pushf ; save carry=\u0026#34;not last cluster\u0026#34; flag ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; look for the loader file to load and run ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; push baseofloader pop es xor di, di ; es:di -\u0026gt; root entries array mov si, filename_loader ; ds:si -\u0026gt; program name mov al, [bpb_sectorspercluster] cbw mul word [bpb_bytespersector] ; ax = bytes per cluster shr ax, 5 mov dx, ax ; dx = # of dir entries to search in ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; looks for a file/dir by its name ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; input: ds:si -\u0026gt; file name (11 chars) ;; ;; es:di -\u0026gt; root directory array ;; ;; dx = number of root entries ;; ;; output: esi = cluster number ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; mov cx, 11 ; the length of loader filename findnamecycle: cmp byte [es:di], 0xc jne findnamenotend jmp print_error_noloader ; end of root directory (null entry found) findnamenotend: pusha repe cmpsb popa je findnamefound add di, 32 dec dx jnz findnamecycle ; next root entry popf ; restore carry=\u0026#34;not last cluster\u0026#34; flag pop esi ; restore esi=next cluster # of root dir jc rootdirreadcontinue ; continue to the next root dir cluster jmp print_error_noloader ; end of root directory (dir end reached) findnamefound: push word [es:di+0x14] push word [es:di+0x1a] pop esi ; si = cluster no. ;;;;;;;;;;;;;;;;;;;;;;;;;; ;; load the entire file ;; ;;;;;;;;;;;;;;;;;;;;;;;;;; push baseofloader pop es xor bx, bx filereadcontinue: call readcluster ; read one cluster of root dir pushf pusha inc byte [clu] mov ax, 0xb800 mov gs, ax mov ah, 0x0f ; 0000: 黑底 1111: 白字 mov al, [clu] mov [gs:((80 * 0 + 39) * 2)], ax ; 屏幕第 0 行, 第 39 列。 popa popf jc filereadcontinue enterloader: mov bl, byte [line] ; save line number jmp baseofloader:offsetofloader ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; reads a fat32 cluster ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; inout: es:bx -\u0026gt; buffer ;; ;; esi = cluster no ;; ;; output: esi = next cluster ;; ;; es:bx -\u0026gt; next addr ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; readcluster: mov ax, [bpb_bytespersector] shr ax, 2 ; ax=# of fat32 entries per sector cwde mov ebp, esi ; ebp=esi=cluster # xchg eax, esi cdq div esi ; eax=fat sector #, edx=entry # in sector movzx edi, word [bpb_reservedsectors] add edi, [bpb_hiddensectors] add eax, edi push dx ; save dx=entry # in sector on stack mov cx, 1 call readsectorlba ; read 1 fat32 sector pop si ; si=entry # in sector add si, si add si, si and byte [es:si+3], 0x0f ; mask cluster value mov esi, [es:si] ; esi=next cluster # lea eax, [ebp-2] movzx ecx, byte [bpb_sectorspercluster] mul ecx mov ebp, eax movzx eax, byte [bpb_totalfats] mul dword [bs_bigsectorsperfat] add eax, ebp add eax, edi call readsectorlba mov ax, [bpb_bytespersector] shr ax, 4 ; ax = paragraphs per sector mul cx ; ax = paragraphs read mov cx, es add cx, ax mov es, cx ; es:bx updated cmp esi, 0x0ffffff8 ; carry=0 if last cluster, and carry=1 otherwise ret ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; reads a sector using bios int 13h fn 42h ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; input: eax = lba ;; ;; cx = sector count ;; ;; es:bx -\u0026gt; buffer address ;; ;; output: cf = 1 if error ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; readsectorlba: pushad readsectorlbanext: pusha push byte 0 push byte 0 ; 32-bit lba only: up to 2tb disks push eax push es push bx push byte 1 ; sector count word = 1 push byte 16 ; packet size byte = 16, reserved byte = 0 mov ah, 42h mov dl, [bs_drivenumber] mov si, sp push ss pop ds int 13h push cs pop ds jc short print_error_read add sp, 16 ; the two instructions are swapped so as not to overwrite carry flag popa dec cx jz readsectorlbadone2 ; last sector add bx, [bpb_bytespersector] ; adjust offset for next sector add eax, byte 1 ; adjust lba for next sector jmp short readsectorlbanext readsectorlbadone2: popad ret print_startboot: pusha mov cx, 10 mov bp, message_startboot mov bx, 0x000f call message_print_end popa ret print_error_read: mov cx, 11 mov bp, message_readerror mov bx, 0x000f call message_print_end jmp $ print_error_noloader: mov cx, 15 mov bp, message_noloader mov bx, 0x000c call message_print_end jmp $ message_print_end: push es push ds mov ax, 0 mov ds, ax mov es, ax mov ax, 0x1301 mov dl, 0 mov dh, [line] inc byte [line] int 10h pop ds pop es ret baseofloader: equ 0x1000 offsetofloader: equ 0x0000 baseofstack: equ 0x7c00 message_startboot: db \u0026#34;start boot\u0026#34; ; 10 message_readerror: db \u0026#34;error: read\u0026#34; ; 11 message_noloader: db \u0026#34;no loader found\u0026#34; ; 15 filename_loader: db \u0026#34;loader bin\u0026#34; ; 11 line: db 0x00 clu: db 0x41 times 510 - ($ - $$) db 0 ;----------------------------------------------- [end of sector marker; offset: 0x1fe; length: 2 bytes] dw 0xaa55 ","date":"2022-08-22","permalink":"https://blog.akvicor.com/posts/aos/boot/","summary":"初始化寄存器 我将物理地址0x050000-0x070008之间的内存分配给了堆栈。栈顶设置为0x070008的原因是，kernel函数在编译后会在函数开头加上这","title":"boot: 从fat32分区搜索并读取loader"},{"content":" 排序算法 不稳定排序 $math_inline$o(n\\log(n))$math_inline$ 堆 堆是具有以下性质的完全二叉树：\n根结点标号为 0，则对于根 i 的左子为 2i+1 右子为 2i+2\n**大顶堆：**每个结点的值都大于或等于其左右子结点的值 arr[i] \u0026gt;= arr[2i+1] \u0026amp;\u0026amp; arr[i] \u0026gt;= arr[2i+2] **小顶堆：**每个结点的值都小于或等于其左右子结点的值 arr[i] \u0026lt;= arr[2i+1] \u0026amp;\u0026amp; arr[i] \u0026lt;= arr[2i+2] 基本思想步骤 一般升序采用大顶堆，降序采用小顶堆\n将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点 将根结点与末尾元素进行交换，此时末尾就为最大值 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值 ","date":"2020-01-23","permalink":"https://blog.akvicor.com/posts/algorithm/heapsort/","summary":"\u003cul\u003e\n\u003cli\u003e排序算法\u003c/li\u003e\n\u003cli\u003e不稳定排序\u003c/li\u003e\n\u003cli\u003e\n\n    \n        $math_inline$O(n\\log(n))$math_inline$\n    \n\n\u003c/li\u003e\n\u003c/ul\u003e","title":"堆排序"},{"content":"枚举\n指数型 /* *********************************************** author : akvicor created time : wed sep 18 21:07:30 2019 file name : 1026.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); using namespace std; vector\u0026lt;int\u0026gt; vt; int n; void dfs(int x){ //vt.push_back(x); if(x == n+1){ for(int i = 0; i \u0026lt; vt.size(); ++i){ if(i != 0) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; vt[i]; }cout \u0026lt;\u0026lt; endl; return; } dfs(x+1); vt.push_back(x); dfs(x+1); vt.pop_back(); } int main() { cin \u0026gt;\u0026gt; n; dfs(1); return 0; } 组合 /* *********************************************** author : akvicor created time : thu sep 19 18:31:55 2019 file name : 1027.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); using namespace std; int n, m; vector\u0026lt;int\u0026gt; vt; void dfs(int x, int k){ if(k \u0026gt; m || k + n-x+1 \u0026lt; m) return; if(k == m){ for(int i = 0; i \u0026lt; vt.size(); ++i){ cout \u0026lt;\u0026lt; vt[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }cout \u0026lt;\u0026lt; endl; return; } vt.push_back(x); dfs(x+1, k+1); vt.pop_back(); dfs(x+1, k); } int main() { fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dfs(1, 0); return 0; } 排列 /* *********************************************** author : akvicor created time : thu sep 19 19:10:29 2019 file name : a.cpp ************************************************ */ #include \u0026lt;bits/stdc++.h\u0026gt; #define fast_io ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); using namespace std; int n; bool vis[100]; vector\u0026lt;int\u0026gt; v; void dfs(int k){ if(k == n){ for(auto \u0026amp;i : v) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return; } for(int i = 1; i \u0026lt;= n; ++i){ if(!vis[i]) { vis[i] = true; v.push_back(i); dfs(k+1); v.pop_back(); vis[i] = false; } } } void nper(int n){ vector\u0026lt;int\u0026gt; v(n); for(int i = 0; i \u0026lt; n; ++i) v[i] = i+1; do{ for(int i = 0; i \u0026lt; v.size(); ++i){ cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }cout \u0026lt;\u0026lt; endl; }while(next_permutation(v.begin(), v.end())); } int main() { fast_io; cin \u0026gt;\u0026gt; n; dfs(0); return 0; } ","date":"2019-10-08","permalink":"https://blog.akvicor.com/posts/algorithm/dfs_enum/","summary":"\u003cp\u003e枚举\u003c/p\u003e","title":"递归实现枚举"},{"content":"将汉诺塔中的3跟柱子改为4根，求盘子数为1到12时将全部盘子从第一根移动到最后一根需要移动的次数。\n考虑正常的汉诺塔规则，若有 n 个圆盘，那么就要将前 n−1 个圆盘移动到 2 号柱，再把最大的圆盘移动到 3 号柱，最后将前 n−1 个圆盘移动到 3 号柱。那么将 n−1 个圆盘移动又要涉及到 n−2 个圆盘，以此类推，所以，3个柱子得到的方程是 $f[i]=f[i-1] \\times 2 + 1$\ncode void hanoi(int n, char a, char b, char c){ if(n == 1) printf(\u0026#34;%c -\u0026gt; %c\\n\u0026#34;, a, c); else{ hanoi(n-1, a, c, b); // 把 a 上面的 n-1 块借助 c 移动到 b printf(\u0026#34;%c -\u0026gt; %c\\n\u0026#34;, a, c); // 第 n 块从 a 移动到 c hanoi(n-1, b, a, c); // 把 b 上面的 n-1 块借助 a 移动到 c } } ","date":"2019-09-30","permalink":"https://blog.akvicor.com/posts/algorithm/strange_tower_of_hanoi/","summary":"\u003cp\u003e将汉诺塔中的3跟柱子改为4根，求盘子数为1到12时将全部盘子从第一根移动到最后一根需要移动的次数。\u003c/p\u003e","title":"strange towers of hanoi"},{"content":"常用二进制操作\n常用的运算符共 6 种，分别为与（ \u0026amp; ）、或（ | ）、异或（ ^ ）、取反（ ~ ）、左移（ \u0026lt;\u0026lt; ）和右移（ \u0026gt;\u0026gt; ）。\n运算符 解释 \u0026amp; 只有在两个（对应位数中）都为 1 时才为 1 | 只要在两个（对应位数中）有一个 1 时就为 1 ^ 只有两个（对应位数）不同时才为 1 ^ 运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 (a ^ b) ^ b = a 。\n$math_inline$\\begin{aligned} \u00265\u0026=\u0026\u0026(101)_2\\\\ \u00266\u0026=\u0026\u0026(110)_2\\\\ \u00265\\tt\\,\\\u0026\\,6\\rm\u0026=\u0026\u0026(100)_2\u0026=\\ 4\\\\ \u00265\\tt\\,|\\,\\rm6\u0026=\u0026\u0026(111)_2\u0026=\\ 7\\\\ \u00265\\tt\\,\\text{^}\\,\\rm6\u0026=\u0026\u0026(011)_2\u0026=\\ 3\\\\ \\end{aligned}$math_inline$ 取反是对 1 个数 $math_inline$num$math_inline$ 进行的计算。\n~ 把 $math_inline$num$math_inline$ 的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）。\n补码——正数的补码为其（二进制）本身，负数的补码是其（二进制）取反后 $math_inline$+1$math_inline$ 。\n$math_inline$\\begin{aligned} 5=(0000\\ 0101)_2\\\\ 5\\ \\text{的补码} =(0000\\ 0101)_2\\\\ \\tt\\ \\text{~}\\rm5=(1111\\ 1010)_2 \\end{aligned}$math_inline$ 一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。比如集合 {1, 3, 4, 8} ，可以表示成 0b00000000000000000000000100011010 ，十进制就是 $math_inline$2^8+2^4+2^3+2^1=282$math_inline$ 。\n而对应的位运算也就可以看作是对集合进行的操作。\n操作 集合表示 位运算语句 交集 $math_inline$a \\cap b$math_inline$ a \u0026amp; b 并集 $math_inline$a \\cup b$math_inline$ `a 补集 $math_inline$\\bar{a}$math_inline$ ~a 差集 $math_inline$a \\setminus b$math_inline$ a \u0026amp; (~b) 对称差 $math_inline$a\\triangle b$math_inline$ a ^ b 常用操作 乘 2 n \u0026lt;\u0026lt; 1 除 2 负奇数的运算不可用\n我们平常写的除法是向 0 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 0 时两种方法等价，当数小于 0 时会有区别。 如： $math_inline$-1 \\div 2 = 0$math_inline$ , 而 $math_inline$-1 \u003e\u003e 1 = -1$math_inline$ n \u0026gt;\u0026gt; 1 乘以 2 的 m 次方。 n \u0026lt;\u0026lt; m 除以 2 的 m 次方。 n \u0026gt;\u0026gt; m 判断积偶性 // 结果为1 -\u0026gt; 奇数 // 结果为0 -\u0026gt; 偶数 n \u0026amp; 1 取绝对值 （某些机器上，效率比 n \u0026gt; 0 ? n : -n 高）。\n(n ^ (n \u0026gt;\u0026gt; 31)) - (n \u0026gt;\u0026gt; 31) /* n\u0026gt;\u0026gt;31 取得 n 的符号，若 n 为正数，n\u0026gt;\u0026gt;31 等于 0，若 n 为负数，n\u0026gt;\u0026gt;31 等于 - 1 若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1) 需要计算 n 和 - 1 的补码，然后进行异或运算， 结果 n 变号并且为 n 的绝对值减 1，再减去 - 1 就是绝对值 */ 取两个数的最大值 （某些机器上，效率比 a \u0026gt; b ? a : b 高）。\nb \u0026amp; ((a - b) \u0026gt;\u0026gt; 31) | a \u0026amp; (~(a - b) \u0026gt;\u0026gt; 31) /* 如果 a\u0026gt;=b,(a-b)\u0026gt;\u0026gt;31 为 0，否则为 - 1 */ 取两个数的最小值 取两个数的最小值（某些机器上，效率比 a \u0026gt; b ? b : a 高）。\na \u0026amp; ((a - b) \u0026gt;\u0026gt; 31) | b \u0026amp; (~(a - b) \u0026gt;\u0026gt; 31) /* 如果 a\u0026gt;=b,(a-b)\u0026gt;\u0026gt;31 为 0，否则为 - 1 */ 判断符号是否相同。 (x ^ y) \u0026gt;= 0 // 有 0 的情况例外 // true 表示 x 和 y 有相同的符号，false 表示 x,y 有相反的符号。 计算 2 的 n 次方。 1 \u0026lt;\u0026lt; n 判断一个数是不是 2 的幂。 n \u0026gt; 0 ? (n \u0026amp; (n - 1)) == 0 : false // 当然你也可以使用下面这种更为简便的写法: // return n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; (n - 1)) == 0; /* 如果是 2 的幂，n 一定是 100... n-1 就是 1111.... 所以做与运算结果为 0 */ 对 2 的 n 次方取余。 m \u0026amp; (n - 1) // n 为 2 的次方 /* 如果是 2 的幂，n 一定是 100... n-1 就是 1111.... 所以做与运算结果保留 m 在 n 范围的非 0 的位 */ 求两个整数的平均值。 (x + y) \u0026gt;\u0026gt; 1 交换两个数的值 效率可能并没有 int c = a; a = b; b = c; 高。\nvoid swap(int \u0026amp;a, int \u0026amp;b) { a = a ^ b; b = a ^ b; a = a ^ b; } 遍历一个集合的子集 int b = 0; do { // process subset b } while (b = (b - x) \u0026amp; x); 取出整数 n 在二进制表示下的第 k 位 (n \u0026gt;\u0026gt; k) \u0026amp; 1 取出整数 n 在二进制表示下的第 0 ~ k-1 位（后 k 位） n \u0026amp; ((1 \u0026lt;\u0026lt; k) - 1) 把整数 n 在二进制表示下的第 k 位取反 n ^ (1 \u0026lt;\u0026lt; k) 对整数 n 在二进制表示下的第 k 位赋值 1 n | (1 \u0026lt;\u0026lt; k) 对整数 n 在二进制表示下的第 k 位赋值 0 n \u0026amp; (~(1 \u0026lt;\u0026lt; k)) 成对变换 当 n 位偶数时，n ^ 1 等于 n + 1 当 n 位奇数时，n ^ 1 等于 n - 1 因此：0 与 1、2 与 3、4 与 5 关于 ^1 运算构成 “成对变换”\n这一性质经常用于图论邻接表中边集的存储。在具有无向边（双向边）的图中把一对正反方向的边分别存储在邻接表数组的第 n 与 n+1 位置（其中 n 为偶数），就可以通过 ^1 的运算获得与当前边 (x, y) 反向的边 (y, x) 的存储位置。\nlowbit 运算 lowbit(n) 定义为非负整数 n 在二进制表示下 “最低位的 1 及其后边所有的 0” 构成的数值。例如 $math_inline$n=10$math_inline$ 的二进制表示为 $math_inline$(1010)_2$math_inline$ 则 lowbit(n) = 2 = (10)_2。\n设 $math_inline$n \u003e 0$math_inline$ , n 的第 k 位是 1，第 0 ~ k-1 位都是 0。\n为了实现 lowbit 运算，先把 n 取反，此时第 k 位变为 0，第 0 ～ k-1 位都是 1 再令 n = n+1，此时因为进位，第 k 位变为 1，第 0 ～ k-1 位都是0.\n在上面的取反加 1 操作后，n 的第 k+1 位到最高位恰好与原来相反，所以 n\u0026amp;(~n+1) 仅有第 k 位为 1，其余位都是 0。而在补码表示下，~n = -1-n，因此；\nlowbit(n) = n\u0026amp;(~n+1) = n\u0026amp;(-n) 找出一个数的那些位为 1 利用上面的 lowbit，我们不断把 n 赋值为 n-lowbit(n)，直至 n = 0. 对 lowbit 值取对数即可得到所在位置，但 math 库自带的函数是以 e 为底的实数运算，且常数较大，所以可以预处理一个数组，利用 hash 的方法代替 log 运算。\nvoid f1(int n){ const int max_n = 1 \u0026lt;\u0026lt; 20; int h[max_n]; for(int i = 0; i \u0026lt; 20; ++i) h[1 \u0026lt;\u0026lt; i] = i; while(n \u0026gt; 0){ cout \u0026lt;\u0026lt; h[n \u0026amp; -n] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; n -= n \u0026amp; -n; } cout \u0026lt;\u0026lt; endl; } 稍微复杂但是效率更高的一个方法是建立一个长度为 37 的数组 h，令 $math_inline$h[2^k \\text{mod} 37] = k$math_inline$ 。这里利用了一个小小的数学技巧： $math_inline$\\forall(k)\\in [0, 35], 2^k \\text{mod} 37$math_inline$ 互不相等，且恰好取遍整数 1 ~ 36。\nvoid f2(int n){ int h[37]; for(int i = 0; i \u0026lt; 36; ++i) h[(1ll \u0026lt;\u0026lt; i) % 37] = i; while(n \u0026gt; 0){ cout \u0026lt;\u0026lt; h[(n \u0026amp; -n) % 37] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; n -= n \u0026amp; -n; } cout \u0026lt;\u0026lt; endl; } gcc 编译器还提供了一些内置函数，可以高效的计算 lowbit 以及二进制数中 1 的个数。不过这些并非 c 语言标准，有的函数更是与及其或编译器版本相关。\nint __buildin_ctz(usigned int x) int __buildin_ctzll(usigned long long x) // 返回 x 的二进制表示下最低位的 1 后边有多少个 0 int __builtin_popcount(usigned int x) int __builtin_popcountll(usigned long long x) // 返回 x 的二进制表示下有多少位为 1 ","date":"2019-09-14","permalink":"https://blog.akvicor.com/posts/algorithm/bit_operation/","summary":"\u003cp\u003e常用二进制操作\u003c/p\u003e","title":"二进制操作"},{"content":"快速乘\no(log) 快速幂思想 类似于快速幂的思想，把整数 b 用二进制表示，即\n$math_inline$b=c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_{0}2^{0}$math_inline$ 那么\n$math_inline$a * b=c_{k-1} * a * 2^{k-1}+c_{k-2} * a * 2^{k-2}+...+c_{0} * a * 2^{0}$math_inline$ 因为 $math_inline$a * 2^i=(a * 2^{i-1}) * 2$math_inline$ ，若已求出 $math_inline$a * 2^{i-1}\\text{mod}p$math_inline$ ，则计算 $math_inline$a * 2^{i-1}\\text{mod}p$math_inline$ 时，运算过程中的每一步结果都不超过 $math_inline$2 * 10^{18}$math_inline$ o(1) 特殊情况下易精度丢失导致答案错误 利用 $math_inline$a * b\\text{mod}p = a * b-\\lfloor a * b/p \\rfloor * p$math_inline$ 首先，当 $math_inline$a,b \u003c p$math_inline$ 时， $math_inline$a * b/p$math_inline$ 下取整以后也一定小于 $math_inline$p$math_inline$ 。我们可以用浮点数执行 $math_inline$a * b/p$math_inline$ 的运算，而不用关心小数点之后的部分。long double 在十进制下有效位为 18~19 位。当浮点数的精度不足以保存精确数值时，它会像科学计数法一样舍弃低位，正好符合我们的要求。\n虽然 $math_inline$a * b$math_inline$ 和 $math_inline$\\lfloor a * b/p \\rfloor * p$math_inline$ 可能很大，但是两者的差一定在 0~p-1之间。所以我们用 long long 来保存 $math_inline$a * b$math_inline$ 和 $math_inline$\\lfloor a * b/p \\rfloor * p$math_inline$ 各自的记过。整数运算溢出相当于舍弃高位，也正好符合我们的要求。\ncode code 1 // o(1) ll mul(ll a, ll b, ll p) { return ((__int128)a*b)%p; } // o(1) ll mul(ll a, ll b, ll p) { a %= p; b %= p; ll c = (long double)a * b / p; ll ans = a * b - c * p; return (ans % p + p) % p; } // o(log) ll mul(ll a, ll b, ll p) { ll ans = 0; while (b) { if (b \u0026amp; 1) ans = (ans + a) % p; a = a * 2 % p; b \u0026gt;\u0026gt;= 1; } return ans; } problem 64 bit integer multiplication\n","date":"2019-09-13","permalink":"https://blog.akvicor.com/posts/algorithm/64bit_multiplication/","summary":"\u003cp\u003e快速乘\u003c/p\u003e","title":"64位整数乘法"},{"content":"快速幂\n根据数学常识，每一个正整数可以唯一表示为若干指数不重复的 2 的次幂的和。\n$math_inline$3^{13} = 3^{(1101)_2} = 3^8 \\cdot 3^4 \\cdot 3^1$math_inline$ 也就是说，如果 b 在二进制表示下有 k 位，其中第 $math_inline$i(0 \\leq i \u003c k)$math_inline$ 位的数字是 $math_inline$c_i$math_inline$ ，那么\n$math_inline$b=c_{k-1}2^{k-1}+c_{k-2}2^{k-2}+...+c_{0}2^{0}$math_inline$ 于是\n$math_inline$a^b=a^{c_{k-1}*2^{k-1}}*a^{c_{k-2}*2^{k-2}}*...*a^{c_0}*2^0$math_inline$ 因为 $math_inline$k=\\lceil\\log_2{(b+1)}\\rceil$math_inline$ ，所以上式乘积的数量不多于 $math_inline$\\lceil\\log_2{(b+1)}\\rceil$math_inline$ 个\n又因为 $math_inline$a^{2^i}=\\left(a^{2^{i-1}}\\right)^2$math_inline$ ，所以很容易通过 k 次递推求出每个乘积项，当 $math_inline$c_i=1$math_inline$ 时，把该乘积项累积到答案中\n因此为了计算 $math_inline$3^{13}$math_inline$ ，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了\n$math_inline$13 = (1101)_2$math_inline$ $math_inline$3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$math_inline$ $math_inline$\\begin{align} 3^1 \u0026= 3 \\\\ 3^2 \u0026= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 \u0026= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 \u0026= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align}$math_inline$ code code 1 ll quick_pow(ll a, ll b, ll p) { a %= p; ll res = 1 % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) res = res * a % p; a = a * a % p; } return res; } problem a^b\n","date":"2019-09-13","permalink":"https://blog.akvicor.com/posts/algorithm/quick_pow/","summary":"\u003cp\u003e快速幂\u003c/p\u003e","title":"快速幂 a^b"},{"content":"假设班里有 $math_inline$10$math_inline$ 个学生喜欢数学， $math_inline$15$math_inline$ 个学生喜欢语文， $math_inline$21$math_inline$ 个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？\n是 $math_inline$10+15+21=46$math_inline$ 个吗？不是的，因为有些学生可能同时喜欢数学和语文，或者语文和编程，甚至还有可能三者都喜欢。\n为了叙述方便，我们把喜欢语文、数学、编程的学生集合分别用 $math_inline$a,b,c$math_inline$ 表示，则学生总数等于 $math_inline$|a\\cup b\\cup c|$math_inline$ 。\n刚才已经讲过，如果把这三个集合的元素个数 $math_inline$|a|,|b|,|c|$math_inline$ 直接加起来，会有一些元素重复统计了，因此需要扣掉 $math_inline$|a\\cap b|,|b\\cap c|,|c\\cap a|$math_inline$ ，但这样一来，又有一小部分多扣了，需要加回来，即 $math_inline$|a\\cap b\\cap c|$math_inline$ 。\n即： $math_inline$|a\\cup b\\cup c|=|a|+|b|+|c|-|a\\cap b|-|b\\cap c|-|c\\cap a|+|a\\cap b\\cap c|$math_inline$ 把上述问题推广到一般情况，就是我们熟知的容斥原理。\n容斥原理 设 u 中元素有 n 种不同的属性，而第 i 种属性称为 $math_inline$p_i$math_inline$ ，拥有属性 $math_inline$p_i$math_inline$ 的元素构成集合 $math_inline$s_i$math_inline$ ，那么\n$math_inline$ \\begin{split} \\left|\\bigcup_{i=1}^{n}s_i\\right|=\u0026\\sum_{i}|s_i|-\\sum_{i","date":"2019-08-15","permalink":"https://blog.akvicor.com/posts/algorithm/inclusion_exclusion_principle/","summary":"\u003cp\u003e假设班里有\n\n    \n        $math_inline$10$math_inline$\n    \n\n个学生喜欢数学，\n\n    \n        $math_inline$15$math_inline$\n    \n\n个学生喜欢语文，\n\n    \n        $math_inline$21$math_inline$\n    \n\n个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？\u003c/p\u003e","title":"容斥原理"},{"content":"给定任意正整数 $math_inline$n$math_inline$ ，那么在小于等于 $math_inline$n$math_inline$ 的所有正整数之中，有多少个与 $math_inline$n$math_inline$ 构成互质关系？\n计算这个值的方法就叫做欧拉函数 $math_inline$\\phi(n)$math_inline$ 表示：在 $math_inline$1$math_inline$ 到 $math_inline$n$math_inline$ 之中，与n构成互质关系的数的数量。\n分析 情况一 如果 $math_inline$n=1$math_inline$ ，则 $math_inline$\\phi(1)=1$math_inline$ 。因为1与任何数（包括自身）都构成互质关系\n情况二 如果 $math_inline$n$math_inline$ 是质数，则 $math_inline$\\phi(n)=n-1$math_inline$ 。因为质数与小于它的每一个数，都构成互质关系。比如 $math_inline$5$math_inline$ 与 $math_inline$1、2、3、4$math_inline$ 都构成互质关系。\n情况三 如果 $math_inline$n$math_inline$ 是质数的某一个次方，即 $math_inline$n=p^k$math_inline$ （ $math_inline$p$math_inline$ 为质数， $math_inline$k$math_inline$ 为大于等于 $math_inline$1$math_inline$ 的整数），则 $math_inline$\\phi(p^k)=p^k-p^{k-1}$math_inline$ 比如 $math_inline$\\phi(8)=\\phi(2^3)=2^3-2^2=8-4=4$math_inline$ 这是因为只有当一个数不包含质数 $math_inline$p$math_inline$ ，才有可能与 $math_inline$n$math_inline$ 互质。而包含质数 $math_inline$p$math_inline$ 的数一共有 $math_inline$p^{k-1}$math_inline$ 个。\n即 $math_inline$1\\times p、2\\times p、3\\times p、... 、p^{k-1}\\times p$math_inline$ ，把他们去除，剩下的就是与 $math_inline$n$math_inline$ 互质的数。\n上面的式子还可以写成下面的形式：\n$math_inline$\\phi(p^k)=p^k-p^{k-1}=p^k(1-\\frac{1}{p})$math_inline$ 可以看出，上面的第二种情况是 $math_inline$k=1$math_inline$ 时的特例\n情况四 如果n可以分解成两个互质的整数之积： $math_inline$n=p_1\\times p_2$math_inline$ 则： $math_inline$\\phi(n)=\\phi(p_1p_2)=\\phi(p_1)\\phi(p_2)$math_inline$ 即积的欧拉函数等于各个因子的欧拉函数之积。比如 $math_inline$\\phi(56)=\\phi(8\\times 7)=\\phi(8)\\phi(7)=4\\times 6=24$math_inline$ 对于素数 $math_inline$p$math_inline$ ， $math_inline$\\phi(p)=p-1$math_inline$ ，对于两个素数 $math_inline$p,q$math_inline$ ， $math_inline$\\phi(pq)=pq-1$math_inline$ 欧拉函数是积性函数，但不是完全积性函数\n欧拉函数的积性 若 $math_inline$m,n$math_inline$ 互质，则 $math_inline$\\phi(mn)=\\phi(m)\\phi(n)$math_inline$ 。\n由“ $math_inline$m,n$math_inline$ 互质”可知 $math_inline$m,n$math_inline$ 无公因数，所以：\n$math_inline$\\phi(m)\\phi(n)=m(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})...(1-\\frac{1}{p_n})\\cdot n(1-\\frac{1}{p_1'})(1-\\frac{1}{p_2'})(1-\\frac{1}{p_3'})...(1-\\frac{1}{p_n'})$math_inline$ 其中 $math_inline$p_1、p_2、p_3...p_n$math_inline$ 为 $math_inline$m$math_inline$ 的质因数， $math_inline$p_1'、p_2'、p_3'...p_n'$math_inline$ 为 $math_inline$n$math_inline$ 的质因数，而 $math_inline$m,n$math_inline$ 无公因数。\n所以 $math_inline$p_1、p_2、p_3...p_n、p_1'、p_2'、p_3'...p_n$math_inline$ 互不相同，所以 $math_inline$p_1、p_2、p_3...p_n、p_1'、p_2'、p_3'...p_n$math_inline$ 均为 $math_inline$mn$math_inline$ 的质因数且为 $math_inline$mn$math_inline$ 的质因数的全集。\n所以 $math_inline$\\phi(mn)=mn(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})...(1-\\frac{1}{p_n})\\cdot (1-\\frac{1}{p_1'})(1-\\frac{1}{p_2'})(1-\\frac{1}{p_3'})...(1-\\frac{1}{p_n'})$math_inline$ 所以 $math_inline$\\phi(mn)=\\phi(m)\\phi(n)$math_inline$ 。\n以上部分涉及到“中国剩余定理”\n情况五 因为任意一个大于1的正整数，都可以写成一系列质数的积。（分解质因数）\n$math_inline$n=p_1^{k_1}p_2^{k_2}...p_r^{k_r}$math_inline$ 根据结论四，得到\n$math_inline$\\phi(n)=\\phi(p_1^{k_1})\\phi(p_2^{k_2})...\\phi(p_r^{k_r})$math_inline$ 再根据结论三，得到\n$math_inline$\\phi(n)=p_1^{k_1}p_2^{k_2}...p_r^{k_r}(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_r})$math_inline$ 也就等于\n$math_inline$\\phi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_r})$math_inline$ 结论 比如 $math_inline$\\phi(1323)=(3^3\\times 7^2)=1323(1-\\frac{1}{3})(1-\\frac{1}{7})=756$math_inline$ 即 $math_inline$\\phi(mn)=\\phi(n)\\phi(m)$math_inline$ 只在 $math_inline$(m,n)=1$math_inline$ 时成立。\n对于一个正整数 $math_inline$n$math_inline$ 的素数幂分解 $math_inline$n=p_1^{q_1}p_2^{q_2}...p_n^{q_n}$math_inline$ $math_inline$\\phi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_n})$math_inline$ 除了 $math_inline$n=2, \\phi(n)$math_inline$ 都是偶数\n设 $math_inline$n$math_inline$ 为正整数， $math_inline$\\sum{\\phi(d)}=n(d|n)$math_inline$ 欧拉函数 根据性质二，我们可以在 $math_inline$o(\\sqrt{n})$math_inline$ 的时间复杂度内求出一个数的欧拉函数值。\ncode //直接求解欧拉函数 int euler(int n) { //返回euler(n) int res = n, a = n; for (int i = 2; i * i \u0026lt;= a; i++) { if (a % i == 0) { res = res / i * (i - 1);//先进行除法是为了防止中间数据的溢出 while (a % i == 0) a /= i; } } if (a \u0026gt; 1) res = res / a * (a - 1); return res; } 欧拉函数线性筛 如果要求 $math_inline$n$math_inline$ 以内的所有数的欧拉函数 $math_inline$o(n)$math_inline$ code const int maxn = 1e6; //欧拉线性筛：在线性时间内筛素数的同时求出所有数的欧拉函数 int tot; int phi[maxn]; //保存各个数字的欧拉函数 int prime[maxn]; //按顺序保存素数 bool mark[maxn]; //判断是否是素数 void get_phi(int n){ phi[1] = 1; for(int i = 2; i \u0026lt;= maxn; i++){ //相当于分解质因数的逆过程 if(!mark[i]){ prime[++tot] = i; phi[i] = i-1; } for(int j = 1; j \u0026lt;= tot; j++){ if(i * prime[j] \u0026gt; n) break; mark[i * prime[j]] = 1; //确定i*prime[j]不是素数 if(i % prime[j] == 0){ //判断prime[j] 是否为 i的约数 phi[i * prime[j]] = phi[i] * prime[j]; break; } else{ //prime[j] - 1 就是 phi[prime[j]],利用了欧拉函数的积性 phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } } } ","date":"2019-08-13","permalink":"https://blog.akvicor.com/posts/algorithm/euler/","summary":"\u003cp\u003e给定任意正整数\n\n    \n        $math_inline$n$math_inline$\n    \n\n，那么在小于等于\n\n    \n        $math_inline$n$math_inline$\n    \n\n的所有正整数之中，有多少个与\n\n    \n        $math_inline$n$math_inline$\n    \n\n构成互质关系？\u003c/p\u003e\n\u003cp\u003e计算这个值的方法就叫做欧拉函数\n\n    \n        $math_inline$\\phi(n)$math_inline$\n    \n\n表示：在\n\n    \n        $math_inline$1$math_inline$\n    \n\n到\n\n    \n        $math_inline$n$math_inline$\n    \n\n之中，与n构成互质关系的数的数量。\u003c/p\u003e","title":"欧拉函数证明"},{"content":"dirichlet卷积\n定义 定义数论函数 $math_inline$f$math_inline$ 和 $math_inline$g$math_inline$ 的狄利克雷卷积为 $math_inline$h$math_inline$ ，则 $math_inline$h(n)=\\sum_{d|n}f(d) g(\\frac{n}{d})$math_inline$ 记做 $math_inline$h=f * g$math_inline$ （ * 代表卷积）\n性质 狄利克雷卷积满足交换律，结合律，对加法满足分配律\n交换律： $math_inline$f * g = g * f$math_inline$ 结合律： $math_inline$(f * g) * h = f * (g * h)$math_inline$ 分配律： $math_inline$f * (g+h)=f * g + f * h$math_inline$ 单位元： $math_inline$f * e = e * f$math_inline$ 逆元：对于每一个 $math_inline$f(1)\\neq 0$math_inline$ 的函数 $math_inline$f$math_inline$ ，都有 $math_inline$f * g=\\epsilon$math_inline$ 两个积性函数的狄利克雷卷积依旧为积性函数。 $math_inline$f,g$math_inline$ 为积性函数，则 $math_inline$f * g$math_inline$ 也为积性函数\n$math_inline$e$math_inline$ 为单位元，它卷上任意的数论函数仍为原数论函数，简单来说，就是 $math_inline$e(n)=[n=1]$math_inline$ 求一个函数的逆\n只需定义： $math_inline$g(n)=\\frac{1}{f(1)}\\left([n==1]-\\sum_{i|n,i\\neq1}f(i)g(\\frac{n}{i})\\right)$math_inline$ 这样的话： $math_inline$\\sum_{i|n}f(i)g(\\frac{n}{i})=f(1)g(n)+\\sum_{i|n,i\\neq1}f(i)g(\\frac{n}{i})=[n==1]$math_inline$ 常用的狄利克雷卷积 $math_inline$(1\\cdot\\mu)=e$math_inline$ ，因为 $math_inline$\\sum_{d|n}\\mu(d)=[n=1]$math_inline$ $math_inline$\\mu\\cdot id=\\phi$math_inline$ ，将欧拉函数的通式展开即可得到次式。\n$math_inline$1\\cdot id = \\sigma$math_inline$ $math_inline$1\\cdot 1 = \\tau$math_inline$ 我们能够通过简单的狄利克雷卷积运算轻易的证出莫比乌斯反演\n若有 $math_inline$f(n)=\\sum_{d|n}f(d)$math_inline$ 则有 $math_inline$f=1\\cdot f$math_inline$ ，两边同时卷上 $math_inline$\\mu$math_inline$ ，可得\n$math_inline$\\mu \\cdot f = \\mu \\cdot 1 \\cdot f$math_inline$ 又因为 $math_inline$1\\cdot \\mu =e$math_inline$ ，所以 $math_inline$f=\\mu\\cdot f$math_inline$ 即 $math_inline$f(n)=\\sum_{d|n}\\mu(d)\\cdot f(\\frac{n}{d})$math_inline$ 我们甚至可以弄出一些很棒的东西，比如说\n$math_inline$id=id\\cdot e=id\\cdot\\mu\\cdot 1=\\phi\\cdot1$math_inline$ $math_inline$n=id(n)=\\sum_{d|n}\\phi(d)$math_inline$ $math_inline$\\sigma=1\\cdot id=1\\cdot(1\\cdot\\phi)=(1\\cdot 1)\\cdot\\phi=\\tau\\cdot\\phi$math_inline$ $math_inline$\\sigma(n)=\\sum_{d|n}\\tau(d)\\cdot\\phi(\\frac{n}{d})$math_inline$","date":"2019-08-07","permalink":"https://blog.akvicor.com/posts/algorithm/dirichlet_convolution/","summary":"\u003cp\u003eDirichlet卷积\u003c/p\u003e","title":"狄利克雷卷积"},{"content":"莫比乌斯反演是数论中的重要内容，对于一些函数 $math_inline$f(n)$math_inline$ ，如果很难直接求出它的值，而容易求出其倍数和或约数和 $math_inline$g(n)$math_inline$ ，那么可以通过莫比乌斯反演简化运算，求得 $math_inline$f(n)$math_inline$ 的值。\n开始学习莫比乌斯反演前我们需要一些前置知识：积性函数、dirichlet卷积、莫比乌斯函数\n数论分块与整除相 引理 1 $math_inline$ \\forall a,b,c\\in\\mathbb{z},\\left\\lfloor\\frac{a}{bc}\\right\\rfloor=\\left\\lfloor\\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor $math_inline$ 略证\n$math_inline$ \\begin{split} \u0026\\frac{a}{b}=\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r(0\\leq r\u003c1)\\\\\\\\ \\rightarrow \u0026\\left\\lfloor\\frac{a}{bc}\\right\\rfloor =\\left\\lfloor\\frac{a}{b}\\cdot\\frac{1}{c}\\right\\rfloor =\\left\\lfloor \\frac{1}{c}\\left(\\left\\lfloor\\frac{a}{b}\\right\\rfloor+r\\right)\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c} +\\frac{r}{c}\\right\\rfloor =\\left\\lfloor \\frac{\\left\\lfloor\\frac{a}{b}\\right\\rfloor}{c}\\right\\rfloor \\end{split} $math_inline$ 引理 2 $math_inline$ \\forall{n} \\in n, \\left | \\left\\{ \\lfloor \\frac{n}{d} \\rfloor \\mid d \\in n \\right\\}\\right| \\leq \\lfloor 2\\sqrt{n} \\rfloor $math_inline$ $math_inline$|v|$math_inline$ 表示集合 $math_inline$v$math_inline$ 的元素个数\n略证\n对于 $math_inline$d\\leq\\lfloor\\sqrt{n}\\rfloor$math_inline$ ， $math_inline$\\lfloor \\frac{n}{d}\\rfloor$math_inline$ 有 $math_inline$\\lfloor\\sqrt{n}\\rfloor$math_inline$ 种取值\n对于 $math_inline$d\u003e\\lfloor\\sqrt{n}\\rfloor$math_inline$ ，有 $math_inline$\\lfloor \\frac{n}{d}\\rfloor\\leq\\lfloor\\sqrt{n}\\rfloor$math_inline$ ，也只有 $math_inline$\\lfloor\\sqrt{n}\\rfloor$math_inline$ 种取值\n综上得证\n数论分块 数论分块的过程大概如下：考虑含有 $math_inline$\\lfloor\\frac{n}{i}\\rfloor$math_inline$ 的求和式子（ $math_inline$n$math_inline$ 为常数）\n对于任意一个 $math_inline$i(i\\leq n)$math_inline$ ，我们需要找到一个最大的 $math_inline$j(i\\leq j\\leq n)$math_inline$ ，使得 $math_inline$\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{j}\\rfloor$math_inline$ 而 $math_inline$j=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor$math_inline$ 略证\n$math_inline$ \\begin{split} \u0026\\left\\lfloor\\frac{n}{i}\\right\\rfloor \\leq \\frac{n}{i}\\\\ \\rightarrow \u0026\\left\\lfloor\\frac{n}{ \\left\\lfloor\\frac{n}{i}\\right\\rfloor }\\right\\rfloor \\geq \\left\\lfloor\\frac{n}{ \\frac{n}{i} }\\right\\rfloor = \\left\\lfloor i \\right\\rfloor=i \\\\ \\rightarrow \u0026i\\leq \\left\\lfloor\\frac{n}{ \\left\\lfloor\\frac{n}{i}\\right\\rfloor }\\right\\rfloor \\end{split} $math_inline$ 即 $math_inline$j=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor$math_inline$ 利用上述结论，我们每次以 $math_inline$[i,j]$math_inline$ 为一块，分块求和即可\n积性函数 定义 若 $math_inline$\\gcd(x,y)=1$math_inline$ 且 $math_inline$f(xy)=f(x)f(y)$math_inline$ ，则 $math_inline$f(n)$math_inline$ 为积性函数。\n性质 若 $math_inline$f(x)$math_inline$ 和 $math_inline$g(x)$math_inline$ 均为积性函数，则以下函数也为积性函数\n$math_inline$ \\begin{aligned} h(x)\u0026=f(x^p)\\\\ h(x)\u0026=f^p(x)\\\\ h(x)\u0026=f(x)g(x)\\\\ h(x)\u0026=\\sum_{d\\mid x}f(d)g(\\frac{x}{d}) \\end{aligned} $math_inline$ 例子\n单位函数： $math_inline$\\epsilon(n)=[n=1]$math_inline$ 恒等函数： $math_inline$\\operatorname{id}_k(n)=n^k\\operatorname{id}_{1}(n)$math_inline$ 通常记做 $math_inline$\\operatorname{id}(n)$math_inline$ 常数函数： $math_inline$1(n)=1$math_inline$ 除数函数： $math_inline$\\sigma_{k}(n)=\\sum_{d\\mid n}d^{k}\\sigma_{0}(n)$math_inline$ 通常简记做 $math_inline$\\operatorname{d}(n)$math_inline$ 或 $math_inline$\\tau(n)$math_inline$ ， $math_inline$\\sigma_{1}(n)$math_inline$ 通常简记做 $math_inline$\\sigma(n)$math_inline$ 欧拉函数： $math_inline$\\varphi(n)=\\sum_{i=1}^n [\\gcd(i,n)=1]$math_inline$ 莫比乌斯函数： $math_inline$\\mu(n) = \\begin{cases}1 \u0026 n=1 \\\\ 0 \u0026 \\exists d:d^{2} \\mid n \\\\ (-1)^{\\omega(n)} \u0026 otherwise\\end{cases}$math_inline$ 其中 $math_inline$\\omega(n)$math_inline$ 表示 $math_inline$n$math_inline$ 的本质不同质因子个数，是一个加性函数 dirichlet卷积 定义 定义两个数论函数 $math_inline$f,g$math_inline$ 的dirichlet卷积为\n$math_inline$ (f*g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d}) $math_inline$ 性质 dirichlet卷积满足交换律和结合律\n其中 $math_inline$\\varepsilon$math_inline$ 为dirichlet卷积的单位元（任何函数卷 $math_inline$\\epsilon$math_inline$ 都为其本身）\n例子 $math_inline$ \\begin{aligned} \\varepsilon=\\mu*1\u0026\\leftrightarrow\\varepsilon(n)=\\sum_{d\\mid n}\\mu(d)\\\\ d=1*1\u0026\\leftrightarrow d(n)=\\sum_{d\\mid n}1\\\\ \\sigma=d*1\u0026\\leftrightarrow\\varepsilon(n)=\\sum_{d\\mid n}d\\\\ \\varphi=\\mu*\\text{id}\u0026\\leftrightarrow\\varphi(n)=\\sum_{d\\mid n}d\\cdot\\mu(\\frac{n}{d}) \\end{aligned} $math_inline$ 莫比乌斯函数 定义 $math_inline$\\mu$math_inline$ 为莫比乌斯函数\n性质 莫比乌斯函数不但是积性函数，还有如下性质：\n$math_inline$ \\mu(n)= \\begin{cases} 1\u0026n=1\\\\ 0\u0026n\\text{ 含有平方因子}\\\\ (-1)^k\u0026k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\\\ \\end{cases} $math_inline$ 证明 $math_inline$ \\varepsilon(n)= \\begin{cases} 1\u0026n=1\\\\ 0\u0026n\\neq 1\\\\ \\end{cases} $math_inline$ 其中 $math_inline$\\displaystyle\\varepsilon(n)=\\sum_{d\\mid n}\\mu(d)$math_inline$ 即 $math_inline$\\varepsilon=\\mu*1$math_inline$ 设 $math_inline$\\displaystyle n=\\prod_{i=1}^k{p_i}^{c_i},n'=\\prod_{i=1}^k p_i$math_inline$ 那么 $math_inline$\\displaystyle\\sum_{d\\mid n}\\mu(d)=\\sum_{d\\mid n'}\\mu(d)=\\sum_{i=0}^k c_k^i\\cdot(-1)^k$math_inline$ 根据二项式定理，易知该式子的值在 $math_inline$k=0$math_inline$ 即 $math_inline$n=1$math_inline$ 时的值为 $math_inline$1$math_inline$ 否则为 $math_inline$0$math_inline$ ，这也同时证明了 $math_inline$\\sum_{d|n}{\\mu(d)}=[n=1]$math_inline$ 补充结论 反演推论： $math_inline$\\displaystyle [gcd(i,j)=1] \\leftrightarrow\\sum_{d\\mid\\gcd(i,j)}\\mu(d)$math_inline$ **直接推导：**如果看懂了上一个结论，这个结论稍加思考便可以推出：如果 $math_inline$\\gcd(i,j)=1$math_inline$ 的话，那么代表着我们按上个结论中枚举的那个 $math_inline$n$math_inline$ 是 $math_inline$1$math_inline$ ，也就是式子的值是 $math_inline$1$math_inline$ ，反之，有一个与 $math_inline$[\\gcd(i,j)=1]$math_inline$ 相同的值：0 **利用 $math_inline$\\varepsilon$math_inline$ 函数：**根据上一结论， $math_inline$[\\gcd(i,j)=1]\\rightarrow \\varepsilon(\\gcd(i,j))$math_inline$ ，将 $math_inline$\\varepsilon$math_inline$ 展开即可。 线性筛 由于 $math_inline$\\mu$math_inline$ 函数为积性函数，因此可以线性筛莫比乌斯函数（线性筛基本可以求所有的积性函数，尽管方法不尽相同）。\ncode void getmu() { mu[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!flg[i]) p[++tot] = i, mu[i] = -1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } } 拓展 $math_inline$\\varphi*1=\\text{id}\\text{（id 函数即 } f(x)=x\\text{）}$math_inline$ 将 $math_inline$n$math_inline$ 分解质因数： $math_inline$\\displaystyle n=\\prod_{i=1}^k {p_i}^{c_i}$math_inline$ 首先，因为 $math_inline$\\varphi$math_inline$ 是积性函数，故只要证明当 $math_inline$n'=p^c$math_inline$ 时 $math_inline$\\displaystyle\\varphi*1=\\sum_{d\\mid n'}\\varphi(\\frac{n'}{d})=\\text{id}$math_inline$ 成立即可。\n因为 $math_inline$p$math_inline$ 是质数，于是 $math_inline$d=p^0,p^1,p^2,\\cdots,p^c$math_inline$ 易知如下过程\n$math_inline$ \\begin{aligned} \\varphi*1\u0026=\\sum_{d\\mid n}\\varphi(\\frac{n}{d})\\\\ \u0026=\\sum_{i=0}^c\\varphi(p^i)\\\\ \u0026=1+p^0\\cdot(p-1)+p^1\\cdot(p-1)+\\cdots+p^{c-1}\\cdot(p-1)\\\\ \u0026=p^c\\\\ \u0026=\\text{id}\\\\ \\end{aligned} $math_inline$ 该式子两侧同时卷 $math_inline$\\mu$math_inline$ 可得 $math_inline$\\displaystyle\\varphi(n)=\\sum_{d\\mid n}d\\cdot\\mu(\\frac{n}{d})$math_inline$ 莫比乌斯反演 公式 设 $math_inline$f(n),g(n)$math_inline$ 为两个数论函数\n如果有 $math_inline$f(n)=\\sum_{d\\mid n}g(d)$math_inline$ 那么有 $math_inline$g(n)=\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})$math_inline$ 证明 **暴力计算：** $math_inline$\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})=\\sum_{d\\mid n}\\mu(d)\\sum_{k\\mid \\frac{n}{d}}g(k)=\\sum_{k\\mid n}g(k)\\sum_{d\\mid \\frac{n}{k}}\\mu(d)=g(n)$math_inline$ 用 $math_inline$\\displaystyle\\sum_{d\\mid n}g(d)$math_inline$ 来替换 $math_inline$f(\\dfrac{n}{d})$math_inline$ ，再变换求和顺序。最后一步转为的依据： $math_inline$\\displaystyle\\sum_{d\\mid n}\\mu(d)=[n=1]$math_inline$ 因此在 $math_inline$\\dfrac{n}{k}=1$math_inline$ 时第二个和式的值才为 $math_inline$1$math_inline$ 。此时 $math_inline$n=k$math_inline$ ，故原式等价于 $math_inline$\\displaystyle\\sum_{k\\mid n}[n=k]\\cdot g(k)=g(n)$math_inline$ 运用卷积：\n原问题为：已知 $math_inline$f=g*1$math_inline$ ，证明 $math_inline$g=f*\\mu$math_inline$ 易知如下转化： $math_inline$f*\\mu=g*1*\\mu\\rightarrow f*\\mu=g$math_inline$ （其中 $math_inline$1*\\mu=\\varepsilon$math_inline$ ）\n莫比乌斯反演拓展 对于数论函数 $math_inline$f,g$math_inline$ 和完全积性函数 $math_inline$t$math_inline$ 且 $math_inline$t(1)=1$math_inline$ ：\n$math_inline$ f(n)=\\sum_{i=1}^nt(i)g\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\ \\leftrightarrow g(n)=\\sum_{i=1}^n\\mu(i)t(i)f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right) $math_inline$ 我们来证明一下：\n$math_inline$ \\begin{eqnarray} \u0026\u0026g(n)=\\sum_{i=1}^n\\mu(i)t(i)f\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\ \u0026=\u0026\\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}t(j) g\\left(\\left\\lfloor\\frac{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}{j}\\right\\rfloor\\right)\\\\ \u0026=\u0026\\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}t(j) g\\left(\\left\\lfloor\\frac{n}{ij}\\right\\rfloor\\right)\\\\ \u0026=\u0026\\sum_{t=1}^n \\sum_{i=1}^n\\mu(i)t(i) \\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}[ij=t] t(j)g\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \u0026\u0026\\text{【先枚举 ij 乘积】}\\\\ \u0026=\u0026\\sum_{t=1}^n \\sum_{i|t}\\mu(i)t(i) t\\left(\\frac{t}{i}\\right)g\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \u0026\u0026\\text{【}\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}[ij=t] \\text{对答案的贡献为 1，于是省略】}\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \\sum_{i|t}\\mu(i)t(i)t\\left(\\frac{t}{i}\\right)\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right) \\sum_{i|t}\\mu(i)t(t) \u0026\u0026\\text{【t 是完全积性函数】}\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right)t(t) \\sum_{i|t}\\mu(i)\\\\ \u0026=\u0026\\sum_{t=1}^ng\\left(\\left\\lfloor\\frac{n}{t}\\right\\rfloor\\right)t(t) \\varepsilon(t) \u0026\u0026\\text{【}\\mu\\ast 1= \\varepsilon\\text{】}\\\\ \u0026=\u0026g(n)t(1) \u0026\u0026\\text{【当且仅当 t=1,}\\varepsilon(t)=1\\text{时】}\\\\ \u0026=\u0026g(n) \u0026\u0026 \\square \\end{eqnarray} $math_inline$ 解法二：\n转化一下，可以将式子写成\n$math_inline$ \\begin{eqnarray} \u0026\u0026\\sum_{d=1}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ijd\\cdot[gcd(i,j)=1]\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ij\\sum_{t\\mid gcd(i,j)}\\mu(t)\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ij\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(t)[t\\mid gcd(i,j)]\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\sum_{i=1}^{\\lfloor\\frac{n}{td}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{td}\\rfloor}ij[1\\mid gcd(i,j)]\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\sum_{i=1}^{\\lfloor\\frac{n}{td}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{td}\\rfloor}ij \\end{eqnarray} $math_inline$ 容易知道\n$math_inline$ \\sum_{i=1}^{n}\\sum_{j=1}^{m}ij=\\frac{n(n+1)}{2}\\cdot \\frac{m(m+1)}{2} $math_inline$ 设 $math_inline$sum(n,m)=\\sum_{i=1}^{n}\\sum_{j=1}^{m}ij$math_inline$ ，继续接着前面的往下推\n$math_inline$ \\begin{eqnarray} \u0026\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\sum_{i=1}^{\\lfloor\\frac{n}{td}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{td}\\rfloor}ij\\\\ \u0026=\u0026\\sum_{d=1}^{n}d\\sum_{t=1}^{\\lfloor\\frac{n}{d}\\rfloor}t^2 \\mu(t)\\cdot sum(\\lfloor\\frac{n}{td}\\rfloor,\\lfloor\\frac{m}{td}\\rfloor)\\\\ \u0026=\u0026\\sum_{t=1}^{n}sum(\\lfloor\\frac{n}{t}\\rfloor,\\lfloor\\frac{m}{t}\\rfloor)\\sum_{d\\mid t}d\\cdot (\\frac{t}{d})^2\\mu(\\frac{t}{d})\\\\ \u0026=\u0026\\sum_{t=1}^{n}sum(\\lfloor\\frac{n}{t}\\rfloor,\\lfloor\\frac{m}{t}\\rfloor)(t\\sum_{d\\mid t}d\\cdot\\mu(d)) \\end{eqnarray} $math_inline$ 这时我们只要对每个 $math_inline$t$math_inline$ 预处理出 $math_inline$t\\sum_{d\\mid t}d\\cdot\\mu(d)$math_inline$ 的值就行了，考虑如何快速求解\n设 $math_inline$f(n)=\\sum_{d\\mid n}d\\cdot\\mu(d)$math_inline$ 实际上 $math_inline$f$math_inline$ 可以用线性筛筛出，具体的是\n$math_inline$ f(n)= \\begin{cases} 1-n \u0026,n\\in primes \\\\ f(\\frac{x}{p}) \u0026,p^2\\mid n\\\\ f(\\frac{x}{p})\\cdot f(p) \u0026,p^2\\nmid n \\end{cases} $math_inline$ 其中 $math_inline$p$math_inline$ 表示 $math_inline$n$math_inline$ 的最小质因子\n总时间复杂度 $math_inline$o(n+\\sqrt{n})$math_inline$ 例题 「haoi 2011」problem b 「spoj 5971」lcmsum 「bzoj 2154」crash 的数字表格 「sdoi2015」约数个数和 「luogu 3768」简单的数学题 ","date":"2019-08-06","permalink":"https://blog.akvicor.com/posts/algorithm/mobius/","summary":"\u003cp\u003e莫比乌斯反演是数论中的重要内容，对于一些函数\n\n    \n        $math_inline$f(n)$math_inline$\n    \n\n，如果很难直接求出它的值，而容易求出其倍数和或约数和\n\n    \n        $math_inline$g(n)$math_inline$\n    \n\n，那么可以通过莫比乌斯反演简化运算，求得\n\n    \n        $math_inline$f(n)$math_inline$\n    \n\n的值。\u003c/p\u003e\n\u003cp\u003e开始学习莫比乌斯反演前我们需要一些前置知识：\u003cstrong\u003e积性函数、Dirichlet卷积、莫比乌斯函数\u003c/strong\u003e\u003c/p\u003e","title":"莫比乌斯反演"},{"content":" 威尔逊定理 欧拉定理（数论中的欧拉定理） 中国剩余定理（又称孙子定理） 费马小定理 相关定义 积性函数 积性函数：对于任意互质的整数 $math_inline$a$math_inline$ 和 $math_inline$b$math_inline$ 有性质 $math_inline$f(ab)=f(a)f(b)$math_inline$ 的数论函数\n完全积性函数：对于任意整数 $math_inline$a$math_inline$ 和 $math_inline$b$math_inline$ 有性质 $math_inline$f(ab)=f(a)f(b)$math_inline$ 的数论函数\n$math_inline$\\phi(n) \\quad - \\quad \\text{欧拉函数}$math_inline$ $math_inline$\\mu(n) \\quad - \\quad \\text{莫比乌斯函数，关于非平方数的质因子数目}$math_inline$ $math_inline$\\gcd(n,k) \\quad - \\quad \\text{最大公因子，当k固定的情况}$math_inline$ $math_inline$d(n) \\quad - \\quad \\text{n的正因子数目}$math_inline$ $math_inline$\\sigma(n) \\quad - \\quad \\text{n的所有正因子之和}$math_inline$ $math_inline$\\sigma k(n) \\quad - \\quad \\text{因子函数，n的所有正因子的k次幂之和，当中k可为任何复数。}$math_inline$ $math_inline$1(n) \\quad - \\quad \\text{不变的函数，定义为1(n)=1 （完全积性）}$math_inline$ $math_inline$id(n) \\quad - \\quad \\text{单位函数，定义为id(n)=n （完全积性）}$math_inline$ $math_inline$idk(n) \\quad - \\quad \\text{幂函数，对于任何复数、实数k，定义为}idk(n)=n^k \\text{（完全积性）}$math_inline$ $math_inline$\\epsilon(n) \\quad - \\quad \\text{定义为：若}n=1, \\epsilon(n)=1 \\text{；若}n\u003e1, \\epsilon(n)=0 \\text{分别称为“对于狄利克雷卷积的乘法单位” （完全积性）}$math_inline$ $math_inline$\\lambda(n) \\quad - \\quad \\text{刘维尔函数，关于能整数n的质因子的数目}$math_inline$ $math_inline$\\gamma(n) \\quad - \\quad \\text{定义为：} \\gamma(n)=(-1)^{\\omega(n)} \\text{，在次加性函数}\\omega(n)\\text{是不同能整除n的质数的数目}$math_inline$ $math_inline$\\text{另外，所有狄利克雷特征均是完全积性的}$math_inline$ 积性函数的性质\n性质一\n这和算数基本定理有关\n若将n表示成质因子分解式\n$math_inline$n=p_{1}^{a_1}p_{2}^{a_2}...p_{k}^{a_k}$math_inline$ 则有\n$math_inline$f(n)=f(p_{1}^{a_1})f(p_{2}^{a_2})...f(p_{k}^{a_k})$math_inline$ 性质二\n若f为积性函数且有 $math_inline$f(p^n)=f^n(p)$math_inline$ 则f为完全积性函数\n非积性函数\n冯·曼戈尔特函数：当n是质数p的整数幂， $math_inline$\\lambda(n)=\\ln(p)$math_inline$ ，否则 $math_inline$\\lambda(n)=0$math_inline$ 不大于正整数n的质数的数目 $math_inline$\\pi(n)$math_inline$ 整数拆分的数目 $math_inline$p(n)$math_inline$ ：一个整数能表示成正整数之和的方法的数目\n取余的性质 对于基本的四种运算而言，加减乘都符合“分配率”，唯独除法不满足。\n$math_inline$(a-b)\\%c = (a\\%c-b\\%c)\\%c$math_inline$ $math_inline$(a+b)\\%c = (a\\%c+b\\%c)\\%c$math_inline$ $math_inline$(a\\times b)\\%c = (a\\%c\\times b\\%c)\\%c$math_inline$ 如果要实现除法，那么必须把除法转换为乘法，假设 $math_inline$b^{-1}$math_inline$ 是 $math_inline$b$math_inline$ 关于 $math_inline$c$math_inline$ 的逆元。\n$math_inline$(a\\div b)\\%c 可以转化为 (a\\times b^{-1})\\%c = (a\\%c\\times b^{-1}\\%c)\\%c$math_inline$ 完全剩余系 完全剩余系： 从模n的每个剩余类中各取一个数，得到一个由n个数组成的集合，叫做模n的一个完全剩余系。完全剩余系常用于数论中存在性证明。\n在模n的剩余类中各取一个元素，则这n个数就构成了模n的一个完全剩余系。\n命n为一个自然数，a，b为整数。如果a-b为n的整数倍，则称a，b关于n同余，用同余式 $math_inline$a\\equiv b\\left(\\text{mod}n\\right)$math_inline$ 记之。否则称a，b关于n不同余，记为 $math_inline$a\\not\\equiv b\\left(\\text{mod}n\\right)$math_inline$ 。我们称n为同余式的模。同余式满足：\n反射性（reflection），即 $math_inline$a\\equiv a \\left(\\text{mod}n\\right)$math_inline$ 对称性（symmetry），即由 $math_inline$a\\equiv b\\left(\\text{mod}n\\right)$math_inline$ 可得 $math_inline$b\\equiv a\\left(\\text{mod}n\\right)$math_inline$ 传递性（transitivity），即由 $math_inline$a\\equiv b\\left(\\text{mod}n\\right)$math_inline$ , $math_inline$b\\equiv c\\left(\\text{mod}n\\right)$math_inline$ 可得 $math_inline$a\\equiv c\\left(\\text{mod}n\\right)$math_inline$ 因此，可以利用同余关系将整数分类，凡同余的数属于一个类，于是异类中的数皆不同余。共得到整数的n个类。在每一个类中各取一个数作为代表所成的集合称为模n的一个完全剩余系。\n举例\n取最小非负剩余为代表，则得完全剩余系{0,1,2,\u0026hellip;,n-1}。剩余类的代表相加得一数属于另一类，这个类仅与相加两数所在的类有关，而与代表的选取无关。于是，可以定义剩余类间的加法，以0所在的类o为单位元，则剩余类的全体关于加法构成一个交换群。当然在剩余类之间可以定义乘法。但关于除法就不一定可能，例如： $math_inline$3\\cdot 2\\equiv 1\\cdot 2\\left(\\text{mod}4\\right)$math_inline$ ， $math_inline$2\\equiv 2\\left(\\text{mod}4\\right)$math_inline$ ，但是 $math_inline$3\\not\\equiv 1 \\left(\\text{mod}4\\right)$math_inline$ 一个数除以4的余数只能是0，1，2，3，{0，1，2，3}和{4，5，-2，11}是模4的完全剩余系。可以看出0和4，1和5，2和-2，3和11模4同余，这4组数分别属于四个剩余类。\n性质\n(m,n)=1 -\u0026gt; m、n两个数的最大公约数是1\n对于n个整数，其构成模n的完全系等价于其关于模n两两不同余 若 $math_inline$a_i \\left(1\\leq i \\leq n\\right)$math_inline$ 构成模n的完系， $math_inline$k、m \\in z，\\left(m,n\\right)=1$math_inline$ ，则 $math_inline$k+ma_i\\left(1\\leq i \\leq n\\right)$math_inline$ 也构成模n的完系 若 $math_inline$a_i \\left(1\\leq i \\leq n\\right)$math_inline$ 构成模n的完系，则 $math_inline$\\sum_{i=1}^{n}a_i = \\frac{n\\left(n+1\\right)}{2}=\\lbrace ^{\\frac{n}{2}\\left(\\text{mod}n\\right)}_{0\\left(\\text{mod}n\\right)}$math_inline$ 剩余类 剩余类，亦称同余类，是一种数学的用语，为数论的基本概念之一。\n设模为n，则根据余数可将所有的整数分为n类，把所有与整数a模n同余的整数构成的集合叫做模n的一个剩余类，记做[a]。并把a叫做剩余类[a]的一个代表元。\n定义\n一个整数被正整数n除后，余数有n中情形：0，1，2，3，。。。，n-1，他们彼此对模n不同余。这表明，每个整数恰与这n个整数中的某一个对模n同余。这样一来，按模n是否同余对整数集进行分类，可以将整数集分成n个两两不相交的子集。我们把（所有）对模n同余的整数构成的一个集合叫做模n的一个剩余类。\n模m的剩余类具有以下性质\n每一个整数恰包含在某一个类 $math_inline$c_j$math_inline$ 里( $math_inline$0 \\leq j \\leq m-1$math_inline$ ) 两个整数x，y属于同一类的充分必要条件是 $math_inline$x\\equiv y\\left(\\text{mod} m\\right)$math_inline$ 剩余类与完全剩余类\n由此可引出抽象代数中的重要概念，如群论中的陪集，环论中的剩余类等。任取n，这n个数(o, 1, \u0026hellip;, n-1)称为模n的一个完全剩余类。每个数称为相应类的代表元。最常用的完全剩余系是{0, 1, \u0026hellip;, n-1}。\n若 $math_inline$n \\in z^{+}$math_inline$ ，则n个整数， $math_inline$r_0, r_1, ..., r_{n-1}$math_inline$ 构成一个完全剩余系数的充分必要条件是这n个除n的余数两两不相等。 若 $math_inline$n \\in z^{+}, k \\in z, \\left(k, n\\right)=1$math_inline$ ，当 $math_inline$x_1, x_2,..., x_n$math_inline$ 为完全剩余系时， $math_inline$kx_1+m, kx_2+m,..., kx_n+m$math_inline$ 也为完全剩余系数。 若 $math_inline$m,n \\in z^{+}, \\left(m, n\\right)=1$math_inline$ ，则当 $math_inline$a_0,a_1,...,a_{m-1},b_0,b_1,...,b_{n-1}$math_inline$ 是完全剩余系数时， $math_inline$na_i+mb_j\\left(i=0, 1,...,m-1;j=0,1,...,n-1\\right)$math_inline$ 也构成 $math_inline$m\\times n$math_inline$ 完全剩余系 剩余类与简化剩余类\n在剩余类选取一个与n互素代表元构成简化剩余类\n$math_inline$n \\in z^{+}, k \\in z, \\left(k, n\\right)=1$math_inline$ ，当 $math_inline$x_1, x_2,..., x_n$math_inline$ 为简化剩余系时， $math_inline$kx_1+m, kx_2+m,..., kx_n+m$math_inline$ 也为简化剩余系数。 若 $math_inline$m,n \\in z^{+}, \\left(m, n\\right)=1$math_inline$ ，则当 $math_inline$a_0,a_1,...,a_t,b_0,b_1,...,b_s$math_inline$ 是简化剩余系数时， $math_inline$na_i+mb_j\\left(i=0...t;j=0...s\\right)$math_inline$ 也构成 $math_inline$m\\times n$math_inline$ 完全剩余系 缩系 简化剩余系也称既约剩余系、缩系，是数学术语。\n**缩系的定义：**如果一个模m的剩余类里面的数与m互素（显然，只需有一个与m互素，其余的均与m互素）就把它叫做一个与模m互素的剩余类，在与模m互素的全部剩余类中，各取一数所组成的集叫做模m的一组简化剩余系\n若整数 $math_inline$a_1, a_2,..., a_m$math_inline$ 模n分别对应 $math_inline$0, 1, 2,..., n-1$math_inline$ 中所有m个与n互素的自然数，则称集合{ $math_inline$a_1, a_2,..., a_m$math_inline$ }为模n的一个缩系\n缩系的性质：\n对于任意的与n互质的正整数k，若{ $math_inline$a_1, a_2,..., a_m$math_inline$ }为模n的一个缩系，(k,n)=1，则{ $math_inline$k \\times a_1, k \\times a_2,..., k \\times a_m$math_inline$ }也为模n的一个缩系 $math_inline$\\left(k \\times a_1\\right)...\\left(k \\times a_1\\right) \\equiv a_1 \\times a_2...a_m\\left(\\text{mod}n\\right)$math_inline$ 威尔逊定理 欧拉定理 中国剩余定理 费马小定理 费马小定理(fermat\u0026rsquo;s little theorem)是数论中的一个重要定理，在1636年由 皮埃尔·德·费马 提出。如果p是一个质数，而 $math_inline$\\gcd(a,p)=1$math_inline$ (整数a不是p的倍数)，则有 $math_inline$a^{p-1}\\equiv 1\\text{mod}p$math_inline$ 根据费马小定理 $math_inline$a^{p-1}\\equiv 1\\text{mod}p$math_inline$ ，可以发现 $math_inline$a^{p-2} \\times a\\equiv 1\\text{mod}p$math_inline$ 也成立。可知 $math_inline$a^{p-2}$math_inline$ 是 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的逆元。所以求 $math_inline$a$math_inline$ 的逆元，就直接用快速幂求 $math_inline$a^{p-2}$math_inline$ 就可以\ncode ll power(ll a, int x) { ll ans = 1; while(x) { if(x\u0026amp;1) ans = (ans * a) %mod; a = (a * a) %mod; x \u0026gt;\u0026gt;= 1; } return ans; } ll inv(ll a) { return power(a, mod - 2); } 实际上，它是欧拉定理的一个特殊情况（即 $math_inline$a^{\\phi(p)}=q^{p-1}\\equiv 1(\\text{mod}p)$math_inline$ ）\n有些学家独立制作相关的假说（有时也被错误的称为中国的假说），当成立时，p是素数。这是费马小定理的一个特殊情况。然而，这一假说的前设是错误的：例如，341，而341=11*31是一个伪素数。所有的伪素数都是此假说的反例。\n如上所述，中国猜测仅有一半是正确的。符合中国猜测但不是素数的数被称为伪素数。\n更极端的反例是卡迈克尔数：假设a与561互质，则 $math_inline$a^{560}$math_inline$ 被561除都余1.这样的数被称为卡迈克尔数，561是最小的卡迈克尔数。\n验证推倒 引理1\n若a,b,c为任意三个整数，m为正整数，且(m,c)=1，则当 $math_inline$a\\cdot c\\equiv b\\cdot c(\\text{mod}m)$math_inline$ 时有 $math_inline$a\\equiv b(\\text{mod}m)$math_inline$ 证明： $math_inline$a\\cdot c\\equiv b\\cdot c(\\text{mod}m)$math_inline$ 可得 $math_inline$a\\cdot c - b\\cdot c\\equiv 0(\\text{mod}m)$math_inline$ 可得 $math_inline$(a - b)\\cdot c\\equiv 0(\\text{mod}m)$math_inline$ 。因为(m,c)=1即m,c互质，c可以约去， $math_inline$a - b \\equiv 0(\\text{mod}m)$math_inline$ 可得 $math_inline$a \\equiv b(\\text{mod}m)$math_inline$ 引理2\n设m是一个整数且m\u0026gt;1，b是一个整数且(m,b)=1。如果 $math_inline$a[1],a[2],a[3],a[4],...,a[m]$math_inline$ 是模m的一个完全剩余系，则 $math_inline$b\\cdot a[1],b\\cdot a[2],b\\cdot a[3],b\\cdot a[4],...,b\\cdot a[m]$math_inline$ 也构成模m的一个完全剩余系。\n证明：若存在2个整数 $math_inline$b\\cdot a[i]和b\\cdot [j]$math_inline$ 同余即 $math_inline$b\\cdot a[i] \\equiv b\\cdot a[j](\\text{mod}m)\\quad (i\\geq 1 \\\u0026\\\u0026 j\\geq 1)$math_inline$ ，根据引理1则有 $math_inline$a[i]\\equiv a[j](\\text{mod}m)$math_inline$ 。根据完全剩余系的定义可知这是不可能的，因此不存在两个整数 $math_inline$b\\cdot a[i]和b\\cdot [j]$math_inline$ 同余。\n所以 $math_inline$b\\cdot a[1],b\\cdot a[2],b\\cdot a[3],b\\cdot a[4],...,b\\cdot a[m]$math_inline$ 构成模m的一个完全剩余系。\n构造素数 $math_inline$p$math_inline$ 的完全剩余系 $math_inline$p= \\lbrace 1,2,3,...,p-1 \\rbrace$math_inline$ 因为 $math_inline$(a,p)=1$math_inline$ ，由引理2可得 $math_inline$a = \\lbrace a,2a,3a,...,(p-1)a \\rbrace$math_inline$ 也是 $math_inline$p$math_inline$ 的一个完全剩余系。由完全剩余系的性质， $math_inline$1 \\times 2 \\times 3 \\times ... \\times(p-1) \\equiv a,2a,3a,...,(p-1)a (\\text{mod}p)$math_inline$ 即 $math_inline$(p-1)! \\equiv (p-1)! \\cdot a^{p-1} (\\text{mod}p)$math_inline$ 易知 $math_inline$((p-1)!,p)=1$math_inline$ ，同余式两边可约去 $math_inline$(p-1)!$math_inline$ ，得到 $math_inline$a^{p-1}\\equiv 1(\\text{mod}p)$math_inline$ 应用 计算 $math_inline$2^{100}$math_inline$ 除以13的余数\n$math_inline$2^{100} \\equiv 2^{12\\times 8 + 4}(\\text{mod}13)$math_inline$ $math_inline$\\equiv (2^{12})^8\\cdot 2^4(\\text{mod}13)$math_inline$ $math_inline$\\equiv 1^8\\cdot 16(\\text{mod}13)$math_inline$ $math_inline$\\equiv 16(\\text{mod}13)$math_inline$ $math_inline$\\equiv 3(\\text{mod}13)$math_inline$ 故余数为3\n证明对于任意整数a而言， $math_inline$a^{13}-a$math_inline$ 恒为2730的倍数。13-1为12，12的正因数有1，2，3，4，6，12，分别加1，为2，3，4，5，7，13，其中2，3，5，7，13为质数，根据定理 $math_inline$a^{13}-a$math_inline$ 为2的倍数、为3的倍数、为5的倍数、为7的倍数、为13的倍数，即 $math_inline$2\\times 3\\times 5\\times 7\\times 13=2730$math_inline$ 的倍数。\n\u0026gt;\u0026gt;\u0026gt; n =221 \u0026gt;\u0026gt;\u0026gt; a = 38 \u0026gt;\u0026gt;\u0026gt; pow(a ,n -1,n) 1 \u0026#34;\u0026#34;\u0026#34;221 may be a prime number.\u0026#34;\u0026#34;\u0026#34; import random def isprime(n,k=128): if n\u0026lt;2: return false for _ in range(k): a = random.randrange(1,n) if pow(a,n-1,n)!=1: return false return true ","date":"2019-08-02","permalink":"https://blog.akvicor.com/posts/algorithm/wilson_euler_chinese_remainder_fermat_little/","summary":"\u003cul\u003e\n\u003cli\u003e威尔逊定理\u003c/li\u003e\n\u003cli\u003e欧拉定理（数论中的欧拉定理）\u003c/li\u003e\n\u003cli\u003e中国剩余定理（又称孙子定理）\u003c/li\u003e\n\u003cli\u003e费马小定理\u003c/li\u003e\n\u003c/ul\u003e","title":"初等数论四大定理"},{"content":" 乘法逆元 乘法逆元 对于缩系中的元素，每个数a均有唯一的与之对应的乘法逆元x，使得 $math_inline$ax\\equiv 1\\left(\\text{mod}n\\right)$math_inline$ ，一个数有逆元的充分必要条件是gcd(a,n)=1，此时逆元唯一存在\n在一般数学中，我们所说的逆元就是倒数，但是在数论中，如果一个数字a存在一个对p的逆元x，就可以写成 $math_inline$ax\\equiv 1\\left(\\text{mod}p\\right)$math_inline$ 的形式(此处p与a互质，若不互质，则不存在逆元)\n逆元的含义：模n意义下，1个数a如果有逆元x，那么除以a相当于乘以x。\n满足 $math_inline$a \\times k\\equiv 1(\\text{mod}p)的k值就是a关于p的乘法逆元$math_inline$ 当我们要求 $math_inline$\\frac{a}{b}\\text{mod}p$math_inline$ 的值时，我们就可以用到乘法逆元。我们可以用过求b关于p的乘法逆元k，将a乘上k再模p，即 $math_inline$(a \\times k)\\text{mod}p$math_inline$ 。其结果与 $math_inline$\\frac{a}{b}\\text{mod}p$math_inline$ 等价\n证明 根据 $math_inline$b \\times k\\equiv 1(\\text{mod}p)$math_inline$ 有 $math_inline$b \\times k=p \\times x+1$math_inline$ $math_inline$k=\\frac{p \\times x+1}{b}$math_inline$ 把k带入 $math_inline$(a \\times k)\\text{mod}p$math_inline$ 得\n$math_inline$(\\frac{a \\times (p \\times x+1)}{b})\\text{mod}p$math_inline$ $math_inline$=(\\frac{a \\times p \\times x}{b}+\\frac{a}{b})\\text{mod}p$math_inline$ $math_inline$=[(\\frac{a \\times p \\times x}{b}\\text{mod}p)+\\frac{a}{b}]\\text{mod}p$math_inline$ $math_inline$=[(\\frac{p \\times (a \\times x)}{b}\\text{mod}p)+\\frac{a}{b}]\\text{mod}p$math_inline$ $math_inline$//p \\times [\\frac{a \\times x}{b}]\\text{mod}p=0$math_inline$ 所以原式等于： $math_inline$\\frac{a}{b}\\text{mod}p$math_inline$ 拓展欧几里得 **拓展欧几里得:** $math_inline$ax+by=\\gcd(a,b)$math_inline$ 的解一定存在\n当我们要求 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的逆元时，若逆元存在，则 $math_inline$\\gcd(a,p)=1$math_inline$ 。假设逆元为 $math_inline$x$math_inline$ ，即： $math_inline$ax \\equiv 1(\\text{mod}p)$math_inline$ 我们可以展开一下变成 $math_inline$ax=1+pk$math_inline$ ，由于 $math_inline$k$math_inline$ 可正可负，我们可以得到 $math_inline$ax+pk=1$math_inline$ ，其实就是 $math_inline$ax+by=\\gcd(a,b)$math_inline$ 。\n我们用拓展欧几里得求出一个最小的x就是 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的一个逆元。\n求解：\n现在我们已经有了 $math_inline$ax+by=\\gcd(a,b)$math_inline$ 了。我们想试着求出一个特解 $math_inline$x$math_inline$ 。\n根据欧几里得算法我们可以知道 $math_inline$\\gcd(a,b)=\\gcd(b,a\\%b)$math_inline$ 。\n而且我们可以看出 $math_inline$bx+(a\\%b)y = \\gcd(b,\\%b)$math_inline$ 由此我们可得：(由于两边 $math_inline$x$math_inline$ , $math_inline$y$math_inline$ 值不用，我们用 $math_inline$x'$math_inline$ 和 $math_inline$y'$math_inline$ 进行区分)\n$math_inline$bx'+(a\\%b)y'=ax+by$math_inline$ 我们想要把式子简化一下，可以从 $math_inline$a\\%b$math_inline$ 入手，即 $math_inline$a\\%b=a-\\lfloor \\frac{a}{b} \\rfloor\\times b$math_inline$ 。\n所以我们可以化简得到 $math_inline$ax+by=bx'+(a-\\lfloor \\frac{a}{b} \\rfloor\\times b)y'$math_inline$ 移项： $math_inline$ax+by=ay'+b(x'-\\lfloor \\frac{a}{b} \\rfloor y')$math_inline$ 系数相等，所以我们可以解得\n$math_inline$ \\begin{equation} \\left\\{ \\begin{array}{lr} x=y' \u0026 \\\\ y=(x'-\\lfloor \\frac{a}{b} \\rfloor y') \u0026 \\end{array} \\right. \\end{equation} $math_inline$ 根据欧几里得算法，我们一直递归下去，总会到 $math_inline$a\\%b=0$math_inline$ 所以式子变成了 $math_inline$ax=\\gcd(a,b)$math_inline$ 。此时我们取一个特解 $math_inline$x=1,y=0$math_inline$ 。然后往回推，就可以得到一开始的那个x。\n此时解出来的 $math_inline$x$math_inline$ 就是 $math_inline$a$math_inline$ 关于 $math_inline$p$math_inline$ 的一个逆元。\nps：算法效率较高，常数较小，时间复杂度 $math_inline$o(\\ln{n})$math_inline$ code void exgcd(ll a, ll b, ll \u0026amp;x, ll \u0026amp;y) { if (b == 0) { x = 1;y = 0; } else { exgcd(b, a%b, y, x); y -= (a/b) * x; } } void extgcd(ll a, ll b, ll \u0026amp;d, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { d = a; x = 1; y = 0; } else { extgcd(b, a % b, d, y, x); y -= x * (a / b); } } ll inverse(ll a, ll n) { ll d, x, y; extgcd(a, n, d, x, y); return d == 1 ? (x + n) % n : -1; } 递推求阶乘逆元 我们经常会用到阶乘的逆元，我们可以考虑用费马小定理先求出最大的那个阶乘的逆元，然后再往回推\n我们可以把 $math_inline$n!$math_inline$ 的逆元表示为 $math_inline$\\left[n!\\right]^{-1}$math_inline$ 。\n我们要求 $math_inline$(n-1)!$math_inline$ 的逆元，我们可以考虑给 $math_inline$(n-1)!$math_inline$ 乘上一个 $math_inline$n$math_inline$ 把他变为 $math_inline$n!$math_inline$ 。\n即 $math_inline$(n-1)!\\times n\\left[n!\\right]^{-1} \\equiv 1\\text{mod}p$math_inline$ 因此 $math_inline$\\left[n!\\right]^{-1}$math_inline$ 是 $math_inline$(n-1)!$math_inline$ 关于 $math_inline$p$math_inline$ 的一个逆元。\ncode void init() { fact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } } 费马小定理 在模为素数p的情况下，有费马小定理 $math_inline$a^{p-1}\\equiv 1(\\text{mod}p)$math_inline$ ，（左右同除a）得 $math_inline$a^{p-2}=a^{-1}(\\text{mod}p)$math_inline$ ，也就是说a的逆元为 $math_inline$a^{p-2}$math_inline$ 符号解释 既约 $math_inline$\\perp$math_inline$ ， $math_inline$a\\perp m$math_inline$ ，a与m既约、不可约、互素：\n既约，或称不可约，或称互质，或称互素，a,m既约，记做 $math_inline$a \\perp m$math_inline$ 或 $math_inline$(a,m)=1$math_inline$ 即a,m二者的最大公约数为1，已经约去公因子到不可再约了。\n而在模数不为素数p得情况下，有欧拉定理 $math_inline$a^{phi(m)}\\equiv q (\\text{mod}m)\\quad(a \\perp m)$math_inline$ 同理 $math_inline$a^{-1}=a^{phi(m)-1}$math_inline$ 因此逆元x便可以套用快速幂求得了 $math_inline$x=a^{phi(m)-1}$math_inline$ 如何判断a是否有逆元？检验逆元的性质，看求出的幂值x与a相乘是否为1即可\nps：这种算法复杂度为 $math_inline$o(\\log_2(n))$math_inline$ 在几次测试中，常数似乎较上种方法大\n当p比较大的时候需要用快速幂求解\ncode ll pow_mod(ll x, ll n, ll mod) { ll res = 1; while (n \u0026gt; 0) { if (n \u0026amp; 1)res = res * x % mod; x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } 当模p不是素数的时候需要用到欧拉定理\n$math_inline$a^{phi(p)}\\equiv 1 \\quad (\\text{mod}p)$math_inline$ $math_inline$a \\times a^{phi(p)-1}\\equiv 1 \\quad (\\text{mod}p)$math_inline$ $math_inline$a^{-1}\\equiv a^{phi(p)-1} \\quad (\\text{mod}p)$math_inline$ 所以时间复杂度即求出单个欧拉函数的值\n(当p为素数的时候 $math_inline$phi(p)=p-1$math_inline$ ，则 $math_inline$phi(p)-1=p-2$math_inline$ 可以看出欧拉定理是费马小定理的推广)\nps：这里就贴出欧拉定理的板子，很少会用欧拉定理求逆元\n特殊情况 一 当n是质数，这点也很好理解。当n是质数， $math_inline$0","date":"2019-08-01","permalink":"https://blog.akvicor.com/posts/algorithm/factorial_inverse/","summary":"\u003cul\u003e\n\u003cli\u003e乘法逆元\u003c/li\u003e\n\u003c/ul\u003e","title":"逆元的求法（欧拉定理、阶乘逆元、费马小定理、模质数p的情况）"},{"content":" 最大流 最小费用最大流 最大流 引入 假设你所在的村庄开通了地下流水管道，自来水厂源源不断的提供水，村民们用水直接或间接用水，而村庄用完的废水统一回收于另一点（设从自来水厂流出的水全部回收）。当然每个管道有一定的容量，求出废水站最多可以汇聚多少水。\n概念 **容量：**每条边都有一个容量（水管的最大水流容量） **源点：**出发点（水厂） **汇点：**结束点（废水站） **流：**一个合法解称作一个流，也就是一条可以从源点到汇点的一条合法路径。 **流量：**每条边各自被经过的次数称作其流量，最终收集的总数为整个流的流量。\n限制 **容量限制：**每条边的流量不超过其容量（水管会爆炸） **流量平衡：**对于除源点和汇点以外的点来说，其流入量一定等于流出量。\n解决 现在我们简化一下这个图，来解决这个问题。\nx/y表示总流量为y，已经流了x\n首先我们会想到找随即路径，然而如果走到如上图所示。\n当走完 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 我们就找不到其他路径了，那么答案为1吗？不，答案为2.\n那么现在我们改进算法，给流过的路径建立反向边\n这样就给了一个反悔的机会。\n定义一跳变得残量为：容量-已流过的流量\n反向边的流量值=正向流过的总流量，也就是说正向流过多少，反向就可以流回多少。\n从而我们又找到 1-\u0026gt;3-\u0026gt;2-\u0026gt;4 的一条路径\n再次建路径上的反向边，我们发现没有路径可以到达4点，所以答案为2.\n小结 在图上找到一条从源点到汇点的路径（称为“增广路”） 去增广路上的残量最小值v（也就是流过的路径中流量最小的那一个） 将答案加上v 将增广路上所有边的残量减去v，反向边的残量加上v 重复上边四个步骤直到找不到增广路为止，这称作 ff 方法\n首先这个算法必定不会死循环，因为每次增广都会导致流量增加（并且增加的是整数），而且流量有一个客观存在的最大值，所以它必定结束。\n由于我们并没有指定它走那一条边，所以优先考虑随便走一条边。\n考虑一种极限的情况：\n现增广 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 会出现一条 3-\u0026gt;2 容量为1的边。\n再增广 1-\u0026gt;3-\u0026gt;2-\u0026gt;4 ，再增广 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 \u0026hellip;\n浪费大量的时间，如果脸黑的话最多2e5次\n然而我们如果先 1-\u0026gt;2-\u0026gt;4 然后 1-\u0026gt;3-\u0026gt;4 走两次就好了。\n上面的做法是我们不期望的。我们可以考虑每次增广最短路 （ek算法）\nek算法 ek算法是以上算法的实现：每次寻找最短路进行增广。\n时间复杂度 $math_inline$o(m^2n)$math_inline$ 结构体储存三个变量 next to dis 【邻接表建边】\nflow[i]：表示流过i点的v值，也就是说目前经过到i点的路径上的最小的残量。\ndis[i]：表示i点距离源点的距离，s，t表示源点以及汇点\n首先我们利用bfs处理图的连通性以及所有点于源点的距离，当然，当这条边上的残量已经为0的时候，我们认为它已经不能经过，我们可以直接不考虑。\n在bfs中国呢pre数组是记录每个点最短路的前驱，last数组记录上条边的编号，从而记录出最短路径，然后从汇点进行更新即可。\ncode bool bfs(int s,int t) { memset(flow,0x7f,sizeof(flow)); memset(dis,0x7f,sizeof(dis)); memset(vis,0,sizeof(vis)); q.push(s);vis[s]=1;dis[s]=0,pre[t]=-1; while(!q.empty()) { int temp=q.front(); q.pop(); vis[temp]=0; for(int i=head[temp];i!=-1;i=edge[i].nxt) { int v=edge[i].to; if(edge[i].flow\u0026gt;0\u0026amp;\u0026amp;dis[v]\u0026gt;dis[temp]+edge[i].dis) { dis[v]=dis[temp]+edge[i].dis; pre[v]=temp; last[v]=i; flow[v]=min(flow[temp],edge[i].flow); if(!vis[v]) { vis[v]=1; q.push(v); } } } } return pre[t]!=-1; } 从汇点向前更新\ncode while(bfs(s,t)) { int now=t; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; while(now!=s) { edge[last[now]].flow-=flow[t]; edge[last[now]^1].flow+=flow[t]; now=pre[now]; } } 最大流最小割定理 什么是割？\n比如：你的仇人是一个工厂老板。你要炸掉一些车，让他每个货物都运不到销售点。炸掉越大的车，你越容易被发现。你希望炸掉的车的容量之和尽量小，最小化这个值\n选出一些边的集合，使得删除他们之后从源点无法到达汇点，那么这个集合就叫做一个割。这些边的容量之和叫做这个割的容量\n**定理1:**任取一个割，其容量大于最大流的流量\n从源点汇点每次都会经过割上的最少一条边。\n割掉这条边以后，把源点能到达的边放在左边，不能到达的放在右边。\n显然源点到汇点的流量不会超过从左边走向右边的次数，而这又不会超过从左边到右边的容量之和\n**直观一点：**假设你是在车装着货物的时候炸掉了它。\n每个货物你至少付出1的代价炸掉（流量小于容量的时候你要付出比货物数更多的代价），所以你炸的代价不会小于货物数\n定理2: 最小割的容量大于最大流的流量，且ff方法能够正确的求出它。\n这意味着一个惊人的事实：你能够仅付出和货物数相同的代价，就把你的仇人的财路炸断\n考虑ff算法结束时，残量网络上没有了增广路\n那么我们假设这个时候，从源点经过残量网络能达到的点组成的集合为x，不能达到的点为y。显然汇点在y例，并且残量网络上没有从x到y的边。\n可以发现以下事实成立：\ny到x的边流量为0，如果流量不为0，那么应该存在一条从x到y的反向边，于是矛盾 x到y的边流量等于其容量。只有这样它才不会在残量网络中出现 根据第一个条件，我们可以得知：没有流量从过年x到y之后又回到x，所以当前流量应该等于x到y的边的流量之和，根据第二个条件它又等于从x到y的边容量之和，而所有从x到y的边又构成一个割，其容量等于这些边的容量之和。\n这意味着我们找到一个流和一个割，使得前者的流量等于后者的容量。\n而根据前面的结论，最大流的流量不会超过这个割的容量，所以这个流一定是最大流。\n荣养的，最小割的容量也不会小于这个流的流量，所以这个割也一定是最小割。\n这就是ff法最后的局面（由于ff会终止，所以它必定求出这样一个局面），由此我们得出：ff是正确的，并且最大流等于最小割\nek优化-dinic ek时间复杂度太高，虽然大多数情况跑不到上界。\n有一个显然的优化：\n如果增广一次后发现最短路没有变化，那么可以继续增广，直到源点到汇点的增广路增大，才需要一遍bfs。\nbfs之后我们除去那些可能在最短路上的边，即dis[终点]=dis[起点]+1的那些边\n显然这些边构成的图中没有环，我们只需要沿这些边尽可能的增广即可\ncode int bfs() { memset(dis,-1,sizeof(dis)); dis[s]=0; q.push(s); while(!q.empty()) { int u=q.front(); q.pop() ; for(int i=head[u];i!=-1;i=edge[i].nxt) { int v=edge[i].to; if(dis[v]==-1\u0026amp;\u0026amp;edge[i].w\u0026gt;0) { dis[v]=dis[u]+1; //更新 q.push(v); } } } return dis[t]!=-1; //判断是否联通。 } 当图连通时进行dfs，当前节点为u，每次经过与u距离最近的点，并且这条边的残量值要大于0，然后往后进行dfs。\n我们在dfs时要加一个变量，作为流量控制（最后的流量不能超过前边流量的最小值）\ndfs中变量flow记录这条管道之后的最大流量\ncode bool dfs(int u,int exp) { if(u==t)return exp; //到达重点，全部接受。 int flow=0,tmp=0; for(int i=head[u];i!=-1;i=edge[i].nxt) { int v=edge[i].to; //下一个点。 if(dis[v]==dis[u]+1\u0026amp;\u0026amp;edge[i].w\u0026gt;0) { tmp=dfs(v,min(exp,edge[i].w)); //往下进行 if(!tmp)continue; exp-=tmp; //流量限制-流量，后边有判断。 flow+=tmp; edge[i].w-=tmp; //路径上的边残量减少 edge[i^1].w+=tmp; //流经的边的反向边残量增加。 if(!exp)break; //判断是否在限制边缘 } } return flow; } 重复上边如果图连通（有最短路径），就一直增广\nwhile(bfs())ans+=dfs(s,inf);\n时间复杂度 $math_inline$o(n^2m)$math_inline$ 在某些特殊情况下（每个点要么只有一条入边且容量为1，要么仅有一条出边且容量为1）其时间复杂度甚至能做到 $math_inline$o(m\\sqrt(n))$math_inline$ template 最大流模版 - 链式前向星存图 struct flow_dinic { flow_dinic(int n) { head = vector\u0026lt;int\u0026gt;(n + 10, -1); level = vector\u0026lt;int\u0026gt;(n + 10); } struct edge { int to, cap, next; }; vector\u0026lt;int\u0026gt; head; vector\u0026lt;int\u0026gt; level; int s = 0, t = 0; // max_flow from s to t vector\u0026lt;struct edge\u0026gt; edge; void add_edge(int u, int v, int c) { edge.push_back((struct edge) {v, c, head[u]}); head[u] = edge.size() - 1; edge.push_back((struct edge) {u, 0, head[v]}); head[v] = edge.size() - 1; } bool bfs() { fill(level.begin(), level.end(), 0); level[s] = 1; queue\u0026lt;int\u0026gt; que; que.push(s); while (!que.empty()) { for (int i = head[que.front()]; ~i; i = edge[i].next) { if (edge[i].cap \u0026amp;\u0026amp; !level[edge[i].to]) { level[edge[i].to] = level[que.front()] + 1; que.push(edge[i].to); if (edge[i].to == t) return true; } } que.pop(); } return false; } int dfs(int f, int u) { if (u == t) return f; int d = 0, used = 0; for (int i = head[u]; ~i; i = edge[i].next) { if (edge[i].cap \u0026amp;\u0026amp; level[u] == level[edge[i].to] - 1) { if ((d = dfs(min(f - used, edge[i].cap), edge[i].to))) { edge[i].cap -= d; edge[i ^ 1].cap += d; used += d; } } } if (!used) level[u] = 0; return used; } long long run(int _s, int _t) { s = _s; t = _t; long long max_flow = 0; while (bfs()) { int d = 0; while ((d = dfs(0x3f3f3f3f, s))) max_flow += d; } return max_flow; } }; 最大流模版 - fast - 邻接表存图 struct dinic { dinic(int n) { g = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 10); d = vector\u0026lt;int\u0026gt; (n+10); vis = vector\u0026lt;bool\u0026gt; (n+10); cur = vector\u0026lt;int\u0026gt; (n+10); } struct edge { int from, to, cap, flow; }; int s, t; //节点数,边数,源点编号,汇点编号 vector\u0026lt;edge\u0026gt; edges; //边表,edges[e]和edges[e^1]互为反向弧 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; //邻接表,g[i][j]表示节点i的第j条边在e中的序号 vector\u0026lt;bool\u0026gt; vis; //bfs用 vector\u0026lt;int\u0026gt; d; //从起点到i的距离 vector\u0026lt;int\u0026gt; cur; //当前弧下标 void add_edge(int from, int to, int cap) { edges.push_back({from, to, cap, 0}); edges.push_back({to, from, 0, 0}); g[from].push_back(edges.size() - 2); g[to].push_back(edges.size() - 1); } bool bfs() { fill(vis.begin(), vis.end(), false); queue\u0026lt;int\u0026gt; q; q.push(s); d[s] = 0; vis[s] = true; while (!q.empty()) { for (int id : g[q.front()]) { edge \u0026amp;e = edges[id]; if (!vis[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; e.flow) { vis[e.to] = true; d[e.to] = d[q.front()] + 1; q.push(e.to); } } q.pop(); } return vis[t]; } long long dfs(int u, int a) { if (u == t || a == 0) return a; int flow = 0, f; for (int \u0026amp;i = cur[u]; i \u0026lt; (int) g[u].size(); ++i) { edge \u0026amp;e = edges[g[u][i]]; if (d[u] + 1 == d[e.to] \u0026amp;\u0026amp; (f = dfs(e.to, min(a, e.cap - e.flow))) \u0026gt; 0) { e.flow += f; edges[g[u][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow; } long long run(int _s, int _t) { s = _s; t = _t; long long flow = 0; while (bfs()) { fill(cur.begin(), cur.end(), 0); flow += dfs(s, 0x3f3f3f3f); } return flow; } }; 最小费用最大流","date":"2019-07-28","permalink":"https://blog.akvicor.com/posts/algorithm/flow/","summary":"\u003col\u003e\n\u003cli\u003e最大流\u003c/li\u003e\n\u003cli\u003e最小费用最大流\u003c/li\u003e\n\u003c/ol\u003e","title":"网络流"},{"content":"前向星是一种特殊的边集数组中的每一条边按照起点从小到大排序，如果起点相同就按终点从小到大排序，并记录下某个点为起点的所有边在数组中的起始位置和存储长度，那么前向星就构造好了。\n用len[i]来记录所有以i为起点的边在数组中的存储长度 用head[i]来记录以i为边集在数组中的第一个位置 我们输入的边的顺序为\n1 2 2 3 3 4 1 3 4 1 1 5 4 5 排序后就得到\n编号： 1 2 3 4 5 6 7 起点u： 1 1 1 2 3 4 4 终点v： 2 3 5 3 4 1 5 得到\nhead[1] = 1 len[1] = 3 head[2] = 4 len[2] = 1 head[3] = 5 len[3] = 1 head[4] = 6 len[4] = 2 但是利用前向星会有排序操作，如果用快排时间复杂度至少为 o(nlogn)\n如果用链式前向星，就可以避免排序\n我们建立边结构体为\nstruct edge{ int next; // 与第i条边同起点的下一条边的存储位置 int to; // 表示第i条边的终点 int w; // 边的权值 }; 另外还有一个head[]，它用来表示以i为起点的第一条边存储的位置，实际上你会发现这里的第一条边存储的位置其实在以i为起点的所有边的最后输入的那个编号。\nhead[]一般初始化为-1，对于加边的add函数是这样的\nvoid add(int u, int v, int w){ edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++; } 初始化 cnt = 0 ，来模拟一下\nedge[0].to = 2; edge[0].next = -1; head[1] = 0; edge[1].to = 3; edge[1].next = -1; head[2] = 1; edge[2].to = 4; edge[2].next = -1; head[3] = 2; edge[3].to = 3; edge[3].next = 0; head[1] = 3; edge[4].to = 1; edge[4].next = -1; head[4] = 4; edge[5].to = 5; edge[5].next = 3; head[1] = 5; edge[6].to = 5; edge[6].next = 4; head[4] = 6; 很明显，head[i]保存的是以i为起点的所有边中编号最大的那个，而把这个当作顶点i的第一条起始边的位置。\n这样在遍历时是倒着遍历的，也就是说与输入顺序是相反的，不过这样不影响结果的正确性。\n比如以上图为例，以节点1为起点的边有3条，他们的编号分别是0，3，5 而 head[i] = 5\n我们在遍历以u家电为起始位置的所有边的时候是这样的\nfor(int i = head[u]; ~i; i = edge[i].next) 那么就说先遍历编号为5的边，也就是head[1]，然后就是edge[5].next，也就是编号3的边，然后继续edge[3].next也就是编号0的边，可以看出是逆序的。\n","date":"2019-07-26","permalink":"https://blog.akvicor.com/posts/algorithm/chain_forward_star/","summary":"\u003cp\u003e前向星是一种特殊的边集数组中的每一条边按照起点从小到大排序，如果起点相同就按终点从小到大排序，并记录下某个点为起点的所有边在数组中的起始位置和存储长度，那么前向星就构造好了。\u003c/p\u003e","title":"链式前向星"},{"content":" 最大矩阵 最大正方形 最大子矩阵和 最大矩阵 code - 存到了队列里，可以求第k大 /** * author: akvicor * created: 2019-07-21 21-00-00 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define pb(x) push_back(x) #define mp(x, y) make_pair(x, y) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1010); int mp[maxn][maxn], l[maxn], r[maxn]; priority_queue \u0026lt;int\u0026gt; ans; void solve(){ fast_io; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; loop(i, 1, n) loop(j, 1, m){ char c; cin \u0026gt;\u0026gt; c; mp[i][j] = (c == \u0026#39;1\u0026#39;); } loop(i, 2, n) loop(j, 1, m) if(mp[i-1][j] \u0026amp;\u0026amp; mp[i][j]) mp[i][j] += mp[i-1][j]; loop(i, 1, n){ set\u0026lt;pair\u0026lt;int, pii\u0026gt; \u0026gt; s; stack\u0026lt;int\u0026gt; a, b; loop(j, 1, m){ while(!a.empty() \u0026amp;\u0026amp; mp[i][a.top()] \u0026gt;= mp[i][j]) a.pop(); l[j] = a.size() ? a.top()+1 : 1; a.push(j); } for(int j = m; j \u0026gt;= 1; --j){ while(!b.empty() \u0026amp;\u0026amp; mp[i][b.top()] \u0026gt;= mp[i][j]) b.pop(); r[j] = b.size() ? b.top() - 1 : m; b.push(j); } loop(j, 1, m){ if(mp[i][j]){ pair\u0026lt;int, pii\u0026gt; temp = mp(r[j], mp(l[j], mp[i][j])); pair\u0026lt;int ,pii\u0026gt; temp2; if(!s.count(temp)){ ans.push((r[j] - l[j]+1)*mp[i][j]); s.insert(temp); } if(r[j] - l[j]){ temp = mp(r[j], mp(l[j]+1, mp[i][j])); temp2 = mp(r[j]-1, mp(l[j], mp[i][j])); if(!s.count(temp)){ ans.push((r[j] - l[j]) * mp[i][j]); s.insert(temp); }else if(s.count(temp2)){ ans.push((r[j]-l[j])*mp[i][j]); s.insert(temp2); } } } } } if(ans.size()\u0026lt;2) ans.push(0); ans.pop(); cout \u0026lt;\u0026lt; ans.top() \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; while (true) { debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;--\u0026#34; \u0026lt;\u0026lt; endl; if (cin.eof()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; #endif return 0; } code - 速度更快，但只能求前几大 /** * author: akvicor * created: 2019-07-23 08-52-07 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #ifdef debug #define fast_io 17 #else #define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define endl \u0026#39;\\n\u0026#39; #endif #define rep(i, n) for(int i = 0; i \u0026lt; (n); ++i) #define reep(i, n) for(int i = 0; i \u0026lt;= (n); ++i) #define lop(i, a, n) for(int i = a; i \u0026lt; (n); ++i) #define loop(i, a, n) for(int i = a; i \u0026lt;= (n); ++i) #define per(i, a, n) for(int i = a; i \u0026gt;= (n); --i) #define prec(x) fixed \u0026lt;\u0026lt; setprecision(x) #define ms(s, n) memset(s, n, sizeof(s)) #define all(v) (v).begin(), (v).end() #define sz(x) ((int)(x).size()) #define mp(x, y) make_pair(x, y) #define pb(x) push_back(x) #define fi first #define se second #define mod(x) const int mod = (int)x #define maxn(x) const int maxn = (int)x + 10 typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;pii\u0026gt; vii; namespace sol{ const double eps = 1e-6; const double pi = acos(-1.0); const int inf = 0x3f3f3f3f; const ll linf = 0x7f7f7f7f7f7f7f7f; /** \u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt; **/ mod(1e9+7); maxn(1e3); int n, m; string s; int high[maxn]; int mxx, mxx2; int stkhg[maxn], stkpos[maxn]; int cnt; void solve(){ fast_io; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; high[m+1] = 0; loop(i, 1, n){ cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;-- line #\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; --\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; s; loop(j, 1, m) high[j] = s[j-1]==\u0026#39;0\u0026#39; ? 0 : high[j]+1; #ifdef debug cout \u0026lt;\u0026lt; \u0026#34;str: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;high: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; high[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; #endif stkhg[0] = stkpos[0] = cnt = 0; loop(j, 1, m+1){ if(high[j] \u0026gt; stkhg[cnt]){ // 如果比上一格高，说明可以构成矩形，就push进栈 stkhg[++cnt] = high[j]; stkpos[cnt] = j; }else if(high[j] \u0026lt; stkhg[cnt]){ // 如果比上一格矮， // 那么高度等于上一格高度的矩形已经完全找出来了， // 当前格比上一格矮，不能参与构成上个矩形 while(high[j] \u0026lt; stkhg[cnt]){ // 将栈中高于当前位置的高度全部出栈 int area = (j-stkpos[cnt]) * stkhg[cnt]; // 当前位置坐标-比当前格高的格的坐标就是宽度 // 更新前两大矩形 if(area \u0026gt;= mxx){ mxx2 = mxx; mxx = area; mxx2 = max(mxx2, max(area-stkhg[cnt], area-(j-stkpos[j]))); }else if(area \u0026gt; mxx2){ mxx2 = area; } --cnt; } if(stkhg[cnt] != high[j]){ stkhg[++cnt] = high[j]; } } #ifdef debug cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkhg: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkhg[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; stkpos: \u0026#34;; loop(j, 1, m+1) cout \u0026lt;\u0026lt; stkpos[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mxx: \u0026#34; \u0026lt;\u0026lt; mxx \u0026lt;\u0026lt; \u0026#34; mxx2: \u0026#34; \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; #endif } } cout \u0026lt;\u0026lt; mxx2 \u0026lt;\u0026lt; endl; } /** \u0026gt;----------------------------------\u0026lt; **/ } int main(){ #ifdef debug int debugcnt = 0; clock_t debugstart, debugfinish; double debugduration; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;\u0026gt;------- akvicor\u0026#39;s solution -------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; while (debugcnt \u0026lt; 70) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; debugstart = clock(); #endif sol::solve(); #ifdef debug debugfinish = clock(); debugduration = (double)(debugfinish - debugstart)*1000 / clocks_per_sec; cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;---\u0026gt; test: #\u0026#34; \u0026lt;\u0026lt; debugcnt \u0026lt;\u0026lt; \u0026#34; time: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(4) \u0026lt;\u0026lt; debugduration \u0026lt;\u0026lt; \u0026#34; ms \u0026lt;---\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; if (cin.eof()) break; if (!cin.good()) break; if (cin.fail()) break; if (cin.bad()) break; ++debugcnt; } cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;----------------------------------\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; #endif return 0; } ","date":"2019-07-22","permalink":"https://blog.akvicor.com/posts/algorithm/maximum_submatrix/","summary":"\u003col\u003e\n\u003cli\u003e最大矩阵\u003c/li\u003e\n\u003cli\u003e最大正方形\u003c/li\u003e\n\u003cli\u003e最大子矩阵和\u003c/li\u003e\n\u003c/ol\u003e","title":"最大子矩阵"},{"content":"如果一个平面中有n条直线，最多能将平面划分成多少区域。\n当1条线时 2个平面\n当2条线时 4个平面（交叉1根线等多出2个平面）\n当3条线时 7个平面 (交叉2根线等多出3个平面)\n当4条线时 11个平面 (交叉3根线等多出4个平面)\n\u0026hellip;..\n其实已经可以递推了，前n项和\n$math_inline$f(n)=\\frac{n*(n+1)}{2}+1$math_inline$ while(cin\u0026gt;\u0026gt;n) cout\u0026lt;\u0026lt;n*(n+1)/2+1\u0026lt;\u0026lt;endl; ","date":"2019-05-31","permalink":"https://blog.akvicor.com/posts/algorithm/lines_dividing_planes/","summary":"\u003cp\u003e如果一个平面中有n条直线，最多能将平面划分成多少区域。\u003c/p\u003e","title":"直线划分平面"},{"content":"如何判断两条直线是否相交？\n这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。\n但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？\n这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。\n问题分析 对于“判断两条直线是否相交”这个问题，我们之所以能迅速而准确地进行判断，是因为“相交”与“不相交”这两个状态有着明显的不同点，即斜率是否相等。\n那么现在，为了判断两条线段是否相交，我们也要找出“相交”与“不相交”这两个状态的不同点。\n假设现在有两条线段 ab 和 cd，我们画出它们之间的三种关系：\n其中，情况 1 为不相交，情况 2、3 为相交。\n作出向量 ac、ad、bc、bd。\n首先介绍一个概念： 向量有序对的旋转方向。这个概念指：对于共起点有序向量二元组(a, b)，其旋转方向为 使 a 能够旋转一个小于 180 度的角并与 b 重合的方向，简记为 direct(a, b)。若 a 和 b 反向共线，则旋转方向取任意值。\n举个例子：图一中，direct(ac, ad) 为顺时针方向。\n接下来我们要分析四个值：direct(ac, ad)、direct(bc, bd)、direct(ca, cb)、direct(da, db)。\n对于图一，direct(ac, ad) 和 direct(bc, bd) 都为顺时针，direct(ca, cb) 为逆时针，direct(da, db) 为顺时针。\n对于图二，direct(ac, ad) 为顺时针，direct(bc, bd) 为任意方向，direct(ca, cb) 为逆时针，direct(da, db) 为顺时针。\n对于图三，direct(ac, ad)、direct(da, db) 为顺时针，direct(bc, bd)、direct(ca, cb) 为逆时针。\n不难发现，两条线段相交的充要条件是：direct(ac, ad) != direct(bc, bd) 且 direct(ca, cb) != direct(da, db)。这便是“相交”与“不相交”这两个状态的不同点。\n然而你可能会觉得：旋转方向这么一个虚无飘渺的东西，怎么用程序去描述啊？\n再来看一幅图：\n再来定义有向角：\n有向角 \u0026lt;a, b\u0026gt; 为向量 a 逆时针旋转到与向量 b 重合所经过的角度。\n不难看出，对于向量 a、b：\n若 direct(a, b) 为逆时针，则 0 \u0026lt;= \u0026lt;a, b\u0026gt; \u0026lt;= 180，从而 sin\u0026lt;a, b\u0026gt; \u0026gt;= 0。\n若 direct(a, b) 为顺时针，则 180 \u0026lt;= \u0026lt;a, b\u0026gt; \u0026lt;= 360，从而 sin\u0026lt;a, b\u0026gt; \u0026lt;= 0。\n这样一来，我们可以将旋转方向的问题转化为 求有向角正弦值 的问题。而这个问题，是很容易的。\n如上图，记\n$math_inline$oa=(x_1,y_1),ob=(x_2,y_2)$math_inline$ $math_inline$|oa|=r_1, |ob|=r_2$math_inline$ 则： $math_inline$sin()$math_inline$ $math_inline$=\\sin\\theta$math_inline$ $math_inline$=\\sin(\\alpha-\\beta)$math_inline$ $math_inline$=\\sin\\alpha\\cos\\beta-\\sin\\beta\\cos\\alpha$math_inline$ $math_inline$=\\frac{(\\sin\\alpha\\cos\\beta-\\sin\\beta\\cos\\alpha)r_1\\cdot r_2}{r_1\\cdot r_2}$math_inline$ $math_inline$=\\frac{x_1 \\cdot y_2-x_2 \\cdot y_1}{r_1 \\cdot r_2}$math_inline$ 而这里，我们要的只是 sin(\u0026lt;oa, ob\u0026gt;) 的符号，而 r1 和 r2 又都是恒正的，因此只需判断 x1 * y2 - x2 * y1 的符号即可。\n这个方法的数学背景是 叉乘，可以前往 wikipedia 了解更多。\n思路小结 由点 a，b，c，d 计算出向量 ac，ad，bc，bd\n计算 sin(\u0026lt;ac, ad\u0026gt;) * sin(\u0026lt;bc, bd\u0026gt;) 和 sin(\u0026lt;ca, cb\u0026gt;) * sin(\u0026lt;da, db\u0026gt;)，若皆为非正数，则相交；否则，不相交。\n实现 # 点 class point(object): def __init__(self, x, y): self.x, self.y = x, y # 向量 class vector(object): def __init__(self, start_point, end_point): self.start, self.end = start_point, end_point self.x = end_point.x - start_point.x self.y = end_point.y - start_point.y zero = 1e-9 def negative(vector): \u0026#34;\u0026#34;\u0026#34;取反\u0026#34;\u0026#34;\u0026#34; return vector(vector.end_point, vector.start_point) def vector_product(vectora, vectorb): \u0026#39;\u0026#39;\u0026#39;计算 x_1 * y_2 - x_2 * y_1\u0026#39;\u0026#39;\u0026#39; return vectora.x * vectorb.y - vectorb.x * vectora.y def is_intersected(a, b, c, d): \u0026#39;\u0026#39;\u0026#39;a, b, c, d 为 point 类型\u0026#39;\u0026#39;\u0026#39; ac = vector(a, c) ad = vector(a, d) bc = vector(b, c) bd = vector(b, d) ca = negative(ac) cb = negative(bc) da = negative(ad) db = negative(bd) return (vector_product(ac, ad) * vector_product(bc, bd) \u0026lt;= zero) \\ and (vector_product(ca, cb) * vector_product(da, db) \u0026lt;= zero) ","date":"2019-05-29","permalink":"https://blog.akvicor.com/posts/algorithm/line_intersect/","summary":"\u003cp\u003e如何判断两条直线是否相交？\u003c/p\u003e\n\u003cp\u003e这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。\u003c/p\u003e\n\u003cp\u003e但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？\u003c/p\u003e\n\u003cp\u003e这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。\u003c/p\u003e","title":"判断两个线段相交"},{"content":"所谓素数，是指恰好有两个约数的正整数。\n埃氏筛法 区间筛法 miller-rabin素性测试 判定单一的一个数是不是素数，素性测试：\ncode bool is_prime(int n){ /* 判定一个数是不是素数 ，假设输入的数都是正整数 */ for (int i = 2; i * i \u0026lt;= n; i++) { if (!(n % i)) return false; } return n != 1; /* 1是例外 */ } 如果只对一个数进行素数测试，通常 $math_inline$o(\\sqrt{n})$math_inline$ 的算法就足够了。但\u0026hellip;\u0026hellip;..\nmiller-rabin素性测试 引理1(费马定理) 设p是素数，a为整数，且(a,p)=1，则 $math_inline$a^{p-1} \\equiv 1(\\text{mod}p)$math_inline$ 。\n引理2(二次探测定理) 如果p是一个素数，且 $math_inline$0","date":"2019-05-28","permalink":"https://blog.akvicor.com/posts/algorithm/prime/","summary":"\u003cp\u003e所谓素数，是指恰好有两个约数的正整数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e埃氏筛法\u003c/li\u003e\n\u003cli\u003e区间筛法\u003c/li\u003e\n\u003cli\u003eMiller-Rabin素性测试\u003c/li\u003e\n\u003c/ul\u003e","title":"素数判定"},{"content":"线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（range minimum/maximum query problem）或者区间异或值的查询。\n对应于树状数组，线段树进行更新（update）的操作为o(logn)，进行区间查询（range query）的操作也为o(logn)。\n实现原理 从数据结构的角度来说，线段树是用一个完全二叉树来存储对应于其每一个区间（segment）的数据。该二叉树的每一个结点中保存着相对应于这一个区间的信息。同时，线段树所使用的这个二叉树是用一个数组保存的，与堆（heap）的实现方式相同。\n例如，给定一个长度为n的数组arr，其所对应的线段树t各个结点的含义如下：\nt的根结点代表整个数组所在的区间对应的信息，及arr[0:n]（不含n）所对应的信息。 t的每一个叶结点存储对应于输入数组的每一个单个元素构成的区间arr[i]所对应的信息，此处 $math_inline$0≤i","date":"2019-05-28","permalink":"https://blog.akvicor.com/posts/algorithm/segment_tree/","summary":"\u003cp\u003e线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。\u003c/p\u003e\n\u003cp\u003e对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。\u003c/p\u003e","title":"线段树"},{"content":"求取数组中最大连续子序列和，例如给定数组为a={1， 3， -2， 4， -5}， 则最大连续子序列和为 $math_inline$6$math_inline$ ，即 $math_inline$1+3+(-2)+4=6$math_inline$ 。\n方法一共有三种，复杂度分别为 $math_inline$o(n^2)$math_inline$ 、 $math_inline$o(nlgn)$math_inline$ 、 $math_inline$o(n)$math_inline$ 解法1 - 暴力 - $math_inline$o(n^2)$math_inline$ 因为最大连续子序列和只可能从数组0到n-1中的某个位置，我们可以遍历0到n-1个位置，计算由这个位置开始的所有连续子序列和中的最大值。最终求出最大值即可。\n更详细的讲，就是计算从位置0开始的最大连续子序列和，从位置1开始的最大连续子序列和。。。直到从位置n-1开始的最大连续子序列和，最后求出所有这些连续子序列和中的最大值就是答案。\nint maxsequence(int arr[], int len) { int max = arr[0]; for (int i=0; i\u0026lt;len; i++) { int sum = 0; for (int j=i; j\u0026lt;len; j++) { sum += arr[j]; if (sum \u0026gt; max) max = sum; } } return max; } 解法2 - 分治 - $math_inline$o(nlgn)$math_inline$ 运用分治的思想来求解，最大连续子序列和要么出现在数组左半部分，要么出现在数组右半部分，要么横跨左右两个部分。因此求出这三种情况下的最大值就可以得到最大连续子序列和。\n/*求三个数最大值*/ int max3(int i, int j, int k) { if (i\u0026gt;=j \u0026amp;\u0026amp; i\u0026gt;=k) return i; return max3(j, k, i); } int maxsequence2(int a[], int l, int u) { if (l \u0026gt; u) return 0; if (l == u) return a[l]; int m = (l + u) / 2; /*求横跨左右的最大连续子序列左半部分*/ int lmax=a[m], lsum=0; for (int i=m; i\u0026gt;=l; i--) { lsum += a[i]; if (lsum \u0026gt; lmax) lmax = lsum; } /*求横跨左右的最大连续子序列右半部分*/ int rmax=a[m+1], rsum = 0; for (int i=m+1; i\u0026lt;=u; i++) { rsum += a[i]; if (rsum \u0026gt; rmax) rmax = rsum; } return max3(lmax+rmax, maxsequence2(a, l, m), maxsequence2(a, m+1, u)); //返回三者最大值 } 解法3 - $math_inline$o(n)$math_inline$ 因为最大连续子序列和只可能是以位置0～n-1中某个位置结尾。当遍历到第i个元素时，判断在它前面的连续子序列和是否大于0，如果大于0，则以位置i结尾的最大连续子序列和为元素i和前面的连续子序列和想加；否则，则以位置i结尾的最大连续子序列和为元素i。\nint maxsequence3(int a[], int len) { int maxsum, maxhere; maxsum = maxhere = a[0]; //初始化最大和为a【0】 for (int i=1; i\u0026lt;len; i++) { if (maxhere \u0026lt;= 0) maxhere = a[i]; //如果前面位置最大连续子序列和小于等于0，则以当前位置i结尾的最大连续子序列和为a[i] else maxhere += a[i]; //如果前面位置最大连续子序列和大于0，则以当前位置i结尾的最大连续子序列和为它们两者之和 if (maxhere \u0026gt; maxsum) { maxsum = maxhere; //更新最大连续子序列和 } } return maxsum; } ","date":"2019-05-27","permalink":"https://blog.akvicor.com/posts/algorithm/maximum_slice/","summary":"\u003cp\u003e求取数组中最大连续子序列和，例如给定数组为A={1， 3， -2， 4， -5}， 则最大连续子序列和为\n\n    \n        $math_inline$6$math_inline$\n    \n\n，即 \n\n    \n        $math_inline$1+3+(-2)+4=6$math_inline$\n    \n\n 。\u003c/p\u003e\n\u003cp\u003e方法一共有三种，复杂度分别为 \n\n    \n        $math_inline$O(N^2)$math_inline$\n    \n\n、\n\n    \n        $math_inline$O(NlgN)$math_inline$\n    \n\n、\n\n    \n        $math_inline$O(N)$math_inline$\n    \n\n\u003c/p\u003e","title":"最大子列和问题"},{"content":"每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的质因数。如果一个质数是某个数的因数，那么就说这个质数是这个数的质因数。而这个因数一定是一个质数。\n把一个合数用质因数相乘的形式表示出来，叫做分解质因数。如30=2×3×5 。分解质因数只针对合数。\n质数： 质数（prime number）又称素数，有无限个。\n质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。\n合数： 合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。与之相对的是质数，而1既不属于质数也不属于合数。最小的合数是4。其中，完全数与相亲数是以它为基础的。\n定义 质因数（或质因子）在数论里是指能整除给定正整数的质数。两个没有共同质因子的正整数成为互质。因为1没有质因子，所以1与任何正整数（包括自身）都是质数。正整数的因数分解可将正整数表示为一连串的质因子相乘，质因子如重复可以质数表示。根据算数基本定理，任何正整数皆有独一无二的质因子分解式。只有一个质因子的正整数为质数。\n把一个合数分解成若干个质因数的乘积的形式，即求质因数的过程叫做分解质因数。\n分解质因数只针对合数。（分解质因数也称分解素因数）求一个数分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式叫短除法，和除法的性质差不多，还可以用来求多个个数的公因式。\n例子 1没有质因子 5只有1个质因子，5本身。（5是质数） 6的质因子是2和3（6=2*3） 2、4、8、16等只有一个质因子：2（2是质数， $math_inline$4=2^2$math_inline$ ， $math_inline$8=2^3$math_inline$ ，如此类推） 10有两个质因子：2和5.（10=2*5） 就是一个数的约数，并且是质数，比如 $math_inline$8=2 * 2 * 2$math_inline$ ，2就是8的质因数。 $math_inline$12=2 * 2 * 3$math_inline$ ，2和3就是12的质因数。把一个式子以 $math_inline$12=2 * 2 * 3$math_inline$ 的形式表示，叫做分解质因数。 $math_inline$16=2 * 2 * 2 * 2$math_inline$ ，2就是16的质因数，把一个合数写成几个质数相乘的形式表示，这也是分解质因数。\n分解质因数的方法是先用一个合数的最小质因数去除这个合数，得出的数若是一个质数，就写成这个合数相乘形式；若是一个合数就继续按照原来的方法，直至最后是一个质数。\n分解质因数有两种方法表示，除了大家最长知道的“短除法”之外，还有一种方法就是“塔形分解法”。\n分解质因数对解决一些自然数和乘积的问题有很大的帮助，同时又为最大公约数和最小公倍数做了重要铺垫。\n计算方法 短除法 求一个数的分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式叫短除法，和除法性质差不多，还可以用来求多个个数的公因式：\n求最大公因数的一种方法，也可以用来求最小公倍数。\n求几个数最大公因数的方法，开始时用观察比较的方法，即：先把每个数的因数找出来，然后再找出公因数，最后在公因数中找出最大公因数。\n例如：求12与18的最大公因数。\n12的因数有：1、2、3、4、6、12 18的因数有：1、2、3、6、9、18 12与18的公因数有：1、2、3、6 12与18的最大公因数是6 这两种方法对求两个以上数的最大公因数，特别是数目较大的数，显然是不方便的。于是又采用了给每个数分别分解质因数的方法。\n$math_inline$12=2 * 2 * 3$math_inline$ $math_inline$18=2 * 3 * 3$math_inline$ 12与18都可以分成几种形式不同的乘积，但分解质因数连乘积就只有以上一种，而且不能再分解了。所分出的质因数无疑都能整除原数，因此这些质因数也都是原数的约数。从分解的结果来看，12与18都有公约数2和3，而他们的乘积2*3=6，就是12与18的最大公约数。\n采用分解质因数的方法，也就是采用短除的形式，只不过是分别短除，然后再找公约数和最大公约数。如果吧这两个数合在一起短除，则更容易找出公约数和最大公约数。\n从短除中不难看出，12和18都有公约数2和3，他们的乘积2*3=6就是12与18的最大公约数。与前边分别分解质因数相比较，可以发现：不仅结果相同，而且短除法竖式左边就是这两个数的公共质因数，而两个数的最大公约数，就是这两个数的公共质因数的连乘积。\n实际应用中，是吧需要计算的两个或多个数放置在一起，进行短除。\n在计算多个数的最小公倍数时，对其中任意两个数存在的约数都要算出，其它无此约束的数则原样落下。最后把所有约数和最终剩下无法约分的数连乘即得到最小公倍数。\n只含有一个质因数的数一定是亏数。（在数论中，若一个正整数除了本身之外所有因子之和比此数自身小，则称此数为亏数（又称作缺数）。）\n短除法详解：\n短除富豪就是除号倒过来。短除就是在除法中写余数的地方写两个数共有的质因数，然后落下两个数被共有质因数整除的商，之后再除，以此类推，直到结果互质为止（两个数互质）\n而在用短除法计算多个数时，对其中任意两个数存在的因数都要算出，其它没有这个因数的数则原样落下。直到剩下每两个数都是互质关系。\n求最大公因数遍乘一边，求最小公倍数遍乘一圈。\n在用短除计算多个数时，对其中任意两个数存在的因数都要算出，其它没有这个因数的数则原样落下。直到剩下每两个都是互质关系。**求最大公约数遍乘左边所有数公共的因数，求最小公倍数遍乘一圈。**这种方法对求两个以上数的最大公因数，特别是数目较大的数，显然是不方便的。于是又采用了给每个数分别分解质因数的方法。\npollard rho因数分解 1975年，john m. pollard提出了第二种因数分解的方法，pollard rho快速因数分解。该算法时间复杂度为 $math_inline$o(n^{(1/4)})$math_inline$ 。\n将一个正整数分解质因数。例如：输入90，打印出 $math_inline$90=2 * 3 * 3 * 5$math_inline$ 。 程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：\n如果这个质数恰好等于n，则说明分解质因数的过程已经结束，打印出即可。 如果n\u0026lt;\u0026gt;，但n能被k整除，则应打印出k的值，并用n除以k的商，作为新的正整数n，重复执行第一步。 如果n不能被k整除，则用k+1作为k的值，重复执行第一步。 //将一个数n分解为若干个从小到大排列的质数的积 void f1(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; = \u0026#34;; int n2 = n; if (n \u0026lt; 2) { cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; endl; } //小于2的数不合法，若n为质数则输出它本身 for (int i = 2; i * i \u0026lt;= n2; i++) { //根号n复杂度 while (n2 % i == 0) { n2 = n2 / i; cout \u0026lt;\u0026lt; i; if (n2 != 1) cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; } } if (n2 != 1) cout \u0026lt;\u0026lt; n2; //当n为质数 cout \u0026lt;\u0026lt; endl; } void f2(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; = \u0026#34;; for (int i = 2; i \u0026lt;= n; i++) { while (n != i) { if (n % i == 0) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;*\u0026#39;; n = n / i; } else break; } } cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } void f3(ll n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;=\u0026#39;; int flag = 0; for (ll i = 2; i * i \u0026lt;= n; i++) { while (n % i == 0) { n = n / i; if (!flag) cout \u0026lt;\u0026lt; i; else cout \u0026lt;\u0026lt; \u0026#39;*\u0026#39; \u0026lt;\u0026lt; i; flag |= 1; } } if (n != 1 \u0026amp;\u0026amp; !flag) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; else if (n != 1 \u0026amp;\u0026amp; flag) cout \u0026lt;\u0026lt; \u0026#39;*\u0026#39; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; endl; } 另外代码：\n我们用所有正整数试验一下，从2开始进行拭除，逐步增加除数的值，去寻找一个可以整除n的数。在eratosthenes筛法的讨论中，我们知道如果n是一个复合数，那么它就会有一个素数 $math_inline$p\\leq\\sqrt{n}$math_inline$ 。\n这个算法有两个循环路径，内部的和外部的。外部循环求唯一因数，内部循环求一个因数的多个复本。例如： $math_inline$24=2^3\\times3$math_inline$ ，外部循环求出因数2和3.内部循环求出2是一个多因数。\nvoid trial_divisio_fac(int n) { int a = 2; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;= \u0026#34;; while (a * a \u0026lt;= n) { while (n % a == 0) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;*\u0026#39;; n = n / a; } a++; } if (n \u0026gt; 1) cout \u0026lt;\u0026lt; n;//n没有因数 cout \u0026lt;\u0026lt; endl; } 上面的代码解释比较清楚。为什么这种方法可以得到素数。\n因为我们在内层循环中，已经把当前a的所有倍数都去除了。这跟埃斯托尼算法一样的。\n如果整数较小，这种情况下拭除法通常都是很有效的，但是如果用来分解更大的整数，拭除法就变得非常低效甚至不可用了。这种算法的复杂度是随着n的增加呈指数级别增长的。\n拭除法是整数分解算法中最简单和最容易理解的算法。\n给定一个合数n（这里，n是待分解的整数），拭除法看成是用小于等于 $math_inline$\\sqrt{n}$math_inline$ 的每个素数去拭除待分解的整数。如果找到一个数能够整除除尽，这个数就是待分解整数的因子。\n运用拭除法求1233的因数\n$math_inline$1233=3^2 * 137$math_inline$","date":"2019-05-26","permalink":"https://blog.akvicor.com/posts/algorithm/integer_factorization/","summary":"\u003cp\u003e每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的质因数。如果一个质数是某个数的因数，那么就说这个质数是这个数的质因数。而这个因数一定是一个质数。\u003c/p\u003e\n\u003cp\u003e把一个合数用质因数相乘的形式表示出来，叫做分解质因数。如30=2×3×5 。分解质因数只针对合数。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e质数：\u003c/strong\u003e\n质数（prime number）又称素数，有无限个。\u003c/p\u003e\n\u003cp\u003e质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e合数：\u003c/strong\u003e\n合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。与之相对的是质数，而1既不属于质数也不属于合数。最小的合数是4。其中，完全数与相亲数是以它为基础的。\u003c/p\u003e","title":"分解质因数"},{"content":"约数个数定理可以计算出一个数约数的个数\n约数个数定理 对于一个大于1正整数n可以分解质因数： $math_inline$f(n)=\\prod^k_{i=1}{p_i}^{a_i}={p_1}^{a_1}\\cdot{p_2}^{a_2}\\cdot...\\cdot{p_k}^{a_k}$math_inline$ 则n的正约数的个数就是 $math_inline$f(n)=\\prod^k_{i=1}(a_i+1)=(a_1+1)+(a_2+1)..(a_k+1)$math_inline$ 。\n其中 $math_inline$a_1、a_2、a_3...a_k$math_inline$ 是 $math_inline$p_1、p_2、p_3，p_k$math_inline$ 的指数。\n定理简证 首先同上，n可以分解质因数 $math_inline$n={p_1}^{a_1}\\times{p_2}^{a_2}\\times ... \\times{p_k}^{a_k}$math_inline$ ,\n由约数定义可知 $math_inline${p_1}^{a_1}$math_inline$ 的约数有: $math_inline${p_1}^0, {p_1}^1, {p_1}^2......{p_1}^{a_1}$math_inline$ ，共 $math_inline$(a_1+1)$math_inline$ 个;同理 $math_inline${p_2}^{a_2}$math_inline$ 的约数有 $math_inline$(a_2+1)$math_inline$ 个\u0026hellip;\u0026hellip; $math_inline${p_k}^{a_k}$math_inline$ 的约数有 $math_inline$(a_k+1)$math_inline$ 个。\n故根据乘法原理：n的约数的个数就是 $math_inline$(a_1+1)(a_2+1)(a_3+1)…(a_k+1)$math_inline$ 。\n例 例：正整数378000共有多少个正约数？\n解：将378000分解质因数 $math_inline$378000=2^4×3^3×5^3×7^1$math_inline$ 由约数个数定理可知378000共有正约数 $math_inline$(4+1)×(3+1)×(3+1)×(1+1)=160$math_inline$ 个。\n实现 int f1(int n) { int r = (int) sqrt(1.0 * n); int sum = 0; if (r * r == n) { sum++; r--; } for (int i = 1; i \u0026lt;= r; i++) if (n % i == 0) { sum += 2; } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } // 稍快于f1 int f2(int n){ int s = 1, r; for (int i = 2; i * i \u0026lt;= n; i++) { r = 0; while (n % i == 0) { r++; n /= i; } if (r \u0026gt; 0) { r++; s *= r; } } if (n \u0026gt; 1) s *= 2; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } ll f3(ll n) { ll res=1; for(ll i=2;i*i\u0026lt;=n;i++){ ll k=0; while(n%i == 0){ n = n/i; k++; } if(k) res *= (k+1); } if(n != 1) res=res*2; if(res==1){ if(n==1) return 1; else return 2; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } 约数和定理 对于一个大于1正整数n可以分解质因数： $math_inline$n={p_1}^{a_1}\\cdot{p_2}^{a_2}\\cdot...\\cdot{p_k}^{a_k}$math_inline$ 则由约数个数定理可知n的正约数有 $math_inline$(a_i+1)(a_2+1)(a_3+1)$math_inline$ 个，那么n的 $math_inline$(a_i+1)(a_2+1)(a_3+1)$math_inline$ 个正约数的和为\n$math_inline$f(n)=(p_1^0+p_1^1+p_1^2+...+p_1^{a_1})(p_2^0+p_2^1+p_2^2+...++p_2^{a_2})...(p_k^0+p_k^1+p_k^2+...++p_k^{a_k})$math_inline$ 定理证明 若n可以分解质因数： $math_inline$n=p_1^{a_1}*p_2^{a_2}*p_3^{a_3}*...*p_k^{a_k}$math_inline$ 可知 $math_inline$p_1^{a_1}$math_inline$ 的约数有： $math_inline$p_1^0,p_1^1,p_1^2,...,p_1^{a_1}$math_inline$ \u0026hellip;.\n同理可知， $math_inline$p_k^{a_k}$math_inline$ 的约数有： $math_inline$p_k^0,p_k^1,p_k^2,...,p_k^{a_k}$math_inline$ 实际上n的约数是在 $math_inline$p_1^{a_1}、p_2^{a_2}、p_3^{a_3}、...、p_k^{a_k}$math_inline$ 每一个的约数中分别挑一个相乘得来，可知共有 $math_inline$(a_1+1)(a_2+1)(a_3+1)...(a_k+1)$math_inline$ 种挑法，即约数的个数。\n由乘法原理可知它们的和为\n$math_inline$f(n)=(p_1^0+p_1^1+p_1^2+...+p_1^{a_1})(p_2^0+p_2^1+p_2^2+...+p_2^{a_2})...(p_k^0+p_k^1+p_k^2+...+p_k^{a_k})$math_inline$ 例 例：正整数360的所有正约数的和是多少？\n解：\n将360分解质因数可得 $math_inline$360=2^3 * 3^2 * 5^1$math_inline$ 由约数和定理可知，360所有正约数的和为\n$math_inline$(2^0+2^1+2^2+2^3)×(3^0+3^1+3^2)×(5^0+5^1)=(1+2+4+8)(1+3+9)(1+5)=15×13×6=1170$math_inline$ 可知360的约数有：\n$math_inline$1、2、3、4、5、6、8、9、10、12、15、18、20、24、30、36、40、45、60、72、90、120、180、360$math_inline$ 则它们的和为：\n$math_inline$1+2+3+4+5+6+8+9+10+12+15+18+20+24+30+36+40+45+60+72+90+120+180+360=1170$math_inline$ 实现 ll qpow(ll x, ll y) { ll res = 1; while (y) { if (y \u0026amp; 1) res *= x; x *= x; y \u0026gt;\u0026gt;= 1; } return res; } ll getsum(ll n) {//返回n的约数和是多少. ll res = 1; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) { n = n / i; k++; } res *= ((1 - qpow(i, k + 1)) / (1 - i)); } //用等比数列公式(快速幂)算. if (n != 1) res *= (1 + n); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } 题目 求正约数应用例题hihocoder – 1284\n直接暴力肯定不行, 所以想到求他们的约数, 则n的约数*m的约数/gcd(n,m)的约数就是答案. 求约数用以上定理.\nll getnum(ll n) { //得到a的约数个数. ll res = 1; for (ll i = 2; i * i \u0026lt;= n; i++) { ll k = 0; while (n % i == 0) { n = n / i; k++; } if (k) res *= (k + 1); } if (n != 1) res = res * 2; //最后一个素数. if (res == 1) { //本身就是素数或1. if (n == 1) return 1; else return 2; } return res; } void solve(ll n, ll m) { ll k = __gcd(m, n); ll num1 = getnum(n); ll num2 = getnum(m); ll num3 = getnum(k); ll t = __gcd(num3, num1 * num2); printf(\u0026#34;%lld %lld\\n\u0026#34;, 1ll * num1 * num2 / t, 1ll * num3 / t); } ","date":"2019-05-26","permalink":"https://blog.akvicor.com/posts/algorithm/sum_of_the_positive_divisors/","summary":"\u003cp\u003e约数个数定理可以计算出一个数约数的个数\u003c/p\u003e","title":"约数定理（约数个数定理，约束和定理）"},{"content":"在运算过程中如果运算结果很大，普通的数据类型无法储存，就需要用到所谓的高精度算法，即用数组来存储整数，并模拟手算的方式进行四则运算。\nfirst code #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct biginteger { static const int base = 100000000; static const int width = 8; vector\u0026lt;int\u0026gt; s; biginteger(long long num = 0) { *this = num; } biginteger\u0026amp; operator = (long long num) { s.clear(); do { s.push_back(num % base); num /= base; } while (num \u0026gt; 0); return *this; } biginteger\u0026amp; operator = (const string\u0026amp; str) { s.clear(); int x, len = (str.length() - 1) / width + 1; for(int i = 0; i \u0026lt; len; ++i){ int end = str.length() - i * width; int start = max(0, end - width); sscanf(str.substr(start, end-start).c_str(), \u0026#34;%d\u0026#34;, \u0026amp;x); s.push_back(x); } return *this; } friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;out, const biginteger\u0026amp; x){ out \u0026lt;\u0026lt; x.s.back(); for(int i = x.s.size()-2; i \u0026gt;= 0; --i){ char buf[20]; sprintf(buf, \u0026#34;%08d\u0026#34;, x.s[i]); for(int j = 0; j \u0026lt; strlen(buf); ++j) out \u0026lt;\u0026lt; buf[j]; } return out; } friend istream\u0026amp; operator \u0026gt;\u0026gt; (istream \u0026amp;in, biginteger\u0026amp; x){ string st; if(!(in \u0026gt;\u0026gt; st)) return in; x = st; return in; } biginteger operator + (const biginteger\u0026amp; b) const{ biginteger c; c.s.clear(); for(int i = 0, g = 0; ; ++i){ if(g==0 \u0026amp;\u0026amp; i\u0026gt;=s.size() \u0026amp;\u0026amp; i\u0026gt;=b.s.size()) break; int x = g; if(i \u0026lt; s.size()) x += s[i]; if(i \u0026lt; b.s.size()) x += b.s[i]; c.s.push_back(x % base); g = x / base; } return c; } biginteger operator += (const biginteger\u0026amp; b){ *this = *this + b; return *this; } bool operator \u0026lt; (const biginteger\u0026amp; b) const { if(s.size() != b.s.size()) return s.size() \u0026lt; b.s.size(); for(int i = s.size()-1; i \u0026gt;= 0; --i) if(s[i] != b.s[i]) return s[i] \u0026lt; b.s[i]; return false; } bool operator \u0026gt; (const biginteger\u0026amp; b) const { return b \u0026lt; *this; } bool operator \u0026lt;= (const biginteger\u0026amp; b) const { return !(b \u0026lt; *this); } bool operator \u0026gt;= (const biginteger\u0026amp; b) const { return !(*this \u0026lt; b); } bool operator != (const biginteger\u0026amp; b) const { return b \u0026lt; *this || *this \u0026lt; b; } bool operator == (const biginteger\u0026amp; b) const { return !(b \u0026lt; *this) \u0026amp;\u0026amp; !(*this \u0026lt; b); } }; int main() { biginteger a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;a= \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;b= \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a+b= \u0026#34; \u0026lt;\u0026lt; (a+b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026lt;b \u0026#34; \u0026lt;\u0026lt; (a\u0026lt;b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026gt;b \u0026#34; \u0026lt;\u0026lt; (a\u0026gt;b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026lt;=b \u0026#34; \u0026lt;\u0026lt; (a\u0026lt;=b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a\u0026gt;=b \u0026#34; \u0026lt;\u0026lt; (a\u0026gt;=b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a!=b \u0026#34; \u0026lt;\u0026lt; (a!=b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a==b \u0026#34; \u0026lt;\u0026lt; (a==b) \u0026lt;\u0026lt; endl; return 0; } second code #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int maxn = 410; struct biginteger { int len, s[maxn]; biginteger() { memset(s, 0, sizeof(s)); len = 1; } biginteger(int num) { *this = num; } biginteger(const char *num) { *this = num; } biginteger operator=(const int num) { char s[maxn]; sprintf(s, \u0026#34;%d\u0026#34;, num); *this = s; return *this; } biginteger operator=(const char *num) { for (int i = 0; num[i] == \u0026#39;0\u0026#39;; num++); //去前导0 len = strlen(num); for (int i = 0; i \u0026lt; len; i++) s[i] = num[len - i - 1] - \u0026#39;0\u0026#39;; return *this; } biginteger operator+(const biginteger \u0026amp;b) const //+ { biginteger c; c.len = 0; for (int i = 0, g = 0; g || i \u0026lt; max(len, b.len); i++) { int x = g; if (i \u0026lt; len) x += s[i]; if (i \u0026lt; b.len) x += b.s[i]; c.s[c.len++] = x % 10; g = x / 10; } return c; } biginteger operator+=(const biginteger \u0026amp;b) { *this = *this + b; return *this; } void clean() { while (len \u0026gt; 1 \u0026amp;\u0026amp; !s[len - 1]) len--; } biginteger operator*(const biginteger \u0026amp;b) //* { biginteger c; c.len = len + b.len; for (int i = 0; i \u0026lt; len; i++) { for (int j = 0; j \u0026lt; b.len; j++) { c.s[i + j] += s[i] * b.s[j]; } } for (int i = 0; i \u0026lt; c.len; i++) { c.s[i + 1] += c.s[i] / 10; c.s[i] %= 10; } c.clean(); return c; } biginteger operator*=(const biginteger \u0026amp;b) { *this = *this * b; return *this; } biginteger operator-(const biginteger \u0026amp;b) { biginteger c; c.len = 0; for (int i = 0, g = 0; i \u0026lt; len; i++) { int x = s[i] - g; if (i \u0026lt; b.len) x -= b.s[i]; if (x \u0026gt;= 0) g = 0; else { g = 1; x += 10; } c.s[c.len++] = x; } c.clean(); return c; } biginteger operator-=(const biginteger \u0026amp;b) { *this = *this - b; return *this; } biginteger operator/(const biginteger \u0026amp;b) { biginteger c, f = 0; for (int i = len - 1; i \u0026gt;= 0; i--) { f = f * 10; f.s[0] = s[i]; while (f \u0026gt;= b) { f -= b; c.s[i]++; } } c.len = len; c.clean(); return c; } biginteger operator/=(const biginteger \u0026amp;b) { *this = *this / b; return *this; } biginteger operator%(const biginteger \u0026amp;b) { biginteger r = *this / b; r = *this - r * b; return r; } biginteger operator%=(const biginteger \u0026amp;b) { *this = *this % b; return *this; } bool operator\u0026lt;(const biginteger \u0026amp;b) { if (len != b.len) return len \u0026lt; b.len; for (int i = len - 1; i \u0026gt;= 0; i--) { if (s[i] != b.s[i]) return s[i] \u0026lt; b.s[i]; } return false; } bool operator\u0026gt;(const biginteger \u0026amp;b) { if (len != b.len) return len \u0026gt; b.len; for (int i = len - 1; i \u0026gt;= 0; i--) { if (s[i] != b.s[i]) return s[i] \u0026gt; b.s[i]; } return false; } bool operator==(const biginteger \u0026amp;b) { return !(*this \u0026gt; b) \u0026amp;\u0026amp; !(*this \u0026lt; b); } bool operator!=(const biginteger \u0026amp;b) { return !(*this == b); } bool operator\u0026lt;=(const biginteger \u0026amp;b) { return *this \u0026lt; b || *this == b; } bool operator\u0026gt;=(const biginteger \u0026amp;b) { return *this \u0026gt; b || *this == b; } string str() const { string res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; len; i++) res = char(s[i] + \u0026#39;0\u0026#39;) + res; return res; } }; istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;in, biginteger \u0026amp;x) { string s; in \u0026gt;\u0026gt; s; x = s.c_str(); return in; } ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;out, const biginteger \u0026amp;x) { out \u0026lt;\u0026lt; x.str(); return out; } int main() { biginteger a, b, c, d, e, f, g; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { a.clean(), b.clean(); c = a + b; d = a - b; e = a * b; f = a / b; g = a % b; cout \u0026lt;\u0026lt; \u0026#34;a+b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // a += b cout \u0026lt;\u0026lt; \u0026#34;a-b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // a -= b; cout \u0026lt;\u0026lt; \u0026#34;a*b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl; // a *= b; cout \u0026lt;\u0026lt; \u0026#34;a/b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; // a /= b; cout \u0026lt;\u0026lt; \u0026#34;a%b\u0026#34; \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; // a %= b; if (a != b) printf(\u0026#34;yes\\n\u0026#34;); else printf(\u0026#34;no\\n\u0026#34;); } return 0; } third (the most complete) code #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // base and base_digits must be consistent constexpr int base = 1000000000; constexpr int base_digits = 9; struct bigint { // value == 0 is represented by empty z vector\u0026lt;int\u0026gt; z; // digits // sign == 1 \u0026lt;==\u0026gt; value \u0026gt;= 0 // sign == -1 \u0026lt;==\u0026gt; value \u0026lt; 0 int sign; bigint() : sign(1) {} bigint(long long v) { *this = v; } bigint \u0026amp;operator=(long long v) { sign = v \u0026lt; 0 ? -1 : 1; v *= sign; z.clear(); for (; v \u0026gt; 0; v = v / base) z.push_back((int) (v % base)); return *this; } bigint(const string \u0026amp;s) { read(s); } bigint \u0026amp;operator+=(const bigint \u0026amp;other) { if (sign == other.sign) { for (int i = 0, carry = 0; i \u0026lt; other.z.size() || carry; ++i) { if (i == z.size()) z.push_back(0); z[i] += carry + (i \u0026lt; other.z.size() ? other.z[i] : 0); carry = z[i] \u0026gt;= base; if (carry) z[i] -= base; } } else if (other != 0 /* prevent infinite loop */) { *this -= -other; } return *this; } friend bigint operator+(bigint a, const bigint \u0026amp;b) { return a += b; } bigint \u0026amp;operator-=(const bigint \u0026amp;other) { if (sign == other.sign) { if (sign == 1 \u0026amp;\u0026amp; *this \u0026gt;= other || sign == -1 \u0026amp;\u0026amp; *this \u0026lt;= other) { for (int i = 0, carry = 0; i \u0026lt; other.z.size() || carry; ++i) { z[i] -= carry + (i \u0026lt; other.z.size() ? other.z[i] : 0); carry = z[i] \u0026lt; 0; if (carry) z[i] += base; } trim(); } else { *this = other - *this; this-\u0026gt;sign = -this-\u0026gt;sign; } } else { *this += -other; } return *this; } friend bigint operator-(bigint a, const bigint \u0026amp;b) { return a -= b; } bigint \u0026amp;operator*=(int v) { if (v \u0026lt; 0) sign = -sign, v = -v; for (int i = 0, carry = 0; i \u0026lt; z.size() || carry; ++i) { if (i == z.size()) z.push_back(0); long long cur = (long long) z[i] * v + carry; carry = (int) (cur / base); z[i] = (int) (cur % base); } trim(); return *this; } bigint operator*(int v) const { return bigint(*this) *= v; } friend pair\u0026lt;bigint, bigint\u0026gt; divmod(const bigint \u0026amp;a1, const bigint \u0026amp;b1) { int norm = base / (b1.z.back() + 1); bigint a = a1.abs() * norm; bigint b = b1.abs() * norm; bigint q, r; q.z.resize(a.z.size()); for (int i = (int) a.z.size() - 1; i \u0026gt;= 0; i--) { r *= base; r += a.z[i]; int s1 = b.z.size() \u0026lt; r.z.size() ? r.z[b.z.size()] : 0; int s2 = b.z.size() - 1 \u0026lt; r.z.size() ? r.z[b.z.size() - 1] : 0; int d = (int) (((long long) s1 * base + s2) / b.z.back()); r -= b * d; while (r \u0026lt; 0) r += b, --d; q.z[i] = d; } q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); return {q, r / norm}; } friend bigint sqrt(const bigint \u0026amp;a1) { bigint a = a1; while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0); int n = a.z.size(); int firstdigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]); int norm = base / (firstdigit + 1); a *= norm; a *= norm; while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0); bigint r = (long long) a.z[n - 1] * base + a.z[n - 2]; firstdigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]); int q = firstdigit; bigint res; for (int j = n / 2 - 1; j \u0026gt;= 0; j--) { for (;; --q) { bigint r1 = (r - (res * 2 * base + q) * q) * base * base + (j \u0026gt; 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0); if (r1 \u0026gt;= 0) { r = r1; break; } } res *= base; res += q; if (j \u0026gt; 0) { int d1 = res.z.size() + 2 \u0026lt; r.z.size() ? r.z[res.z.size() + 2] : 0; int d2 = res.z.size() + 1 \u0026lt; r.z.size() ? r.z[res.z.size() + 1] : 0; int d3 = res.z.size() \u0026lt; r.z.size() ? r.z[res.z.size()] : 0; q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstdigit * 2)); } } res.trim(); return res / norm; } bigint operator/(const bigint \u0026amp;v) const { return divmod(*this, v).first; } bigint operator%(const bigint \u0026amp;v) const { return divmod(*this, v).second; } bigint \u0026amp;operator/=(int v) { if (v \u0026lt; 0) sign = -sign, v = -v; for (int i = (int) z.size() - 1, rem = 0; i \u0026gt;= 0; --i) { long long cur = z[i] + rem * (long long) base; z[i] = (int) (cur / v); rem = (int) (cur % v); } trim(); return *this; } bigint operator/(int v) const { return bigint(*this) /= v; } int operator%(int v) const { if (v \u0026lt; 0) v = -v; int m = 0; for (int i = (int) z.size() - 1; i \u0026gt;= 0; --i) m = (int) ((z[i] + m * (long long) base) % v); return m * sign; } bigint \u0026amp;operator*=(const bigint \u0026amp;v) { return *this = *this * v; } bigint \u0026amp;operator/=(const bigint \u0026amp;v) { return *this = *this / v; } bool operator\u0026lt;(const bigint \u0026amp;v) const { if (sign != v.sign) return sign \u0026lt; v.sign; if (z.size() != v.z.size()) return z.size() * sign \u0026lt; v.z.size() * v.sign; for (int i = (int) z.size() - 1; i \u0026gt;= 0; i--) if (z[i] != v.z[i]) return z[i] * sign \u0026lt; v.z[i] * sign; return false; } bool operator\u0026gt;(const bigint \u0026amp;v) const { return v \u0026lt; *this; } bool operator\u0026lt;=(const bigint \u0026amp;v) const { return !(v \u0026lt; *this); } bool operator\u0026gt;=(const bigint \u0026amp;v) const { return !(*this \u0026lt; v); } bool operator==(const bigint \u0026amp;v) const { return !(*this \u0026lt; v) \u0026amp;\u0026amp; !(v \u0026lt; *this); } bool operator!=(const bigint \u0026amp;v) const { return *this \u0026lt; v || v \u0026lt; *this; } void trim() { while (!z.empty() \u0026amp;\u0026amp; z.back() == 0) z.pop_back(); if (z.empty()) sign = 1; } bool iszero() const { return z.empty(); } friend bigint operator-(bigint v) { if (!v.z.empty()) v.sign = -v.sign; return v; } bigint abs() const { return sign == 1 ? *this : -*this; } long long longvalue() const { long long res = 0; for (int i = (int) z.size() - 1; i \u0026gt;= 0; i--) res = res * base + z[i]; return res * sign; } friend bigint gcd(const bigint \u0026amp;a, const bigint \u0026amp;b) { return b.iszero() ? a : gcd(b, a % b); } friend bigint lcm(const bigint \u0026amp;a, const bigint \u0026amp;b) { return a / gcd(a, b) * b; } void read(const string \u0026amp;s) { sign = 1; z.clear(); int pos = 0; while (pos \u0026lt; s.size() \u0026amp;\u0026amp; (s[pos] == \u0026#39;-\u0026#39; || s[pos] == \u0026#39;+\u0026#39;)) { if (s[pos] == \u0026#39;-\u0026#39;) sign = -sign; ++pos; } for (int i = (int) s.size() - 1; i \u0026gt;= pos; i -= base_digits) { int x = 0; for (int j = max(pos, i - base_digits + 1); j \u0026lt;= i; j++) x = x * 10 + s[j] - \u0026#39;0\u0026#39;; z.push_back(x); } trim(); } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;stream, bigint \u0026amp;v) { string s; stream \u0026gt;\u0026gt; s; v.read(s); return stream; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;stream, const bigint \u0026amp;v) { if (v.sign == -1) stream \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; stream \u0026lt;\u0026lt; (v.z.empty() ? 0 : v.z.back()); for (int i = (int) v.z.size() - 2; i \u0026gt;= 0; --i) stream \u0026lt;\u0026lt; setw(base_digits) \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; v.z[i]; return stream; } static vector\u0026lt;int\u0026gt; convert_base(const vector\u0026lt;int\u0026gt; \u0026amp;a, int old_digits, int new_digits) { vector\u0026lt;long long\u0026gt; p(max(old_digits, new_digits) + 1); p[0] = 1; for (int i = 1; i \u0026lt; p.size(); i++) p[i] = p[i - 1] * 10; vector\u0026lt;int\u0026gt; res; long long cur = 0; int cur_digits = 0; for (int v : a) { cur += v * p[cur_digits]; cur_digits += old_digits; while (cur_digits \u0026gt;= new_digits) { res.push_back(int(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; } } res.push_back((int) cur); while (!res.empty() \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } typedef vector\u0026lt;long long\u0026gt; vll; static vll karatsubamultiply(const vll \u0026amp;a, const vll \u0026amp;b) { int n = a.size(); vll res(n + n); if (n \u0026lt;= 32) { for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) res[i + j] += a[i] * b[j]; return res; } int k = n \u0026gt;\u0026gt; 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubamultiply(a1, b1); vll a2b2 = karatsubamultiply(a2, b2); for (int i = 0; i \u0026lt; k; i++) a2[i] += a1[i]; for (int i = 0; i \u0026lt; k; i++) b2[i] += b1[i]; vll r = karatsubamultiply(a2, b2); for (int i = 0; i \u0026lt; a1b1.size(); i++) r[i] -= a1b1[i]; for (int i = 0; i \u0026lt; a2b2.size(); i++) r[i] -= a2b2[i]; for (int i = 0; i \u0026lt; r.size(); i++) res[i + k] += r[i]; for (int i = 0; i \u0026lt; a1b1.size(); i++) res[i] += a1b1[i]; for (int i = 0; i \u0026lt; a2b2.size(); i++) res[i + n] += a2b2[i]; return res; } bigint operator*(const bigint \u0026amp;v) const { vector\u0026lt;int\u0026gt; a6 = convert_base(this-\u0026gt;z, base_digits, 6); vector\u0026lt;int\u0026gt; b6 = convert_base(v.z, base_digits, 6); vll a(a6.begin(), a6.end()); vll b(b6.begin(), b6.end()); while (a.size() \u0026lt; b.size()) a.push_back(0); while (b.size() \u0026lt; a.size()) b.push_back(0); while (a.size() \u0026amp; (a.size() - 1)) a.push_back(0), b.push_back(0); vll c = karatsubamultiply(a, b); bigint res; res.sign = sign * v.sign; for (int i = 0, carry = 0; i \u0026lt; c.size(); i++) { long long cur = c[i] + carry; res.z.push_back((int) (cur % 1000000)); carry = (int) (cur / 1000000); } res.z = convert_base(res.z, 6, base_digits); res.trim(); return res; } }; bigint random_bigint(int n) { string s; for (int i = 0; i \u0026lt; n; i++) { s += rand() % 10 + \u0026#39;0\u0026#39;; } return bigint(s); } // random tests void biginttest() { bigint x = bigint(\u0026#34;120\u0026#34;); bigint y = bigint(\u0026#34;5\u0026#34;); cout \u0026lt;\u0026lt; x / y \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 1000; i++) { int n = rand() % 100 + 1; bigint a = random_bigint(n); bigint res = sqrt(a); bigint xx = res * res; bigint yy = (res + 1) * (res + 1); if (xx \u0026gt; a || yy \u0026lt;= a) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; break; } int m = rand() % n + 1; bigint b = random_bigint(m) + 1; res = a / b; xx = res * b; yy = b * (res + 1); if (xx \u0026gt; a || yy \u0026lt;= a) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; break; } } bigint a = random_bigint(10000); bigint b = random_bigint(2000); clock_t start = clock(); bigint c = a / b; printf(\u0026#34;time=%.3lfsec\\n\u0026#34;, (clock() - start) * 1. / clocks_per_sec); } string str(bigint b) { stringstream ss; ss \u0026lt;\u0026lt; b; string s; ss \u0026gt;\u0026gt; s; return s; } ","date":"2019-05-23","permalink":"https://blog.akvicor.com/posts/algorithm/arbitrary_precision/","summary":"\u003cp\u003e在运算过程中如果运算结果很大，普通的数据类型无法储存，就需要用到所谓的高精度算法，即用数组来存储整数，并模拟手算的方式进行四则运算。\u003c/p\u003e","title":"高精度(arbitrary-precision arithmetic)"},{"content":"knuth-morris-pratt 字符串查找算法，简称为 “kmp算法”，常用于在一个文本串s内查找一个模式串p 的出现位置，这个算法由donald knuth、vaughan pratt、james h. morris三人于1977年联合发表，故取这3人的姓氏命名此算法。\n算法流程 假设现在文本串s匹配到 i 位置，模式串匹配到 j 位置 如果 j=-1，或者当前字符匹配成功（即s[i]==p[i]），都令i++，j++，继续匹配下一个字符 如果 j!=-1，且当前字符匹配失败（即s[i]!=p[j]），则令 i 不变，j=next[j]。这意味着失配时，模式串p相对于文本串s向右移动了j-next[j]位。 next数组中各值含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如next[j]=k，代表j之前的字符串中有最大长度为k的相同前缀后缀。\n这也意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到那个位置。如果next[j]=0或-1，则跳到模式串的开头字符，若next[j]=k 且 k\u0026gt;0，代表下次匹配跳到j之前的某个字符，而不是跳到开头，且具体跳过了k个字符。\n计算next数组 void kmp_pre(char s[], int len, int next[]){ int i, j; j = next[0] = -1; i = 0; while(i \u0026lt; len){ while(-1 != j \u0026amp;\u0026amp; s[i]!=s[j]) j = next[j]; next[++i] = ++j; } } // a b c a b c a b c d e f a b c d e f g h i // -1 0 0 0 1 2 3 4 5 6 0 0 0 1 2 3 0 0 0 0 0 // a b c d a b d // -1 0 0 0 0 1 2 ","date":"2019-04-30","permalink":"https://blog.akvicor.com/posts/algorithm/kmp/","summary":"\u003cp\u003eKnuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。\u003c/p\u003e","title":"kmp 算法"},{"content":"what is adb android debug bridge (adb) is a command line tool that lets you communicate with an emulator or connected android device. you can find the adb tool in android sdk/platform-tools or download adb kits.\nadb debugging adb devices adb forward adb kill-server adb devices prints a list of all attached emulator/device\nadb devices in response, return serial number and state\ne4b25377 device emulator-5554 device adb forward forward socket connections\nadb forward \u0026lt;local\u0026gt; \u0026lt;remote\u0026gt; adb forward tcp:8000 tcp:9000 set up forwarding of host port 8000 to emulator/device port 9000\nprerequisites: enable usb debugging on the device.\nadb kill-server terminates the adb server process\nadb kill-server notes: kill the server if it is running. (terminal adb.exe process)\nwireless adb connect \u0026lt;host\u0026gt;[:\u0026lt;port\u0026gt;] adb usb adb connect use adb over wi-fi\nadb connect \u0026lt;host\u0026gt;[:\u0026lt;port\u0026gt;] step 1. connect to the device over usb.\nstep 2. adb devices list of devices attached ######## device\nnotes: step 1,2 is required\nstep 3. adb tcpip 5555 restarting in tcp mode port: 5555\nstep 4. find out the ip address of the android device: settings -\u0026gt; about -\u0026gt; status -\u0026gt; ip address. remember the ip address, of the form #.#.#.#.\nstep 5. adb connect #.#.#.# connected to #.#.#.#:5555\nstep 6. remove usb cable from device, and confirm you can still access device:\nadb devices list of devices attached #.#.#.#:5555 device\nnotes: make sure that your host is still connected to the same wi-fi network your android device is.\nadb usb restarting adb in usb mode.\nsee also: adb connect\npackage manager adb install [option] \u0026lt;path\u0026gt; adb uninstall [options] \u0026lt;package\u0026gt; adb shell pm list packages [options] \u0026lt;filter\u0026gt; adb shell pm path \u0026lt;package\u0026gt; adb shell pm clear \u0026lt;package\u0026gt; adb install pushes an android application (specified as a full path to an .apk file) to an emulator/device.\nadb install test.apk adb install -l test.apk # forward lock application adb install -r test.apk # replace existing application adb install -t test.apk # allow test packages adb install -s test.apk # install application on sdcard adb install -d test.apk # allow version code downgrade adb install -p test.apk # partial application install adb uninstall removes a package from the emulator/device.\nadb uninstall com.test.app adb uninstall -k com.test.app # keep the data and cache directories around after package removal. adb shell pm list packages prints all packages, optionally only those whose package name contains the text in \u0026lt;filter\u0026gt;.\nadb shell pm list packages adb shell pm list packages -f # see their associated file. adb shell pm list packages -d # filter to only show disabled packages. adb shell pm list packages -e # filter to only show enabled packages. adb shell pm list packages -s # filter to only show system packages. adb shell pm list packages -3 # filter to only show third party packages. adb shell pm list packages -i # see the installer for the packages. adb shell pm list packages -u # also include uninstalled packages. adb shell pm list packages --user \u0026lt;user_id\u0026gt; # the user space to query. adb shell pm path print the path to the apk of the given \u0026lt;package\u0026gt;.\nadb shell pm path com.android.phone package:/system/priv-app/teleservice/teleservice.apk\nadb shell pm clear deletes all data associated with a package.\nadb shell pm clear com.test.abc notes: clearing app data, cache\nfile manager adb pull \u0026lt;remote\u0026gt; [local] adb push \u0026lt;local\u0026gt; \u0026lt;remote\u0026gt; adb shell ls adb shell cd adb shell rm adb shell mkdir adb shell touch adb shell pwd adb shell cp adb shell mv adb pull download a specified file from an emulator/device to your computer.\nadb pull /sdcard/demo.mp4 download /sdcard/demo.mp4 to \u0026lt;android-sdk-path\u0026gt;/platform-tools directory.\nadb pull /sdcard/demo.mp4 e:\\ download /sdcard/demo.mp4 to drive e.\nadb push upload a specified file from your computer to an emulator/device.\nadb push test.apk /sdcard copies \u0026lt;android-sdk-path\u0026gt;/platform-tools/test.apk to /sdcard directory.\nadb push d:\\test.apk /sdcard copies d:\\test.apk to /sdcard directory.\nadb shell ls list directory contents\nls [options] \u0026lt;directory\u0026gt; step 1. adb shell step 2. ls ls -a # do not hide entries starting with ls -i # print index number of each file ls -s # print size of each file, in blocks ls -n # list numeric uids and gids ls -r # list subdirectories recursively notes: press ctrl-c to stop\nadb shell cd change directory\ncd \u0026lt;directory\u0026gt; step 1. adb shell step 2. cd /system adb shell rm remove files or directories\nrm [options] \u0026lt;files or directory\u0026gt; step 1.\nadb shell step 2.\nrm /sdcard/test.txt\nrm -f /sdcard/test.txt # force remove without prompt rm -r /sdcard/tmp # remove the contents of directories recursively rm -d /sdcard/tmp # remove directory, even if it is a non-empty directory notes: rm -d equal rmdir command\nrm -i /sdcard/test.txt # prompt before any removal adb shell mkdir make directories\nmkdir [options] \u0026lt;directory name\u0026gt; mkdir /sdcard/tmp mkdir -m 777 /sdcard/tmp # set permission mode mkdir -p /sdcard/tmp/sub1/sub2 # create parent directories as needed adb shell touch create empty file or change file timestamps\ntouch [options] \u0026lt;file\u0026gt; step 1.\nadb shell step 2.\ntouch /sdcard/tmp/test.txt ls /sdcard/tmp\nadb shell pwd print current working directory location.\npwd adb shell cp copy files and directories\ncp [options] \u0026lt;source\u0026gt; \u0026lt;dest\u0026gt; step 1.\nadb shell step 2.\ncp /sdcard/test.txt /sdcard/demo.txt\nadb shell mv move or rename files\nmv [options] \u0026lt;source\u0026gt; \u0026lt;dest\u0026gt; step 1.\nadb shell step 2.\nmv /sdcard/tmp /system/tmp # move mv /sdcard/tmp /sdcard/test # rename network adb shell netstat adb shell ping adb shell netcfg adb shell ip adb shell netstat network statistics\nnetstat step 1.\nadb shell step 2.\nnetstat adb shell ping test the connection and latency between two network connection.\nping [-aabbddfhlnoqrruvv] [-c count] [-i interval] [-i interface] [-m mark] [-m pmtudisc_option] [-l preload] [-p pattern] [-q tos] [-s packetsize] [-s sndbuf] [-t ttl] [-t timestamp_option] [-w deadline] [-w timeout] [hop1 \u0026hellip;] destination\nstep 1. adb shell step 2. ping www.google.com notes: press ctrl-c to stop ping\nping www.google.com -c 4 adb shell netcfg configure and manage network connections via profiles\nnetcfg [\u0026lt;interface\u0026gt; {dhcp|up|down}] step 1. adb shell step 2. netcfg adb shell ip show, manipulate routing, devices, policy routing and tunnels\nip [ options ] object object := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp }\noptions := { -v[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]}\nstep 1. adb shell step 2. ip -f inet addr show wlan0 # show wifi ip address logcat adb logcat adb shell dumpsys adb shell dumpstate prints log data to the screen.\nadb logcat [option] [filter-specs] adb logcat notes: press ctrl-c to stop monitor\nadb logcat *:v # lowest priority, filter to only show verbose level adb logcat *:d # filter to only show debug level adb logcat *:i # filter to only show info level adb logcat *:w # filter to only show warning level adb logcat *:e # filter to only show error level adb logcat *:f # filter to only show fatal level adb logcat *:s # silent, highest priority, on which nothing is ever printed adb logcat -b \u0026lt;buffer\u0026gt; adb logcat -b radio # view the buffer that contains radio/telephony related messages. adb logcat -b event # view the buffer containing events-related messages. adb logcat -b main # default adb logcat -c # clears the entire log and exits. adb logcat -d # dumps the log to the screen and exits. adb logcat -f test.logs # writes log message output to test.logs . adb logcat -g # prints the size of the specified log buffer and exits. adb logcat -n \u0026lt;count\u0026gt; # sets the maximum number of rotated logs to \u0026lt;count\u0026gt;. notes: the default value is 4. requires the -r option.\nadb logcat -r \u0026lt;kbytes\u0026gt; # rotates the log file every \u0026lt;kbytes\u0026gt; of output. notes: the default value is 16. requires the -f option.\nadb logcat -s # sets the default filter spec to silent. adb logcat -v \u0026lt;format\u0026gt; adb logcat -v brief # display priority/tag and pid of the process issuing the message (default format). adb logcat -v process # display pid only.) adb logcat -v tag # display the priority/tag only. adb logcat -v raw # display the raw log message, with no other metadata fields. adb logcat -v time # display the date, invocation time, priority/tag, and pid of the process issuing the message. adb logcat -v threadtime # display the date, invocation time, priority, tag, and the pid and tid of the thread issuing the message. adb logcat -v long # display all metadata fields and separate messages with blank lines. adb shell dumpsys dumps system data\nadb shell dumpsys [options] adb shell dumpsys adb shell dumpsys meminfo\nadb shell dumpsys battery notes: a mobile device with developer options enabled running android 5.0 or higher.\nadb shell dumpsys batterystats # collects battery data from your device **notes: battery historian converts that data into an html visualization. ** step 1 adb shell dumpsys batterystats \u0026gt; batterystats.txt step 2 python historian.py batterystats.txt \u0026gt; batterystats.html\nadb shell dumpsys batterystats --reset # erases old collection data adb shell dumpsys activity\nadb shell dumpsys gfxinfo com.android.phone measuring com.android.phone ui performance\nadb shell dumpstate dumps state\nadb shell dumpstate adb shell dumpstate \u0026gt; state.logs # dumps state to a file screenshot adb shell screencap adb shell screenrecord [4.4+] adb shell screencap taking a screenshot of a device display.\nadb shell screencap \u0026lt;filename\u0026gt; adb shell screencap /sdcard/screen.png download the file from the device\nadb pull /sdcard/screen.png adb shell screenrecord recording the display of devices running android 4.4 (api level 19) and higher.\nadb shell screenrecord [options] \u0026lt;filename\u0026gt; adb shell screenrecord /sdcard/demo.mp4 (press ctrl-c to stop recording)\ndownload the file from the device\nadb pull /sdcard/demo.mp4 notes: stop the screen recording by pressing ctrl-c, otherwise the recording stops automatically at three minutes or the time limit set by \u0026ndash;time-limit.\nadb shell screenrecord --size \u0026lt;widthxheight\u0026gt; sets the video size: 1280x720. the default value is the device\u0026rsquo;s native display resolution (if supported), 1280x720 if not. for best results, use a size supported by your device\u0026rsquo;s advanced video coding (avc) encoder.\nadb shell screenrecord --bit-rate \u0026lt;rate\u0026gt; sets the video bit rate for the video, in megabits per second. the default value is 4mbps. you can increase the bit rate to improve video quality, but doing so results in larger movie files. the following example sets the recording bit rate to 5mbps: adb shell screenrecord \u0026ndash;bit-rate 5000000 /sdcard/demo.mp4\nadb shell screenrecord --time-limit \u0026lt;time\u0026gt; sets the maximum recording time, in seconds. the default and maximum value is 180 (3 minutes).\nadb shell screenrecord --rotate rotates the output 90 degrees. this feature is experimental.\nadb shell screenrecord --verbose displays log information on the command-line screen. if you do not set this option, the utility does not display any information while running.\nsystem adb rootadb sideload adb shell ps adb shell top adb shell getprop adb shell setprop adb root restarts the adbd daemon with root permissions\nadb root notes: adbd cannot run as root in production builds (test in emulator)\nadb sideload flashing/restoring android update.zip packages.\nadb sideload \u0026lt;update.zip\u0026gt; notes: adb reboot sideload [android m+]\nadb shell ps print process status\nps [options] step 1. adb shell step 2. ps ps -p\nadb shell top display top cpu processes\ntop [options] step 1. adb shell step 2. top notes: (press ctrl-c to stop monitor)\ntop -t show threads instead of processes.\nadb shell getprop get property via the android property service\ngetprop [options] step 1. adb shell step 2. getprop getprop ro.build.version.sdk getprop ro.chipname getprop | grep adb see also adb shell setprop\nadb shell setprop set property service\nsetprop \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; step 1. adb shell step 2. setprop service.adb.tcp.port 5555\nsee also adb shell getprop\n","date":"2019-04-28","permalink":"https://blog.akvicor.com/posts/android/adb/","summary":"\u003ch2 id=\"what-is-adb\"\u003eWhat Is ADB\u003c/h2\u003e\n\u003cp\u003eAndroid Debug Bridge (adb) is a command line tool that lets you communicate with an emulator or connected Android device. You can find the adb tool in \u003cem\u003eandroid sdk/platform-tools\u003c/em\u003e or Download \u003ca href=\"http://adbshell.com/downloads\"\u003eADB Kits\u003c/a\u003e.\u003c/p\u003e","title":"adb commands"},{"content":"完全数，又称完美数或完备数，是一些特殊的自然数：它所有的真因子（即除了自身以外的约数）的和，恰好等于它本身，完全数不可能是楔形数。\n例如：第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3＝6，恰好等于本身。第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14＝28，也恰好等于本身。后面的数是496、8128。\n十进制的5位数到7位数、9位数、11位数、13到18位数等位数都没有完全数，它们不是亏数就是过剩数。\n完全数的发现 古希腊数学家欧几里得是通过 $math_inline$2^{n-1}\\times(2^n-1)$math_inline$ 的表达式发现前四个完全数的。\n当 $math_inline$n=2 : 2^1\\times(2^2-1)=6$math_inline$ 当 $math_inline$n=3 : 2^2\\times(2^3-1)=28$math_inline$ 当 $math_inline$n=5 : 2^4\\times(2^5-1)=496$math_inline$ 当 $math_inline$n=7 : 2^6\\times(2^7-1)=8128$math_inline$ 一个偶数是完美数，当且仅当它具有如下形式： $math_inline${\\displaystyle 2^{n-1}(2^{n}-1)}$math_inline$ ，其中 $math_inline${\\displaystyle 2^{n}-1}$math_inline$ 是素数，此事实的充分性由欧几里得证明，而必要性则由欧拉所证明。\n比如，上面的 $math_inline${\\displaystyle 6}$math_inline$ 和 $math_inline${\\displaystyle 28}$math_inline$ 对应着 $math_inline${\\displaystyle n=2}$math_inline$ 和 $math_inline${\\displaystyle 3}$math_inline$ 的情况。我们只要找到了一个形如 $math_inline${\\displaystyle 2^{n}-1}​$math_inline$ 的素数（即梅森素数），也就知道了一个偶完美数。\n尽管没有发现奇完全数，但是当代数学家奥斯丁·欧尔证明，若有奇完全数，则其形式必然是 $math_inline${\\displaystyle 12p+1}$math_inline$ 或 $math_inline${\\displaystyle 36p+9}$math_inline$ 的形式，其中 $math_inline${\\displaystyle p}$math_inline$ 是素数。\n首十个完全数是（ a000396）：\n6（1位） 28（2位） 496（3位） 8128（4位） 33550336（8位） 8589869056（10位） 137438691328（12位） 2305843008139952128（19位） 2658455991569831744654692615953842176（37位） 191561942608236107294793378084303638130997321548169216（54位） 每一个梅森素数给出一个偶完全数；反之，每个偶完全数给出一个梅森素数，这结果称为欧几里得－欧拉定理。到 2018 年 1 月为止，共发现了 50 个完全数，且都是偶数。最大的已知完全数为 $math_inline$2^{77232916}\\times(2^{77232917}-1)$math_inline$ 共有 $math_inline${\\displaystyle 46498850}$math_inline$ 位数[1]。\n性质 以下是目前已发现的完全数共有的性质。\n偶完全数都是以6或28结尾。 在十二进制中，除了6跟28以外的偶完全数都以54结尾，甚至，除了6, 28, 496以外的偶完全数都以054或854结尾。而如果存在奇完全数，她在十二进制中必定以1, 09, 39, 69或99结尾。 除6以外的偶完全数，把它的各位数字相加，直到变成个位数，那么这个个位数一定是1[注 1]： $math_inline$28→2+8=10→1+0=1$math_inline$ 所有的偶完全数都可以表达为2的一些连续正整数次幂之和，从 $math_inline${\\displaystyle 2^{p-1}}$math_inline$ 到 $math_inline${\\displaystyle 2^{2p-2}}$math_inline$ ： $math_inline$6=2^1+2^2$math_inline$ $math_inline$28=2^2+2^3+2^4$math_inline$ $math_inline$496=2^4+2^5+2^6+2^7+2^8$math_inline$ $math_inline$8128=2^6+2^7+...+2^{12}$math_inline$ 每个偶完全数都可以写成连续自然数之和[注 2]： $math_inline$6=1+2+3$math_inline$ $math_inline$28=1+2+3+4+5+6+7$math_inline$ $math_inline$496=1+2+3+4+…+30+31$math_inline$ 除6以外的偶完全数，还可以表示成连续奇立方数之和（被加的项共有 $math_inline${\\displaystyle {\\sqrt {2^{p-1}}}}$math_inline$ )[注 3]： $math_inline$28=1^3+3^3$math_inline$ $math_inline$496=1^3+3^3+5^3+7^3$math_inline$ 每个完全数的所有约数（包括本身）的倒数之和，都等于2：（这可以用通分证得。因此每个完全数都是欧尔调和数。） $math_inline$\\frac{1}{1}+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{6}=\\frac{6+3+2+1}{6}=2​$math_inline$ $math_inline$\\frac{1}{1}+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{7}+\\frac{1}{14}+\\frac{1}{28}=\\frac{28+14+7+4+2+1}{28}=2$math_inline$ 它们的二进制表达式也很有趣：（因为偶完全数形式均如 $math_inline$2^{n-1}(2^n-1)$math_inline$ )\n$math_inline$(6)_{10}=(110)_2​$math_inline$ $math_inline$(28)_{10}=(11100)_2$math_inline$ $math_inline$(496)_{10}=(111110000)_2$math_inline$","date":"2019-04-20","permalink":"https://blog.akvicor.com/posts/algorithm/perfect_number/","summary":"\u003cp\u003e\u003cstrong\u003e完全数\u003c/strong\u003e，又称\u003cstrong\u003e完美数\u003c/strong\u003e或\u003cstrong\u003e完备数\u003c/strong\u003e，是一些特殊的\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0\"\u003e自然数\u003c/a\u003e：它所有的真\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%9B%A0%E5%AD%90\"\u003e因子\u003c/a\u003e（即除了自身以外的约数）的和，恰好等于它本身，完全数不可能是\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%A5%94%E5%BD%A2%E6%95%B8\"\u003e楔形数\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e例如：第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3＝6，恰好等于本身。第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14＝28，也恰好等于本身。后面的数是\u003ca href=\"https://zh.wikipedia.org/wiki/496\"\u003e496\u003c/a\u003e、\u003ca href=\"https://zh.wikipedia.org/wiki/8128\"\u003e8128\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E5%8D%81%E9%80%B2%E4%BD%8D\"\u003e十进制\u003c/a\u003e的5位数到7位数、9位数、11位数、13到18位数等位数都没有完全数，它们不是\u003ca href=\"https://zh.wikipedia.org/wiki/%E4%BA%8F%E6%95%B0\"\u003e亏数\u003c/a\u003e就是\u003ca href=\"https://zh.wikipedia.org/wiki/%E9%81%8E%E5%89%A9%E6%95%B8\"\u003e过剩数\u003c/a\u003e。\u003c/p\u003e","title":"完全数"},{"content":"判断一个多边形的边界曲线是否是顺时针或者逆时针\ndouble d = 0; for (int i = 0; i \u0026lt; n - 1; i++) { d += -0.5 * ( y[i + 1] + y[i]) * (x[i + 1] - x[i]); } if ( d \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;counter clockwise\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;clockwise\u0026#34; \u0026lt;\u0026lt; endl; ","date":"2019-04-14","permalink":"https://blog.akvicor.com/posts/algorithm/green_determine_clockwise/","summary":"\u003cp\u003e判断一个多边形的边界曲线是否是顺时针或者逆时针\u003c/p\u003e","title":"green公式-判断多边形边界曲线顺/逆时针"},{"content":"背包的状态转换方程 : $math_inline$f[i,j] = max\\lbrace f[i-1,j-w_i]+pi( j \u003e= w_i ), f[i-1,j] \\rbrace$math_inline$ $math_inline$f[i,j]$math_inline$ 表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。 pi表示第i件物品的价值。 决策：为了背包中物品总价值最大化，第 i件物品应该放入背包中吗 ？\n假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。\n有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？\nname weight value 1 2 3 4 5 6 7 8 9 10 a 2 6 0 6 6 9 9 12 12 15 15 15 b 2 3 0 3 3 6 6 9 9 9 10 11 c 6 5 0 0 0 6 6 6 6 6 10 11 d 5 4 0 0 0 6 6 6 6 6 10 10 e 4 6 0 0 0 6 6 6 6 6 6 6 首先要明确这张表是自底向上，从左到右生成的。\n只要你能通过找规律手工填写出上面这张表就算理解了01背包的动态规划算法。\n为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。\n对于d2单元格，表示只有物品e，d时,承重为2的背包，所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。\n同理，c2=0，b2=3，a2=6。\n对于承重为8的背包，a8=15,是怎么得出的呢？\n根据01背包的状态转换方程，需要考察两个值，\n一个是 $math_inline$f[i-1,j]$math_inline$ ，对于这个例子来说就是b8的值9，另一个是 $math_inline$f[i-1,j-wi]+pi$math_inline$ ；\n在这里，\n$math_inline$f[i-1,j]$math_inline$ 表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值\n$math_inline$f[i-1,j-wi]$math_inline$ 表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值\n$math_inline$f[i-1,j-wi]$math_inline$ 就是指单元格b6,值为9，pi指的是a物品的价值，即6\nvoid findmax(){ memset(v, 0, sizeof(v)); for(int i = 1; i \u0026lt;= number; ++i){ for(int j = 1; j \u0026lt;= capacity; ++j){ if(j\u0026lt;w[i]){ // 装不进去 v[i][j] = v[i-1][j]; }else{ // 能装 if(v[i-1][j] \u0026gt; v[i-1][j-w[i]]+v[i]){ // 不装价值大 v[i][j] = v[i-1][j]; }else{ // 前i-1个物品的最优解与第i个物品的价值之和更大 v[i][j] = v[i-1][j-w[i]]+v[i]; } } } } } ","date":"2019-04-05","permalink":"https://blog.akvicor.com/posts/algorithm/dynamic_programming/","summary":"\u003cp\u003e背包的状态转换方程 : \n\n    \n        $math_inline$f[i,j] = Max\\lbrace f[i-1,j-W_i]+Pi( j \u003e= W_i ),  f[i-1,j] \\rbrace$math_inline$\n    \n\n\u003c/p\u003e\n\u003cp\u003e\n\n    \n        $math_inline$f[i,j]$math_inline$\n    \n\n表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。\nPi表示第i件物品的价值。\n决策：为了背包中物品总价值最大化，第 i件物品应该放入背包中吗 ？\u003c/p\u003e","title":"动态规划"},{"content":"\npath 1 2 3 4 5 6 7 8 1 0 3 2 3 ∞ ∞ ∞ ∞ 2 3 0 ∞ ∞ 5 4 ∞ ∞ 3 2 ∞ 0 ∞ ∞ 4 6 ∞ 4 3 ∞ ∞ 0 4 ∞ 6 ∞ 5 ∞ 5 ∞ 4 0 2 2 ∞ 6 ∞ 4 4 ∞ 2 0 ∞ 3 7 ∞ ∞ 6 6 2 ∞ 0 3 8 ∞ ∞ ∞ ∞ ∞ 3 3 0 dis 1 2 3 4 5 6 7 8 估计值 0 3 2 3 ∞ ∞ ∞ ∞ path代表地图 例如path[i][j]代表从i到j的距离\ndis代表从起点到达i的距离，开始时初始化为最大，代表无穷远即未连同\nvis代表当前节点[i]是否访问过\n既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 3 号顶点。\n当选择了 3 号顶点后，dis[3]的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 3 号顶点的最短路程就是当前 dis[3]值。因为目前离 1 号顶点最近的是 3 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 3 号顶点的路程进一步缩短了。因为 1 号顶点到其它顶点的路程肯定没有 1 号到 3 号顶点短。\n既然选了 3 号顶点，接下来再来看 3 号顶点有哪些出边呢。有 3-\u0026gt;6 和 3-\u0026gt;7 这两条边。先讨论通过 3-\u0026gt;6 这条边是否能够让 1 号顶点到 6 号顶点的路程变短。也就是说比较dis[6]和dis[3]+path[3][6]的大小。其中 dis[3] 表示 1 号顶带你到 3 号顶点的路程。dis[3]+path[3][6]中dis[3]表示 1 号顶点到 3 号顶点的路程，path[3][6]表示 3-\u0026gt;6 这条边。所以 dis[3]+path[3][6]就表示从1号顶带你到3号顶点，再通过3-\u0026gt;6这条边到达3号顶点的路程\n我们发现 dis[6]=∞，dis[3]+path[3][6]=6，dis[6] \u0026gt; dis[3]+path[3][6]，因此dis[6]要更新为10。这个过程有个专业术语叫“松弛”。即 1 号顶点到 3 号顶点的路程即 dis[3] ，通过 3-\u0026gt;6 这条边松弛成功。这便是dijkstra算法的主要思想：通过“边”来松弛 1 号顶点到其余各个顶点的路程。\n算法的基本思想是：每次找到离源点（上面例子的源点就是 1 号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：\n将所有的顶点分为两部分：已知最短路程的顶点集合 p 和未知最短路径的顶点集合 q。最开始，已知最短路径的顶点集合 p 中只有源点一个顶点。我们这里用一个 vis[ i ]数组来记录哪些点在集合 p 中。例如对于某个顶点 i，如果 vis[ i ]为 1 则表示这个顶点在集合 p 中，如果 vis[ i ]为 0 则表示这个顶点在集合 q 中。 设置源点 s 到自己的最短路径为 0 即 dis=0。若存在源点有能直接到达的顶点 i，则把 dis[ i ]设为 path[s][ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为 ∞。 在集合 q 的所有顶点中选择一个离源点 s 最近的顶点 u（即 dis[u]最小）加入到集合 p。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v 的边，那么可以通过将边 u-\u0026gt;v 添加到尾部来拓展一条从 s 到 v 的路径，这条路径的长度是 dis[u]+path[u][v]。如果这个值比目前已知的 dis[v]的值要小，我们可以用新值来替代当前 dis[v]中的值。 重复第 3 步，如果集合 q 为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径。 in\n8 13 1 2 3 1 3 2 1 4 3 2 6 4 2 5 5 3 6 4 3 7 6 4 5 4 4 7 6 6 8 3 6 5 2 5 7 2 7 8 3 out\n1 to 2 min= 3 1 to 3 min= 2 1 to 4 min= 3 1 to 5 min= 7 1 to 6 min= 6 1 to 7 min= 8 1 to 8 min= 9 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;limits.h\u0026gt; using namespace std; const int inf = 0x3f3f3f3f; #define maxn 1000+100 int path[maxn][maxn], dis[maxn]; // 地图 起点到达i的距离 bool vis[maxn]; // 是否访问过 int n, t; // 地标数 路径数 void init() { for (int i = 0; i \u0026lt; maxn; ++i) { for (int j = 0; j \u0026lt; maxn; ++j) { path[i][j] = inf; } path[i][i] = 0; } } void dijkstra(){ // 将1到i的距离初始化 for (int i = 1; i \u0026lt;= n; i++) { dis[i] = path[1][i]; vis[i] = false; } vis[1] = true; // 标记起点为访问过的 dis[1] = 0; // 起点到起点的距离为0 for (int i = 2; i \u0026lt;= n; i++) { // 从2号节点遍历到n号节点 int now = -1, minl = inf; // 遍历一遍dis数组，寻找到未访问过的到1最短的路径长度 for (int j = 1; j \u0026lt;= n; j++) { // 从1到n if (!vis[j] \u0026amp;\u0026amp; minl \u0026gt; dis[j]) { // 如果没有访问过当前节点，并且当前从1到j的距离小于最大长度 now = j; // 更新最短路径的位置 minl = dis[j]; // 最短距离等于当前 } } if (now == -1) break; // 未找到 vis[now] = true; // 将now标记为访问过 // 从1开始寻找到j最短的路径 for (int j = 1; j \u0026lt;= n; j++) { // 没有访问过 并且当前已走的长度加上走到j节点的长度小于当前dis[j] if (!vis[j] \u0026amp;\u0026amp; (dis[now] + path[now][j]) \u0026lt; dis[j]) { dis[j] = dis[now] + path[now][j]; // 更新从起点到j的最短路径 } } } } int main() { freopen(\u0026#34;in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // 从指定文件输入数据 提交时注释掉 // memset(path, int_max, sizeof(path)); while (scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;t) != eof) { init(); for (int i = 0; i \u0026lt; t; i++) { int from, to, len; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;from, \u0026amp;to, \u0026amp;len); if (path[from][to] \u0026gt; len) path[from][to] = path[to][from] = len; } dijkstra(); for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;1 to %d min= %d\\n\u0026#34;, i, dis[i]); } } return 0; } ","date":"2019-04-03","permalink":"https://blog.akvicor.com/posts/algorithm/dijkstra/","summary":"\u003cp\u003e\u003cimg src=\"https://img.akvicor.com/i/2024/09/15/66e67546df179.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003epath\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e1\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e2\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e3\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e4\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e5\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e6\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e7\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e8\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e1\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e7\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e8\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e∞\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003edis\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003cth\u003e7\u003c/th\u003e\n\u003cth\u003e8\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e估计值\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003ctd\u003e∞\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003epath\u003c/code\u003e代表地图 例如\u003ccode\u003epath[i][j]\u003c/code\u003e代表从\u003ccode\u003ei\u003c/code\u003e到\u003ccode\u003ej\u003c/code\u003e的距离\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edis\u003c/code\u003e代表从起点到达\u003ccode\u003ei\u003c/code\u003e的距离，开始时初始化为最大，代表无穷远即未连同\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evis\u003c/code\u003e代表当前节点\u003ccode\u003e[i]\u003c/code\u003e是否访问过\u003c/p\u003e","title":"dijkstra(迪杰斯特拉)算法 单源最短路径算法"},{"content":"并查集是一种树型的数据结构，用于处理一些**不交集（disjoint sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）**定义了两个用于此数据结构的操作：\nfind：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 union：将两个子集合并成同一个集合。 算法实现 变量 一个数组parent代表第i个元素所指向的父节点\n一个数组sz代表以i为根的集合中的元素个数 （用以优化算法，非必须）\nint* parent; // parent[i]表示第i个元素所指向的父节点 // 使用sz还是rank优化需要根据题目的要求进行选择 int* sz; // sz[i]表示以i为根的集合中元素个数 int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int count; // 数据个数 函数 初始化 循环对每个元素的parent和sz赋值，此时每个元素都以自己为根节点，且集合中元素个数均为1\nparent = new int[count]; sz = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; sz[i] = 1; } find函数 assert需要assert.h头文件，处理异常数据p\n// 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } union函数 寻找两个元素的根节点并将两个元素所在的集合合并\n基于sz的优化 // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( sz[proot] \u0026lt; sz[qroot] ){ parent[proot] = qroot; sz[qroot] += sz[proot]; } else{ parent[qroot] = proot; sz[proot] += sz[qroot]; } } 基于rank的优化 // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( rank[proot] \u0026lt; rank[qroot] ){ parent[proot] = qroot; }else if( rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; }else{ // rank[proot] == rank[qroot] parent[proot] = qroot; rank[qroot] += 1; // 此时, 我维护rank的值 } } isconnected函数 用于检测两个元素是否属于同一集合\n// 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } count函数 如hdu-1232需要检测一共有几个集合\nint count_sets(){ int count = 0; for(int i = 0; i \u0026lt; this-\u0026gt;count; i++){ if(find(i) == i) count++; } return count; } 完整算法 全部使用c++的类写的算法，使用方法如下\nint n; cin \u0026gt;\u0026gt; n; uf1::unionfind uf = uf1::unionfind(n); 也可以将其中的变量及函数放到min函数外面使用\n基于sz优化 #include \u0026lt;cassert\u0026gt; using namespace std; namespace uf1{ class unionfind{ private: int* parent; // parent[i]表示第i个元素所指向的父节点 int* sz; // sz[i]表示以i为根的集合中元素个数 int count; // 数据个数 public: // 构造函数 unionfind(int count){ parent = new int[count]; sz = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; sz[i] = 1; } } // 析构函数 ~unionfind(){ delete[] parent; delete[] sz; } // 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } // 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( sz[proot] \u0026lt; sz[qroot] ){ parent[proot] = qroot; sz[qroot] += sz[proot]; } else{ parent[qroot] = proot; sz[proot] += sz[qroot]; } } }; } 基于rank优化 #include \u0026lt;cassert\u0026gt; using namespace std; namespace uf2{ class unionfind{ private: int* rank; // rank[i]表示以i为根的集合所表示的树的层数 int* parent; // parent[i]表示第i个元素所指向的父节点 int count; // 数据个数 public: // 构造函数 unionfind(int count){ parent = new int[count]; rank = new int[count]; this-\u0026gt;count = count; for( int i = 0 ; i \u0026lt; count ; i ++ ){ parent[i] = i; rank[i] = 1; } } // 析构函数 ~unionfind(){ delete[] parent; delete[] rank; } // 查找过程, 查找元素p所对应的集合编号 // o(h)复杂度, h为树的高度 int find(int p){ assert( p \u0026gt;= 0 \u0026amp;\u0026amp; p \u0026lt; count ); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while( p != parent[p] ) p = parent[p]; return p; } // 查看元素p和元素q是否所属一个集合 // o(h)复杂度, h为树的高度 bool isconnected( int p , int q ){ return find(p) == find(q); } // 合并元素p和元素q所属的集合 // o(h)复杂度, h为树的高度 void unionelements(int p, int q){ int proot = find(p); int qroot = find(q); if( proot == qroot ) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if( rank[proot] \u0026lt; rank[qroot] ){ parent[proot] = qroot; } else if( rank[qroot] \u0026lt; rank[proot]){ parent[qroot] = proot; } else{ // rank[proot] == rank[qroot] parent[proot] = qroot; rank[qroot] += 1; // 此时, 我维护rank的值 } } }; } ","date":"2019-03-24","permalink":"https://blog.akvicor.com/posts/algorithm/union_find/","summary":"\u003cp\u003e\u003cstrong\u003e并查集\u003c/strong\u003e是一种树型的数据结构，用于处理一些**不交集（Disjoint Sets）\u003cstrong\u003e的合并及查询问题。有一个\u003c/strong\u003e联合-查找算法（union-find algorithm）**定义了两个用于此数据结构的操作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFind：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。\u003c/li\u003e\n\u003cli\u003eUnion：将两个子集合并成同一个集合。\u003c/li\u003e\n\u003c/ul\u003e","title":"并查集"},{"content":"统计一个字符串在另一个字符串中出现的次数，包含重叠和非重叠两种情况\n子串可重叠情况 int count_substring_in_string_overlapping(const std::string \u0026amp;str, const std::string \u0026amp;sub) { int num = 0; for (size_t i = 0; (i = str.find(sub, i)) != std::string::npos; num++, i++); return num; } 子串不可重叠情况 int count_substring_in_string_non_overlapping(const std::string \u0026amp;str, const std::string \u0026amp;sub) { int num = 0; size_t len = sub.length(); if (len == 0)len = 1; for (size_t i = 0; (i = str.find(sub, i)) != std::string::npos; num++, i += len); return num; } ","date":"2019-03-22","permalink":"https://blog.akvicor.com/posts/algorithm/count_substring/","summary":"\u003cp\u003e统计一个字符串在另一个字符串中出现的次数，包含重叠和非重叠两种情况\u003c/p\u003e","title":"统计字符串中子串数目"},{"content":"欧拉φ函数：在数论中，对正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数、欧拉商数等。\nφ(1)=1; φ(2)=1; φ(3)=2; φ(4)=2; φ(9)=6\n欧拉φ函数 int geteuler(int n) { //欧拉函数 int res = n; for(int i = 2;i*i \u0026lt;= n; ++i){ if(a%i == 0){ res -= res/i; while(n%i == 0) n /= i; } } if(a \u0026gt; 1) // 因为是遍历到sqrt(n)，所以可能存在未除尽或者n本身就为质数的情况 res -= res/n; return res; } int phi(int x) { //欧拉函数 int i, re = x; for (i = 2; i * i \u0026lt;= x; i++) if (x % i == 0) { re /= i; re *= i - 1; while (x % i == 0) x /= i; } if (x ^ 1) re /= x, re *= x - 1; return re; } 欧拉降幂公式 ab(modc) = abmodφ(c)+φ(c)mod(c)\n快速幂 ll quickpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y \u0026gt;\u0026gt;= 1, x = x * x % mod) if (y \u0026amp; 1)res = res * x % mod; return res; } long long quickpow(long long a, int n) { long long answer = 1; for (; n; n /= 2, a = a * a % mod) if (n % 2 == 1) answer = answer * a % mod; return answer % mod; } 应用题目 题目目标：2的n次方mod1e9+7（1\u0026lt;=n\u0026lt;=10100000）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; typedef long long ll; const int mod = 1e9 + 7; int geteuler(int n) //欧拉函数 { int i; int res = n, a = n; for (i = 2; i * i \u0026lt;= a; ++i) { if (a % i == 0) { res -= res / i; while (a % i == 0) a /= i; } } if (a \u0026gt; 1) res -= res / a; return res; } ll quickpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y \u0026gt;\u0026gt;= 1, x = x * x % mod) if (y \u0026amp; 1)res = res * x % mod; return res; } char n[100006]; char m[100006]; int main() { scanf(\u0026#34;%s %s\u0026#34;, n, m); int phi_c = geteuler(mod); int len = strlen(n); ll sum = 0; for (int i = 0; i \u0026lt; len; ++i) { sum = (sum * 10 + n[i] - \u0026#39;0\u0026#39;) % phi_c; } cout \u0026lt;\u0026lt; quickpow(2,sum+phi_c,mod) \u0026lt;\u0026lt; endl; } 快速幂方法推导 算法1.直接设计算法 int ans = 1; for(int i = 1;i\u0026lt;=b;i++) { ans = ans * a; } ans = ans % c; 缺点：这个算法存在着明显的问题，如果a和b过大，很容易就会溢出。\n我们先来看看第一个改进方案：在讲这个方案之前，要先看这样一个公式：ab mod c = (a mod c)b mod c\n算法2.改进算法 int ans = 1; a = a % c; //加上这一句 for(int i = 1;i\u0026lt;=b;i++) { ans = ans * a; } ans = ans % c; 既然某个因子取余之后相乘再取余保持余数不变，那么新算得的ans也可以进行取余，所以得到比较良好的改进版本。\n算法3.进一步改进算法 int ans = 1; a = a % c; //加上这一句 for(int i = 1;i\u0026lt;=b;i++) { ans = (ans * a) % c;//这里再取了一次余 } ans = ans % c; 这个算法在时间复杂度上没有改进，仍为o(b)，不过已经好很多的，但是在c过大的条件下，还是很有可能超时，所以，我们推出以下的快速幂算法。\n算法4.快速幂算法 快速幂算法依赖于以下明显的公式：\nab mod c = ((a2)b/2) mod c\t,b是偶数\nab mod c = ((a2)b/2×a) mod c\t,b是奇数\nint powermod(int a, int b, int c) { int ans = 1; a = a % c; while(b\u0026gt;0) { if(b % 2 = = 1) ans = (ans * a) % c; b = b/2; a = (a * a) % c; } return ans; } 本算法的时间复杂度为o(logb)\n","date":"2019-02-18","permalink":"https://blog.akvicor.com/posts/algorithm/euler_quick_pow/","summary":"\u003cp\u003e\u003cstrong\u003e欧拉φ函数\u003c/strong\u003e：在数论中，对正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数、欧拉商数等。\u003c/p\u003e\n\u003cp\u003eφ(1)=1;  φ(2)=1;  φ(3)=2;  φ(4)=2;  φ(9)=6\u003c/p\u003e","title":"欧拉降幂 \u0026\u0026 快速幂"},{"content":"aos32-gb2312.tgz\n一个gb2312汉字是由两个字节编码的，范围为a1a1~fefe。a1-a9为符号区，b0到f7为汉字区。每一个区有94个字符。\n点阵结构 从图片可以看出：\n日文编码的第一个字节为点阵的左半部分，第二个字节为点阵的右半部分。 中文编码的第一个字节为点阵的上半部分，第二个字节为点阵的下半部分 偏移 在汉字占的两个字节中，前一个字节为该汉字的区号，后一个字节为该字的位号。其中，每个区记录94个汉字，位号为该字在该区中的位置。\n区码：区号（汉字的第一个字节）- 0xa0 (因为汉字编码是从0xa0区开始的，所以文件最前面就是从0xa0区开始，要算出相对区码) 位码：位号（汉字的第二个字节）- 0xa0 由此可以得到汉字在hzk16中的绝对偏移位置：offset=(94*(区码-1)+(位码-1))*32\n区码减1是因为数组是以0为开始而区号位号是以1为开始的 (94*(区号-1)+位号-1)是一个汉字字模占用的字节数 最后乘以32是因为汉字库文应从该位置起的32字节信息记录该字的字模信息（前面提到一个汉字要有32个字节显示） 代码实现 由于点阵结构不同，原先的putfont8函数并不适用于gb2312，所以重新编写一个函数来显示中文\nvoid putfont8_ud_rev(char *vram, int xsize, int x, int y, char c, char *font) { int i, k; char *p, d ; for(i = 0; i \u0026lt; 8; i++) { p = vram + (y + i) * xsize + x; d = font[2 * i]; for(k = 0; k \u0026lt; 8; k++) { if(d\u0026amp;(0x01\u0026lt;\u0026lt;k)) { p[k] = c; } } p += 8; d = font[2 * i + 1]; for(k = 0; k \u0026lt; 8; k++) { if(d\u0026amp;(0x01\u0026lt;\u0026lt;k)) { p[k] = c; } } } return; } 在putfonts8_asc中添加新的模式用以显示中文\nif (task-\u0026gt;langmode == 3) { for (; *s != 0x00; s++) { if (task-\u0026gt;langbyte1 == 0) { if (0xa1 \u0026lt;= *s \u0026amp;\u0026amp; *s \u0026lt;= 0xfe) { task-\u0026gt;langbyte1 = *s; } else { //只要是半角就使用hankaku里面的字符 putfont8(vram, xsize, x, y, c, hankaku + *s * 16); } } else { k = task-\u0026gt;langbyte1 - 0xa1; t = *s - 0xa1; task-\u0026gt;langbyte1 = 0; font = chinese + (k * 94 + t) * 32; putfont8_ud_rev(vram, xsize, x - 8, y , c, font ); putfont8_ud_rev(vram, xsize, x - 8, y + 8, c, font + 16); } x += 8; } } 如果不需要日文字体，可以直接将中文字体数据读入bootpack.c中的nihongo变量（注意分配的内存大小需要修改为memman_alloc_4k(memman, 0x5d5d * 32)）。\n如果想要共存则需要添加新的变量，并且增大读入的扇区数量。\n在chklang.c文件中添加下列代码，用户测试中文\nstatic char s3[16] = { // 中文 0xc4, 0xe3, 0xba, 0xc3, 0xce, 0xd2, 0xca, 0xc7, 0x41, 0x6b, 0x76, 0x69, 0x63, 0x6f, 0x72, 0x00 }; if (langmode == 3) { api_putstr0(s3); } 修改ipl.nas中读入的扇区数量\ncyls\tequ\t30 修改bootpack.c\n// 定义全局变量 unsigned char *chinese; unsigned char *nihongo; // 函数void harimain(void) 中 nihongo = (unsigned char *) memman_alloc_4k(memman, 16 * 256 + 32 * 94 * 47); chinese = (unsigned char *) memman_alloc_4k(memman, 0x5d5d * 32); fat = (int *) memman_alloc_4k(memman, 4 * 2880); file_readfat(fat, (unsigned char *) (adr_diskimg + 0x000200)); finfo = file_search(\u0026#34;nihongo.fnt\u0026#34;, (struct fileinfo *) (adr_diskimg + 0x002600), 224); if (finfo != 0) { file_loadfile(finfo-\u0026gt;clustno, finfo-\u0026gt;size, nihongo, fat, (char *) (adr_diskimg + 0x003e00)); } else { for (i = 0; i \u0026lt; 16 * 256; i++) { nihongo[i] = hankaku[i]; // 没有字库，半角部分直接复制英文字裤 } for (i = 16 * 256; i \u0026lt; 16 * 256 + 32 * 94 * 47; i++) { nihongo[i] = 0xff; // 没有字库，全角部分以0xff填充 } } finfo = file_search(\u0026#34;hzk16.fnt\u0026#34;, (struct fileinfo *) (adr_diskimg + 0x002600), 224); if (finfo != 0) { file_loadfile(finfo-\u0026gt;clustno, finfo-\u0026gt;size, chinese, fat, (char *) (adr_diskimg + 0x003e00)); } else { for (i = 0; i \u0026lt; 16 * 256; i++) { chinese[i] = hankaku[i]; // 没有字库，半角部分直接复制英文字裤 } for (i = 16 * 256; i \u0026lt; 16 * 256 + 32 * 94 * 47; i++) { chinese[i] = 0xff; // 没有字库，全角部分以0xff填充 } } memman_free_4k(memman, (int) fat, 4 * 2880); 修改graphic.c文件putfonts8_asc的代码，添加下面两行\nextern char *nihongo; extern char *chinese; 修改console.c文件cmd_langmode函数中的if (mode \u0026lt;= 2)为if (mode \u0026lt;= 3)\n","date":"0001-01-01","permalink":"https://blog.akvicor.com/posts/aos32/gb2312/","summary":"aos32-gb2312.tgz 一个GB2312汉字是由两个字节编码的，范围为A1A1~FEFE。A1-A9为符号区，B0到F7为汉字区。每一个区有94个字符。 点阵结构 从图片可以看出： 日文编","title":"aos32 显示中文字符gb2312"},]
            
        
    </div>

    <div id="search">
        
        <span class="sc-icon"><img src="/imgs/icons/search.svg" width="48"> </span>
        <span id="sc-clear" onclick="clearInputVal()">✖</span>
        <input id="sc-input" oninput="search()" type="text" placeholder="here search search..." />
        <div id="sc-res"></div>
    </div>
    <script src="/js/search.js" defer></script>
</div>

    

    
    
    

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="" target="_blank">
        
        <span class="some">世界一、 幸せな女の子だ<span>
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>
